/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@fortawesome/fontawesome-svg-core/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@fortawesome/fontawesome-svg-core/index.es.js ***!
  \********************************************************************/
/*! exports provided: icon, noAuto, config, toHtml, layer, text, counter, library, dom, parse, findIconDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "icon", function() { return icon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noAuto", function() { return noAuto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHtml", function() { return toHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layer", function() { return layer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "counter", function() { return counter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "library", function() { return library; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dom", function() { return dom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIconDefinition", function() { return findIconDefinition; });
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var noop = function noop() {};

var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};

try {
  if (typeof window !== 'undefined') _WINDOW = window;
  if (typeof document !== 'undefined') _DOCUMENT = document;
  if (typeof MutationObserver !== 'undefined') _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== 'undefined') _PERFORMANCE = performance;
} catch (e) {}

var _ref = _WINDOW.navigator || {},
    _ref$userAgent = _ref.userAgent,
    userAgent = _ref$userAgent === void 0 ? '' : _ref$userAgent;

var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';
var IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');

var NAMESPACE_IDENTIFIER = '___FONT_AWESOME___';
var UNITS_IN_GRID = 16;
var DEFAULT_FAMILY_PREFIX = 'fa';
var DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa';
var DATA_FA_I2SVG = 'data-fa-i2svg';
var DATA_FA_PSEUDO_ELEMENT = 'data-fa-pseudo-element';
var DATA_FA_PSEUDO_ELEMENT_PENDING = 'data-fa-pseudo-element-pending';
var DATA_PREFIX = 'data-prefix';
var DATA_ICON = 'data-icon';
var HTML_CLASS_I2SVG_BASE_CLASS = 'fontawesome-i2svg';
var MUTATION_APPROACH_ASYNC = 'async';
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ['HTML', 'HEAD', 'STYLE', 'SCRIPT'];
var PRODUCTION = function () {
  try {
    return "development" === 'production';
  } catch (e) {
    return false;
  }
}();
var PREFIX_TO_STYLE = {
  'fas': 'solid',
  'far': 'regular',
  'fal': 'light',
  'fab': 'brands',
  'fa': 'solid'
};
var STYLE_TO_PREFIX = {
  'solid': 'fas',
  'regular': 'far',
  'light': 'fal',
  'brands': 'fab'
};
var LAYERS_TEXT_CLASSNAME = 'fa-layers-text';
var FONT_FAMILY_PATTERN = /Font Awesome 5 (Solid|Regular|Light|Brands|Free|Pro)/;
var FONT_WEIGHT_TO_PREFIX = {
  '900': 'fas',
  '400': 'far',
  'normal': 'far',
  '300': 'fal'
};
var oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'];
var RESERVED_CLASSES = ['xs', 'sm', 'lg', 'fw', 'ul', 'li', 'border', 'pull-left', 'pull-right', 'spin', 'pulse', 'rotate-90', 'rotate-180', 'rotate-270', 'flip-horizontal', 'flip-vertical', 'flip-both', 'stack', 'stack-1x', 'stack-2x', 'inverse', 'layers', 'layers-text', 'layers-counter'].concat(oneToTen.map(function (n) {
  return "".concat(n, "x");
})).concat(oneToTwenty.map(function (n) {
  return "w-".concat(n);
}));

var initial = WINDOW.FontAwesomeConfig || {};

function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector('script[' + attr + ']');

  if (element) {
    return element.getAttribute(attr);
  }
}

function coerce(val) {
  // Getting an empty string will occur if the attribute is set on the HTML tag but without a value
  // We'll assume that this is an indication that it should be toggled to true
  // For example <script data-search-pseudo-elements src="..."></script>
  if (val === '') return true;
  if (val === 'false') return false;
  if (val === 'true') return true;
  return val;
}

if (DOCUMENT && typeof DOCUMENT.querySelector === 'function') {
  var attrs = [['data-family-prefix', 'familyPrefix'], ['data-replacement-class', 'replacementClass'], ['data-auto-replace-svg', 'autoReplaceSvg'], ['data-auto-add-css', 'autoAddCss'], ['data-auto-a11y', 'autoA11y'], ['data-search-pseudo-elements', 'searchPseudoElements'], ['data-observe-mutations', 'observeMutations'], ['data-mutate-approach', 'mutateApproach'], ['data-keep-original-source', 'keepOriginalSource'], ['data-measure-performance', 'measurePerformance'], ['data-show-missing-icons', 'showMissingIcons']];
  attrs.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        attr = _ref2[0],
        key = _ref2[1];

    var val = coerce(getAttrConfig(attr));

    if (val !== undefined && val !== null) {
      initial[key] = val;
    }
  });
}

var _default = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: 'async',
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};

var _config = _objectSpread({}, _default, initial);

if (!_config.autoReplaceSvg) _config.observeMutations = false;

var config = _objectSpread({}, _config);

WINDOW.FontAwesomeConfig = config;

var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];

var functions = [];

var listener = function listener() {
  DOCUMENT.removeEventListener('DOMContentLoaded', listener);
  loaded = 1;
  functions.map(function (fn) {
    return fn();
  });
};

var loaded = false;

if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);
}

function domready (fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';

var NOOP = function NOOP() {};

var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
  // run promise callbacks
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  } // reset async asyncQueue


  asyncQueue = [];
  asyncTimer = false;
}

function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);

  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}

function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }

  function rejectPromise(reason) {
    reject(promise, reason);
  }

  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e) {
    rejectPromise(e);
  }
}

function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;

  if (typeof callback === 'function') {
    settled = FULFILLED;

    try {
      value = callback(value);
    } catch (e) {
      reject(promise, e);
    }
  }

  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }

    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}

function handleThenable(promise, value) {
  var resolved;

  try {
    if (promise === value) {
      throw new TypeError('A promises callback cannot return that same promise.');
    }

    if (value && (typeof value === 'function' || _typeof(value) === 'object')) {
      // then should be retrieved only once
      var then = value.then;

      if (typeof then === 'function') {
        then.call(value, function (val) {
          if (!resolved) {
            resolved = true;

            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function (reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e) {
    if (!resolved) {
      reject(promise, e);
    }

    return true;
  }

  return false;
}

function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}

function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}

function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}

function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}

function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);

  if (!promise._handled && isNode) {
    global.process.emit('unhandledRejection', promise._data, promise);
  }
}

function notifyRejectionHandled(promise) {
  global.process.emit('rejectionHandled', promise);
}
/**
 * @class
 */


function P(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('Promise resolver ' + resolver + ' is not a function');
  }

  if (this instanceof P === false) {
    throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
  }

  this._then = [];
  invokeResolver(resolver, this);
}

P.prototype = {
  constructor: P,
  _state: PENDING,
  _then: null,
  _data: undefined,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };

    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;

      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }

    if (this._state === FULFILLED || this._state === REJECTED) {
      // already resolved, call callback async
      asyncCall(invokeCallback, subscriber);
    } else {
      // subscribe
      this._then.push(subscriber);
    }

    return subscriber.then;
  },
  catch: function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

P.all = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.all().');
  }

  return new P(function (resolve, reject) {
    var results = [];
    var remaining = 0;

    function resolver(index) {
      remaining++;
      return function (value) {
        results[index] = value;

        if (! --remaining) {
          resolve(results);
        }
      };
    }

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolver(i), reject);
      } else {
        results[i] = promise;
      }
    }

    if (!remaining) {
      resolve(results);
    }
  });
};

P.race = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.race().');
  }

  return new P(function (resolve, reject) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
  });
};

P.resolve = function (value) {
  if (value && _typeof(value) === 'object' && value.constructor === P) {
    return value;
  }

  return new P(function (resolve) {
    resolve(value);
  });
};

P.reject = function (reason) {
  return new P(function (resolve, reject) {
    reject(reason);
  });
};

var picked = typeof Promise === 'function' ? Promise : P;

var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};

function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function insertCss(css) {
  if (!css || !IS_DOM) {
    return;
  }

  var style = DOCUMENT.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;

  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || '').toUpperCase();

    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }

  DOCUMENT.head.insertBefore(style, beforeChild);
  return css;
}
var idPool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function nextUniqueId() {
  var size = 12;
  var id = '';

  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }

  return id;
}
function toArray(obj) {
  var array = [];

  for (var i = (obj || []).length >>> 0; i--;) {
    array[i] = obj[i];
  }

  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute('class') || '').split(' ').filter(function (i) {
      return i;
    });
  }
}
function getIconName(familyPrefix, cls) {
  var parts = cls.split('-');
  var prefix = parts[0];
  var iconName = parts.slice(1).join('-');

  if (prefix === familyPrefix && iconName !== '' && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function (acc, attributeName) {
    return acc + "".concat(attributeName, "=\"").concat(htmlEscape(attributes[attributeName]), "\" ");
  }, '').trim();
}
function joinStyles(styles) {
  return Object.keys(styles || {}).reduce(function (acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles[styleName], ";");
  }, '');
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  var transform = _ref.transform,
      containerWidth = _ref.containerWidth,
      iconWidth = _ref.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer: outer,
    inner: inner,
    path: path
  };
}
function transformForCss(_ref2) {
  var transform = _ref2.transform,
      _ref2$width = _ref2.width,
      width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width,
      _ref2$height = _ref2.height,
      height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height,
      _ref2$startCentered = _ref2.startCentered,
      startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = '';

  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d - width / 2, "em, ").concat(transform.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d, "em), calc(-50% + ").concat(transform.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d, "em, ").concat(transform.y / d, "em) ");
  }

  val += "scale(".concat(transform.size / d * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}

var ALL_SPACE = {
  x: 0,
  y: 0,
  width: '100%',
  height: '100%'
};
function makeIconMasking (_ref) {
  var children = _ref.children,
      attributes = _ref.attributes,
      main = _ref.main,
      mask = _ref.mask,
      transform = _ref.transform;
  var mainWidth = main.width,
      mainPath = main.icon;
  var maskWidth = mask.width,
      maskPath = mask.icon;
  var trans = transformForSvg({
    transform: transform,
    containerWidth: maskWidth,
    iconWidth: mainWidth
  });
  var maskRect = {
    tag: 'rect',
    attributes: _objectSpread({}, ALL_SPACE, {
      fill: 'white'
    })
  };
  var maskInnerGroup = {
    tag: 'g',
    attributes: _objectSpread({}, trans.inner),
    children: [{
      tag: 'path',
      attributes: _objectSpread({}, mainPath.attributes, trans.path, {
        fill: 'black'
      })
    }]
  };
  var maskOuterGroup = {
    tag: 'g',
    attributes: _objectSpread({}, trans.outer),
    children: [maskInnerGroup]
  };
  var maskId = "mask-".concat(nextUniqueId());
  var clipId = "clip-".concat(nextUniqueId());
  var maskTag = {
    tag: 'mask',
    attributes: _objectSpread({}, ALL_SPACE, {
      id: maskId,
      maskUnits: 'userSpaceOnUse',
      maskContentUnits: 'userSpaceOnUse'
    }),
    children: [maskRect, maskOuterGroup]
  };
  var defs = {
    tag: 'defs',
    children: [{
      tag: 'clipPath',
      attributes: {
        id: clipId
      },
      children: [maskPath]
    }, maskTag]
  };
  children.push(defs, {
    tag: 'rect',
    attributes: _objectSpread({
      fill: 'currentColor',
      'clip-path': "url(#".concat(clipId, ")"),
      mask: "url(#".concat(maskId, ")")
    }, ALL_SPACE)
  });
  return {
    children: children,
    attributes: attributes
  };
}

function makeIconStandard (_ref) {
  var children = _ref.children,
      attributes = _ref.attributes,
      main = _ref.main,
      transform = _ref.transform,
      styles = _ref.styles;
  var styleString = joinStyles(styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  if (transformIsMeaningful(transform)) {
    var trans = transformForSvg({
      transform: transform,
      containerWidth: main.width,
      iconWidth: main.width
    });
    children.push({
      tag: 'g',
      attributes: _objectSpread({}, trans.outer),
      children: [{
        tag: 'g',
        attributes: _objectSpread({}, trans.inner),
        children: [{
          tag: main.icon.tag,
          children: main.icon.children,
          attributes: _objectSpread({}, main.icon.attributes, trans.path)
        }]
      }]
    });
  } else {
    children.push(main.icon);
  }

  return {
    children: children,
    attributes: attributes
  };
}

function asIcon (_ref) {
  var children = _ref.children,
      main = _ref.main,
      mask = _ref.mask,
      attributes = _ref.attributes,
      styles = _ref.styles,
      transform = _ref.transform;

  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    var width = main.width,
        height = main.height;
    var offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes['style'] = joinStyles(_objectSpread({}, styles, {
      'transform-origin': "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    }));
  }

  return [{
    tag: 'svg',
    attributes: attributes,
    children: children
  }];
}

function asSymbol (_ref) {
  var prefix = _ref.prefix,
      iconName = _ref.iconName,
      children = _ref.children,
      attributes = _ref.attributes,
      symbol = _ref.symbol;
  var id = symbol === true ? "".concat(prefix, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: 'svg',
    attributes: {
      style: 'display: none;'
    },
    children: [{
      tag: 'symbol',
      attributes: _objectSpread({}, attributes, {
        id: id
      }),
      children: children
    }]
  }];
}

function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons,
      main = _params$icons.main,
      mask = _params$icons.mask,
      prefix = params.prefix,
      iconName = params.iconName,
      transform = params.transform,
      symbol = params.symbol,
      title = params.title,
      extra = params.extra,
      _params$watchable = params.watchable,
      watchable = _params$watchable === void 0 ? false : _params$watchable;

  var _ref = mask.found ? mask : main,
      width = _ref.width,
      height = _ref.height;

  var widthClass = "fa-w-".concat(Math.ceil(width / height * 16));
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : '', widthClass].filter(function (c) {
    return extra.classes.indexOf(c) === -1;
  }).concat(extra.classes).join(' ');
  var content = {
    children: [],
    attributes: _objectSpread({}, extra.attributes, {
      'data-prefix': prefix,
      'data-icon': iconName,
      'class': attrClass,
      'role': extra.attributes.role || 'img',
      'xmlns': 'http://www.w3.org/2000/svg',
      'viewBox': "0 0 ".concat(width, " ").concat(height)
    })
  };

  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = '';
  }

  if (title) content.children.push({
    tag: 'title',
    attributes: {
      id: content.attributes['aria-labelledby'] || "title-".concat(nextUniqueId())
    },
    children: [title]
  });

  var args = _objectSpread({}, content, {
    prefix: prefix,
    iconName: iconName,
    main: main,
    mask: mask,
    transform: transform,
    symbol: symbol,
    styles: extra.styles
  });

  var _ref2 = mask.found && main.found ? makeIconMasking(args) : makeIconStandard(args),
      children = _ref2.children,
      attributes = _ref2.attributes;

  args.children = children;
  args.attributes = attributes;

  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content,
      width = params.width,
      height = params.height,
      transform = params.transform,
      title = params.title,
      extra = params.extra,
      _params$watchable2 = params.watchable,
      watchable = _params$watchable2 === void 0 ? false : _params$watchable2;

  var attributes = _objectSpread({}, extra.attributes, title ? {
    'title': title
  } : {}, {
    'class': extra.classes.join(' ')
  });

  if (watchable) {
    attributes[DATA_FA_I2SVG] = '';
  }

  var styles = _objectSpread({}, extra.styles);

  if (transformIsMeaningful(transform)) {
    styles['transform'] = transformForCss({
      transform: transform,
      startCentered: true,
      width: width,
      height: height
    });
    styles['-webkit-transform'] = styles['transform'];
  }

  var styleString = joinStyles(styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}
function makeLayersCounterAbstract(params) {
  var content = params.content,
      title = params.title,
      extra = params.extra;

  var attributes = _objectSpread({}, extra.attributes, title ? {
    'title': title
  } : {}, {
    'class': extra.classes.join(' ')
  });

  var styleString = joinStyles(extra.styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}

var noop$1 = function noop() {};

var p = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = "FA \"5.9.0\"";

var begin = function begin(name) {
  p.mark("".concat(preamble, " ").concat(name, " begins"));
  return function () {
    return end(name);
  };
};

var end = function end(name) {
  p.mark("".concat(preamble, " ").concat(name, " ends"));
  p.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};

var perf = {
  begin: begin,
  end: end
};

/**
 * Internal helper to bind a function known to have 4 arguments
 * to a given context.
 */

var bindInternal4 = function bindInternal4(func, thisContext) {
  return function (a, b, c, d) {
    return func.call(thisContext, a, b, c, d);
  };
};

/**
 * # Reduce
 *
 * A fast object `.reduce()` implementation.
 *
 * @param  {Object}   subject      The object to reduce over.
 * @param  {Function} fn           The reducer function.
 * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].
 * @param  {Object}   thisContext  The context for the reducer.
 * @return {mixed}                 The final result.
 */


var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject),
      length = keys.length,
      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,
      i,
      key,
      result;

  if (initialValue === undefined) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }

  for (; i < length; i++) {
    key = keys[i];
    result = iterator(result, subject[key], key, subject);
  }

  return result;
};

function toHex(unicode) {
  var result = '';

  for (var i = 0; i < unicode.length; i++) {
    var hex = unicode.charCodeAt(i).toString(16);
    result += ('000' + hex).slice(-4);
  }

  return result;
}

function defineIcons(prefix, icons) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks,
      skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = Object.keys(icons).reduce(function (acc, iconName) {
    var icon = icons[iconName];
    var expanded = !!icon.icon;

    if (expanded) {
      acc[icon.iconName] = icon.icon;
    } else {
      acc[iconName] = icon;
    }

    return acc;
  }, {});

  if (typeof namespace.hooks.addPack === 'function' && !skipHooks) {
    namespace.hooks.addPack(prefix, normalized);
  } else {
    namespace.styles[prefix] = _objectSpread({}, namespace.styles[prefix] || {}, normalized);
  }
  /**
   * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction
   * of new styles we needed to differentiate between them. Prefix `fa` is now an alias
   * for `fas` so we'll easy the upgrade process for our users by automatically defining
   * this as well.
   */


  if (prefix === 'fas') {
    defineIcons('fa', icons);
  }
}

var styles = namespace.styles,
    shims = namespace.shims;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var build = function build() {
  var lookup = function lookup(reducer) {
    return reduce(styles, function (o, style, prefix) {
      o[prefix] = reduce(style, reducer, {});
      return o;
    }, {});
  };

  _byUnicode = lookup(function (acc, icon, iconName) {
    if (icon[3]) {
      acc[icon[3]] = iconName;
    }

    return acc;
  });
  _byLigature = lookup(function (acc, icon, iconName) {
    var ligatures = icon[2];
    acc[iconName] = iconName;
    ligatures.forEach(function (ligature) {
      acc[ligature] = iconName;
    });
    return acc;
  });
  var hasRegular = 'far' in styles;
  _byOldName = reduce(shims, function (acc, shim) {
    var oldName = shim[0];
    var prefix = shim[1];
    var iconName = shim[2];

    if (prefix === 'far' && !hasRegular) {
      prefix = 'fas';
    }

    acc[oldName] = {
      prefix: prefix,
      iconName: iconName
    };
    return acc;
  }, {});
};
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}

var styles$1 = namespace.styles;
var emptyCanonicalIcon = function emptyCanonicalIcon() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalIcon(values) {
  return values.reduce(function (acc, cls) {
    var iconName = getIconName(config.familyPrefix, cls);

    if (styles$1[cls]) {
      acc.prefix = cls;
    } else if (config.autoFetchSvg && ['fas', 'far', 'fal', 'fab', 'fa'].indexOf(cls) > -1) {
      acc.prefix = cls;
    } else if (iconName) {
      var shim = acc.prefix === 'fa' ? byOldName(iconName) : {};
      acc.iconName = shim.iconName || iconName;
      acc.prefix = shim.prefix || acc.prefix;
    } else if (cls !== config.replacementClass && cls.indexOf('fa-w-') !== 0) {
      acc.rest.push(cls);
    }

    return acc;
  }, emptyCanonicalIcon());
}
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix: prefix,
      iconName: iconName,
      icon: mapping[prefix][iconName]
    };
  }
}

function toHtml(abstractNodes) {
  var tag = abstractNodes.tag,
      _abstractNodes$attrib = abstractNodes.attributes,
      attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib,
      _abstractNodes$childr = abstractNodes.children,
      children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;

  if (typeof abstractNodes === 'string') {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(''), "</").concat(tag, ">");
  }
}

var noop$2 = function noop() {};

function isWatched(node) {
  var i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === 'string';
}

function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }

  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}

var mutators = {
  replace: function replace(mutation) {
    var node = mutation[0];
    var abstract = mutation[1];
    var newOuterHTML = abstract.map(function (a) {
      return toHtml(a);
    }).join('\n');

    if (node.parentNode && node.outerHTML) {
      node.outerHTML = newOuterHTML + (config.keepOriginalSource && node.tagName.toLowerCase() !== 'svg' ? "<!-- ".concat(node.outerHTML, " -->") : '');
    } else if (node.parentNode) {
      var newNode = document.createElement('span');
      node.parentNode.replaceChild(newNode, node);
      newNode.outerHTML = newOuterHTML;
    }
  },
  nest: function nest(mutation) {
    var node = mutation[0];
    var abstract = mutation[1]; // If we already have a replaced node we do not want to continue nesting within it.
    // Short-circuit to the standard replacement

    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }

    var forSvg = new RegExp("".concat(config.familyPrefix, "-.*"));
    delete abstract[0].attributes.style;
    var splitClasses = abstract[0].attributes.class.split(' ').reduce(function (acc, cls) {
      if (cls === config.replacementClass || cls.match(forSvg)) {
        acc.toSvg.push(cls);
      } else {
        acc.toNode.push(cls);
      }

      return acc;
    }, {
      toNode: [],
      toSvg: []
    });
    abstract[0].attributes.class = splitClasses.toSvg.join(' ');
    var newInnerHTML = abstract.map(function (a) {
      return toHtml(a);
    }).join('\n');
    node.setAttribute('class', splitClasses.toNode.join(' '));
    node.setAttribute(DATA_FA_I2SVG, '');
    node.innerHTML = newInnerHTML;
  }
};

function performOperationSync(op) {
  op();
}

function perform(mutations, callback) {
  var callbackFunction = typeof callback === 'function' ? callback : noop$2;

  if (mutations.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;

    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }

    frame(function () {
      var mutator = getMutator();
      var mark = perf.begin('mutate');
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }

  if (!config.observeMutations) {
    return;
  }

  var treeCallback = options.treeCallback,
      nodeCallback = options.nodeCallback,
      pseudoElementsCallback = options.pseudoElementsCallback,
      _options$observeMutat = options.observeMutationsRoot,
      observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function (objects) {
    if (disabled) return;
    toArray(objects).forEach(function (mutationRecord) {
      if (mutationRecord.type === 'childList' && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }

        treeCallback(mutationRecord.target);
      }

      if (mutationRecord.type === 'attributes' && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }

      if (mutationRecord.type === 'attributes' && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === 'class') {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)),
              prefix = _getCanonicalIcon.prefix,
              iconName = _getCanonicalIcon.iconName;

          if (prefix) mutationRecord.target.setAttribute('data-prefix', prefix);
          if (iconName) mutationRecord.target.setAttribute('data-icon', iconName);
        } else {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo) return;
  mo.disconnect();
}

function styleParser (node) {
  var style = node.getAttribute('style');
  var val = [];

  if (style) {
    val = style.split(';').reduce(function (acc, style) {
      var styles = style.split(':');
      var prop = styles[0];
      var value = styles.slice(1);

      if (prop && value.length > 0) {
        acc[prop] = value.join(':').trim();
      }

      return acc;
    }, {});
  }

  return val;
}

function classParser (node) {
  var existingPrefix = node.getAttribute('data-prefix');
  var existingIconName = node.getAttribute('data-icon');
  var innerText = node.innerText !== undefined ? node.innerText.trim() : '';
  var val = getCanonicalIcon(classArray(node));

  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }

  if (val.prefix && innerText.length > 1) {
    val.iconName = byLigature(val.prefix, node.innerText);
  } else if (val.prefix && innerText.length === 1) {
    val.iconName = byUnicode(val.prefix, toHex(node.innerText));
  }

  return val;
}

var parseTransformString = function parseTransformString(transformString) {
  var transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };

  if (!transformString) {
    return transform;
  } else {
    return transformString.toLowerCase().split(' ').reduce(function (acc, n) {
      var parts = n.toLowerCase().split('-');
      var first = parts[0];
      var rest = parts.slice(1).join('-');

      if (first && rest === 'h') {
        acc.flipX = true;
        return acc;
      }

      if (first && rest === 'v') {
        acc.flipY = true;
        return acc;
      }

      rest = parseFloat(rest);

      if (isNaN(rest)) {
        return acc;
      }

      switch (first) {
        case 'grow':
          acc.size = acc.size + rest;
          break;

        case 'shrink':
          acc.size = acc.size - rest;
          break;

        case 'left':
          acc.x = acc.x - rest;
          break;

        case 'right':
          acc.x = acc.x + rest;
          break;

        case 'up':
          acc.y = acc.y - rest;
          break;

        case 'down':
          acc.y = acc.y + rest;
          break;

        case 'rotate':
          acc.rotate = acc.rotate + rest;
          break;
      }

      return acc;
    }, transform);
  }
};
function transformParser (node) {
  return parseTransformString(node.getAttribute('data-fa-transform'));
}

function symbolParser (node) {
  var symbol = node.getAttribute('data-fa-symbol');
  return symbol === null ? false : symbol === '' ? true : symbol;
}

function attributesParser (node) {
  var extraAttributes = toArray(node.attributes).reduce(function (acc, attr) {
    if (acc.name !== 'class' && acc.name !== 'style') {
      acc[attr.name] = attr.value;
    }

    return acc;
  }, {});
  var title = node.getAttribute('title');

  if (config.autoA11y) {
    if (title) {
      extraAttributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(nextUniqueId());
    } else {
      extraAttributes['aria-hidden'] = 'true';
      extraAttributes['focusable'] = 'false';
    }
  }

  return extraAttributes;
}

function maskParser (node) {
  var mask = node.getAttribute('data-fa-mask');

  if (!mask) {
    return emptyCanonicalIcon();
  } else {
    return getCanonicalIcon(mask.split(' ').map(function (i) {
      return i.trim();
    }));
  }
}

function blankMeta() {
  return {
    iconName: null,
    title: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  var _classParser = classParser(node),
      iconName = _classParser.iconName,
      prefix = _classParser.prefix,
      extraClasses = _classParser.rest;

  var extraStyles = styleParser(node);
  var transform = transformParser(node);
  var symbol = symbolParser(node);
  var extraAttributes = attributesParser(node);
  var mask = maskParser(node);
  return {
    iconName: iconName,
    title: node.getAttribute('title'),
    prefix: prefix,
    transform: transform,
    symbol: symbol,
    mask: mask,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  };
}

function MissingIcon(error) {
  this.name = 'MissingIcon';
  this.message = error || 'Icon unavailable';
  this.stack = new Error().stack;
}
MissingIcon.prototype = Object.create(Error.prototype);
MissingIcon.prototype.constructor = MissingIcon;

var FILL = {
  fill: 'currentColor'
};
var ANIMATION_BASE = {
  attributeType: 'XML',
  repeatCount: 'indefinite',
  dur: '2s'
};
var RING = {
  tag: 'path',
  attributes: _objectSpread({}, FILL, {
    d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
  })
};

var OPACITY_ANIMATE = _objectSpread({}, ANIMATION_BASE, {
  attributeName: 'opacity'
});

var DOT = {
  tag: 'circle',
  attributes: _objectSpread({}, FILL, {
    cx: '256',
    cy: '364',
    r: '28'
  }),
  children: [{
    tag: 'animate',
    attributes: _objectSpread({}, ANIMATION_BASE, {
      attributeName: 'r',
      values: '28;14;28;28;14;28;'
    })
  }, {
    tag: 'animate',
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: '1;0;1;1;0;1;'
    })
  }]
};
var QUESTION = {
  tag: 'path',
  attributes: _objectSpread({}, FILL, {
    opacity: '1',
    d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
  }),
  children: [{
    tag: 'animate',
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: '1;0;0;0;0;1;'
    })
  }]
};
var EXCLAMATION = {
  tag: 'path',
  attributes: _objectSpread({}, FILL, {
    opacity: '0',
    d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
  }),
  children: [{
    tag: 'animate',
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: '0;0;1;1;0;0;'
    })
  }]
};
var missing = {
  tag: 'g',
  children: [RING, DOT, QUESTION, EXCLAMATION]
};

var styles$2 = namespace.styles;
function findIcon(iconName, prefix) {
  return new picked(function (resolve, reject) {
    var val = {
      found: false,
      width: 512,
      height: 512,
      icon: missing
    };

    if (iconName && prefix && styles$2[prefix] && styles$2[prefix][iconName]) {
      var icon = styles$2[prefix][iconName];
      var width = icon[0];
      var height = icon[1];
      var vectorData = icon.slice(4);
      val = {
        found: true,
        width: width,
        height: height,
        icon: {
          tag: 'path',
          attributes: {
            fill: 'currentColor',
            d: vectorData[0]
          }
        }
      };
      return resolve(val);
    }

    if (iconName && prefix && !config.showMissingIcons) {
      reject(new MissingIcon("Icon is missing for prefix ".concat(prefix, " with icon name ").concat(iconName)));
    } else {
      resolve(val);
    }
  });
}

var styles$3 = namespace.styles;

function generateSvgReplacementMutation(node, nodeMeta) {
  var iconName = nodeMeta.iconName,
      title = nodeMeta.title,
      prefix = nodeMeta.prefix,
      transform = nodeMeta.transform,
      symbol = nodeMeta.symbol,
      mask = nodeMeta.mask,
      extra = nodeMeta.extra;
  return new picked(function (resolve, reject) {
    picked.all([findIcon(iconName, prefix), findIcon(mask.iconName, mask.prefix)]).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          main = _ref2[0],
          mask = _ref2[1];

      resolve([node, makeInlineSvgAbstract({
        icons: {
          main: main,
          mask: mask
        },
        prefix: prefix,
        iconName: iconName,
        transform: transform,
        symbol: symbol,
        mask: mask,
        title: title,
        extra: extra,
        watchable: true
      })]);
    });
  });
}

function generateLayersText(node, nodeMeta) {
  var title = nodeMeta.title,
      transform = nodeMeta.transform,
      extra = nodeMeta.extra;
  var width = null;
  var height = null;

  if (IS_IE) {
    var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
    var boundingClientRect = node.getBoundingClientRect();
    width = boundingClientRect.width / computedFontSize;
    height = boundingClientRect.height / computedFontSize;
  }

  if (config.autoA11y && !title) {
    extra.attributes['aria-hidden'] = 'true';
  }

  return picked.resolve([node, makeLayersTextAbstract({
    content: node.innerHTML,
    width: width,
    height: height,
    transform: transform,
    title: title,
    extra: extra,
    watchable: true
  })]);
}

function generateMutation(node) {
  var nodeMeta = parseMeta(node);

  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return generateLayersText(node, nodeMeta);
  } else {
    return generateSvgReplacementMutation(node, nodeMeta);
  }
}

function onTree(root) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!IS_DOM) return;
  var htmlClassList = DOCUMENT.documentElement.classList;

  var hclAdd = function hclAdd(suffix) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var hclRemove = function hclRemove(suffix) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var prefixes = config.autoFetchSvg ? Object.keys(PREFIX_TO_STYLE) : Object.keys(styles$3);
  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map(function (p) {
    return ".".concat(p, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(', ');

  if (prefixesDomQuery.length === 0) {
    return;
  }

  var candidates = [];

  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e) {// noop
  }

  if (candidates.length > 0) {
    hclAdd('pending');
    hclRemove('complete');
  } else {
    return;
  }

  var mark = perf.begin('onTree');
  var mutations = candidates.reduce(function (acc, node) {
    try {
      var mutation = generateMutation(node);

      if (mutation) {
        acc.push(mutation);
      }
    } catch (e) {
      if (!PRODUCTION) {
        if (e instanceof MissingIcon) {
          console.error(e);
        }
      }
    }

    return acc;
  }, []);
  return new picked(function (resolve, reject) {
    picked.all(mutations).then(function (resolvedMutations) {
      perform(resolvedMutations, function () {
        hclAdd('active');
        hclAdd('complete');
        hclRemove('pending');
        if (typeof callback === 'function') callback();
        mark();
        resolve();
      });
    }).catch(function () {
      mark();
      reject();
    });
  });
}
function onNode(node) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  generateMutation(node).then(function (mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}

function replaceForPosition(node, position) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(':', '-'));
  return new picked(function (resolve, reject) {
    if (node.getAttribute(pendingAttribute) !== null) {
      // This node is already being processed
      return resolve();
    }

    var children = toArray(node.children);
    var alreadyProcessedPseudoElement = children.filter(function (c) {
      return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
    })[0];
    var styles = WINDOW.getComputedStyle(node, position);
    var fontFamily = styles.getPropertyValue('font-family').match(FONT_FAMILY_PATTERN);
    var fontWeight = styles.getPropertyValue('font-weight');

    if (alreadyProcessedPseudoElement && !fontFamily) {
      // If we've already processed it but the current computed style does not result in a font-family,
      // that probably means that a class name that was previously present to make the icon has been
      // removed. So we now should delete the icon.
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamily) {
      var content = styles.getPropertyValue('content');
      var prefix = ~['Light', 'Regular', 'Solid', 'Brands'].indexOf(fontFamily[1]) ? STYLE_TO_PREFIX[fontFamily[1].toLowerCase()] : FONT_WEIGHT_TO_PREFIX[fontWeight];
      var hexValue = toHex(content.length === 3 ? content.substr(1, 1) : content);
      var iconName = byUnicode(prefix, hexValue);
      var iconIdentifier = iconName; // Only convert the pseudo element in this :before/:after position into an icon if we haven't
      // already done so with the same prefix and iconName

      if (iconName && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);

        if (alreadyProcessedPseudoElement) {
          // Delete the old one, since we're replacing it with a new one
          node.removeChild(alreadyProcessedPseudoElement);
        }

        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then(function (main) {
          var abstract = makeInlineSvgAbstract(_objectSpread({}, meta, {
            icons: {
              main: main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix,
            iconName: iconIdentifier,
            extra: extra,
            watchable: true
          }));
          var element = DOCUMENT.createElement('svg');

          if (position === ':before') {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }

          element.outerHTML = abstract.map(function (a) {
            return toHtml(a);
          }).join('\n');
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}

function replace(node) {
  return picked.all([replaceForPosition(node, ':before'), replaceForPosition(node, ':after')]);
}

function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== 'svg');
}

function searchPseudoElements (root) {
  if (!IS_DOM) return;
  return new picked(function (resolve, reject) {
    var operations = toArray(root.querySelectorAll('*')).filter(processable).map(replace);
    var end = perf.begin('searchPseudoElements');
    disableObservation();
    picked.all(operations).then(function () {
      end();
      enableObservation();
      resolve();
    }).catch(function () {
      end();
      enableObservation();
      reject();
    });
  });
}

var baseStyles = "svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}";

function css () {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc = config.replacementClass;
  var s = baseStyles;

  if (fp !== dfp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), 'g');
    var rPatt = new RegExp("\\.".concat(drc), 'g');
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }

  return s;
}

var Library =
/*#__PURE__*/
function () {
  function Library() {
    _classCallCheck(this, Library);

    this.definitions = {};
  }

  _createClass(Library, [{
    key: "add",
    value: function add() {
      var _this = this;

      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }

      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function (key) {
        _this.definitions[key] = _objectSpread({}, _this.definitions[key] || {}, additions[key]);
        defineIcons(key, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function (key) {
        var _normalized$key = normalized[key],
            prefix = _normalized$key.prefix,
            iconName = _normalized$key.iconName,
            icon = _normalized$key.icon;
        if (!additions[prefix]) additions[prefix] = {};
        additions[prefix][iconName] = icon;
      });
      return additions;
    }
  }]);

  return Library;
}();

function prepIcon(icon) {
  var width = icon[0];
  var height = icon[1];
  var vectorData = icon.slice(4);
  return {
    found: true,
    width: width,
    height: height,
    icon: {
      tag: 'path',
      attributes: {
        fill: 'currentColor',
        d: vectorData[0]
      }
    }
  };
}

function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());

    _cssInserted = true;
  }
}

function apiObject(val, abstractCreator) {
  Object.defineProperty(val, 'abstract', {
    get: abstractCreator
  });
  Object.defineProperty(val, 'html', {
    get: function get() {
      return val.abstract.map(function (a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, 'node', {
    get: function get() {
      if (!IS_DOM) return;
      var container = DOCUMENT.createElement('div');
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}

function findIconDefinition(iconLookup) {
  var _iconLookup$prefix = iconLookup.prefix,
      prefix = _iconLookup$prefix === void 0 ? 'fa' : _iconLookup$prefix,
      iconName = iconLookup.iconName;
  if (!iconName) return;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}

function resolveIcons(next) {
  return function (maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;

    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }

    return next(iconDefinition, _objectSpread({}, params, {
      mask: mask
    }));
  };
}

var library = new Library();
var noAuto = function noAuto() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  disconnect();
};
var _cssInserted = false;
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (IS_DOM) {
      ensureCss();
      var _params$node = params.node,
          node = _params$node === void 0 ? DOCUMENT : _params$node,
          _params$callback = params.callback,
          callback = _params$callback === void 0 ? function () {} : _params$callback;

      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }

      return onTree(node, callback);
    } else {
      return picked.reject('Operation requires a DOM of some kind.');
    }
  },
  css: css,
  insertCss: function insertCss$$1() {
    if (!_cssInserted) {
      insertCss(css());

      _cssInserted = true;
    }
  },
  watch: function watch() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot,
        observeMutationsRoot = params.observeMutationsRoot;

    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }

    config.observeMutations = true;
    domready(function () {
      autoReplace({
        autoReplaceSvgRoot: autoReplaceSvgRoot
      });
      observe({
        treeCallback: onTree,
        nodeCallback: onNode,
        pseudoElementsCallback: searchPseudoElements,
        observeMutationsRoot: observeMutationsRoot
      });
    });
  }
};
var parse = {
  transform: function transform(transformString) {
    return parseTransformString(transformString);
  }
};
var icon = resolveIcons(function (iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$transform = params.transform,
      transform = _params$transform === void 0 ? meaninglessTransform : _params$transform,
      _params$symbol = params.symbol,
      symbol = _params$symbol === void 0 ? false : _params$symbol,
      _params$mask = params.mask,
      mask = _params$mask === void 0 ? null : _params$mask,
      _params$title = params.title,
      title = _params$title === void 0 ? null : _params$title,
      _params$classes = params.classes,
      classes = _params$classes === void 0 ? [] : _params$classes,
      _params$attributes = params.attributes,
      attributes = _params$attributes === void 0 ? {} : _params$attributes,
      _params$styles = params.styles,
      styles = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix = iconDefinition.prefix,
      iconName = iconDefinition.iconName,
      icon = iconDefinition.icon;
  return apiObject(_objectSpread({
    type: 'icon'
  }, iconDefinition), function () {
    ensureCss();

    if (config.autoA11y) {
      if (title) {
        attributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(nextUniqueId());
      } else {
        attributes['aria-hidden'] = 'true';
        attributes['focusable'] = 'false';
      }
    }

    return makeInlineSvgAbstract({
      icons: {
        main: prepIcon(icon),
        mask: mask ? prepIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix,
      iconName: iconName,
      transform: _objectSpread({}, meaninglessTransform, transform),
      symbol: symbol,
      title: title,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: classes
      }
    });
  });
});
var text = function text(content) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$transform2 = params.transform,
      transform = _params$transform2 === void 0 ? meaninglessTransform : _params$transform2,
      _params$title2 = params.title,
      title = _params$title2 === void 0 ? null : _params$title2,
      _params$classes2 = params.classes,
      classes = _params$classes2 === void 0 ? [] : _params$classes2,
      _params$attributes2 = params.attributes,
      attributes = _params$attributes2 === void 0 ? {} : _params$attributes2,
      _params$styles2 = params.styles,
      styles = _params$styles2 === void 0 ? {} : _params$styles2;
  return apiObject({
    type: 'text',
    content: content
  }, function () {
    ensureCss();
    return makeLayersTextAbstract({
      content: content,
      transform: _objectSpread({}, meaninglessTransform, transform),
      title: title,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: ["".concat(config.familyPrefix, "-layers-text")].concat(_toConsumableArray(classes))
      }
    });
  });
};
var counter = function counter(content) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$title3 = params.title,
      title = _params$title3 === void 0 ? null : _params$title3,
      _params$classes3 = params.classes,
      classes = _params$classes3 === void 0 ? [] : _params$classes3,
      _params$attributes3 = params.attributes,
      attributes = _params$attributes3 === void 0 ? {} : _params$attributes3,
      _params$styles3 = params.styles,
      styles = _params$styles3 === void 0 ? {} : _params$styles3;
  return apiObject({
    type: 'counter',
    content: content
  }, function () {
    ensureCss();
    return makeLayersCounterAbstract({
      content: content.toString(),
      title: title,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: ["".concat(config.familyPrefix, "-layers-counter")].concat(_toConsumableArray(classes))
      }
    });
  });
};
var layer = function layer(assembler) {
  return apiObject({
    type: 'layer'
  }, function () {
    ensureCss();
    var children = [];
    assembler(function (args) {
      Array.isArray(args) ? args.map(function (a) {
        children = children.concat(a.abstract);
      }) : children = children.concat(args.abstract);
    });
    return [{
      tag: 'span',
      attributes: {
        class: "".concat(config.familyPrefix, "-layers")
      },
      children: children
    }];
  });
};
var api = {
  noAuto: noAuto,
  config: config,
  dom: dom,
  library: library,
  parse: parse,
  findIconDefinition: findIconDefinition,
  icon: icon,
  text: text,
  counter: counter,
  layer: layer,
  toHtml: toHtml
};

var autoReplace = function autoReplace() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot,
      autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebook.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faFacebook.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'facebook';
var width = 512;
var height = 512;
var ligatures = [];
var unicode = 'f09a';
var svgPathData = 'M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faFacebook = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebookF.js":
/*!************************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faFacebookF.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'facebook-f';
var width = 320;
var height = 512;
var ligatures = [];
var unicode = 'f39e';
var svgPathData = 'M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faFacebookF = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faInstagram.js":
/*!************************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faInstagram.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'instagram';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f16d';
var svgPathData = 'M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faInstagram = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faLinkedin.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'linkedin';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f08c';
var svgPathData = 'M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faLinkedin = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedinIn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faLinkedinIn.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'linkedin-in';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f0e1';
var svgPathData = 'M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faLinkedinIn = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faTwitter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faTwitter.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'twitter';
var width = 512;
var height = 512;
var ligatures = [];
var unicode = 'f099';
var svgPathData = 'M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faTwitter = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faYoutube.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faYoutube.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'youtube';
var width = 576;
var height = 512;
var ligatures = [];
var unicode = 'f167';
var svgPathData = 'M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faYoutube = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/js/bundle.js":
/*!**************************!*\
  !*** ./src/js/bundle.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modernizr_custom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modernizr-custom */ "./src/js/modernizr-custom.js");
/* harmony import */ var _modernizr_custom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modernizr_custom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rarebird_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rarebird-includes */ "./src/js/rarebird-includes.js");
/* harmony import */ var _rarebird_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rarebird_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _icons_import__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons-import */ "./src/js/icons-import.js");




/***/ }),

/***/ "./src/js/icons-import.js":
/*!********************************!*\
  !*** ./src/js/icons-import.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fortawesome/fontawesome-svg-core */ "./node_modules/@fortawesome/fontawesome-svg-core/index.es.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faFacebookF */ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebookF.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faFacebook */ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebook.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faTwitter */ "./node_modules/@fortawesome/free-brands-svg-icons/faTwitter.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faInstagram */ "./node_modules/@fortawesome/free-brands-svg-icons/faInstagram.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faLinkedin */ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedin.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faLinkedinIn */ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedinIn.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faYoutube__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faYoutube */ "./node_modules/@fortawesome/free-brands-svg-icons/faYoutube.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faYoutube__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faYoutube__WEBPACK_IMPORTED_MODULE_7__);
//
// Icons import file
// --------------------------------------------------
// Uses Font Awesome 5 icons + API:
// https://fontawesome.com/how-to-use/on-the-web/advanced/svg-javascript-core
// https://fontawesome.com/how-to-use/with-the-api/setup/getting-started
// --------------------------------------------------
// 
// --------------------------------------------------
// Gulp is used to command Rollup to turn this import
// file in to a rendered, tree-shaken file, that only
// includes the icons desired.
// --------------------------------------------------
// [Step 1] Import desired icons...
// ---------------------------------------
// First, import the library and DOM manipulation utilities
 // Add the icons you want to use here, AND include them in the Library .add() function below
// Common Brands _________



 // import { faPinterest } from '@fortawesome/free-brands-svg-icons';




 // Demo: Light, Solid, and Regular versions of the same icon _________
// import { faEnvelope as falEnvelope } from '@fortawesome/pro-light-svg-icons';
// import { faEnvelope as fasEnvelope } from '@fortawesome/pro-solid-svg-icons';
// import { faEnvelope as farEnvelope } from '@fortawesome/pro-regular-svg-icons';
// Common Icons that RB uses on sites _________
// import { faEnvelope } from '@fortawesome/pro-regular-svg-icons';
// import { faFilter } from '@fortawesome/pro-regular-svg-icons';
// import { faFilePdf } from '@fortawesome/pro-regular-svg-icons';
// import { faExclamationTriangle } from '@fortawesome/pro-regular-svg-icons';
// import { faInfoCircle } from '@fortawesome/pro-regular-svg-icons';
// import { faLink } from '@fortawesome/pro-regular-svg-icons';
// import { faSearch } from '@fortawesome/pro-regular-svg-icons';
// import { faPrint } from '@fortawesome/pro-regular-svg-icons';
// import { faPlus } from '@fortawesome/pro-regular-svg-icons';
// import { faMinus } from '@fortawesome/pro-regular-svg-icons';
// import { faTimes } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronUp } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronRight } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronDown } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronLeft } from '@fortawesome/pro-regular-svg-icons';
// [Step 2] Add desired icons to library
// ---------------------------------------

_fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__["library"].add( // faEnvelope,
_fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1__["faFacebookF"], _fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2__["faFacebook"], _fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3__["faTwitter"], // faPinterest,
_fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4__["faInstagram"], _fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5__["faLinkedin"], _fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6__["faLinkedinIn"], _fortawesome_free_brands_svg_icons_faYoutube__WEBPACK_IMPORTED_MODULE_7__["faYoutube"] // falEnvelope,
// fasEnvelope,
// farEnvelope,
// faFilter,
// faFilePdf,
// faExclamationTriangle,
// faInfoCircle,
// faLink,
// faSearch,
// faPrint,
// faPlus,
// faMinus,
// faTimes,
// faChevronUp,
// faChevronRight,
// faChevronDown,
// faChevronLeft,
); // Replace any existing <i> tags with <svg> and set up a MutationObserver to
// continue doing this as the DOM changes.
// ---------------------------------------

_fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__["dom"].watch();

/***/ }),

/***/ "./src/js/modernizr-custom.js":
/*!************************************!*\
  !*** ./src/js/modernizr-custom.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! modernizr 3.6.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-backdropfilter-backgroundcliptext-cssfilters-cssgrid_cssgridlegacy-csspositionsticky-picture-domprefixes-prefixed-prefixes-setclasses-testallprops-testprop-teststyles-cssclassprefix:mod- !*/
!function (e, t, n) {
  function r(e, t) {
    return _typeof(e) === t;
  }

  function s() {
    var e, t, n, s, o, i, l;

    for (var a in S) {
      if (S.hasOwnProperty(a)) {
        if (e = [], t = S[a], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) {
          e.push(t.options.aliases[n].toLowerCase());
        }

        for (s = r(t.fn, "function") ? t.fn() : t.fn, o = 0; o < e.length; o++) {
          i = e[o], l = i.split("."), 1 === l.length ? Modernizr[l[0]] = s : (!Modernizr[l[0]] || Modernizr[l[0]] instanceof Boolean || (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])), Modernizr[l[0]][l[1]] = s), C.push((s ? "" : "no-") + l.join("-"));
        }
      }
    }
  }

  function o(e) {
    var t = w.className,
        n = Modernizr._config.classPrefix || "";

    if (b && (t = t.baseVal), Modernizr._config.enableJSClass) {
      var r = new RegExp("(^|\\s)" + n + "no-js(\\s|$)");
      t = t.replace(r, "$1" + n + "js$2");
    }

    Modernizr._config.enableClasses && (t += " " + n + e.join(" " + n), b ? w.className.baseVal = t : w.className = t);
  }

  function i(e) {
    return e.replace(/([a-z])-([a-z])/g, function (e, t, n) {
      return t + n.toUpperCase();
    }).replace(/^-/, "");
  }

  function l() {
    return "function" != typeof t.createElement ? t.createElement(arguments[0]) : b ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments);
  }

  function a(e, t) {
    return !!~("" + e).indexOf(t);
  }

  function u() {
    var e = t.body;
    return e || (e = l(b ? "svg" : "body"), e.fake = !0), e;
  }

  function f(e, n, r, s) {
    var o,
        i,
        a,
        f,
        d = "modernizr",
        p = l("div"),
        c = u();
    if (parseInt(r, 10)) for (; r--;) {
      a = l("div"), a.id = s ? s[r] : d + (r + 1), p.appendChild(a);
    }
    return o = l("style"), o.type = "text/css", o.id = "s" + d, (c.fake ? c : p).appendChild(o), c.appendChild(p), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(t.createTextNode(e)), p.id = d, c.fake && (c.style.background = "", c.style.overflow = "hidden", f = w.style.overflow, w.style.overflow = "hidden", w.appendChild(c)), i = n(p, e), c.fake ? (c.parentNode.removeChild(c), w.style.overflow = f, w.offsetHeight) : p.parentNode.removeChild(p), !!i;
  }

  function d(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  }

  function p(e, t, n) {
    var s;

    for (var o in e) {
      if (e[o] in t) return n === !1 ? e[o] : (s = t[e[o]], r(s, "function") ? d(s, n || t) : s);
    }

    return !1;
  }

  function c(e) {
    return e.replace(/([A-Z])/g, function (e, t) {
      return "-" + t.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }

  function m(t, n, r) {
    var s;

    if ("getComputedStyle" in e) {
      s = getComputedStyle.call(e, t, n);
      var o = e.console;
      if (null !== s) r && (s = s.getPropertyValue(r));else if (o) {
        var i = o.error ? "error" : "log";
        o[i].call(o, "getComputedStyle returning null, its possible modernizr test results are inaccurate");
      }
    } else s = !n && t.currentStyle && t.currentStyle[r];

    return s;
  }

  function g(t, r) {
    var s = t.length;

    if ("CSS" in e && "supports" in e.CSS) {
      for (; s--;) {
        if (e.CSS.supports(c(t[s]), r)) return !0;
      }

      return !1;
    }

    if ("CSSSupportsRule" in e) {
      for (var o = []; s--;) {
        o.push("(" + c(t[s]) + ":" + r + ")");
      }

      return o = o.join(" or "), f("@supports (" + o + ") { #modernizr { position: absolute; } }", function (e) {
        return "absolute" == m(e, null, "position");
      });
    }

    return n;
  }

  function y(e, t, s, o) {
    function u() {
      d && (delete L.style, delete L.modElem);
    }

    if (o = r(o, "undefined") ? !1 : o, !r(s, "undefined")) {
      var f = g(e, s);
      if (!r(f, "undefined")) return f;
    }

    for (var d, p, c, m, y, v = ["modernizr", "tspan", "samp"]; !L.style && v.length;) {
      d = !0, L.modElem = l(v.shift()), L.style = L.modElem.style;
    }

    for (c = e.length, p = 0; c > p; p++) {
      if (m = e[p], y = L.style[m], a(m, "-") && (m = i(m)), L.style[m] !== n) {
        if (o || r(s, "undefined")) return u(), "pfx" == t ? m : !0;

        try {
          L.style[m] = s;
        } catch (h) {}

        if (L.style[m] != y) return u(), "pfx" == t ? m : !0;
      }
    }

    return u(), !1;
  }

  function v(e, t, n, s, o) {
    var i = e.charAt(0).toUpperCase() + e.slice(1),
        l = (e + " " + z.join(i + " ") + i).split(" ");
    return r(t, "string") || r(t, "undefined") ? y(l, t, s, o) : (l = (e + " " + P.join(i + " ") + i).split(" "), p(l, t, n));
  }

  function h(e, t, r) {
    return v(e, n, n, t, r);
  }

  var C = [],
      S = [],
      x = {
    _version: "3.6.0",
    _config: {
      classPrefix: "mod-",
      enableClasses: !0,
      enableJSClass: !0,
      usePrefixes: !0
    },
    _q: [],
    on: function on(e, t) {
      var n = this;
      setTimeout(function () {
        t(n[e]);
      }, 0);
    },
    addTest: function addTest(e, t, n) {
      S.push({
        name: e,
        fn: t,
        options: n
      });
    },
    addAsyncTest: function addAsyncTest(e) {
      S.push({
        name: null,
        fn: e
      });
    }
  },
      Modernizr = function Modernizr() {};

  Modernizr.prototype = x, Modernizr = new Modernizr(), Modernizr.addTest("picture", "HTMLPictureElement" in e);

  var _ = x._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];

  x._prefixes = _;
  var w = t.documentElement,
      b = "svg" === w.nodeName.toLowerCase(),
      T = "Moz O ms Webkit",
      P = x._config.usePrefixes ? T.toLowerCase().split(" ") : [];
  x._domPrefixes = P, Modernizr.addTest("csspositionsticky", function () {
    var e = "position:",
        t = "sticky",
        n = l("a"),
        r = n.style;
    return r.cssText = e + _.join(t + ";" + e).slice(0, -e.length), -1 !== r.position.indexOf(t);
  });
  var k = "CSS" in e && "supports" in e.CSS,
      E = "supportsCSS" in e;
  Modernizr.addTest("supports", k || E);
  var z = x._config.usePrefixes ? T.split(" ") : [];
  x._cssomPrefixes = z;

  var j = function j(t) {
    var r,
        s = _.length,
        o = e.CSSRule;
    if ("undefined" == typeof o) return n;
    if (!t) return !1;
    if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in o) return "@" + t;

    for (var i = 0; s > i; i++) {
      var l = _[i],
          a = l.toUpperCase() + "_" + r;
      if (a in o) return "@-" + l.toLowerCase() + "-" + t;
    }

    return !1;
  };

  x.atRule = j;
  var N = (x.testStyles = f, {
    elem: l("modernizr")
  });

  Modernizr._q.push(function () {
    delete N.elem;
  });

  var L = {
    style: N.elem.style
  };

  Modernizr._q.unshift(function () {
    delete L.style;
  });

  x.testProp = function (e, t, r) {
    return y([e], n, t, r);
  };

  x.testAllProps = v;

  x.prefixed = function (e, t, n) {
    return 0 === e.indexOf("@") ? j(e) : (-1 != e.indexOf("-") && (e = i(e)), t ? v(e, t, n) : v(e, "pfx"));
  };

  x.testAllProps = h, Modernizr.addTest("backdropfilter", h("backdropFilter")), Modernizr.addTest("backgroundcliptext", function () {
    return h("backgroundClip", "text");
  }), Modernizr.addTest("cssgridlegacy", h("grid-columns", "10px", !0)), Modernizr.addTest("cssgrid", h("grid-template-rows", "none", !0)), Modernizr.addTest("cssfilters", function () {
    if (Modernizr.supports) return h("filter", "blur(2px)");
    var e = l("a");
    return e.style.cssText = _.join("filter:blur(2px); "), !!e.style.length && (t.documentMode === n || t.documentMode > 9);
  }), s(), o(C), delete x.addTest, delete x.addAsyncTest;

  for (var O = 0; O < Modernizr._q.length; O++) {
    Modernizr._q[O]();
  }

  e.Modernizr = Modernizr;
}(window, document);

/***/ }),

/***/ "./src/js/rarebird-includes.js":
/*!*************************************!*\
  !*** ./src/js/rarebird-includes.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//
// Compiled Site Scripts
// ----------------------------------------------------------------------------
// Warning: Global.js is a COMPILED file! Edit a source file, or create a new
// one. See gulpfile.js!
//
//  #######
//     #    #    # #  ####      #  ####        ##
//     #    #    # # #          # #           #  #
//     #    ###### #  ####      #  ####      #    #
//     #    #    # #      #     #      #     ######
//     #    #    # # #    #     # #    #     #    #
//     #    #    # #  ####      #  ####      #    #
//  #####  ####### #     # ######  ### #       ####### ######
// #     # #     # ##   ## #     #  #  #       #       #     #
// #       #     # # # # # #     #  #  #       #       #     #
// #       #     # #  #  # ######   #  #       #####   #     #
// #       #     # #     # #        #  #       #       #     #
// #     # #     # #     # #        #  #       #       #     #
//  #####  ####### #     # #       ### ####### ####### ######
//
// ####### ### #       #######
// #        #  #       #
// #        #  #       #
// #####    #  #       #####
// #        #  #       #
// #        #  #       #
// #       ### ####### #######
//
// Warning: Global.js is a COMPILED file! Edit a source file, or create a new
// one. See gulpfile.babel.js!
// ----------------------------------------------------------------------------
//
// Polyfill for using forEach() on NodeLists
// --------------------------------------------------
// Adds support for IE 11 without calling in a 
// Babel dumptruck.
// --------------------------------------------------
// via https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#Polyfill
// --------------------------------------------------
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = function (callback, thisArg) {
    thisArg = thisArg || window;

    for (var i = 0; i < this.length; i++) {
      callback.call(thisArg, this[i], i, this);
    }
  };
}
/* ========================================================================
 * Bootstrap: transition.js v3.4.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict'; // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap');
    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    };

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return {
          end: transEndEventNames[name]
        };
      }
    }

    return false; // explicit for ie8 (  ._.)
  } // http://blog.alexmaccaw.com/css-transitions


  $.fn.emulateTransitionEnd = function (duration) {
    var called = false;
    var $el = this;
    $(this).one('bsTransitionEnd', function () {
      called = true;
    });

    var callback = function callback() {
      if (!called) $($el).trigger($.support.transition.end);
    };

    setTimeout(callback, duration);
    return this;
  };

  $(function () {
    $.support.transition = transitionEnd();
    if (!$.support.transition) return;
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function handle(e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
      }
    };
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: alert.js v3.4.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
  'use strict'; // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]';

  var Alert = function Alert(el) {
    $(el).on('click', dismiss, this.close);
  };

  Alert.VERSION = '3.4.0';
  Alert.TRANSITION_DURATION = 150;

  Alert.prototype.close = function (e) {
    var $this = $(this);
    var selector = $this.attr('data-target');

    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

    selector = selector === '#' ? [] : selector;
    var $parent = $(document).find(selector);
    if (e) e.preventDefault();

    if (!$parent.length) {
      $parent = $this.closest('.alert');
    }

    $parent.trigger(e = $.Event('close.bs.alert'));
    if (e.isDefaultPrevented()) return;
    $parent.removeClass('in');

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove();
    }

    $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
  }; // ALERT PLUGIN DEFINITION
  // =======================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.alert');
      if (!data) $this.data('bs.alert', data = new Alert(this));
      if (typeof option == 'string') data[option].call($this);
    });
  }

  var old = $.fn.alert;
  $.fn.alert = Plugin;
  $.fn.alert.Constructor = Alert; // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  }; // ALERT DATA-API
  // ==============


  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
}(jQuery);
/* ========================================================================
 * Bootstrap: modal.js v3.4.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
  'use strict'; // MODAL CLASS DEFINITION
  // ======================

  var Modal = function Modal(element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find('.modal-dialog');
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;

    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };

  Modal.VERSION = '3.4.0';
  Modal.TRANSITION_DURATION = 300;
  Modal.BACKDROP_TRANSITION_DURATION = 150;
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };

  Modal.prototype.show = function (_relatedTarget) {
    var that = this;
    var e = $.Event('show.bs.modal', {
      relatedTarget: _relatedTarget
    });
    this.$element.trigger(e);
    if (this.isShown || e.isDefaultPrevented()) return;
    this.isShown = true;
    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass('modal-open');
    this.escape();
    this.resize();
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
      });
    });
    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body); // don't move modals dom position
      }

      that.$element.show().scrollTop(0);
      that.adjustDialog();

      if (transition) {
        that.$element[0].offsetWidth; // force reflow
      }

      that.$element.addClass('in');
      that.enforceFocus();
      var e = $.Event('shown.bs.modal', {
        relatedTarget: _relatedTarget
      });
      transition ? that.$dialog // wait for modal to slide in
      .one('bsTransitionEnd', function () {
        that.$element.trigger('focus').trigger(e);
      }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
    });
  };

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault();
    e = $.Event('hide.bs.modal');
    this.$element.trigger(e);
    if (!this.isShown || e.isDefaultPrevented()) return;
    this.isShown = false;
    this.escape();
    this.resize();
    $(document).off('focusin.bs.modal');
    this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
    this.$dialog.off('mousedown.dismiss.bs.modal');
    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
  };

  Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal') // guard against infinite focus loop
    .on('focusin.bs.modal', $.proxy(function (e) {
      if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
        this.$element.trigger('focus');
      }
    }, this));
  };

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal');
    }
  };

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
    } else {
      $(window).off('resize.bs.modal');
    }
  };

  Modal.prototype.hideModal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass('modal-open');
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger('hidden.bs.modal');
    });
  };

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };

  Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass('fade') ? 'fade' : '';

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;
      this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }

        if (e.target !== e.currentTarget) return;
        this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
      }, this));
      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

      this.$backdrop.addClass('in');
      if (!callback) return;
      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in');

      var callbackRemove = function callbackRemove() {
        that.removeBackdrop();
        callback && callback();
      };

      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
    } else if (callback) {
      callback();
    }
  }; // these following methods are used to handle overflowing modals


  Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    });
  };

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    });
  };

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;

    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect();
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
    }

    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || '';
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
  };

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad);
  };

  Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement('div');
    scrollDiv.className = 'modal-scrollbar-measure';
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  }; // MODAL PLUGIN DEFINITION
  // =======================


  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);
      if (!data) $this.data('bs.modal', data = new Modal(this, options));
      if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
    });
  }

  var old = $.fn.modal;
  $.fn.modal = Plugin;
  $.fn.modal.Constructor = Modal; // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  }; // MODAL DATA-API
  // ==============


  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this);
    var href = $this.attr('href');
    var target = $this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

    var $target = $(document).find(target);
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({
      remote: !/#/.test(href) && href
    }, $target.data(), $this.data());
    if ($this.is('a')) e.preventDefault();
    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown

      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus');
      });
    });
    Plugin.call($target, option, this);
  });
}(jQuery);
/*global define:false */

/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.2
 * @url craig.is/killing/mice
 */

(function (window, document, undefined) {
  // Check if mousetrap is used inside browser, if not, return
  if (!window) {
    return;
  }
  /**
   * mapping of special keycodes to their corresponding keys
   *
   * everything in this dictionary cannot use keypress events
   * so it has to be here to map to the correct keycodes for
   * keyup/keydown events
   *
   * @type {Object}
   */


  var _MAP = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    16: 'shift',
    17: 'ctrl',
    18: 'alt',
    20: 'capslock',
    27: 'esc',
    32: 'space',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    45: 'ins',
    46: 'del',
    91: 'meta',
    93: 'meta',
    224: 'meta'
  };
  /**
   * mapping for special characters so they can support
   *
   * this dictionary is only used incase you want to bind a
   * keyup or keydown event to one of these keys
   *
   * @type {Object}
   */

  var _KEYCODE_MAP = {
    106: '*',
    107: '+',
    109: '-',
    110: '.',
    111: '/',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: '\''
  };
  /**
   * this is a mapping of keys that require shift on a US keypad
   * back to the non shift equivelents
   *
   * this is so you can use keyup events with these keys
   *
   * note that this will only work reliably on US keyboards
   *
   * @type {Object}
   */

  var _SHIFT_MAP = {
    '~': '`',
    '!': '1',
    '@': '2',
    '#': '3',
    '$': '4',
    '%': '5',
    '^': '6',
    '&': '7',
    '*': '8',
    '(': '9',
    ')': '0',
    '_': '-',
    '+': '=',
    ':': ';',
    '\"': '\'',
    '<': ',',
    '>': '.',
    '?': '/',
    '|': '\\'
  };
  /**
   * this is a list of special strings you can use to map
   * to modifier keys when you specify your keyboard shortcuts
   *
   * @type {Object}
   */

  var _SPECIAL_ALIASES = {
    'option': 'alt',
    'command': 'meta',
    'return': 'enter',
    'escape': 'esc',
    'plus': '+',
    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
  };
  /**
   * variable to store the flipped version of _MAP from above
   * needed to check if we should use keypress or not when no action
   * is specified
   *
   * @type {Object|undefined}
   */

  var _REVERSE_MAP;
  /**
   * loop through the f keys, f1 to f19 and add them to the map
   * programatically
   */


  for (var i = 1; i < 20; ++i) {
    _MAP[111 + i] = 'f' + i;
  }
  /**
   * loop through to map numbers on the numeric keypad
   */


  for (i = 0; i <= 9; ++i) {
    // This needs to use a string cause otherwise since 0 is falsey
    // mousetrap will never fire for numpad 0 pressed as part of a keydown
    // event.
    //
    // @see https://github.com/ccampbell/mousetrap/pull/258
    _MAP[i + 96] = i.toString();
  }
  /**
   * cross browser add event method
   *
   * @param {Element|HTMLDocument} object
   * @param {string} type
   * @param {Function} callback
   * @returns void
   */


  function _addEvent(object, type, callback) {
    if (object.addEventListener) {
      object.addEventListener(type, callback, false);
      return;
    }

    object.attachEvent('on' + type, callback);
  }
  /**
   * takes the event and returns the key character
   *
   * @param {Event} e
   * @return {string}
   */


  function _characterFromEvent(e) {
    // for keypress events we should return the character as is
    if (e.type == 'keypress') {
      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume
      // that we want the character to be lowercase.  this means if
      // you accidentally have caps lock on then your key bindings
      // will continue to work
      //
      // the only side effect that might not be desired is if you
      // bind something like 'A' cause you want to trigger an
      // event when capital A is pressed caps lock will no longer
      // trigger the event.  shift+a will though.

      if (!e.shiftKey) {
        character = character.toLowerCase();
      }

      return character;
    } // for non keypress events the special maps are needed


    if (_MAP[e.which]) {
      return _MAP[e.which];
    }

    if (_KEYCODE_MAP[e.which]) {
      return _KEYCODE_MAP[e.which];
    } // if it is not in the special map
    // with keydown and keyup events the character seems to always
    // come in as an uppercase character whether you are pressing shift
    // or not.  we should make sure it is always lowercase for comparisons


    return String.fromCharCode(e.which).toLowerCase();
  }
  /**
   * checks if two arrays are equal
   *
   * @param {Array} modifiers1
   * @param {Array} modifiers2
   * @returns {boolean}
   */


  function _modifiersMatch(modifiers1, modifiers2) {
    return modifiers1.sort().join(',') === modifiers2.sort().join(',');
  }
  /**
   * takes a key event and figures out what the modifiers are
   *
   * @param {Event} e
   * @returns {Array}
   */


  function _eventModifiers(e) {
    var modifiers = [];

    if (e.shiftKey) {
      modifiers.push('shift');
    }

    if (e.altKey) {
      modifiers.push('alt');
    }

    if (e.ctrlKey) {
      modifiers.push('ctrl');
    }

    if (e.metaKey) {
      modifiers.push('meta');
    }

    return modifiers;
  }
  /**
   * prevents default for this event
   *
   * @param {Event} e
   * @returns void
   */


  function _preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
      return;
    }

    e.returnValue = false;
  }
  /**
   * stops propogation for this event
   *
   * @param {Event} e
   * @returns void
   */


  function _stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
      return;
    }

    e.cancelBubble = true;
  }
  /**
   * determines if the keycode specified is a modifier key or not
   *
   * @param {string} key
   * @returns {boolean}
   */


  function _isModifier(key) {
    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
  }
  /**
   * reverses the map lookup so that we can look for specific keys
   * to see what can and can't use keypress
   *
   * @return {Object}
   */


  function _getReverseMap() {
    if (!_REVERSE_MAP) {
      _REVERSE_MAP = {};

      for (var key in _MAP) {
        // pull out the numeric keypad from here cause keypress should
        // be able to detect the keys from the character
        if (key > 95 && key < 112) {
          continue;
        }

        if (_MAP.hasOwnProperty(key)) {
          _REVERSE_MAP[_MAP[key]] = key;
        }
      }
    }

    return _REVERSE_MAP;
  }
  /**
   * picks the best action based on the key combination
   *
   * @param {string} key - character for key
   * @param {Array} modifiers
   * @param {string=} action passed in
   */


  function _pickBestAction(key, modifiers, action) {
    // if no action was picked in we should try to pick the one
    // that we think would work best for this key
    if (!action) {
      action = _getReverseMap()[key] ? 'keydown' : 'keypress';
    } // modifier keys don't work as expected with keypress,
    // switch to keydown


    if (action == 'keypress' && modifiers.length) {
      action = 'keydown';
    }

    return action;
  }
  /**
   * Converts from a string key combination to an array
   *
   * @param  {string} combination like "command+shift+l"
   * @return {Array}
   */


  function _keysFromString(combination) {
    if (combination === '+') {
      return ['+'];
    }

    combination = combination.replace(/\+{2}/g, '+plus');
    return combination.split('+');
  }
  /**
   * Gets info for a specific key combination
   *
   * @param  {string} combination key combination ("command+s" or "a" or "*")
   * @param  {string=} action
   * @returns {Object}
   */


  function _getKeyInfo(combination, action) {
    var keys;
    var key;
    var i;
    var modifiers = []; // take the keys from this pattern and figure out what the actual
    // pattern is all about

    keys = _keysFromString(combination);

    for (i = 0; i < keys.length; ++i) {
      key = keys[i]; // normalize key names

      if (_SPECIAL_ALIASES[key]) {
        key = _SPECIAL_ALIASES[key];
      } // if this is not a keypress event then we should
      // be smart about using shift keys
      // this will only work for US keyboards however


      if (action && action != 'keypress' && _SHIFT_MAP[key]) {
        key = _SHIFT_MAP[key];
        modifiers.push('shift');
      } // if this key is a modifier then add it to the list of modifiers


      if (_isModifier(key)) {
        modifiers.push(key);
      }
    } // depending on what the key combination is
    // we will try to pick the best event for it


    action = _pickBestAction(key, modifiers, action);
    return {
      key: key,
      modifiers: modifiers,
      action: action
    };
  }

  function _belongsTo(element, ancestor) {
    if (element === null || element === document) {
      return false;
    }

    if (element === ancestor) {
      return true;
    }

    return _belongsTo(element.parentNode, ancestor);
  }

  function Mousetrap(targetElement) {
    var self = this;
    targetElement = targetElement || document;

    if (!(self instanceof Mousetrap)) {
      return new Mousetrap(targetElement);
    }
    /**
     * element to attach key events to
     *
     * @type {Element}
     */


    self.target = targetElement;
    /**
     * a list of all the callbacks setup via Mousetrap.bind()
     *
     * @type {Object}
     */

    self._callbacks = {};
    /**
     * direct map of string combinations to callbacks used for trigger()
     *
     * @type {Object}
     */

    self._directMap = {};
    /**
     * keeps track of what level each sequence is at since multiple
     * sequences can start out with the same sequence
     *
     * @type {Object}
     */

    var _sequenceLevels = {};
    /**
     * variable to store the setTimeout call
     *
     * @type {null|number}
     */

    var _resetTimer;
    /**
     * temporary state where we will ignore the next keyup
     *
     * @type {boolean|string}
     */


    var _ignoreNextKeyup = false;
    /**
     * temporary state where we will ignore the next keypress
     *
     * @type {boolean}
     */

    var _ignoreNextKeypress = false;
    /**
     * are we currently inside of a sequence?
     * type of action ("keyup" or "keydown" or "keypress") or false
     *
     * @type {boolean|string}
     */

    var _nextExpectedAction = false;
    /**
     * resets all sequence counters except for the ones passed in
     *
     * @param {Object} doNotReset
     * @returns void
     */

    function _resetSequences(doNotReset) {
      doNotReset = doNotReset || {};
      var activeSequences = false,
          key;

      for (key in _sequenceLevels) {
        if (doNotReset[key]) {
          activeSequences = true;
          continue;
        }

        _sequenceLevels[key] = 0;
      }

      if (!activeSequences) {
        _nextExpectedAction = false;
      }
    }
    /**
     * finds all callbacks that match based on the keycode, modifiers,
     * and action
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event|Object} e
     * @param {string=} sequenceName - name of the sequence we are looking for
     * @param {string=} combination
     * @param {number=} level
     * @returns {Array}
     */


    function _getMatches(character, modifiers, e, sequenceName, combination, level) {
      var i;
      var callback;
      var matches = [];
      var action = e.type; // if there are no events related to this keycode

      if (!self._callbacks[character]) {
        return [];
      } // if a modifier key is coming up on its own we should allow it


      if (action == 'keyup' && _isModifier(character)) {
        modifiers = [character];
      } // loop through all callbacks for the key that was pressed
      // and see if any of them match


      for (i = 0; i < self._callbacks[character].length; ++i) {
        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at
        // the wrong level then move onto the next match

        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
          continue;
        } // if the action we are looking for doesn't match the action we got
        // then we should keep going


        if (action != callback.action) {
          continue;
        } // if this is a keypress event and the meta key and control key
        // are not pressed that means that we need to only look at the
        // character, otherwise check the modifiers as well
        //
        // chrome will not fire a keypress if meta or control is down
        // safari will fire a keypress if meta or meta+shift is down
        // firefox will fire a keypress if meta or control is down


        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
          // when you bind a combination or sequence a second time it
          // should overwrite the first one.  if a sequenceName or
          // combination is specified in this call it does just that
          //
          // @todo make deleting its own method?
          var deleteCombo = !sequenceName && callback.combo == combination;
          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;

          if (deleteCombo || deleteSequence) {
            self._callbacks[character].splice(i, 1);
          }

          matches.push(callback);
        }
      }

      return matches;
    }
    /**
     * actually calls the callback function
     *
     * if your callback function returns false this will use the jquery
     * convention - prevent default and stop propogation on the event
     *
     * @param {Function} callback
     * @param {Event} e
     * @returns void
     */


    function _fireCallback(callback, e, combo, sequence) {
      // if this event should not happen stop here
      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
        return;
      }

      if (callback(e, combo) === false) {
        _preventDefault(e);

        _stopPropagation(e);
      }
    }
    /**
     * handles a character key event
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event} e
     * @returns void
     */


    self._handleKey = function (character, modifiers, e) {
      var callbacks = _getMatches(character, modifiers, e);

      var i;
      var doNotReset = {};
      var maxLevel = 0;
      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence

      for (i = 0; i < callbacks.length; ++i) {
        if (callbacks[i].seq) {
          maxLevel = Math.max(maxLevel, callbacks[i].level);
        }
      } // loop through matching callbacks for this key event


      for (i = 0; i < callbacks.length; ++i) {
        // fire for all sequence callbacks
        // this is because if for example you have multiple sequences
        // bound such as "g i" and "g t" they both need to fire the
        // callback for matching g cause otherwise you can only ever
        // match the first one
        if (callbacks[i].seq) {
          // only fire callbacks for the maxLevel to prevent
          // subsequences from also firing
          //
          // for example 'a option b' should not cause 'option b' to fire
          // even though 'option b' is part of the other sequence
          //
          // any sequences that do not match here will be discarded
          // below by the _resetSequences call
          if (callbacks[i].level != maxLevel) {
            continue;
          }

          processedSequenceCallback = true; // keep a list of which sequences were matches for later

          doNotReset[callbacks[i].seq] = 1;

          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);

          continue;
        } // if there were no sequence matches but we are still here
        // that means this is a regular match so we should fire that


        if (!processedSequenceCallback) {
          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
        }
      } // if the key you pressed matches the type of sequence without
      // being a modifier (ie "keyup" or "keypress") then we should
      // reset all sequences that were not matched by this event
      //
      // this is so, for example, if you have the sequence "h a t" and you
      // type "h e a r t" it does not match.  in this case the "e" will
      // cause the sequence to reset
      //
      // modifier keys are ignored because you can have a sequence
      // that contains modifiers such as "enter ctrl+space" and in most
      // cases the modifier key will be pressed before the next key
      //
      // also if you have a sequence such as "ctrl+b a" then pressing the
      // "b" key will trigger a "keypress" and a "keydown"
      //
      // the "keydown" is expected when there is a modifier, but the
      // "keypress" ends up matching the _nextExpectedAction since it occurs
      // after and that causes the sequence to reset
      //
      // we ignore keypresses in a sequence that directly follow a keydown
      // for the same character


      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;

      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
        _resetSequences(doNotReset);
      }

      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
    };
    /**
     * handles a keydown event
     *
     * @param {Event} e
     * @returns void
     */


    function _handleKeyEvent(e) {
      // normalize e.which for key events
      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
      if (typeof e.which !== 'number') {
        e.which = e.keyCode;
      }

      var character = _characterFromEvent(e); // no character found then stop


      if (!character) {
        return;
      } // need to use === for the character check because the character can be 0


      if (e.type == 'keyup' && _ignoreNextKeyup === character) {
        _ignoreNextKeyup = false;
        return;
      }

      self.handleKey(character, _eventModifiers(e), e);
    }
    /**
     * called to set a 1 second timeout on the specified sequence
     *
     * this is so after each key press in the sequence you have 1 second
     * to press the next key before you have to start over
     *
     * @returns void
     */


    function _resetSequenceTimer() {
      clearTimeout(_resetTimer);
      _resetTimer = setTimeout(_resetSequences, 1000);
    }
    /**
     * binds a key sequence to an event
     *
     * @param {string} combo - combo specified in bind call
     * @param {Array} keys
     * @param {Function} callback
     * @param {string=} action
     * @returns void
     */


    function _bindSequence(combo, keys, callback, action) {
      // start off by adding a sequence level record for this combination
      // and setting the level to 0
      _sequenceLevels[combo] = 0;
      /**
       * callback to increase the sequence level for this sequence and reset
       * all other sequences that were active
       *
       * @param {string} nextAction
       * @returns {Function}
       */

      function _increaseSequence(nextAction) {
        return function () {
          _nextExpectedAction = nextAction;
          ++_sequenceLevels[combo];

          _resetSequenceTimer();
        };
      }
      /**
       * wraps the specified callback inside of another function in order
       * to reset all sequence counters as soon as this sequence is done
       *
       * @param {Event} e
       * @returns void
       */


      function _callbackAndReset(e) {
        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down
        // or keypress.  this is so if you finish a sequence and
        // release the key the final key will not trigger a keyup


        if (action !== 'keyup') {
          _ignoreNextKeyup = _characterFromEvent(e);
        } // weird race condition if a sequence ends with the key
        // another sequence begins with


        setTimeout(_resetSequences, 10);
      } // loop through keys one at a time and bind the appropriate callback
      // function.  for any key leading up to the final one it should
      // increase the sequence. after the final, it should reset all sequences
      //
      // if an action is specified in the original bind call then that will
      // be used throughout.  otherwise we will pass the action that the
      // next key in the sequence should match.  this allows a sequence
      // to mix and match keypress and keydown events depending on which
      // ones are better suited to the key provided


      for (var i = 0; i < keys.length; ++i) {
        var isFinal = i + 1 === keys.length;
        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);

        _bindSingle(keys[i], wrappedCallback, action, combo, i);
      }
    }
    /**
     * binds a single keyboard combination
     *
     * @param {string} combination
     * @param {Function} callback
     * @param {string=} action
     * @param {string=} sequenceName - name of sequence if part of sequence
     * @param {number=} level - what part of the sequence the command is
     * @returns void
     */


    function _bindSingle(combination, callback, action, sequenceName, level) {
      // store a direct mapped reference for use with Mousetrap.trigger
      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space

      combination = combination.replace(/\s+/g, ' ');
      var sequence = combination.split(' ');
      var info; // if this pattern is a sequence of keys then run through this method
      // to reprocess each pattern one key at a time

      if (sequence.length > 1) {
        _bindSequence(combination, sequence, callback, action);

        return;
      }

      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time
      // a callback is added for this key

      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one

      _getMatches(info.key, info.modifiers, {
        type: info.action
      }, sequenceName, combination, level); // add this call back to the array
      // if it is a sequence put it at the beginning
      // if not put it at the end
      //
      // this is important because the way these are processed expects
      // the sequence ones to come first


      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
        callback: callback,
        modifiers: info.modifiers,
        action: info.action,
        seq: sequenceName,
        level: level,
        combo: combination
      });
    }
    /**
     * binds multiple combinations to the same callback
     *
     * @param {Array} combinations
     * @param {Function} callback
     * @param {string|undefined} action
     * @returns void
     */


    self._bindMultiple = function (combinations, callback, action) {
      for (var i = 0; i < combinations.length; ++i) {
        _bindSingle(combinations[i], callback, action);
      }
    }; // start!


    _addEvent(targetElement, 'keypress', _handleKeyEvent);

    _addEvent(targetElement, 'keydown', _handleKeyEvent);

    _addEvent(targetElement, 'keyup', _handleKeyEvent);
  }
  /**
   * binds an event to mousetrap
   *
   * can be a single key, a combination of keys separated with +,
   * an array of keys, or a sequence of keys separated by spaces
   *
   * be sure to list the modifier keys first to make sure that the
   * correct key ends up getting bound (the last key in the pattern)
   *
   * @param {string|Array} keys
   * @param {Function} callback
   * @param {string=} action - 'keypress', 'keydown', or 'keyup'
   * @returns void
   */


  Mousetrap.prototype.bind = function (keys, callback, action) {
    var self = this;
    keys = keys instanceof Array ? keys : [keys];

    self._bindMultiple.call(self, keys, callback, action);

    return self;
  };
  /**
   * unbinds an event to mousetrap
   *
   * the unbinding sets the callback function of the specified key combo
   * to an empty function and deletes the corresponding key in the
   * _directMap dict.
   *
   * TODO: actually remove this from the _callbacks dictionary instead
   * of binding an empty function
   *
   * the keycombo+action has to be exactly the same as
   * it was defined in the bind method
   *
   * @param {string|Array} keys
   * @param {string} action
   * @returns void
   */


  Mousetrap.prototype.unbind = function (keys, action) {
    var self = this;
    return self.bind.call(self, keys, function () {}, action);
  };
  /**
   * triggers an event that has already been bound
   *
   * @param {string} keys
   * @param {string=} action
   * @returns void
   */


  Mousetrap.prototype.trigger = function (keys, action) {
    var self = this;

    if (self._directMap[keys + ':' + action]) {
      self._directMap[keys + ':' + action]({}, keys);
    }

    return self;
  };
  /**
   * resets the library back to its initial state.  this is useful
   * if you want to clear out the current keyboard shortcuts and bind
   * new ones - for example if you switch to another page
   *
   * @returns void
   */


  Mousetrap.prototype.reset = function () {
    var self = this;
    self._callbacks = {};
    self._directMap = {};
    return self;
  };
  /**
   * should we stop this event before firing off callbacks
   *
   * @param {Event} e
   * @param {Element} element
   * @return {boolean}
   */


  Mousetrap.prototype.stopCallback = function (e, element) {
    var self = this; // if the element has the class "mousetrap" then no need to stop

    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
      return false;
    }

    if (_belongsTo(element, self.target)) {
      return false;
    } // stop for input, select, and textarea


    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
  };
  /**
   * exposes _handleKey publicly so it can be overwritten by extensions
   */


  Mousetrap.prototype.handleKey = function () {
    var self = this;
    return self._handleKey.apply(self, arguments);
  };
  /**
   * allow custom key mappings
   */


  Mousetrap.addKeycodes = function (object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        _MAP[key] = object[key];
      }
    }

    _REVERSE_MAP = null;
  };
  /**
   * Init the global mousetrap functions
   *
   * This method is needed to allow the global mousetrap functions to work
   * now that mousetrap is a constructor function.
   */


  Mousetrap.init = function () {
    var documentMousetrap = Mousetrap(document);

    for (var method in documentMousetrap) {
      if (method.charAt(0) !== '_') {
        Mousetrap[method] = function (method) {
          return function () {
            return documentMousetrap[method].apply(documentMousetrap, arguments);
          };
        }(method);
      }
    }
  };

  Mousetrap.init(); // expose mousetrap to the global object

  window.Mousetrap = Mousetrap; // expose as a common js module

  if ( true && module.exports) {
    module.exports = Mousetrap;
  } // expose mousetrap as an AMD module


  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Mousetrap;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null); // luhn extra validators


window.ParsleyConfig = window.ParsleyConfig || {};
window.ParsleyConfig.validators = window.ParsleyConfig.validators || {};
window.ParsleyConfig.validators.luhn = {
  fn: function fn(value) {
    value = value.replace(/[ -]/g, '');
    var digit;
    var n;

    var _j;

    var _len1;

    var _ref2;

    var sum = 0;
    _ref2 = value.split('').reverse();

    for (n = _j = 0, _len1 = _ref2.length; _j < _len1; n = ++_j) {
      digit = _ref2[n];
      digit = +digit;

      if (n % 2) {
        digit *= 2;

        if (digit < 10) {
          sum += digit;
        } else {
          sum += digit - 9;
        }
      } else {
        sum += digit;
      }
    }

    return sum % 10 === 0;
  },
  priority: 32
};
/*!
* Parsley.js
* Version 2.8.1 - built Sat, Feb 3rd 2018, 2:27 pm
* http://parsleyjs.org
* Guillaume Potier - <guillaume@wisembly.com>
* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>
* MIT Licensed
*/
// The source code below is generated by babel as
// Parsley is written in ECMAScript 6
//

var _slice = Array.prototype.slice;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i['return']) _i['return']();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError('Invalid attempt to destructure non-iterable instance');
    }
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function ($) {
  'use strict';

  var globalID = 1;
  var pastWarnings = {};
  var Utils = {
    // Parsley DOM-API
    // returns object from dom attributes and values
    attr: function attr(element, namespace, obj) {
      var i;
      var attribute;
      var attributes;
      var regex = new RegExp('^' + namespace, 'i');
      if ('undefined' === typeof obj) obj = {};else {
        // Clear all own properties. This won't affect prototype's values
        for (i in obj) {
          if (obj.hasOwnProperty(i)) delete obj[i];
        }
      }
      if (!element) return obj;
      attributes = element.attributes;

      for (i = attributes.length; i--;) {
        attribute = attributes[i];

        if (attribute && attribute.specified && regex.test(attribute.name)) {
          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);
        }
      }

      return obj;
    },
    checkAttr: function checkAttr(element, namespace, _checkAttr) {
      return element.hasAttribute(namespace + _checkAttr);
    },
    setAttr: function setAttr(element, namespace, attr, value) {
      element.setAttribute(this.dasherize(namespace + attr), String(value));
    },
    getType: function getType(element) {
      return element.getAttribute('type') || 'text';
    },
    generateID: function generateID() {
      return '' + globalID++;
    },

    /** Third party functions **/
    deserializeValue: function deserializeValue(value) {
      var num;

      try {
        return value ? value == "true" || (value == "false" ? false : value == "null" ? null : !isNaN(num = Number(value)) ? num : /^[\[\{]/.test(value) ? JSON.parse(value) : value) : value;
      } catch (e) {
        return value;
      }
    },
    // Zepto camelize function
    camelize: function camelize(str) {
      return str.replace(/-+(.)?/g, function (match, chr) {
        return chr ? chr.toUpperCase() : '';
      });
    },
    // Zepto dasherize function
    dasherize: function dasherize(str) {
      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
    },
    warn: function warn() {
      var _window$console;

      if (window.console && 'function' === typeof window.console.warn) (_window$console = window.console).warn.apply(_window$console, arguments);
    },
    warnOnce: function warnOnce(msg) {
      if (!pastWarnings[msg]) {
        pastWarnings[msg] = true;
        this.warn.apply(this, arguments);
      }
    },
    _resetWarnings: function _resetWarnings() {
      pastWarnings = {};
    },
    trimString: function trimString(string) {
      return string.replace(/^\s+|\s+$/g, '');
    },
    parse: {
      date: function date(string) {
        var parsed = string.match(/^(\d{4,})-(\d\d)-(\d\d)$/);
        if (!parsed) return null;

        var _parsed$map = parsed.map(function (x) {
          return parseInt(x, 10);
        });

        var _parsed$map2 = _slicedToArray(_parsed$map, 4);

        var _ = _parsed$map2[0];
        var year = _parsed$map2[1];
        var month = _parsed$map2[2];
        var day = _parsed$map2[3];
        var date = new Date(year, month - 1, day);
        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) return null;
        return date;
      },
      string: function string(_string) {
        return _string;
      },
      integer: function integer(string) {
        if (isNaN(string)) return null;
        return parseInt(string, 10);
      },
      number: function number(string) {
        if (isNaN(string)) throw null;
        return parseFloat(string);
      },
      'boolean': function _boolean(string) {
        return !/^\s*false\s*$/i.test(string);
      },
      object: function object(string) {
        return Utils.deserializeValue(string);
      },
      regexp: function regexp(_regexp) {
        var flags = ''; // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern

        if (/^\/.*\/(?:[gimy]*)$/.test(_regexp)) {
          // Replace the regexp literal string with the first match group: ([gimy]*)
          // If no flag is present, this will be a blank string
          flags = _regexp.replace(/.*\/([gimy]*)$/, '$1'); // Again, replace the regexp literal string with the first match group:
          // everything excluding the opening and closing slashes and the flags

          _regexp = _regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');
        } else {
          // Anchor regexp:
          _regexp = '^' + _regexp + '$';
        }

        return new RegExp(_regexp, flags);
      }
    },
    parseRequirement: function parseRequirement(requirementType, string) {
      var converter = this.parse[requirementType || 'string'];
      if (!converter) throw 'Unknown requirement specification: "' + requirementType + '"';
      var converted = converter(string);
      if (converted === null) throw 'Requirement is not a ' + requirementType + ': "' + string + '"';
      return converted;
    },
    namespaceEvents: function namespaceEvents(events, namespace) {
      events = this.trimString(events || '').split(/\s+/);
      if (!events[0]) return '';
      return $.map(events, function (evt) {
        return evt + '.' + namespace;
      }).join(' ');
    },
    difference: function difference(array, remove) {
      // This is O(N^2), should be optimized
      var result = [];
      $.each(array, function (_, elem) {
        if (remove.indexOf(elem) == -1) result.push(elem);
      });
      return result;
    },
    // Alter-ego to native Promise.all, but for jQuery
    all: function all(promises) {
      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements
      return $.when.apply($, _toConsumableArray(promises).concat([42, 42]));
    },
    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill
    objectCreate: Object.create || function () {
      var Object = function Object() {};

      return function (prototype) {
        if (arguments.length > 1) {
          throw Error('Second argument not supported');
        }

        if (_typeof(prototype) != 'object') {
          throw TypeError('Argument must be an object');
        }

        Object.prototype = prototype;
        var result = new Object();
        Object.prototype = null;
        return result;
      };
    }(),
    _SubmitSelector: 'input[type="submit"], button:submit'
  }; // All these options could be overriden and specified directly in DOM using
  // `data-parsley-` default DOM-API
  // eg: `inputs` can be set in DOM using `data-parsley-inputs="input, textarea"`
  // eg: `data-parsley-stop-on-first-failing-constraint="false"`

  var Defaults = {
    // ### General
    // Default data-namespace for DOM API
    namespace: 'data-parsley-',
    // Supported inputs by default
    inputs: 'input, textarea, select',
    // Excluded inputs by default
    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',
    // Stop validating field on highest priority failing constraint
    priorityEnabled: true,
    // ### Field only
    // identifier used to group together inputs (e.g. radio buttons...)
    multiple: null,
    // identifier (or array of identifiers) used to validate only a select group of inputs
    group: null,
    // ### UI
    // Enable\Disable error messages
    uiEnabled: true,
    // Key events threshold before validation
    validationThreshold: 3,
    // Focused field on form validation error. 'first'|'last'|'none'
    focus: 'first',
    // event(s) that will trigger validation before first failure. eg: `input`...
    trigger: false,
    // event(s) that will trigger validation after first failure.
    triggerAfterFailure: 'input',
    // Class that would be added on every failing validation Parsley field
    errorClass: 'parsley-error',
    // Same for success validation
    successClass: 'parsley-success',
    // Return the `$element` that will receive these above success or error classes
    // Could also be (and given directly from DOM) a valid selector like `'#div'`
    classHandler: function classHandler(Field) {},
    // Return the `$element` where errors will be appended
    // Could also be (and given directly from DOM) a valid selector like `'#div'`
    errorsContainer: function errorsContainer(Field) {},
    // ul elem that would receive errors' list
    errorsWrapper: '<ul class="parsley-errors-list"></ul>',
    // li elem that would receive error message
    errorTemplate: '<li></li>'
  };

  var Base = function Base() {
    this.__id__ = Utils.generateID();
  };

  Base.prototype = {
    asyncSupport: true,
    // Deprecated
    _pipeAccordingToValidationResult: function _pipeAccordingToValidationResult() {
      var _this = this;

      var pipe = function pipe() {
        var r = $.Deferred();
        if (true !== _this.validationResult) r.reject();
        return r.resolve().promise();
      };

      return [pipe, pipe];
    },
    actualizeOptions: function actualizeOptions() {
      Utils.attr(this.element, this.options.namespace, this.domOptions);
      if (this.parent && this.parent.actualizeOptions) this.parent.actualizeOptions();
      return this;
    },
    _resetOptions: function _resetOptions(initOptions) {
      this.domOptions = Utils.objectCreate(this.parent.options);
      this.options = Utils.objectCreate(this.domOptions); // Shallow copy of ownProperties of initOptions:

      for (var i in initOptions) {
        if (initOptions.hasOwnProperty(i)) this.options[i] = initOptions[i];
      }

      this.actualizeOptions();
    },
    _listeners: null,
    // Register a callback for the given event name
    // Callback is called with context as the first argument and the `this`
    // The context is the current parsley instance, or window.Parsley if global
    // A return value of `false` will interrupt the calls
    on: function on(name, fn) {
      this._listeners = this._listeners || {};
      var queue = this._listeners[name] = this._listeners[name] || [];
      queue.push(fn);
      return this;
    },
    // Deprecated. Use `on` instead
    subscribe: function subscribe(name, fn) {
      $.listenTo(this, name.toLowerCase(), fn);
    },
    // Unregister a callback (or all if none is given) for the given event name
    off: function off(name, fn) {
      var queue = this._listeners && this._listeners[name];

      if (queue) {
        if (!fn) {
          delete this._listeners[name];
        } else {
          for (var i = queue.length; i--;) {
            if (queue[i] === fn) queue.splice(i, 1);
          }
        }
      }

      return this;
    },
    // Deprecated. Use `off`
    unsubscribe: function unsubscribe(name, fn) {
      $.unsubscribeTo(this, name.toLowerCase());
    },
    // Trigger an event of the given name
    // A return value of `false` interrupts the callback chain
    // Returns false if execution was interrupted
    trigger: function trigger(name, target, extraArg) {
      target = target || this;
      var queue = this._listeners && this._listeners[name];
      var result;
      var parentResult;

      if (queue) {
        for (var i = queue.length; i--;) {
          result = queue[i].call(target, target, extraArg);
          if (result === false) return result;
        }
      }

      if (this.parent) {
        return this.parent.trigger(name, target, extraArg);
      }

      return true;
    },
    asyncIsValid: function asyncIsValid(group, force) {
      Utils.warnOnce("asyncIsValid is deprecated; please use whenValid instead");
      return this.whenValid({
        group: group,
        force: force
      });
    },
    _findRelated: function _findRelated() {
      return this.options.multiple ? $(this.parent.element.querySelectorAll('[' + this.options.namespace + 'multiple="' + this.options.multiple + '"]')) : this.$element;
    }
  };

  var convertArrayRequirement = function convertArrayRequirement(string, length) {
    var m = string.match(/^\s*\[(.*)\]\s*$/);
    if (!m) throw 'Requirement is not an array: "' + string + '"';
    var values = m[1].split(',').map(Utils.trimString);
    if (values.length !== length) throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';
    return values;
  };

  var convertExtraOptionRequirement = function convertExtraOptionRequirement(requirementSpec, string, extraOptionReader) {
    var main = null;
    var extra = {};

    for (var key in requirementSpec) {
      if (key) {
        var value = extraOptionReader(key);
        if ('string' === typeof value) value = Utils.parseRequirement(requirementSpec[key], value);
        extra[key] = value;
      } else {
        main = Utils.parseRequirement(requirementSpec[key], string);
      }
    }

    return [main, extra];
  }; // A Validator needs to implement the methods `validate` and `parseRequirements`


  var Validator = function Validator(spec) {
    $.extend(true, this, spec);
  };

  Validator.prototype = {
    // Returns `true` iff the given `value` is valid according the given requirements.
    validate: function validate(value, requirementFirstArg) {
      if (this.fn) {
        // Legacy style validator
        if (arguments.length > 3) // If more args then value, requirement, instance...
          requirementFirstArg = [].slice.call(arguments, 1, -1); // Skip first arg (value) and last (instance), combining the rest

        return this.fn(value, requirementFirstArg);
      }

      if (Array.isArray(value)) {
        if (!this.validateMultiple) throw 'Validator `' + this.name + '` does not handle multiple values';
        return this.validateMultiple.apply(this, arguments);
      } else {
        var instance = arguments[arguments.length - 1];

        if (this.validateDate && instance._isDateInput()) {
          arguments[0] = Utils.parse.date(arguments[0]);
          if (arguments[0] === null) return false;
          return this.validateDate.apply(this, arguments);
        }

        if (this.validateNumber) {
          if (isNaN(value)) return false;
          arguments[0] = parseFloat(arguments[0]);
          return this.validateNumber.apply(this, arguments);
        }

        if (this.validateString) {
          return this.validateString.apply(this, arguments);
        }

        throw 'Validator `' + this.name + '` only handles multiple values';
      }
    },
    // Parses `requirements` into an array of arguments,
    // according to `this.requirementType`
    parseRequirements: function parseRequirements(requirements, extraOptionReader) {
      if ('string' !== typeof requirements) {
        // Assume requirement already parsed
        // but make sure we return an array
        return Array.isArray(requirements) ? requirements : [requirements];
      }

      var type = this.requirementType;

      if (Array.isArray(type)) {
        var values = convertArrayRequirement(requirements, type.length);

        for (var i = 0; i < values.length; i++) {
          values[i] = Utils.parseRequirement(type[i], values[i]);
        }

        return values;
      } else if ($.isPlainObject(type)) {
        return convertExtraOptionRequirement(type, requirements, extraOptionReader);
      } else {
        return [Utils.parseRequirement(type, requirements)];
      }
    },
    // Defaults:
    requirementType: 'string',
    priority: 2
  };

  var ValidatorRegistry = function ValidatorRegistry(validators, catalog) {
    this.__class__ = 'ValidatorRegistry'; // Default Parsley locale is en

    this.locale = 'en';
    this.init(validators || {}, catalog || {});
  };

  var typeTesters = {
    email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/,
    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers
    number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i,
    integer: /^-?\d+$/,
    digits: /^\d+$/,
    alphanum: /^\w+$/i,
    date: {
      test: function test(value) {
        return Utils.parse.date(value) !== null;
      }
    },
    url: new RegExp("^" + // protocol identifier
    "(?:(?:https?|ftp)://)?" + // ** mod: make scheme optional
    // user:pass authentication
    "(?:\\S+(?::\\S*)?@)?" + "(?:" + // IP address exclusion
    // private & local networks
    // "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +   // ** mod: allow local networks
    // "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +  // ** mod: allow local networks
    // "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +  // ** mod: allow local networks
    // IP address dotted notation octets
    // excludes loopback network 0.0.0.0
    // excludes reserved space >= 224.0.0.0
    // excludes network & broacast addresses
    // (first & last IP address of each class)
    "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + // host name
    "(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)" + // domain name
    "(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*" + // TLD identifier
    "(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,}))" + ")" + // port number
    "(?::\\d{2,5})?" + // resource path
    "(?:/\\S*)?" + "$")
  };
  typeTesters.range = typeTesters.number; // See http://stackoverflow.com/a/10454560/8279

  var decimalPlaces = function decimalPlaces(num) {
    var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);

    if (!match) {
      return 0;
    }

    return Math.max(0, // Number of digits right of decimal point.
    (match[1] ? match[1].length : 0) - ( // Adjust for scientific notation.
    match[2] ? +match[2] : 0));
  }; // parseArguments('number', ['1', '2']) => [1, 2]


  var ValidatorRegistry__parseArguments = function ValidatorRegistry__parseArguments(type, args) {
    return args.map(Utils.parse[type]);
  }; // operatorToValidator returns a validating function for an operator function, applied to the given type


  var ValidatorRegistry__operatorToValidator = function ValidatorRegistry__operatorToValidator(type, operator) {
    return function (value) {
      for (var _len = arguments.length, requirementsAndInput = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        requirementsAndInput[_key - 1] = arguments[_key];
      }

      requirementsAndInput.pop(); // Get rid of `input` argument

      return operator.apply(undefined, [value].concat(_toConsumableArray(ValidatorRegistry__parseArguments(type, requirementsAndInput))));
    };
  };

  var ValidatorRegistry__comparisonOperator = function ValidatorRegistry__comparisonOperator(operator) {
    return {
      validateDate: ValidatorRegistry__operatorToValidator('date', operator),
      validateNumber: ValidatorRegistry__operatorToValidator('number', operator),
      requirementType: operator.length <= 2 ? 'string' : ['string', 'string'],
      // Support operators with a 1 or 2 requirement(s)
      priority: 30
    };
  };

  ValidatorRegistry.prototype = {
    init: function init(validators, catalog) {
      this.catalog = catalog; // Copy prototype's validators:

      this.validators = _extends({}, this.validators);

      for (var name in validators) {
        this.addValidator(name, validators[name].fn, validators[name].priority);
      }

      window.Parsley.trigger('parsley:validator:init');
    },
    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n
    setLocale: function setLocale(locale) {
      if ('undefined' === typeof this.catalog[locale]) throw new Error(locale + ' is not available in the catalog');
      this.locale = locale;
      return this;
    },
    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`
    addCatalog: function addCatalog(locale, messages, set) {
      if ('object' === _typeof(messages)) this.catalog[locale] = messages;
      if (true === set) return this.setLocale(locale);
      return this;
    },
    // Add a specific message for a given constraint in a given locale
    addMessage: function addMessage(locale, name, message) {
      if ('undefined' === typeof this.catalog[locale]) this.catalog[locale] = {};
      this.catalog[locale][name] = message;
      return this;
    },
    // Add messages for a given locale
    addMessages: function addMessages(locale, nameMessageObject) {
      for (var name in nameMessageObject) {
        this.addMessage(locale, name, nameMessageObject[name]);
      }

      return this;
    },
    // Add a new validator
    //
    //    addValidator('custom', {
    //        requirementType: ['integer', 'integer'],
    //        validateString: function(value, from, to) {},
    //        priority: 22,
    //        messages: {
    //          en: "Hey, that's no good",
    //          fr: "Aye aye, pas bon du tout",
    //        }
    //    })
    //
    // Old API was addValidator(name, function, priority)
    //
    addValidator: function addValidator(name, arg1, arg2) {
      if (this.validators[name]) Utils.warn('Validator "' + name + '" is already defined.');else if (Defaults.hasOwnProperty(name)) {
        Utils.warn('"' + name + '" is a restricted keyword and is not a valid validator name.');
        return;
      }
      return this._setValidator.apply(this, arguments);
    },
    hasValidator: function hasValidator(name) {
      return !!this.validators[name];
    },
    updateValidator: function updateValidator(name, arg1, arg2) {
      if (!this.validators[name]) {
        Utils.warn('Validator "' + name + '" is not already defined.');
        return this.addValidator.apply(this, arguments);
      }

      return this._setValidator.apply(this, arguments);
    },
    removeValidator: function removeValidator(name) {
      if (!this.validators[name]) Utils.warn('Validator "' + name + '" is not defined.');
      delete this.validators[name];
      return this;
    },
    _setValidator: function _setValidator(name, validator, priority) {
      if ('object' !== _typeof(validator)) {
        // Old style validator, with `fn` and `priority`
        validator = {
          fn: validator,
          priority: priority
        };
      }

      if (!validator.validate) {
        validator = new Validator(validator);
      }

      this.validators[name] = validator;

      for (var locale in validator.messages || {}) {
        this.addMessage(locale, name, validator.messages[locale]);
      }

      return this;
    },
    getErrorMessage: function getErrorMessage(constraint) {
      var message; // Type constraints are a bit different, we have to match their requirements too to find right error message

      if ('type' === constraint.name) {
        var typeMessages = this.catalog[this.locale][constraint.name] || {};
        message = typeMessages[constraint.requirements];
      } else message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);

      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;
    },
    // Kind of light `sprintf()` implementation
    formatMessage: function formatMessage(string, parameters) {
      if ('object' === _typeof(parameters)) {
        for (var i in parameters) {
          string = this.formatMessage(string, parameters[i]);
        }

        return string;
      }

      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';
    },
    // Here is the Parsley default validators list.
    // A validator is an object with the following key values:
    //  - priority: an integer
    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these
    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise
    // Alternatively, a validator can be a function that returns such an object
    //
    validators: {
      notblank: {
        validateString: function validateString(value) {
          return /\S/.test(value);
        },
        priority: 2
      },
      required: {
        validateMultiple: function validateMultiple(values) {
          return values.length > 0;
        },
        validateString: function validateString(value) {
          return /\S/.test(value);
        },
        priority: 512
      },
      type: {
        validateString: function validateString(value, type) {
          var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

          var _ref$step = _ref.step;
          var step = _ref$step === undefined ? 'any' : _ref$step;
          var _ref$base = _ref.base;
          var base = _ref$base === undefined ? 0 : _ref$base;
          var tester = typeTesters[type];

          if (!tester) {
            throw new Error('validator type `' + type + '` is not supported');
          }

          if (!tester.test(value)) return false;

          if ('number' === type) {
            if (!/^any$/i.test(step || '')) {
              var nb = Number(value);
              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));
              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals
                return false; // Be careful of rounding errors by using integers.

              var toInt = function toInt(f) {
                return Math.round(f * Math.pow(10, decimals));
              };

              if ((toInt(nb) - toInt(base)) % toInt(step) != 0) return false;
            }
          }

          return true;
        },
        requirementType: {
          '': 'string',
          step: 'string',
          base: 'number'
        },
        priority: 256
      },
      pattern: {
        validateString: function validateString(value, regexp) {
          return regexp.test(value);
        },
        requirementType: 'regexp',
        priority: 64
      },
      minlength: {
        validateString: function validateString(value, requirement) {
          return value.length >= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      maxlength: {
        validateString: function validateString(value, requirement) {
          return value.length <= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      length: {
        validateString: function validateString(value, min, max) {
          return value.length >= min && value.length <= max;
        },
        requirementType: ['integer', 'integer'],
        priority: 30
      },
      mincheck: {
        validateMultiple: function validateMultiple(values, requirement) {
          return values.length >= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      maxcheck: {
        validateMultiple: function validateMultiple(values, requirement) {
          return values.length <= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      check: {
        validateMultiple: function validateMultiple(values, min, max) {
          return values.length >= min && values.length <= max;
        },
        requirementType: ['integer', 'integer'],
        priority: 30
      },
      min: ValidatorRegistry__comparisonOperator(function (value, requirement) {
        return value >= requirement;
      }),
      max: ValidatorRegistry__comparisonOperator(function (value, requirement) {
        return value <= requirement;
      }),
      range: ValidatorRegistry__comparisonOperator(function (value, min, max) {
        return value >= min && value <= max;
      }),
      equalto: {
        validateString: function validateString(value, refOrValue) {
          var $reference = $(refOrValue);
          if ($reference.length) return value === $reference.val();else return value === refOrValue;
        },
        priority: 256
      }
    }
  };
  var UI = {};

  var diffResults = function diffResults(newResult, oldResult, deep) {
    var added = [];
    var kept = [];

    for (var i = 0; i < newResult.length; i++) {
      var found = false;

      for (var j = 0; j < oldResult.length; j++) {
        if (newResult[i].assert.name === oldResult[j].assert.name) {
          found = true;
          break;
        }
      }

      if (found) kept.push(newResult[i]);else added.push(newResult[i]);
    }

    return {
      kept: kept,
      added: added,
      removed: !deep ? diffResults(oldResult, newResult, true).added : []
    };
  };

  UI.Form = {
    _actualizeTriggers: function _actualizeTriggers() {
      var _this2 = this;

      this.$element.on('submit.Parsley', function (evt) {
        _this2.onSubmitValidate(evt);
      });
      this.$element.on('click.Parsley', Utils._SubmitSelector, function (evt) {
        _this2.onSubmitButton(evt);
      }); // UI could be disabled

      if (false === this.options.uiEnabled) return;
      this.element.setAttribute('novalidate', '');
    },
    focus: function focus() {
      this._focusedField = null;
      if (true === this.validationResult || 'none' === this.options.focus) return null;

      for (var i = 0; i < this.fields.length; i++) {
        var field = this.fields[i];

        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {
          this._focusedField = field.$element;
          if ('first' === this.options.focus) break;
        }
      }

      if (null === this._focusedField) return null;
      return this._focusedField.focus();
    },
    _destroyUI: function _destroyUI() {
      // Reset all event listeners
      this.$element.off('.Parsley');
    }
  };
  UI.Field = {
    _reflowUI: function _reflowUI() {
      this._buildUI(); // If this field doesn't have an active UI don't bother doing something


      if (!this._ui) return; // Diff between two validation results

      var diff = diffResults(this.validationResult, this._ui.lastValidationResult); // Then store current validation result for next reflow

      this._ui.lastValidationResult = this.validationResult; // Handle valid / invalid / none field class

      this._manageStatusClass(); // Add, remove, updated errors messages


      this._manageErrorsMessages(diff); // Triggers impl


      this._actualizeTriggers(); // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user


      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {
        this._failedOnce = true;

        this._actualizeTriggers();
      }
    },
    // Returns an array of field's error message(s)
    getErrorsMessages: function getErrorsMessages() {
      // No error message, field is valid
      if (true === this.validationResult) return [];
      var messages = [];

      for (var i = 0; i < this.validationResult.length; i++) {
        messages.push(this.validationResult[i].errorMessage || this._getErrorMessage(this.validationResult[i].assert));
      }

      return messages;
    },
    // It's a goal of Parsley that this method is no longer required [#1073]
    addError: function addError(name) {
      var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var message = _ref2.message;
      var assert = _ref2.assert;
      var _ref2$updateClass = _ref2.updateClass;
      var updateClass = _ref2$updateClass === undefined ? true : _ref2$updateClass;

      this._buildUI();

      this._addError(name, {
        message: message,
        assert: assert
      });

      if (updateClass) this._errorClass();
    },
    // It's a goal of Parsley that this method is no longer required [#1073]
    updateError: function updateError(name) {
      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var message = _ref3.message;
      var assert = _ref3.assert;
      var _ref3$updateClass = _ref3.updateClass;
      var updateClass = _ref3$updateClass === undefined ? true : _ref3$updateClass;

      this._buildUI();

      this._updateError(name, {
        message: message,
        assert: assert
      });

      if (updateClass) this._errorClass();
    },
    // It's a goal of Parsley that this method is no longer required [#1073]
    removeError: function removeError(name) {
      var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var _ref4$updateClass = _ref4.updateClass;
      var updateClass = _ref4$updateClass === undefined ? true : _ref4$updateClass;

      this._buildUI();

      this._removeError(name); // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult
      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.


      if (updateClass) this._manageStatusClass();
    },
    _manageStatusClass: function _manageStatusClass() {
      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult) this._successClass();else if (this.validationResult.length > 0) this._errorClass();else this._resetClass();
    },
    _manageErrorsMessages: function _manageErrorsMessages(diff) {
      if ('undefined' !== typeof this.options.errorsMessagesDisabled) return; // Case where we have errorMessage option that configure an unique field error message, regardless failing validators

      if ('undefined' !== typeof this.options.errorMessage) {
        if (diff.added.length || diff.kept.length) {
          this._insertErrorWrapper();

          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length) this._ui.$errorsWrapper.append($(this.options.errorTemplate).addClass('parsley-custom-error-message'));
          return this._ui.$errorsWrapper.addClass('filled').find('.parsley-custom-error-message').html(this.options.errorMessage);
        }

        return this._ui.$errorsWrapper.removeClass('filled').find('.parsley-custom-error-message').remove();
      } // Show, hide, update failing constraints messages


      for (var i = 0; i < diff.removed.length; i++) {
        this._removeError(diff.removed[i].assert.name);
      }

      for (i = 0; i < diff.added.length; i++) {
        this._addError(diff.added[i].assert.name, {
          message: diff.added[i].errorMessage,
          assert: diff.added[i].assert
        });
      }

      for (i = 0; i < diff.kept.length; i++) {
        this._updateError(diff.kept[i].assert.name, {
          message: diff.kept[i].errorMessage,
          assert: diff.kept[i].assert
        });
      }
    },
    _addError: function _addError(name, _ref5) {
      var message = _ref5.message;
      var assert = _ref5.assert;

      this._insertErrorWrapper();

      this._ui.$errorClassHandler.attr('aria-describedby', this._ui.errorsWrapperId);

      this._ui.$errorsWrapper.addClass('filled').append($(this.options.errorTemplate).addClass('parsley-' + name).html(message || this._getErrorMessage(assert)));
    },
    _updateError: function _updateError(name, _ref6) {
      var message = _ref6.message;
      var assert = _ref6.assert;

      this._ui.$errorsWrapper.addClass('filled').find('.parsley-' + name).html(message || this._getErrorMessage(assert));
    },
    _removeError: function _removeError(name) {
      this._ui.$errorClassHandler.removeAttr('aria-describedby');

      this._ui.$errorsWrapper.removeClass('filled').find('.parsley-' + name).remove();
    },
    _getErrorMessage: function _getErrorMessage(constraint) {
      var customConstraintErrorMessage = constraint.name + 'Message';
      if ('undefined' !== typeof this.options[customConstraintErrorMessage]) return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);
      return window.Parsley.getErrorMessage(constraint);
    },
    _buildUI: function _buildUI() {
      // UI could be already built or disabled
      if (this._ui || false === this.options.uiEnabled) return;
      var _ui = {}; // Give field its Parsley id in DOM

      this.element.setAttribute(this.options.namespace + 'id', this.__id__);
      /** Generate important UI elements and store them in this **/
      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes

      _ui.$errorClassHandler = this._manageClassHandler(); // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer

      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);
      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId); // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly

      _ui.lastValidationResult = [];
      _ui.validationInformationVisible = false; // Store it in this for later

      this._ui = _ui;
    },
    // Determine which element will have `parsley-error` and `parsley-success` classes
    _manageClassHandler: function _manageClassHandler() {
      // Class handled could also be determined by function given in Parsley options
      if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length) return $(this.options.classHandler); // Class handled could also be determined by function given in Parsley options

      var $handlerFunction = this.options.classHandler; // It might also be the function name of a global function

      if ('string' === typeof this.options.classHandler && 'function' === typeof window[this.options.classHandler]) $handlerFunction = window[this.options.classHandler];

      if ('function' === typeof $handlerFunction) {
        var $handler = $handlerFunction.call(this, this); // If this function returned a valid existing DOM element, go for it

        if ('undefined' !== typeof $handler && $handler.length) return $handler;
      } else if ('object' === _typeof($handlerFunction) && $handlerFunction instanceof jQuery && $handlerFunction.length) {
        return $handlerFunction;
      } else if ($handlerFunction) {
        Utils.warn('The class handler `' + $handlerFunction + '` does not exist in DOM nor as a global JS function');
      }

      return this._inputHolder();
    },
    _inputHolder: function _inputHolder() {
      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container
      if (!this.options.multiple || this.element.nodeName === 'SELECT') return this.$element; // But if multiple element (radio, checkbox), that would be their parent

      return this.$element.parent();
    },
    _insertErrorWrapper: function _insertErrorWrapper() {
      var $errorsContainer = this.options.errorsContainer; // Nothing to do if already inserted

      if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();

      if ('string' === typeof $errorsContainer) {
        if ($($errorsContainer).length) return $($errorsContainer).append(this._ui.$errorsWrapper);else if ('function' === typeof window[$errorsContainer]) $errorsContainer = window[$errorsContainer];else Utils.warn('The errors container `' + $errorsContainer + '` does not exist in DOM nor as a global JS function');
      }

      if ('function' === typeof $errorsContainer) $errorsContainer = $errorsContainer.call(this, this);
      if ('object' === _typeof($errorsContainer) && $errorsContainer.length) return $errorsContainer.append(this._ui.$errorsWrapper);
      return this._inputHolder().after(this._ui.$errorsWrapper);
    },
    _actualizeTriggers: function _actualizeTriggers() {
      var _this3 = this;

      var $toBind = this._findRelated();

      var trigger; // Remove Parsley events already bound on this field

      $toBind.off('.Parsley');
      if (this._failedOnce) $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), function () {
        _this3._validateIfNeeded();
      });else if (trigger = Utils.namespaceEvents(this.options.trigger, 'Parsley')) {
        $toBind.on(trigger, function (event) {
          _this3._validateIfNeeded(event);
        });
      }
    },
    _validateIfNeeded: function _validateIfNeeded(event) {
      var _this4 = this; // For keyup, keypress, keydown, input... events that could be a little bit obstrusive
      // do not validate if val length < min threshold on first validation. Once field have been validated once and info
      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.


      if (event && /key|input/.test(event.type)) if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold) return;

      if (this.options.debounce) {
        window.clearTimeout(this._debounced);
        this._debounced = window.setTimeout(function () {
          return _this4.validate();
        }, this.options.debounce);
      } else this.validate();
    },
    _resetUI: function _resetUI() {
      // Reset all event listeners
      this._failedOnce = false;

      this._actualizeTriggers(); // Nothing to do if UI never initialized for this field


      if ('undefined' === typeof this._ui) return; // Reset all errors' li

      this._ui.$errorsWrapper.removeClass('filled').children().remove(); // Reset validation class


      this._resetClass(); // Reset validation flags and last validation result


      this._ui.lastValidationResult = [];
      this._ui.validationInformationVisible = false;
    },
    _destroyUI: function _destroyUI() {
      this._resetUI();

      if ('undefined' !== typeof this._ui) this._ui.$errorsWrapper.remove();
      delete this._ui;
    },
    _successClass: function _successClass() {
      this._ui.validationInformationVisible = true;

      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);
    },
    _errorClass: function _errorClass() {
      this._ui.validationInformationVisible = true;

      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);
    },
    _resetClass: function _resetClass() {
      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);
    }
  };

  var Form = function Form(element, domOptions, options) {
    this.__class__ = 'Form';
    this.element = element;
    this.$element = $(element);
    this.domOptions = domOptions;
    this.options = options;
    this.parent = window.Parsley;
    this.fields = [];
    this.validationResult = null;
  };

  var Form__statusMapping = {
    pending: null,
    resolved: true,
    rejected: false
  };
  Form.prototype = {
    onSubmitValidate: function onSubmitValidate(event) {
      var _this5 = this; // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior


      if (true === event.parsley) return; // If we didn't come here through a submit button, use the first one in the form

      var submitSource = this._submitSource || this.$element.find(Utils._SubmitSelector)[0];
      this._submitSource = null;
      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);
      if (submitSource && null !== submitSource.getAttribute('formnovalidate')) return;
      window.Parsley._remoteCache = {};
      var promise = this.whenValidate({
        event: event
      });

      if ('resolved' === promise.state() && false !== this._trigger('submit')) {// All good, let event go through. We make this distinction because browsers
        // differ in their handling of `submit` being called from inside a submit event [#1047]
      } else {
        // Rejected or pending: cancel this submit
        event.stopImmediatePropagation();
        event.preventDefault();
        if ('pending' === promise.state()) promise.done(function () {
          _this5._submit(submitSource);
        });
      }
    },
    onSubmitButton: function onSubmitButton(event) {
      this._submitSource = event.currentTarget;
    },
    // internal
    // _submit submits the form, this time without going through the validations.
    // Care must be taken to "fake" the actual submit button being clicked.
    _submit: function _submit(submitSource) {
      if (false === this._trigger('submit')) return; // Add submit button's data

      if (submitSource) {
        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);
        if (0 === $synthetic.length) $synthetic = $('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element);
        $synthetic.attr({
          name: submitSource.getAttribute('name'),
          value: submitSource.getAttribute('value')
        });
      }

      this.$element.trigger(_extends($.Event('submit'), {
        parsley: true
      }));
    },
    // Performs validation on fields while triggering events.
    // @returns `true` if all validations succeeds, `false`
    // if a failure is immediately detected, or `null`
    // if dependant on a promise.
    // Consider using `whenValidate` instead.
    validate: function validate(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');

        var _arguments = _slice.call(arguments);

        var group = _arguments[0];
        var force = _arguments[1];
        var event = _arguments[2];
        options = {
          group: group,
          force: force,
          event: event
        };
      }

      return Form__statusMapping[this.whenValidate(options).state()];
    },
    whenValidate: function whenValidate() {
      var _Utils$all$done$fail$always,
          _this6 = this;

      var _ref7 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var group = _ref7.group;
      var force = _ref7.force;
      var event = _ref7.event;
      this.submitEvent = event;

      if (event) {
        this.submitEvent = _extends({}, event, {
          preventDefault: function preventDefault() {
            Utils.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`");
            _this6.validationResult = false;
          }
        });
      }

      this.validationResult = true; // fire validate event to eventually modify things before every validation

      this._trigger('validate'); // Refresh form DOM options and form's fields that could have changed


      this._refreshFields();

      var promises = this._withoutReactualizingFormOptions(function () {
        return $.map(_this6.fields, function (field) {
          return field.whenValidate({
            force: force,
            group: group
          });
        });
      });

      return (_Utils$all$done$fail$always = Utils.all(promises).done(function () {
        _this6._trigger('success');
      }).fail(function () {
        _this6.validationResult = false;

        _this6.focus();

        _this6._trigger('error');
      }).always(function () {
        _this6._trigger('validated');
      })).pipe.apply(_Utils$all$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));
    },
    // Iterate over refreshed fields, and stop on first failure.
    // Returns `true` if all fields are valid, `false` if a failure is detected
    // or `null` if the result depends on an unresolved promise.
    // Prefer using `whenValid` instead.
    isValid: function isValid(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');

        var _arguments2 = _slice.call(arguments);

        var group = _arguments2[0];
        var force = _arguments2[1];
        options = {
          group: group,
          force: force
        };
      }

      return Form__statusMapping[this.whenValid(options).state()];
    },
    // Iterate over refreshed fields and validate them.
    // Returns a promise.
    // A validation that immediately fails will interrupt the validations.
    whenValid: function whenValid() {
      var _this7 = this;

      var _ref8 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var group = _ref8.group;
      var force = _ref8.force;

      this._refreshFields();

      var promises = this._withoutReactualizingFormOptions(function () {
        return $.map(_this7.fields, function (field) {
          return field.whenValid({
            group: group,
            force: force
          });
        });
      });

      return Utils.all(promises);
    },
    refresh: function refresh() {
      this._refreshFields();

      return this;
    },
    // Reset UI
    reset: function reset() {
      // Form case: emit a reset event for each field
      for (var i = 0; i < this.fields.length; i++) {
        this.fields[i].reset();
      }

      this._trigger('reset');
    },
    // Destroy Parsley instance (+ UI)
    destroy: function destroy() {
      // Field case: emit destroy event to clean UI and then destroy stored instance
      this._destroyUI(); // Form case: destroy all its fields and then destroy stored instance


      for (var i = 0; i < this.fields.length; i++) {
        this.fields[i].destroy();
      }

      this.$element.removeData('Parsley');

      this._trigger('destroy');
    },
    _refreshFields: function _refreshFields() {
      return this.actualizeOptions()._bindFields();
    },
    _bindFields: function _bindFields() {
      var _this8 = this;

      var oldFields = this.fields;
      this.fields = [];
      this.fieldsMappedById = {};

      this._withoutReactualizingFormOptions(function () {
        _this8.$element.find(_this8.options.inputs).not(_this8.options.excluded).each(function (_, element) {
          var fieldInstance = new window.Parsley.Factory(element, {}, _this8); // Only add valid and not excluded `Field` and `FieldMultiple` children

          if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && true !== fieldInstance.options.excluded) {
            var uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;

            if ('undefined' === typeof _this8.fieldsMappedById[uniqueId]) {
              _this8.fieldsMappedById[uniqueId] = fieldInstance;

              _this8.fields.push(fieldInstance);
            }
          }
        });

        $.each(Utils.difference(oldFields, _this8.fields), function (_, field) {
          field.reset();
        });
      });

      return this;
    },
    // Internal only.
    // Looping on a form's fields to do validation or similar
    // will trigger reactualizing options on all of them, which
    // in turn will reactualize the form's options.
    // To avoid calling actualizeOptions so many times on the form
    // for nothing, _withoutReactualizingFormOptions temporarily disables
    // the method actualizeOptions on this form while `fn` is called.
    _withoutReactualizingFormOptions: function _withoutReactualizingFormOptions(fn) {
      var oldActualizeOptions = this.actualizeOptions;

      this.actualizeOptions = function () {
        return this;
      };

      var result = fn();
      this.actualizeOptions = oldActualizeOptions;
      return result;
    },
    // Internal only.
    // Shortcut to trigger an event
    // Returns true iff event is not interrupted and default not prevented.
    _trigger: function _trigger(eventName) {
      return this.trigger('form:' + eventName);
    }
  };

  var Constraint = function Constraint(parsleyField, name, requirements, priority, isDomConstraint) {
    var validatorSpec = window.Parsley._validatorRegistry.validators[name];
    var validator = new Validator(validatorSpec);
    priority = priority || parsleyField.options[name + 'Priority'] || validator.priority;
    isDomConstraint = true === isDomConstraint;

    _extends(this, {
      validator: validator,
      name: name,
      requirements: requirements,
      priority: priority,
      isDomConstraint: isDomConstraint
    });

    this._parseRequirements(parsleyField.options);
  };

  var capitalize = function capitalize(str) {
    var cap = str[0].toUpperCase();
    return cap + str.slice(1);
  };

  Constraint.prototype = {
    validate: function validate(value, instance) {
      var _validator;

      return (_validator = this.validator).validate.apply(_validator, [value].concat(_toConsumableArray(this.requirementList), [instance]));
    },
    _parseRequirements: function _parseRequirements(options) {
      var _this9 = this;

      this.requirementList = this.validator.parseRequirements(this.requirements, function (key) {
        return options[_this9.name + capitalize(key)];
      });
    }
  };

  var Field = function Field(field, domOptions, options, parsleyFormInstance) {
    this.__class__ = 'Field';
    this.element = field;
    this.$element = $(field); // Set parent if we have one

    if ('undefined' !== typeof parsleyFormInstance) {
      this.parent = parsleyFormInstance;
    }

    this.options = options;
    this.domOptions = domOptions; // Initialize some properties

    this.constraints = [];
    this.constraintsByName = {};
    this.validationResult = true; // Bind constraints

    this._bindConstraints();
  };

  var parsley_field__statusMapping = {
    pending: null,
    resolved: true,
    rejected: false
  };
  Field.prototype = {
    // # Public API
    // Validate field and trigger some events for mainly `UI`
    // @returns `true`, an array of the validators that failed, or
    // `null` if validation is not finished. Prefer using whenValidate
    validate: function validate(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');
        options = {
          options: options
        };
      }

      var promise = this.whenValidate(options);
      if (!promise) // If excluded with `group` option
        return true;

      switch (promise.state()) {
        case 'pending':
          return null;

        case 'resolved':
          return true;

        case 'rejected':
          return this.validationResult;
      }
    },
    // Validate field and trigger some events for mainly `UI`
    // @returns a promise that succeeds only when all validations do
    // or `undefined` if field is not in the given `group`.
    whenValidate: function whenValidate() {
      var _whenValid$always$done$fail$always,
          _this10 = this;

      var _ref9 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var force = _ref9.force;
      var group = _ref9.group; // do not validate a field if not the same as given validation group

      this.refresh();
      if (group && !this._isInGroup(group)) return;
      this.value = this.getValue(); // Field Validate event. `this.value` could be altered for custom needs

      this._trigger('validate');

      return (_whenValid$always$done$fail$always = this.whenValid({
        force: force,
        value: this.value,
        _refreshed: true
      }).always(function () {
        _this10._reflowUI();
      }).done(function () {
        _this10._trigger('success');
      }).fail(function () {
        _this10._trigger('error');
      }).always(function () {
        _this10._trigger('validated');
      })).pipe.apply(_whenValid$always$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));
    },
    hasConstraints: function hasConstraints() {
      return 0 !== this.constraints.length;
    },
    // An empty optional field does not need validation
    needsValidation: function needsValidation(value) {
      if ('undefined' === typeof value) value = this.getValue(); // If a field is empty and not required, it is valid
      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators

      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty) return false;
      return true;
    },
    _isInGroup: function _isInGroup(group) {
      if (Array.isArray(this.options.group)) return -1 !== $.inArray(group, this.options.group);
      return this.options.group === group;
    },
    // Just validate field. Do not trigger any event.
    // Returns `true` iff all constraints pass, `false` if there are failures,
    // or `null` if the result can not be determined yet (depends on a promise)
    // See also `whenValid`.
    isValid: function isValid(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');

        var _arguments3 = _slice.call(arguments);

        var force = _arguments3[0];
        var value = _arguments3[1];
        options = {
          force: force,
          value: value
        };
      }

      var promise = this.whenValid(options);
      if (!promise) // Excluded via `group`
        return true;
      return parsley_field__statusMapping[promise.state()];
    },
    // Just validate field. Do not trigger any event.
    // @returns a promise that succeeds only when all validations do
    // or `undefined` if the field is not in the given `group`.
    // The argument `force` will force validation of empty fields.
    // If a `value` is given, it will be validated instead of the value of the input.
    whenValid: function whenValid() {
      var _this11 = this;

      var _ref10 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _ref10$force = _ref10.force;
      var force = _ref10$force === undefined ? false : _ref10$force;
      var value = _ref10.value;
      var group = _ref10.group;
      var _refreshed = _ref10._refreshed; // Recompute options and rebind constraints to have latest changes

      if (!_refreshed) this.refresh(); // do not validate a field if not the same as given validation group

      if (group && !this._isInGroup(group)) return;
      this.validationResult = true; // A field without constraint is valid

      if (!this.hasConstraints()) return $.when(); // Value could be passed as argument, needed to add more power to 'field:validate'

      if ('undefined' === typeof value || null === value) value = this.getValue();
      if (!this.needsValidation(value) && true !== force) return $.when();

      var groupedConstraints = this._getGroupedConstraints();

      var promises = [];
      $.each(groupedConstraints, function (_, constraints) {
        // Process one group of constraints at a time, we validate the constraints
        // and combine the promises together.
        var promise = Utils.all($.map(constraints, function (constraint) {
          return _this11._validateConstraint(value, constraint);
        }));
        promises.push(promise);
        if (promise.state() === 'rejected') return false; // Interrupt processing if a group has already failed
      });
      return Utils.all(promises);
    },
    // @returns a promise
    _validateConstraint: function _validateConstraint(value, constraint) {
      var _this12 = this;

      var result = constraint.validate(value, this); // Map false to a failed promise

      if (false === result) result = $.Deferred().reject(); // Make sure we return a promise and that we record failures

      return Utils.all([result]).fail(function (errorMessage) {
        if (!(_this12.validationResult instanceof Array)) _this12.validationResult = [];

        _this12.validationResult.push({
          assert: constraint,
          errorMessage: 'string' === typeof errorMessage && errorMessage
        });
      });
    },
    // @returns Parsley field computed value that could be overrided or configured in DOM
    getValue: function getValue() {
      var value; // Value could be overriden in DOM or with explicit options

      if ('function' === typeof this.options.value) value = this.options.value(this);else if ('undefined' !== typeof this.options.value) value = this.options.value;else value = this.$element.val(); // Handle wrong DOM or configurations

      if ('undefined' === typeof value || null === value) return '';
      return this._handleWhitespace(value);
    },
    // Reset UI
    reset: function reset() {
      this._resetUI();

      return this._trigger('reset');
    },
    // Destroy Parsley instance (+ UI)
    destroy: function destroy() {
      // Field case: emit destroy event to clean UI and then destroy stored instance
      this._destroyUI();

      this.$element.removeData('Parsley');
      this.$element.removeData('FieldMultiple');

      this._trigger('destroy');
    },
    // Actualize options and rebind constraints
    refresh: function refresh() {
      this._refreshConstraints();

      return this;
    },
    _refreshConstraints: function _refreshConstraints() {
      return this.actualizeOptions()._bindConstraints();
    },
    refreshConstraints: function refreshConstraints() {
      Utils.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh");
      return this.refresh();
    },

    /**
    * Add a new constraint to a field
    *
    * @param {String}   name
    * @param {Mixed}    requirements      optional
    * @param {Number}   priority          optional
    * @param {Boolean}  isDomConstraint   optional
    */
    addConstraint: function addConstraint(name, requirements, priority, isDomConstraint) {
      if (window.Parsley._validatorRegistry.validators[name]) {
        var constraint = new Constraint(this, name, requirements, priority, isDomConstraint); // if constraint already exist, delete it and push new version

        if ('undefined' !== this.constraintsByName[constraint.name]) this.removeConstraint(constraint.name);
        this.constraints.push(constraint);
        this.constraintsByName[constraint.name] = constraint;
      }

      return this;
    },
    // Remove a constraint
    removeConstraint: function removeConstraint(name) {
      for (var i = 0; i < this.constraints.length; i++) {
        if (name === this.constraints[i].name) {
          this.constraints.splice(i, 1);
          break;
        }
      }

      delete this.constraintsByName[name];
      return this;
    },
    // Update a constraint (Remove + re-add)
    updateConstraint: function updateConstraint(name, parameters, priority) {
      return this.removeConstraint(name).addConstraint(name, parameters, priority);
    },
    // # Internals
    // Internal only.
    // Bind constraints from config + options + DOM
    _bindConstraints: function _bindConstraints() {
      var constraints = [];
      var constraintsByName = {}; // clean all existing DOM constraints to only keep javascript user constraints

      for (var i = 0; i < this.constraints.length; i++) {
        if (false === this.constraints[i].isDomConstraint) {
          constraints.push(this.constraints[i]);
          constraintsByName[this.constraints[i].name] = this.constraints[i];
        }
      }

      this.constraints = constraints;
      this.constraintsByName = constraintsByName; // then re-add Parsley DOM-API constraints

      for (var name in this.options) {
        this.addConstraint(name, this.options[name], undefined, true);
      } // finally, bind special HTML5 constraints


      return this._bindHtml5Constraints();
    },
    // Internal only.
    // Bind specific HTML5 constraints to be HTML5 compliant
    _bindHtml5Constraints: function _bindHtml5Constraints() {
      // html5 required
      if (null !== this.element.getAttribute('required')) this.addConstraint('required', true, undefined, true); // html5 pattern

      if (null !== this.element.getAttribute('pattern')) this.addConstraint('pattern', this.element.getAttribute('pattern'), undefined, true); // range

      var min = this.element.getAttribute('min');
      var max = this.element.getAttribute('max');
      if (null !== min && null !== max) this.addConstraint('range', [min, max], undefined, true); // HTML5 min
      else if (null !== min) this.addConstraint('min', min, undefined, true); // HTML5 max
        else if (null !== max) this.addConstraint('max', max, undefined, true); // length

      if (null !== this.element.getAttribute('minlength') && null !== this.element.getAttribute('maxlength')) this.addConstraint('length', [this.element.getAttribute('minlength'), this.element.getAttribute('maxlength')], undefined, true); // HTML5 minlength
      else if (null !== this.element.getAttribute('minlength')) this.addConstraint('minlength', this.element.getAttribute('minlength'), undefined, true); // HTML5 maxlength
        else if (null !== this.element.getAttribute('maxlength')) this.addConstraint('maxlength', this.element.getAttribute('maxlength'), undefined, true); // html5 types

      var type = Utils.getType(this.element); // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise

      if ('number' === type) {
        return this.addConstraint('type', ['number', {
          step: this.element.getAttribute('step') || '1',
          base: min || this.element.getAttribute('value')
        }], undefined, true); // Regular other HTML5 supported types
      } else if (/^(email|url|range|date)$/i.test(type)) {
        return this.addConstraint('type', type, undefined, true);
      }

      return this;
    },
    // Internal only.
    // Field is required if have required constraint without `false` value
    _isRequired: function _isRequired() {
      if ('undefined' === typeof this.constraintsByName.required) return false;
      return false !== this.constraintsByName.required.requirements;
    },
    // Internal only.
    // Shortcut to trigger an event
    _trigger: function _trigger(eventName) {
      return this.trigger('field:' + eventName);
    },
    // Internal only
    // Handles whitespace in a value
    // Use `data-parsley-whitespace="squish"` to auto squish input value
    // Use `data-parsley-whitespace="trim"` to auto trim input value
    _handleWhitespace: function _handleWhitespace(value) {
      if (true === this.options.trimValue) Utils.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"');
      if ('squish' === this.options.whitespace) value = value.replace(/\s{2,}/g, ' ');
      if ('trim' === this.options.whitespace || 'squish' === this.options.whitespace || true === this.options.trimValue) value = Utils.trimString(value);
      return value;
    },
    _isDateInput: function _isDateInput() {
      var c = this.constraintsByName.type;
      return c && c.requirements === 'date';
    },
    // Internal only.
    // Returns the constraints, grouped by descending priority.
    // The result is thus an array of arrays of constraints.
    _getGroupedConstraints: function _getGroupedConstraints() {
      if (false === this.options.priorityEnabled) return [this.constraints];
      var groupedConstraints = [];
      var index = {}; // Create array unique of priorities

      for (var i = 0; i < this.constraints.length; i++) {
        var p = this.constraints[i].priority;
        if (!index[p]) groupedConstraints.push(index[p] = []);
        index[p].push(this.constraints[i]);
      } // Sort them by priority DESC


      groupedConstraints.sort(function (a, b) {
        return b[0].priority - a[0].priority;
      });
      return groupedConstraints;
    }
  };
  var parsley_field = Field;

  var Multiple = function Multiple() {
    this.__class__ = 'FieldMultiple';
  };

  Multiple.prototype = {
    // Add new `$element` sibling for multiple field
    addElement: function addElement($element) {
      this.$elements.push($element);
      return this;
    },
    // See `Field._refreshConstraints()`
    _refreshConstraints: function _refreshConstraints() {
      var fieldConstraints;
      this.constraints = []; // Select multiple special treatment

      if (this.element.nodeName === 'SELECT') {
        this.actualizeOptions()._bindConstraints();

        return this;
      } // Gather all constraints for each input in the multiple group


      for (var i = 0; i < this.$elements.length; i++) {
        // Check if element have not been dynamically removed since last binding
        if (!$('html').has(this.$elements[i]).length) {
          this.$elements.splice(i, 1);
          continue;
        }

        fieldConstraints = this.$elements[i].data('FieldMultiple')._refreshConstraints().constraints;

        for (var j = 0; j < fieldConstraints.length; j++) {
          this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);
        }
      }

      return this;
    },
    // See `Field.getValue()`
    getValue: function getValue() {
      // Value could be overriden in DOM
      if ('function' === typeof this.options.value) return this.options.value(this);else if ('undefined' !== typeof this.options.value) return this.options.value; // Radio input case

      if (this.element.nodeName === 'INPUT') {
        var type = Utils.getType(this.element);
        if (type === 'radio') return this._findRelated().filter(':checked').val() || ''; // checkbox input case

        if (type === 'checkbox') {
          var values = [];

          this._findRelated().filter(':checked').each(function () {
            values.push($(this).val());
          });

          return values;
        }
      } // Select multiple case


      if (this.element.nodeName === 'SELECT' && null === this.$element.val()) return []; // Default case that should never happen

      return this.$element.val();
    },
    _init: function _init() {
      this.$elements = [this.$element];
      return this;
    }
  };

  var Factory = function Factory(element, options, parsleyFormInstance) {
    this.element = element;
    this.$element = $(element); // If the element has already been bound, returns its saved Parsley instance

    var savedparsleyFormInstance = this.$element.data('Parsley');

    if (savedparsleyFormInstance) {
      // If the saved instance has been bound without a Form parent and there is one given in this call, add it
      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {
        savedparsleyFormInstance.parent = parsleyFormInstance;

        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);
      }

      if ('object' === _typeof(options)) {
        _extends(savedparsleyFormInstance.options, options);
      }

      return savedparsleyFormInstance;
    } // Parsley must be instantiated with a DOM element or jQuery $element


    if (!this.$element.length) throw new Error('You must bind Parsley on an existing element.');
    if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__) throw new Error('Parent instance must be a Form instance');
    this.parent = parsleyFormInstance || window.Parsley;
    return this.init(options);
  };

  Factory.prototype = {
    init: function init(options) {
      this.__class__ = 'Parsley';
      this.__version__ = '2.8.1';
      this.__id__ = Utils.generateID(); // Pre-compute options

      this._resetOptions(options); // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute


      if (this.element.nodeName === 'FORM' || Utils.checkAttr(this.element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)) return this.bind('parsleyForm'); // Every other element is bound as a `Field` or `FieldMultiple`

      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');
    },
    isMultiple: function isMultiple() {
      var type = Utils.getType(this.element);
      return type === 'radio' || type === 'checkbox' || this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple');
    },
    // Multiples fields are a real nightmare :(
    // Maybe some refactoring would be appreciated here...
    handleMultiple: function handleMultiple() {
      var _this13 = this;

      var name;
      var multiple;
      var parsleyMultipleInstance; // Handle multiple name

      this.options.multiple = this.options.multiple || (name = this.element.getAttribute('name')) || this.element.getAttribute('id'); // Special select multiple input

      if (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')) {
        this.options.multiple = this.options.multiple || this.__id__;
        return this.bind('parsleyFieldMultiple'); // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it
      } else if (!this.options.multiple) {
        Utils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);
        return this;
      } // Remove special chars


      this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ''); // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name

      if (name) {
        $('input[name="' + name + '"]').each(function (i, input) {
          var type = Utils.getType(input);
          if (type === 'radio' || type === 'checkbox') input.setAttribute(_this13.options.namespace + 'multiple', _this13.options.multiple);
        });
      } // Check here if we don't already have a related multiple instance saved


      var $previouslyRelated = this._findRelated();

      for (var i = 0; i < $previouslyRelated.length; i++) {
        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');

        if ('undefined' !== typeof parsleyMultipleInstance) {
          if (!this.$element.data('FieldMultiple')) {
            parsleyMultipleInstance.addElement(this.$element);
          }

          break;
        }
      } // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`
      // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance


      this.bind('parsleyField', true);
      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');
    },
    // Return proper `Form`, `Field` or `FieldMultiple`
    bind: function bind(type, doNotStore) {
      var parsleyInstance;

      switch (type) {
        case 'parsleyForm':
          parsleyInstance = $.extend(new Form(this.element, this.domOptions, this.options), new Base(), window.ParsleyExtend)._bindFields();
          break;

        case 'parsleyField':
          parsleyInstance = $.extend(new parsley_field(this.element, this.domOptions, this.options, this.parent), new Base(), window.ParsleyExtend);
          break;

        case 'parsleyFieldMultiple':
          parsleyInstance = $.extend(new parsley_field(this.element, this.domOptions, this.options, this.parent), new Multiple(), new Base(), window.ParsleyExtend)._init();
          break;

        default:
          throw new Error(type + 'is not a supported Parsley type');
      }

      if (this.options.multiple) Utils.setAttr(this.element, this.options.namespace, 'multiple', this.options.multiple);

      if ('undefined' !== typeof doNotStore) {
        this.$element.data('FieldMultiple', parsleyInstance);
        return parsleyInstance;
      } // Store the freshly bound instance in a DOM element for later access using jQuery `data()`


      this.$element.data('Parsley', parsleyInstance); // Tell the world we have a new Form or Field instance!

      parsleyInstance._actualizeTriggers();

      parsleyInstance._trigger('init');

      return parsleyInstance;
    }
  };
  var vernums = $.fn.jquery.split('.');

  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {
    throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.";
  }

  if (!vernums.forEach) {
    Utils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');
  } // Inherit `on`, `off` & `trigger` to Parsley:


  var Parsley = _extends(new Base(), {
    element: document,
    $element: $(document),
    actualizeOptions: null,
    _resetOptions: null,
    Factory: Factory,
    version: '2.8.1'
  }); // Supplement Field and Form with Base
  // This way, the constructors will have access to those methods


  _extends(parsley_field.prototype, UI.Field, Base.prototype);

  _extends(Form.prototype, UI.Form, Base.prototype); // Inherit actualizeOptions and _resetOptions:


  _extends(Factory.prototype, Base.prototype); // ### jQuery API
  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`


  $.fn.parsley = $.fn.psly = function (options) {
    if (this.length > 1) {
      var instances = [];
      this.each(function () {
        instances.push($(this).parsley(options));
      });
      return instances;
    } // Return undefined if applied to non existing DOM element


    if (this.length == 0) {
      return;
    }

    return new Factory(this[0], options);
  }; // ### Field and Form extension
  // Ensure the extension is now defined if it wasn't previously


  if ('undefined' === typeof window.ParsleyExtend) window.ParsleyExtend = {}; // ### Parsley config
  // Inherit from ParsleyDefault, and copy over any existing values

  Parsley.options = _extends(Utils.objectCreate(Defaults), window.ParsleyConfig);
  window.ParsleyConfig = Parsley.options; // Old way of accessing global options
  // ### Globals

  window.Parsley = window.psly = Parsley;
  Parsley.Utils = Utils;
  window.ParsleyUtils = {};
  $.each(Utils, function (key, value) {
    if ('function' === typeof value) {
      window.ParsleyUtils[key] = function () {
        Utils.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');
        return Utils[key].apply(Utils, arguments);
      };
    }
  }); // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley

  var registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);
  window.ParsleyValidator = {};
  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator'.split(' '), function (i, method) {
    window.Parsley[method] = function () {
      return registry[method].apply(registry, arguments);
    };

    window.ParsleyValidator[method] = function () {
      var _window$Parsley;

      Utils.warnOnce('Accessing the method \'' + method + '\' through Validator is deprecated. Simply call \'window.Parsley.' + method + '(...)\'');
      return (_window$Parsley = window.Parsley)[method].apply(_window$Parsley, arguments);
    };
  }); // ### UI
  // Deprecated global object

  window.Parsley.UI = UI;
  window.ParsleyUI = {
    removeError: function removeError(instance, name, doNotUpdateClass) {
      var updateClass = true !== doNotUpdateClass;
      Utils.warnOnce('Accessing UI is deprecated. Call \'removeError\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');
      return instance.removeError(name, {
        updateClass: updateClass
      });
    },
    getErrorsMessages: function getErrorsMessages(instance) {
      Utils.warnOnce('Accessing UI is deprecated. Call \'getErrorsMessages\' on the instance directly.');
      return instance.getErrorsMessages();
    }
  };
  $.each('addError updateError'.split(' '), function (i, method) {
    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {
      var updateClass = true !== doNotUpdateClass;
      Utils.warnOnce('Accessing UI is deprecated. Call \'' + method + '\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');
      return instance[method](name, {
        message: message,
        assert: assert,
        updateClass: updateClass
      });
    };
  }); // ### PARSLEY auto-binding
  // Prevent it by setting `ParsleyConfig.autoBind` to `false`

  if (false !== window.ParsleyConfig.autoBind) {
    $(function () {
      // Works only on `data-parsley-validate`.
      if ($('[data-parsley-validate]').length) $('[data-parsley-validate]').parsley();
    });
  }

  var o = $({});

  var deprecated = function deprecated() {
    Utils.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley");
  }; // Returns an event handler that calls `fn` with the arguments it expects


  function adapt(fn, context) {
    // Store to allow unbinding
    if (!fn.parsleyAdaptedCallback) {
      fn.parsleyAdaptedCallback = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift(this);
        fn.apply(context || o, args);
      };
    }

    return fn.parsleyAdaptedCallback;
  }

  var eventPrefix = 'parsley:'; // Converts 'parsley:form:validate' into 'form:validate'

  function eventName(name) {
    if (name.lastIndexOf(eventPrefix, 0) === 0) return name.substr(eventPrefix.length);
    return name;
  } // $.listen is deprecated. Use Parsley.on instead.


  $.listen = function (name, callback) {
    var context;
    deprecated();

    if ('object' === _typeof(arguments[1]) && 'function' === typeof arguments[2]) {
      context = arguments[1];
      callback = arguments[2];
    }

    if ('function' !== typeof callback) throw new Error('Wrong parameters');
    window.Parsley.on(eventName(name), adapt(callback, context));
  };

  $.listenTo = function (instance, name, fn) {
    deprecated();
    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');
    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong parameters');
    instance.on(eventName(name), adapt(fn));
  };

  $.unsubscribe = function (name, fn) {
    deprecated();
    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong arguments');
    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);
  };

  $.unsubscribeTo = function (instance, name) {
    deprecated();
    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');
    instance.off(eventName(name));
  };

  $.unsubscribeAll = function (name) {
    deprecated();
    window.Parsley.off(eventName(name));
    $('form,input,textarea,select').each(function () {
      var instance = $(this).data('Parsley');

      if (instance) {
        instance.off(eventName(name));
      }
    });
  }; // $.emit is deprecated. Use jQuery events instead.


  $.emit = function (name, instance) {
    var _instance;

    deprecated();
    var instanceGiven = instance instanceof parsley_field || instance instanceof Form;
    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);
    args.unshift(eventName(name));

    if (!instanceGiven) {
      instance = window.Parsley;
    }

    (_instance = instance).trigger.apply(_instance, _toConsumableArray(args));
  };

  var pubsub = {};
  $.extend(true, Parsley, {
    asyncValidators: {
      'default': {
        fn: function fn(xhr) {
          // By default, only status 2xx are deemed successful.
          // Note: we use status instead of state() because responses with status 200
          // but invalid messages (e.g. an empty body for content type set to JSON) will
          // result in state() === 'rejected'.
          return xhr.status >= 200 && xhr.status < 300;
        },
        url: false
      },
      reverse: {
        fn: function fn(xhr) {
          // If reverse option is set, a failing ajax request is considered successful
          return xhr.status < 200 || xhr.status >= 300;
        },
        url: false
      }
    },
    addAsyncValidator: function addAsyncValidator(name, fn, url, options) {
      Parsley.asyncValidators[name] = {
        fn: fn,
        url: url || false,
        options: options || {}
      };
      return this;
    }
  });
  Parsley.addValidator('remote', {
    requirementType: {
      '': 'string',
      'validator': 'string',
      'reverse': 'boolean',
      'options': 'object'
    },
    validateString: function validateString(value, url, options, instance) {
      var data = {};
      var ajaxOptions;
      var csr;
      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');
      if ('undefined' === typeof Parsley.asyncValidators[validator]) throw new Error('Calling an undefined async validator: `' + validator + '`');
      url = Parsley.asyncValidators[validator].url || url; // Fill current value

      if (url.indexOf('{value}') > -1) {
        url = url.replace('{value}', encodeURIComponent(value));
      } else {
        data[instance.element.getAttribute('name') || instance.element.getAttribute('id')] = value;
      } // Merge options passed in from the function with the ones in the attribute


      var remoteOptions = $.extend(true, options.options || {}, Parsley.asyncValidators[validator].options); // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`

      ajaxOptions = $.extend(true, {}, {
        url: url,
        data: data,
        type: 'GET'
      }, remoteOptions); // Generate store key based on ajax options

      instance.trigger('field:ajaxoptions', instance, ajaxOptions);
      csr = $.param(ajaxOptions); // Initialise querry cache

      if ('undefined' === typeof Parsley._remoteCache) Parsley._remoteCache = {}; // Try to retrieve stored xhr

      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);

      var handleXhr = function handleXhr() {
        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);
        if (!result) // Map falsy results to rejected promise
          result = $.Deferred().reject();
        return $.when(result);
      };

      return xhr.then(handleXhr, handleXhr);
    },
    priority: -1
  });
  Parsley.on('form:submit', function () {
    Parsley._remoteCache = {};
  });

  Base.prototype.addAsyncValidator = function () {
    Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');
    return Parsley.addAsyncValidator.apply(Parsley, arguments);
  }; // This is included with the Parsley library itself,
  // thus there is no use in adding it to your project.


  Parsley.addMessages('en', {
    defaultMessage: "This value seems to be invalid.",
    type: {
      email: "This value should be a valid email.",
      url: "This value should be a valid url.",
      number: "This value should be a valid number.",
      integer: "This value should be a valid integer.",
      digits: "This value should be digits.",
      alphanum: "This value should be alphanumeric."
    },
    notblank: "This value should not be blank.",
    required: "This value is required.",
    pattern: "This value seems to be invalid.",
    min: "This value should be greater than or equal to %s.",
    max: "This value should be lower than or equal to %s.",
    range: "This value should be between %s and %s.",
    minlength: "This value is too short. It should have %s characters or more.",
    maxlength: "This value is too long. It should have %s characters or fewer.",
    length: "This value length is invalid. It should be between %s and %s characters long.",
    mincheck: "You must select at least %s choices.",
    maxcheck: "You must select %s choices or fewer.",
    check: "You must select between %s and %s choices.",
    equalto: "This value should be the same."
  });
  Parsley.setLocale('en');
  /**
   * inputevent - Alleviate browser bugs for input events
   * https://github.com/marcandre/inputevent
   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)
   * @author Marc-Andre Lafortune <github@marc-andre.ca>
   * @license MIT
   */

  function InputEvent() {
    var _this14 = this;

    var globals = window || global; // Slightly odd way construct our object. This way methods are force bound.
    // Used to test for duplicate library.

    _extends(this, {
      // For browsers that do not support isTrusted, assumes event is native.
      isNativeEvent: function isNativeEvent(evt) {
        return evt.originalEvent && evt.originalEvent.isTrusted !== false;
      },
      fakeInputEvent: function fakeInputEvent(evt) {
        if (_this14.isNativeEvent(evt)) {
          $(evt.target).trigger('input');
        }
      },
      misbehaves: function misbehaves(evt) {
        if (_this14.isNativeEvent(evt)) {
          _this14.behavesOk(evt);

          $(document).on('change.inputevent', evt.data.selector, _this14.fakeInputEvent);

          _this14.fakeInputEvent(evt);
        }
      },
      behavesOk: function behavesOk(evt) {
        if (_this14.isNativeEvent(evt)) {
          $(document) // Simply unbinds the testing handler
          .off('input.inputevent', evt.data.selector, _this14.behavesOk).off('change.inputevent', evt.data.selector, _this14.misbehaves);
        }
      },
      // Bind the testing handlers
      install: function install() {
        if (globals.inputEventPatched) {
          return;
        }

        globals.inputEventPatched = '0.0.3';
        var _arr = ['select', 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]'];

        for (var _i = 0; _i < _arr.length; _i++) {
          var selector = _arr[_i];
          $(document).on('input.inputevent', selector, {
            selector: selector
          }, _this14.behavesOk).on('change.inputevent', selector, {
            selector: selector
          }, _this14.misbehaves);
        }
      },
      uninstall: function uninstall() {
        delete globals.inputEventPatched;
        $(document).off('.inputevent');
      }
    });
  }

  ;
  var inputevent = new InputEvent();
  inputevent.install();
  var parsley = Parsley;
  return parsley;
});

(function (window, factory) {
  var lazySizes = factory(window, window.document);
  window.lazySizes = lazySizes;

  if (( false ? undefined : _typeof(module)) == 'object' && module.exports) {
    module.exports = lazySizes;
  }
})(window, function l(window, document) {
  'use strict';
  /*jshint eqnull:true */

  if (!document.getElementsByClassName) {
    return;
  }

  var lazysizes, lazySizesConfig;
  var docElem = document.documentElement;
  var Date = window.Date;
  var supportPicture = window.HTMLPictureElement;
  var _addEventListener = 'addEventListener';
  var _getAttribute = 'getAttribute';
  var addEventListener = window[_addEventListener];
  var setTimeout = window.setTimeout;
  var requestAnimationFrame = window.requestAnimationFrame || setTimeout;
  var requestIdleCallback = window.requestIdleCallback;
  var regPicture = /^picture$/i;
  var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];
  var regClassCache = {};
  var forEach = Array.prototype.forEach;

  var hasClass = function hasClass(ele, cls) {
    if (!regClassCache[cls]) {
      regClassCache[cls] = new RegExp('(\\s|^)' + cls + '(\\s|$)');
    }

    return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
  };

  var addClass = function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
      ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
    }
  };

  var removeClass = function removeClass(ele, cls) {
    var reg;

    if (reg = hasClass(ele, cls)) {
      ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
    }
  };

  var addRemoveLoadEvents = function addRemoveLoadEvents(dom, fn, add) {
    var action = add ? _addEventListener : 'removeEventListener';

    if (add) {
      addRemoveLoadEvents(dom, fn);
    }

    loadEvents.forEach(function (evt) {
      dom[action](evt, fn);
    });
  };

  var triggerEvent = function triggerEvent(elem, name, detail, noBubbles, noCancelable) {
    var event = document.createEvent('Event');

    if (!detail) {
      detail = {};
    }

    detail.instance = lazysizes;
    event.initEvent(name, !noBubbles, !noCancelable);
    event.detail = detail;
    elem.dispatchEvent(event);
    return event;
  };

  var updatePolyfill = function updatePolyfill(el, full) {
    var polyfill;

    if (!supportPicture && (polyfill = window.picturefill || lazySizesConfig.pf)) {
      if (full && full.src && !el[_getAttribute]('srcset')) {
        el.setAttribute('srcset', full.src);
      }

      polyfill({
        reevaluate: true,
        elements: [el]
      });
    } else if (full && full.src) {
      el.src = full.src;
    }
  };

  var getCSS = function getCSS(elem, style) {
    return (getComputedStyle(elem, null) || {})[style];
  };

  var getWidth = function getWidth(elem, parent, width) {
    width = width || elem.offsetWidth;

    while (width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth) {
      width = parent.offsetWidth;
      parent = parent.parentNode;
    }

    return width;
  };

  var rAF = function () {
    var running, waiting;
    var firstFns = [];
    var secondFns = [];
    var fns = firstFns;

    var run = function run() {
      var runFns = fns;
      fns = firstFns.length ? secondFns : firstFns;
      running = true;
      waiting = false;

      while (runFns.length) {
        runFns.shift()();
      }

      running = false;
    };

    var rafBatch = function rafBatch(fn, queue) {
      if (running && !queue) {
        fn.apply(this, arguments);
      } else {
        fns.push(fn);

        if (!waiting) {
          waiting = true;
          (document.hidden ? setTimeout : requestAnimationFrame)(run);
        }
      }
    };

    rafBatch._lsFlush = run;
    return rafBatch;
  }();

  var rAFIt = function rAFIt(fn, simple) {
    return simple ? function () {
      rAF(fn);
    } : function () {
      var that = this;
      var args = arguments;
      rAF(function () {
        fn.apply(that, args);
      });
    };
  };

  var throttle = function throttle(fn) {
    var running;
    var lastTime = 0;
    var gDelay = lazySizesConfig.throttleDelay;
    var rICTimeout = lazySizesConfig.ricTimeout;

    var run = function run() {
      running = false;
      lastTime = Date.now();
      fn();
    };

    var idleCallback = requestIdleCallback && rICTimeout > 49 ? function () {
      requestIdleCallback(run, {
        timeout: rICTimeout
      });

      if (rICTimeout !== lazySizesConfig.ricTimeout) {
        rICTimeout = lazySizesConfig.ricTimeout;
      }
    } : rAFIt(function () {
      setTimeout(run);
    }, true);
    return function (isPriority) {
      var delay;

      if (isPriority = isPriority === true) {
        rICTimeout = 33;
      }

      if (running) {
        return;
      }

      running = true;
      delay = gDelay - (Date.now() - lastTime);

      if (delay < 0) {
        delay = 0;
      }

      if (isPriority || delay < 9) {
        idleCallback();
      } else {
        setTimeout(idleCallback, delay);
      }
    };
  }; //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html


  var debounce = function debounce(func) {
    var timeout, timestamp;
    var wait = 99;

    var run = function run() {
      timeout = null;
      func();
    };

    var later = function later() {
      var last = Date.now() - timestamp;

      if (last < wait) {
        setTimeout(later, wait - last);
      } else {
        (requestIdleCallback || run)(run);
      }
    };

    return function () {
      timestamp = Date.now();

      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
    };
  };

  (function () {
    var prop;
    var lazySizesDefaults = {
      lazyClass: 'lazyload',
      loadedClass: 'lazyloaded',
      loadingClass: 'lazyloading',
      preloadClass: 'lazypreload',
      errorClass: 'lazyerror',
      //strictClass: 'lazystrict',
      autosizesClass: 'lazyautosizes',
      srcAttr: 'data-src',
      srcsetAttr: 'data-srcset',
      sizesAttr: 'data-sizes',
      //preloadAfterLoad: false,
      minSize: 40,
      customMedia: {},
      init: true,
      expFactor: 1.5,
      hFac: 0.8,
      loadMode: 2,
      loadHidden: true,
      ricTimeout: 0,
      throttleDelay: 125
    };
    lazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};

    for (prop in lazySizesDefaults) {
      if (!(prop in lazySizesConfig)) {
        lazySizesConfig[prop] = lazySizesDefaults[prop];
      }
    }

    window.lazySizesConfig = lazySizesConfig;
    setTimeout(function () {
      if (lazySizesConfig.init) {
        init();
      }
    });
  })();

  var loader = function () {
    var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;
    var eLvW, elvH, eLtop, eLleft, eLright, eLbottom;
    var defaultExpand, preloadExpand, hFac;
    var regImg = /^img$/i;
    var regIframe = /^iframe$/i;
    var supportScroll = 'onscroll' in window && !/(gle|ing)bot/.test(navigator.userAgent);
    var shrinkExpand = 0;
    var currentExpand = 0;
    var isLoading = 0;
    var lowRuns = -1;

    var resetPreloading = function resetPreloading(e) {
      isLoading--;

      if (e && e.target) {
        addRemoveLoadEvents(e.target, resetPreloading);
      }

      if (!e || isLoading < 0 || !e.target) {
        isLoading = 0;
      }
    };

    var isNestedVisible = function isNestedVisible(elem, elemExpand) {
      var outerRect;
      var parent = elem;
      var visible = getCSS(document.body, 'visibility') == 'hidden' || getCSS(elem.parentNode, 'visibility') != 'hidden' && getCSS(elem, 'visibility') != 'hidden';
      eLtop -= elemExpand;
      eLbottom += elemExpand;
      eLleft -= elemExpand;
      eLright += elemExpand;

      while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {
        visible = (getCSS(parent, 'opacity') || 1) > 0;

        if (visible && getCSS(parent, 'overflow') != 'visible') {
          outerRect = parent.getBoundingClientRect();
          visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;
        }
      }

      return visible;
    };

    var checkElements = function checkElements() {
      var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal;
      var lazyloadElems = lazysizes.elements;

      if ((loadMode = lazySizesConfig.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
        i = 0;
        lowRuns++;

        if (preloadExpand == null) {
          if (!('expand' in lazySizesConfig)) {
            lazySizesConfig.expand = docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370;
          }

          defaultExpand = lazySizesConfig.expand;
          preloadExpand = defaultExpand * lazySizesConfig.expFactor;
        }

        if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden) {
          currentExpand = preloadExpand;
          lowRuns = 0;
        } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
          currentExpand = defaultExpand;
        } else {
          currentExpand = shrinkExpand;
        }

        for (; i < eLlen; i++) {
          if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
            continue;
          }

          if (!supportScroll) {
            unveilElement(lazyloadElems[i]);
            continue;
          }

          if (!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)) {
            elemExpand = currentExpand;
          }

          if (beforeExpandVal !== elemExpand) {
            eLvW = innerWidth + elemExpand * hFac;
            elvH = innerHeight + elemExpand;
            elemNegativeExpand = elemExpand * -1;
            beforeExpandVal = elemExpand;
          }

          rect = lazyloadElems[i].getBoundingClientRect();

          if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesConfig.loadHidden || getCSS(lazyloadElems[i], 'visibility') != 'hidden') && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i], elemExpand))) {
            unveilElement(lazyloadElems[i]);
            loadedSomething = true;

            if (isLoading > 9) {
              break;
            }
          } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesConfig.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || lazyloadElems[i][_getAttribute](lazySizesConfig.sizesAttr) != 'auto'))) {
            autoLoadElem = preloadElems[0] || lazyloadElems[i];
          }
        }

        if (autoLoadElem && !loadedSomething) {
          unveilElement(autoLoadElem);
        }
      }
    };

    var throttledCheckElements = throttle(checkElements);

    var switchLoadingClass = function switchLoadingClass(e) {
      addClass(e.target, lazySizesConfig.loadedClass);
      removeClass(e.target, lazySizesConfig.loadingClass);
      addRemoveLoadEvents(e.target, rafSwitchLoadingClass);
      triggerEvent(e.target, 'lazyloaded');
    };

    var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);

    var rafSwitchLoadingClass = function rafSwitchLoadingClass(e) {
      rafedSwitchLoadingClass({
        target: e.target
      });
    };

    var changeIframeSrc = function changeIframeSrc(elem, src) {
      try {
        elem.contentWindow.location.replace(src);
      } catch (e) {
        elem.src = src;
      }
    };

    var handleSources = function handleSources(source) {
      var customMedia;

      var sourceSrcset = source[_getAttribute](lazySizesConfig.srcsetAttr);

      if (customMedia = lazySizesConfig.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) {
        source.setAttribute('media', customMedia);
      }

      if (sourceSrcset) {
        source.setAttribute('srcset', sourceSrcset);
      }
    };

    var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg) {
      var src, srcset, parent, isPicture, event, firesLoad;

      if (!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented) {
        if (sizes) {
          if (isAuto) {
            addClass(elem, lazySizesConfig.autosizesClass);
          } else {
            elem.setAttribute('sizes', sizes);
          }
        }

        srcset = elem[_getAttribute](lazySizesConfig.srcsetAttr);
        src = elem[_getAttribute](lazySizesConfig.srcAttr);

        if (isImg) {
          parent = elem.parentNode;
          isPicture = parent && regPicture.test(parent.nodeName || '');
        }

        firesLoad = detail.firesLoad || 'src' in elem && (srcset || src || isPicture);
        event = {
          target: elem
        };

        if (firesLoad) {
          addRemoveLoadEvents(elem, resetPreloading, true);
          clearTimeout(resetPreloadingTimer);
          resetPreloadingTimer = setTimeout(resetPreloading, 2500);
          addClass(elem, lazySizesConfig.loadingClass);
          addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
        }

        if (isPicture) {
          forEach.call(parent.getElementsByTagName('source'), handleSources);
        }

        if (srcset) {
          elem.setAttribute('srcset', srcset);
        } else if (src && !isPicture) {
          if (regIframe.test(elem.nodeName)) {
            changeIframeSrc(elem, src);
          } else {
            elem.src = src;
          }
        }

        if (isImg && (srcset || isPicture)) {
          updatePolyfill(elem, {
            src: src
          });
        }
      }

      if (elem._lazyRace) {
        delete elem._lazyRace;
      }

      removeClass(elem, lazySizesConfig.lazyClass);
      rAF(function () {
        if (!firesLoad || elem.complete && elem.naturalWidth > 1) {
          if (firesLoad) {
            resetPreloading(event);
          } else {
            isLoading--;
          }

          switchLoadingClass(event);
        }
      }, true);
    });

    var unveilElement = function unveilElement(elem) {
      var detail;
      var isImg = regImg.test(elem.nodeName); //allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")

      var sizes = isImg && (elem[_getAttribute](lazySizesConfig.sizesAttr) || elem[_getAttribute]('sizes'));

      var isAuto = sizes == 'auto';

      if ((isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesConfig.errorClass) && hasClass(elem, lazySizesConfig.lazyClass)) {
        return;
      }

      detail = triggerEvent(elem, 'lazyunveilread').detail;

      if (isAuto) {
        autoSizer.updateElem(elem, true, elem.offsetWidth);
      }

      elem._lazyRace = true;
      isLoading++;
      lazyUnveil(elem, detail, isAuto, sizes, isImg);
    };

    var onload = function onload() {
      if (isCompleted) {
        return;
      }

      if (Date.now() - started < 999) {
        setTimeout(onload, 999);
        return;
      }

      var afterScroll = debounce(function () {
        lazySizesConfig.loadMode = 3;
        throttledCheckElements();
      });
      isCompleted = true;
      lazySizesConfig.loadMode = 3;
      throttledCheckElements();
      addEventListener('scroll', function () {
        if (lazySizesConfig.loadMode == 3) {
          lazySizesConfig.loadMode = 2;
        }

        afterScroll();
      }, true);
    };

    return {
      _: function _() {
        started = Date.now();
        lazysizes.elements = document.getElementsByClassName(lazySizesConfig.lazyClass);
        preloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass + ' ' + lazySizesConfig.preloadClass);
        hFac = lazySizesConfig.hFac;
        addEventListener('scroll', throttledCheckElements, true);
        addEventListener('resize', throttledCheckElements, true);

        if (window.MutationObserver) {
          new MutationObserver(throttledCheckElements).observe(docElem, {
            childList: true,
            subtree: true,
            attributes: true
          });
        } else {
          docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);

          docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);

          setInterval(throttledCheckElements, 999);
        }

        addEventListener('hashchange', throttledCheckElements, true); //, 'fullscreenchange'

        ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend', 'webkitAnimationEnd'].forEach(function (name) {
          document[_addEventListener](name, throttledCheckElements, true);
        });

        if (/d$|^c/.test(document.readyState)) {
          onload();
        } else {
          addEventListener('load', onload);

          document[_addEventListener]('DOMContentLoaded', throttledCheckElements);

          setTimeout(onload, 20000);
        }

        if (lazysizes.elements.length) {
          checkElements();

          rAF._lsFlush();
        } else {
          throttledCheckElements();
        }
      },
      checkElems: throttledCheckElements,
      unveil: unveilElement
    };
  }();

  var autoSizer = function () {
    var autosizesElems;
    var sizeElement = rAFIt(function (elem, parent, event, width) {
      var sources, i, len;
      elem._lazysizesWidth = width;
      width += 'px';
      elem.setAttribute('sizes', width);

      if (regPicture.test(parent.nodeName || '')) {
        sources = parent.getElementsByTagName('source');

        for (i = 0, len = sources.length; i < len; i++) {
          sources[i].setAttribute('sizes', width);
        }
      }

      if (!event.detail.dataAttr) {
        updatePolyfill(elem, event.detail);
      }
    });

    var getSizeElement = function getSizeElement(elem, dataAttr, width) {
      var event;
      var parent = elem.parentNode;

      if (parent) {
        width = getWidth(elem, parent, width);
        event = triggerEvent(elem, 'lazybeforesizes', {
          width: width,
          dataAttr: !!dataAttr
        });

        if (!event.defaultPrevented) {
          width = event.detail.width;

          if (width && width !== elem._lazysizesWidth) {
            sizeElement(elem, parent, event, width);
          }
        }
      }
    };

    var updateElementsSizes = function updateElementsSizes() {
      var i;
      var len = autosizesElems.length;

      if (len) {
        i = 0;

        for (; i < len; i++) {
          getSizeElement(autosizesElems[i]);
        }
      }
    };

    var debouncedUpdateElementsSizes = debounce(updateElementsSizes);
    return {
      _: function _() {
        autosizesElems = document.getElementsByClassName(lazySizesConfig.autosizesClass);
        addEventListener('resize', debouncedUpdateElementsSizes);
      },
      checkElems: debouncedUpdateElementsSizes,
      updateElem: getSizeElement
    };
  }();

  var init = function init() {
    if (!init.i) {
      init.i = true;

      autoSizer._();

      loader._();
    }
  };

  lazysizes = {
    cfg: lazySizesConfig,
    autoSizer: autoSizer,
    loader: loader,
    init: init,
    uP: updatePolyfill,
    aC: addClass,
    rC: removeClass,
    hC: hasClass,
    fire: triggerEvent,
    gW: getWidth,
    rAF: rAF
  };
  return lazysizes;
}); //
// Passive option for event listeners
// --------------------------------------------------
// Feature detection for addEventListener's 'passive' option.
// Allows for conditional setting of the third argument in an event listener.
// --------------------------------------------------
// Example usage:
// el.addEventListener('click', function(){...}, passiveEventListenerOptionSupported ? { passive: true } : false);
// --------------------------------------------------


var passiveEventListenerOptionSupported = false;

try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get() {
      passiveEventListenerOptionSupported = true;
    }
  });
  window.addEventListener("testPassiveOption", null, opts);
  window.removeEventListener("testPassiveOption", null, opts);
} catch (err) {} //
// Remove the scrolling increment/decrement behavior from number input elements
// --------------------------------------------------


document.addEventListener("wheel", function (event) {
  if (document.activeElement.type === "number") {
    document.activeElement.blur();
  }
}, passiveEventListenerOptionSupported ? {
  passive: true
} : false); //
// Exclude hidden elements from Parsley
// --------------------------------------------------

if (typeof Parsley !== 'undefined' && typeof Parsley.options !== 'undefined') {
  Parsley.options.excluded = 'input[type=button], input[type=submit], input[type=reset], input[type=hidden], [disabled], :hidden';
} //
// DOM loaded body class
// --------------------------------------------------
// When the page is loaded, add & remove classes from the body element
// --------------------------------------------------
// H/t to https://www.sitepoint.com/jquery-document-ready-plain-javascript/
// --------------------------------------------------


var domLoadedCallback = function domLoadedCallback() {
  document.body.classList.add('dom-has-loaded');
  document.body.classList.remove('dom-not-yet-loaded');
};

if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
  domLoadedCallback();
} else {
  document.addEventListener("DOMContentLoaded", domLoadedCallback);
} //
// Dispatcher.js
// v0.4.4
// ----------------------------------------------------------------------------
// Create actions & reactions in markup
// ----------------------------------------------------------------------------
// TODO
// - Change data-dispatcher-notify to accept an array of IDs to notify
// - Allow customization of .is-dispatcher-notified class name (for multiple uses of dispatcher)
// - Separate trigger, target, and notified dispatch into 3 functions?
// - Add a callback when dispatch is completed?
// - Rewrite in Vanilla JS (for event delegation, see https://gomakethings.com/checking-event-target-selectors-with-event-bubbling-in-vanilla-javascript/)
// ----------------------------------------------------------------------------
// Functions
// --------------------------------------------------


function clickDispatch(trigger) {
  // Feedback to the trigger element
  // --------------------------
  // if an attribute data-dispatcher-trigger-active-class __exists and has a value__
  if (trigger.attr("data-dispatcher-trigger-active-class")) {
    var $custom_trigger_class = trigger.data("dispatcher-trigger-active-class");
    trigger.toggleClass($custom_trigger_class);
  } else {
    // Toggle active class
    trigger.toggleClass("is-active");
  } // Toggle selected ARIA attributes if they exist


  if (trigger.attr("aria-pressed")) {
    var hasAriaPressedAttr = true;
  }

  if (trigger.attr("aria-expanded")) {
    var hasAriaExpandedAttr = true;
  }

  if (hasAriaPressedAttr) {
    trigger.attr("aria-pressed", trigger.attr("aria-pressed") == "false" ? true : false);
  }

  if (hasAriaExpandedAttr) {
    trigger.attr("aria-expanded", trigger.attr("aria-expanded") == "false" ? true : false);
  } // Notified element dispatch
  // --------------------------
  // If an element is to be notified (a value is given in the attribute),
  // notify it/them with toggled class "is-dispatching"


  if (trigger.attr("data-dispatcher-notify")) {
    var $notify_class = "." + trigger.data("dispatcher-notify");
    $($notify_class).toggleClass("is-dispatcher-notified");
  } // Target element dispatch
  // --------------------------
  // Get the targeted element via data-attribute


  var target = "#" + trigger.data("dispatcher-target");
  target = $(target); // if an attribute data-dispatcher-target-active-class __exists and has a value__

  if (trigger.attr("data-dispatcher-target-active-class")) {
    var $custom_target_class = trigger.data("dispatcher-target-active-class");
    target.toggleClass($custom_target_class);
  } else {
    target.toggleClass("is-active");
  } // ARIA attributes to flip


  target.attr("aria-hidden", target.attr("aria-hidden") == "false" ? true : false); // "One at a time, siblings" dispatch
  // --------------------------
  // For when only one child may be active at a time. (Like an accordion!)
  // --------------------------

  if (trigger.attr("data-dispatcher-parent")) {
    // Get the targeted element via data-attribute
    var $parent = "#" + trigger.data("dispatcher-parent"); // These may _seem_ reversed, but note that at the top of this function, the is-active class is toggled. So at this point, we're not checking "if the trigger had is-active before click", but "if the trigger has is-active now that it has been clicked".

    if (trigger.hasClass("is-active")) {
      $($parent).addClass("has-dispatched-active-child");
    } else {
      $($parent).removeClass("has-dispatched-active-child");
    }

    trigger.siblings(".dispatcher-trigger").removeClass("is-active");
  }
} // Logic
// --------------------------------------------------


$(document).ready(function () {
  // listen for a click or keydown event on elements with .dispatch-trigger. keydown is needed because some elements that are not native <button> or <a> elements — yet have tabindex="0" added allowing for keyboard access — need to receive a spacebar key press or return key press
  $("body").on("click keydown", ".dispatcher-trigger", function (event) {
    // Check if the event is either a click, a spacebar press, or a return press
    if (event.type === "click" || event.which == 13 || event.which == 32) {
      // restricts the "overpowered" preventDefault action ONLY to a direct click/keydown on .dispatch-triger element
      //   - this retains blocking of default actions when the trigger is an anchor itself
      //   - but allows child a, input, button, label, etc. to retain their functionality
      if (event.target === event.currentTarget) {
        // Prevent default click actions
        event.preventDefault();
      } // Fire the main function


      clickDispatch($(this));
    }
  });
}); //
// Perch Navigation / Menu System
// --------------------------------------------------
// Variables defined in perch-core-scripts.js
// --------------------------------------------------
// Variables
// ---------------------------------------

var $global_header = $('#global-header'),
    $nav_outer_wrapper = $('#global-outer-navigation-wrapper'),
    // $nav_parent      = $('.global-nav-item--has-children'),
$nav_active_parent = $('.global-nav-item--has-children.active-parent'),
    // $nav_parent_link     = $('.global-nav-item--has-children > .global-nav-link'),
$nav_child = $('.global-nav-child-list'),
    $nav_reveal_button = $('.hamburger-menu-button'); // Functions
// ---------------------------------------
// Mobile nav opening
// --------------------------

function openMobileNav() {
  $('html').addClass('mobile-nav-is-open is-mobile-scroll-locked');
  $nav_reveal_button.addClass('is-active').attr('aria-expanded', 'true').attr('aria-pressed', 'true');
  $nav_outer_wrapper.addClass('is-active');
  $global_header.addClass('mobile-nav-is-open');
} // Navigation opening
// --------------------------
// Opens the menu for both mobile and desktop.
// Also can accept an argument to open a specific child menu.
//  > Could be used to open the navigation by clicking a link or button on the page.
//  > Was once used on WMU/WordlCrafts sidebar
// --------------------------


function openNav(the_menu) {
  // Use interpolation to take the passed child menu name and then select it below
  var interpolated_selector = ".menu-" + the_menu;
  $(interpolated_selector).focus().addClass('is-open submenu-is-open');
  $(interpolated_selector).children($nav_child).addClass('is-open');
  $(interpolated_selector).children('.child-nav-opener').addClass('is-active'); // Feedback to the body: a child menu is open. Allows for making a backdrop show up over the content/beneath the menu.
  // $('body').addClass('child-menu-is-open');

  openMobileNav();

  if ($nav_outer_wrapper.hasClass('navigation-drawer-wrapper')) {
    drawerListenForClosingSwipe();
  }
} // Navigation closing
// --------------------------


function closeNav(closeNavMilliseconds) {
  $('html').removeClass('mobile-nav-is-open is-mobile-scroll-locked');
  $nav_outer_wrapper.addClass('animating-out');
  $nav_reveal_button.removeClass('is-active').attr('aria-expanded', 'false').attr('aria-pressed', 'false');
  $global_header.removeClass('mobile-nav-is-open'); // Close megamenus for mobile...before animation is finished

  $('.global-nav-item').removeClass('is-open submenu-is-open submenu-is-mobile-open');
  $('body').removeClass('child-menu-is-open'); // if a custom timeout is passed, 

  milliseconds = closeNavMilliseconds >= 0 ? closeNavMilliseconds : 250;
  var nav_close_timer = setTimeout(function () {
    // Close megamenus for mobile...after animation is finished
    $('.child-nav-opener').removeClass('is-active');
    $nav_child.removeClass('is-open');
    $nav_outer_wrapper.removeClass('is-active');
    $nav_outer_wrapper.removeClass('animating-out');
  }, milliseconds); // also close the search

  if (typeof closeSearch === 'function') {
    closeSearch();
  } // if a drawer, pass the false value to remove the swipe event listeners


  if ($nav_outer_wrapper.hasClass('navigation-drawer-wrapper')) {
    drawerListenForClosingSwipe(false);
  }

  return false;
} // Logic
// ---------------------------------------
// Navigation
// --------------------------
// Close the menu if it's currently active. Otherwise: run openNav function.


$nav_reveal_button.on('click keydown', function (e) {
  if (e.type == 'click' || e.keyCode == 32) {
    e.preventDefault();

    if ($(this).hasClass('is-active')) {
      closeNav();
      this.blur(); // Remove the focus from the button so :focus styles don't show on touch screens
    } else {
      openNav();
    }
  }
}); //
// Child Nav Open With Parent Click
// --------------------------------------------------
// If a nav link set to open its child is clicked,
// open the child menu.
// --------------------------------------------------
// Assumes an integration with:
// - navigation-system.js
// --------------------------------------------------
// Do not use alongside child-nav-open-with-generated-button.js
// --------------------------------------------------
// Variables
// ---------------------------------------

var $nav_link_opens_child = $('.global-nav-item--opens-child > .global-nav-link'); // ---------------------------------------
// Logic
// ---------------------------------------

$nav_link_opens_child.click(function (e) {
  // Prevent link from being followed
  e.preventDefault(); // set the parent

  var $the_parent = $(this).parent(); // remove is-open class if it's already there

  if ($the_parent.hasClass('submenu-is-open') || $the_parent.hasClass('submenu-is-mobile-open')) {
    $the_parent.removeClass('submenu-is-open submenu-is-mobile-open').children('.global-nav-child-list').removeClass('is-open');
    $(this).blur();
  } // otherwise, add it
  else {
      $the_parent.addClass('submenu-is-open').children('.global-nav-child-list').addClass('is-open');
    }
}); //
// Modal Search System
// --------------------------------------------------
// Variables defined in perch-core-scripts.js
// --------------------------------------------------
// Variables
// ---------------------------------------

var $search_reveal_button = $('.global-search-reveal-button'),
    $search_menu = $('#global-search-overlay'),
    $search_input = $('#global-search-overlay__input'),
    $search_submit = $('#global-search-overlay__submit'),
    $search_close_btn = $('#global-search-overlay__close-button'),
    // Global standard for triggering search.
// Example usage: rather than embed an additional search form input and submit on a 404 page, add a link or button with this class that summons the site search.
// If not using functionality in the modal search system, write something similar using this class name and variable.
$search_trigger = $('.global-search-trigger'); // ---------------------------------------
// Functions
// ---------------------------------------
// Search opening
// --------------------------

function openSearch() {
  // First, make the link highlighted & show the menu
  $search_reveal_button.addClass('is-active').attr('aria-expanded', 'true').attr('aria-pressed', 'true');
  $search_menu.addClass('is-active'); // Then, select the input field

  $search_input.select();
} // Search closing
// --------------------------


function closeSearch() {
  // Remove classes to the menu and the link
  // $(this).offsetWidth = $(this).offsetWidth;
  $search_menu.addClass('animating-out');
  setTimeout(function () {
    $search_reveal_button.removeClass('is-active').attr('aria-expanded', 'false').attr('aria-pressed', 'false');
    $search_menu.removeClass('is-active');
    $search_menu.removeClass('animating-out');
  }, 250);
  return false;
}

; // Logic
// ---------------------------------------
// Close the menu if it's currently active. Otherwise: run openSearch function.

$search_reveal_button.click(function () {
  if ($(this).hasClass('is-active')) {
    closeSearch();
  } else {
    openSearch();
  }
}); // Open the search menu if any anchor with a certain class is clicked

$search_trigger.click(function () {
  // if the selected search trigger is also a search reveal button, abort this function
  if ($(this).is($search_reveal_button)) {
    return false;
  } // Add classes to the menu and the link


  $search_reveal_button.addClass('is-active');
  $search_menu.addClass('is-active'); // Focus the search input

  $(this).blur();
  $search_input.select();
  return false;
}); // Clicking anywhere in the search's background overlay — except within the actual form — closes the overlay

$search_menu.click(closeSearch); // ...Do not close if the click is inside the inner container.

$('.global-search-overlay__inner').click(function (event) {
  event.stopPropagation();
});
$search_close_btn.click(closeSearch); // Search keyboard assist: when search menu is open, keep focus within the search menu
// by focusing "back to" the corner closer button, which allows the user to close if desired,
// or continue to the next focusable field, the input itself

$search_close_btn.on('focusout', function () {
  $search_input.focus();
}); //
// Keyboard shortcuts with MouseTrap.js
// --------------------------------------------------
// Assumes an integration with:
// - navigation-system.js
// - modal-search-system.js
// --------------------------------------------------
// open search

Mousetrap.bind('/', function (e) {
  if (typeof openSearch == 'function' && $search_menu.length) {
    // If the search menu is already open, nevermind, let the `/` through...
    if ($search_menu.hasClass('is-active')) {
      return true;
    } // But if it's not already open, capture the `/` and open the menu
    else {
        // Prevent '/' char from being typed into the newly-focused search field
        e.preventDefault();
        openSearch();
      }
  } // else {
  //  console.log("Either openSearch is not a function or $search_menu has not been assigned.");
  // }

}); // press escape (ESC) to close menus

Mousetrap.bind('esc', function () {
  if (typeof closeNav == 'function') {
    closeNav();
  }

  if (typeof closeSearch == 'function') {
    closeSearch();
  }
}); // open the menu/nav

Mousetrap.bind('u', function () {
  // Since search input is allowed to listen to Mousetrap (normally it's disabled — but we want it enabled for ESC key close), ignore the "u" character if it is open
  if (!_typeof($search_menu) === 'undefined' && $search_menu.hasClass('is-active')) {
    return true;
  } // Otherwise, if the mobile navigation is open, close it
  else if ($global_header.hasClass('mobile-nav-is-open')) {
      if (typeof closeNav == 'function') {
        closeNav();
      }
    } // ...and if it's not open, open it
    else {
        if (typeof openNav == 'function') {
          openNav();
        }
      }
}); // // konami code!
// Mousetrap.bind('up up down down left right left right b a', function() { //enter
//  document.body.classList.add('konami-code-is-active');
// });

/*!

Holder - client side image placeholders
Version 2.9.6+fblyy
© 2018 Ivan Malopinsky - http://imsky.co

Site:     http://holderjs.com
Issues:   https://github.com/imsky/holder/issues
License:  MIT

*/

(function (window) {
  if (!window.document) return;
  var document = window.document; //https://github.com/inexorabletash/polyfill/blob/master/web.js

  if (!document.querySelectorAll) {
    document.querySelectorAll = function (selectors) {
      var style = document.createElement('style'),
          elements = [],
          element;
      document.documentElement.firstChild.appendChild(style);
      document._qsa = [];
      style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';
      window.scrollBy(0, 0);
      style.parentNode.removeChild(style);

      while (document._qsa.length) {
        element = document._qsa.shift();
        element.style.removeAttribute('x-qsa');
        elements.push(element);
      }

      document._qsa = null;
      return elements;
    };
  }

  if (!document.querySelector) {
    document.querySelector = function (selectors) {
      var elements = document.querySelectorAll(selectors);
      return elements.length ? elements[0] : null;
    };
  }

  if (!document.getElementsByClassName) {
    document.getElementsByClassName = function (classNames) {
      classNames = String(classNames).replace(/^|\s+/g, '.');
      return document.querySelectorAll(classNames);
    };
  } //https://github.com/inexorabletash/polyfill
  // ES5 15.2.3.14 Object.keys ( O )
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys


  if (!Object.keys) {
    Object.keys = function (o) {
      if (o !== Object(o)) {
        throw TypeError('Object.keys called on non-object');
      }

      var ret = [],
          p;

      for (p in o) {
        if (Object.prototype.hasOwnProperty.call(o, p)) {
          ret.push(p);
        }
      }

      return ret;
    };
  } // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )
  // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach


  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (fun
    /*, thisp */
    ) {
      if (this === void 0 || this === null) {
        throw TypeError();
      }

      var t = Object(this);
      var len = t.length >>> 0;

      if (typeof fun !== "function") {
        throw TypeError();
      }

      var thisp = arguments[1],
          i;

      for (i = 0; i < len; i++) {
        if (i in t) {
          fun.call(thisp, t[i], i, t);
        }
      }
    };
  } //https://github.com/inexorabletash/polyfill/blob/master/web.js


  (function (global) {
    var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    global.atob = global.atob || function (input) {
      input = String(input);
      var position = 0,
          output = [],
          buffer = 0,
          bits = 0,
          n;
      input = input.replace(/\s/g, '');

      if (input.length % 4 === 0) {
        input = input.replace(/=+$/, '');
      }

      if (input.length % 4 === 1) {
        throw Error('InvalidCharacterError');
      }

      if (/[^+/0-9A-Za-z]/.test(input)) {
        throw Error('InvalidCharacterError');
      }

      while (position < input.length) {
        n = B64_ALPHABET.indexOf(input.charAt(position));
        buffer = buffer << 6 | n;
        bits += 6;

        if (bits === 24) {
          output.push(String.fromCharCode(buffer >> 16 & 0xFF));
          output.push(String.fromCharCode(buffer >> 8 & 0xFF));
          output.push(String.fromCharCode(buffer & 0xFF));
          bits = 0;
          buffer = 0;
        }

        position += 1;
      }

      if (bits === 12) {
        buffer = buffer >> 4;
        output.push(String.fromCharCode(buffer & 0xFF));
      } else if (bits === 18) {
        buffer = buffer >> 2;
        output.push(String.fromCharCode(buffer >> 8 & 0xFF));
        output.push(String.fromCharCode(buffer & 0xFF));
      }

      return output.join('');
    };

    global.btoa = global.btoa || function (input) {
      input = String(input);
      var position = 0,
          out = [],
          o1,
          o2,
          o3,
          e1,
          e2,
          e3,
          e4;

      if (/[^\x00-\xFF]/.test(input)) {
        throw Error('InvalidCharacterError');
      }

      while (position < input.length) {
        o1 = input.charCodeAt(position++);
        o2 = input.charCodeAt(position++);
        o3 = input.charCodeAt(position++); // 111111 112222 222233 333333

        e1 = o1 >> 2;
        e2 = (o1 & 0x3) << 4 | o2 >> 4;
        e3 = (o2 & 0xf) << 2 | o3 >> 6;
        e4 = o3 & 0x3f;

        if (position === input.length + 2) {
          e3 = 64;
          e4 = 64;
        } else if (position === input.length + 1) {
          e4 = 64;
        }

        out.push(B64_ALPHABET.charAt(e1), B64_ALPHABET.charAt(e2), B64_ALPHABET.charAt(e3), B64_ALPHABET.charAt(e4));
      }

      return out.join('');
    };
  })(window); //https://gist.github.com/jimeh/332357


  if (!Object.prototype.hasOwnProperty) {
    /*jshint -W001, -W103 */
    Object.prototype.hasOwnProperty = function (prop) {
      var proto = this.__proto__ || this.constructor.prototype;
      return prop in this && (!(prop in proto) || proto[prop] !== this[prop]);
    };
    /*jshint +W001, +W103 */

  } // @license http://opensource.org/licenses/MIT
  // copyright Paul Irish 2015
  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill
  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js
  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values
  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page
  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed


  (function () {
    if ('performance' in window === false) {
      window.performance = {};
    }

    Date.now = Date.now || function () {
      // thanks IE8
      return new Date().getTime();
    };

    if ('now' in window.performance === false) {
      var nowOffset = Date.now();

      if (performance.timing && performance.timing.navigationStart) {
        nowOffset = performance.timing.navigationStart;
      }

      window.performance.now = function now() {
        return Date.now() - nowOffset;
      };
    }
  })(); //requestAnimationFrame polyfill for older Firefox/Chrome versions


  if (!window.requestAnimationFrame) {
    if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {
      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-webkit.js
      (function (global) {
        global.requestAnimationFrame = function (callback) {
          return webkitRequestAnimationFrame(function () {
            callback(global.performance.now());
          });
        };

        global.cancelAnimationFrame = global.webkitCancelAnimationFrame;
      })(window);
    } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {
      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-moz.js
      (function (global) {
        global.requestAnimationFrame = function (callback) {
          return mozRequestAnimationFrame(function () {
            callback(global.performance.now());
          });
        };

        global.cancelAnimationFrame = global.mozCancelAnimationFrame;
      })(window);
    } else {
      (function (global) {
        global.requestAnimationFrame = function (callback) {
          return global.setTimeout(callback, 1000 / 60);
        };

        global.cancelAnimationFrame = global.clearTimeout;
      })(window);
    }
  }
})(this);

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(this, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId])
          /******/
          return installedModules[moduleId].exports;
        /******/
        // Create a new module (and put it into the cache)

        /******/

        var module = installedModules[moduleId] = {
          /******/
          exports: {},

          /******/
          id: moduleId,

          /******/
          loaded: false
          /******/

        };
        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        // Flag the module as loaded

        /******/

        module.loaded = true;
        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/
      // __webpack_public_path__

      /******/

      __webpack_require__.p = "";
      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(0);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports, __webpack_require__) {
      /*
      Holder.js - client side image placeholders
      (c) 2012-2015 Ivan Malopinsky - http://imsky.co
      */
      module.exports = __webpack_require__(1);
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        /*
        Holder.js - client side image placeholders
        (c) 2012-2016 Ivan Malopinsky - http://imsky.co
        */
        //Libraries and functions
        var onDomReady = __webpack_require__(2);

        var querystring = __webpack_require__(3);

        var SceneGraph = __webpack_require__(6);

        var utils = __webpack_require__(7);

        var SVG = __webpack_require__(8);

        var DOM = __webpack_require__(9);

        var Color = __webpack_require__(10);

        var constants = __webpack_require__(11);

        var svgRenderer = __webpack_require__(12);

        var sgCanvasRenderer = __webpack_require__(15);

        var extend = utils.extend;
        var dimensionCheck = utils.dimensionCheck; //Constants and definitions

        var SVG_NS = constants.svg_ns;
        var Holder = {
          version: constants.version,

          /**
           * Adds a theme to default settings
           *
           * @param {string} name Theme name
           * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.
           */
          addTheme: function addTheme(name, theme) {
            name != null && theme != null && (App.settings.themes[name] = theme);
            delete App.vars.cache.themeKeys;
            return this;
          },

          /**
           * Appends a placeholder to an element
           *
           * @param {string} src Placeholder URL string
           * @param el A selector or a reference to a DOM node
           */
          addImage: function addImage(src, el) {
            //todo: use jquery fallback if available for all QSA references
            var nodes = DOM.getNodeArray(el);
            nodes.forEach(function (node) {
              var img = DOM.newEl('img');
              var domProps = {};
              domProps[App.setup.dataAttr] = src;
              DOM.setAttr(img, domProps);
              node.appendChild(img);
            });
            return this;
          },

          /**
           * Sets whether or not an image is updated on resize.
           * If an image is set to be updated, it is immediately rendered.
           *
           * @param {Object} el Image DOM element
           * @param {Boolean} value Resizable update flag value
           */
          setResizeUpdate: function setResizeUpdate(el, value) {
            if (el.holderData) {
              el.holderData.resizeUpdate = !!value;

              if (el.holderData.resizeUpdate) {
                updateResizableElements(el);
              }
            }
          },

          /**
           * Runs Holder with options. By default runs Holder on all images with "holder.js" in their source attributes.
           *
           * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties
           */
          run: function run(userOptions) {
            //todo: split processing into separate queues
            userOptions = userOptions || {};
            var engineSettings = {};
            var options = extend(App.settings, userOptions);
            App.vars.preempted = true;
            App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;
            engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;

            if (App.setup.renderers.join(',').indexOf(engineSettings.renderer) === -1) {
              engineSettings.renderer = App.setup.supportsSVG ? 'svg' : App.setup.supportsCanvas ? 'canvas' : 'html';
            }

            var images = DOM.getNodeArray(options.images);
            var bgnodes = DOM.getNodeArray(options.bgnodes);
            var stylenodes = DOM.getNodeArray(options.stylenodes);
            var objects = DOM.getNodeArray(options.objects);
            engineSettings.stylesheets = [];
            engineSettings.svgXMLStylesheet = true;
            engineSettings.noFontFallback = !!options.noFontFallback;
            engineSettings.noBackgroundSize = !!options.noBackgroundSize;
            stylenodes.forEach(function (styleNode) {
              if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == 'stylesheet') {
                var href = styleNode.attributes.href.value; //todo: write isomorphic relative-to-absolute URL function

                var proxyLink = DOM.newEl('a');
                proxyLink.href = href;
                var stylesheetURL = proxyLink.protocol + '//' + proxyLink.host + proxyLink.pathname + proxyLink.search;
                engineSettings.stylesheets.push(stylesheetURL);
              }
            });
            bgnodes.forEach(function (bgNode) {
              //Skip processing background nodes if getComputedStyle is unavailable, since only modern browsers would be able to use canvas or SVG to render to background
              if (!global.getComputedStyle) return;
              var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue('background-image');
              var dataBackgroundImage = bgNode.getAttribute('data-background-src');
              var rawURL = dataBackgroundImage || backgroundImage;
              var holderURL = null;
              var holderString = options.domain + '/';
              var holderStringIndex = rawURL.indexOf(holderString);

              if (holderStringIndex === 0) {
                holderURL = rawURL;
              } else if (holderStringIndex === 1 && rawURL[0] === '?') {
                holderURL = rawURL.slice(1);
              } else {
                var fragment = rawURL.substr(holderStringIndex).match(/([^\"]*)"?\)/);

                if (fragment !== null) {
                  holderURL = fragment[1];
                } else if (rawURL.indexOf('url(') === 0) {
                  throw 'Holder: unable to parse background URL: ' + rawURL;
                }
              }

              if (holderURL) {
                var holderFlags = parseURL(holderURL, options);

                if (holderFlags) {
                  prepareDOMElement({
                    mode: 'background',
                    el: bgNode,
                    flags: holderFlags,
                    engineSettings: engineSettings
                  });
                }
              }
            });
            objects.forEach(function (object) {
              var objectAttr = {};

              try {
                objectAttr.data = object.getAttribute('data');
                objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);
              } catch (e) {}

              var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;
              var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;

              if (objectHasSrcURL) {
                prepareImageElement(options, engineSettings, objectAttr.data, object);
              } else if (objectHasDataSrcURL) {
                prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);
              }
            });
            images.forEach(function (image) {
              var imageAttr = {};

              try {
                imageAttr.src = image.getAttribute('src');
                imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);
                imageAttr.rendered = image.getAttribute('data-holder-rendered');
              } catch (e) {}

              var imageHasSrc = imageAttr.src != null;
              var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;
              var imageRendered = imageAttr.rendered != null && imageAttr.rendered == 'true';

              if (imageHasSrc) {
                if (imageAttr.src.indexOf(options.domain) === 0) {
                  prepareImageElement(options, engineSettings, imageAttr.src, image);
                } else if (imageHasDataSrcURL) {
                  //Image has a valid data-src and an invalid src
                  if (imageRendered) {
                    //If the placeholder has already been render, re-render it
                    prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
                  } else {
                    //If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn't
                    (function (src, options, engineSettings, dataSrc, image) {
                      utils.imageExists(src, function (exists) {
                        if (!exists) {
                          prepareImageElement(options, engineSettings, dataSrc, image);
                        }
                      });
                    })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);
                  }
                }
              } else if (imageHasDataSrcURL) {
                prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
              }
            });
            return this;
          }
        };
        var App = {
          settings: {
            domain: 'holder.js',
            images: 'img',
            objects: 'object',
            bgnodes: 'body .holderjs',
            stylenodes: 'head link.holderjs',
            themes: {
              'gray': {
                bg: '#EEEEEE',
                fg: '#AAAAAA'
              },
              'social': {
                bg: '#3a5a97',
                fg: '#FFFFFF'
              },
              'industrial': {
                bg: '#434A52',
                fg: '#C2F200'
              },
              'sky': {
                bg: '#0D8FDB',
                fg: '#FFFFFF'
              },
              'vine': {
                bg: '#39DBAC',
                fg: '#1E292C'
              },
              'lava': {
                bg: '#F8591A',
                fg: '#1C2846'
              }
            }
          },
          defaults: {
            size: 10,
            units: 'pt',
            scale: 1 / 16
          }
        };
        /**
         * Processes provided source attribute and sets up the appropriate rendering workflow
         *
         * @private
         * @param options Instance options from Holder.run
         * @param renderSettings Instance configuration
         * @param src Image URL
         * @param el Image DOM element
         */

        function prepareImageElement(options, engineSettings, src, el) {
          var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);

          if (holderFlags) {
            prepareDOMElement({
              mode: null,
              el: el,
              flags: holderFlags,
              engineSettings: engineSettings
            });
          }
        }
        /**
         * Processes a Holder URL and extracts configuration from query string
         *
         * @private
         * @param url URL
         * @param instanceOptions Instance options from Holder.run
         */


        function parseURL(url, instanceOptions) {
          var holder = {
            theme: extend(App.settings.themes.gray, null),
            stylesheets: instanceOptions.stylesheets,
            instanceOptions: instanceOptions
          };
          var firstQuestionMark = url.indexOf('?');
          var parts = [url];

          if (firstQuestionMark !== -1) {
            parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];
          }

          var basics = parts[0].split('/');
          holder.holderURL = url;
          var dimensions = basics[1];
          var dimensionData = dimensions.match(/([\d]+p?)x([\d]+p?)/);
          if (!dimensionData) return false;
          holder.fluid = dimensions.indexOf('p') !== -1;
          holder.dimensions = {
            width: dimensionData[1].replace('p', '%'),
            height: dimensionData[2].replace('p', '%')
          };

          if (parts.length === 2) {
            var options = querystring.parse(parts[1]); // Dimensions

            if (utils.truthy(options.ratio)) {
              holder.fluid = true;
              var ratioWidth = parseFloat(holder.dimensions.width.replace('%', ''));
              var ratioHeight = parseFloat(holder.dimensions.height.replace('%', ''));
              ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));
              ratioWidth = 100;
              holder.dimensions.width = ratioWidth + '%';
              holder.dimensions.height = ratioHeight + '%';
            }

            holder.auto = utils.truthy(options.auto); // Colors

            if (options.bg) {
              holder.theme.bg = utils.parseColor(options.bg);
            }

            if (options.fg) {
              holder.theme.fg = utils.parseColor(options.fg);
            } //todo: add automatic foreground to themes without foreground


            if (options.bg && !options.fg) {
              holder.autoFg = true;
            }

            if (options.theme && holder.instanceOptions.themes.hasOwnProperty(options.theme)) {
              holder.theme = extend(holder.instanceOptions.themes[options.theme], null);
            } // Text


            if (options.text) {
              holder.text = options.text;
            }

            if (options.textmode) {
              holder.textmode = options.textmode;
            }

            if (options.size && parseFloat(options.size)) {
              holder.size = parseFloat(options.size);
            }

            if (options.font) {
              holder.font = options.font;
            }

            if (options.align) {
              holder.align = options.align;
            }

            if (options.lineWrap) {
              holder.lineWrap = options.lineWrap;
            }

            holder.nowrap = utils.truthy(options.nowrap); // Miscellaneous

            holder.outline = utils.truthy(options.outline);

            if (utils.truthy(options.random)) {
              App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);
              var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];
              holder.theme = extend(holder.instanceOptions.themes[_theme], null);
            }
          }

          return holder;
        }
        /**
         * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)
         *
         * @private
         * @param settings DOM prep settings
         */


        function prepareDOMElement(prepSettings) {
          var mode = prepSettings.mode;
          var el = prepSettings.el;
          var flags = prepSettings.flags;
          var _engineSettings = prepSettings.engineSettings;
          var dimensions = flags.dimensions,
              theme = flags.theme;
          var dimensionsCaption = dimensions.width + 'x' + dimensions.height;
          mode = mode == null ? flags.fluid ? 'fluid' : 'image' : mode;
          var holderTemplateRe = /holder_([a-z]+)/g;
          var dimensionsInText = false;

          if (flags.text != null) {
            theme.text = flags.text; //<object> SVG embedding doesn't parse Unicode properly

            if (el.nodeName.toLowerCase() === 'object') {
              var textLines = theme.text.split('\\n');

              for (var k = 0; k < textLines.length; k++) {
                textLines[k] = utils.encodeHtmlEntity(textLines[k]);
              }

              theme.text = textLines.join('\\n');
            }
          }

          if (theme.text) {
            var holderTemplateMatches = theme.text.match(holderTemplateRe);

            if (holderTemplateMatches !== null) {
              //todo: optimize template replacement
              holderTemplateMatches.forEach(function (match) {
                if (match === 'holder_dimensions') {
                  theme.text = theme.text.replace(match, dimensionsCaption);
                }
              });
            }
          }

          var holderURL = flags.holderURL;
          var engineSettings = extend(_engineSettings, null);

          if (flags.font) {
            /*
            If external fonts are used in a <img> placeholder rendered with SVG, Holder falls back to canvas.
             This is done because Firefox and Chrome disallow embedded SVGs from referencing external assets.
            The workaround is either to change the placeholder tag from <img> to <object> or to use the canvas renderer.
            */
            theme.font = flags.font;

            if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === 'img' && App.setup.supportsCanvas && engineSettings.renderer === 'svg') {
              engineSettings = extend(engineSettings, {
                renderer: 'canvas'
              });
            }
          } //Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas


          if (flags.font && engineSettings.renderer == 'canvas') {
            engineSettings.reRender = true;
          }

          if (mode == 'background') {
            if (el.getAttribute('data-background-src') == null) {
              DOM.setAttr(el, {
                'data-background-src': holderURL
              });
            }
          } else {
            var domProps = {};
            domProps[App.vars.dataAttr] = holderURL;
            DOM.setAttr(el, domProps);
          }

          flags.theme = theme; //todo consider using all renderSettings in holderData

          el.holderData = {
            flags: flags,
            engineSettings: engineSettings
          };

          if (mode == 'image' || mode == 'fluid') {
            DOM.setAttr(el, {
              'alt': theme.text ? dimensionsInText ? theme.text : theme.text + ' [' + dimensionsCaption + ']' : dimensionsCaption
            });
          }

          var renderSettings = {
            mode: mode,
            el: el,
            holderSettings: {
              dimensions: dimensions,
              theme: theme,
              flags: flags
            },
            engineSettings: engineSettings
          };

          if (mode == 'image') {
            if (!flags.auto) {
              el.style.width = dimensions.width + 'px';
              el.style.height = dimensions.height + 'px';
            }

            if (engineSettings.renderer == 'html') {
              el.style.backgroundColor = theme.bg;
            } else {
              render(renderSettings);

              if (flags.textmode == 'exact') {
                el.holderData.resizeUpdate = true;
                App.vars.resizableImages.push(el);
                updateResizableElements(el);
              }
            }
          } else if (mode == 'background' && engineSettings.renderer != 'html') {
            render(renderSettings);
          } else if (mode == 'fluid') {
            el.holderData.resizeUpdate = true;

            if (dimensions.height.slice(-1) == '%') {
              el.style.height = dimensions.height;
            } else if (flags.auto == null || !flags.auto) {
              el.style.height = dimensions.height + 'px';
            }

            if (dimensions.width.slice(-1) == '%') {
              el.style.width = dimensions.width;
            } else if (flags.auto == null || !flags.auto) {
              el.style.width = dimensions.width + 'px';
            }

            if (el.style.display == 'inline' || el.style.display === '' || el.style.display == 'none') {
              el.style.display = 'block';
            }

            setInitialDimensions(el);

            if (engineSettings.renderer == 'html') {
              el.style.backgroundColor = theme.bg;
            } else {
              App.vars.resizableImages.push(el);
              updateResizableElements(el);
            }
          }
        }
        /**
         * Core function that takes output from renderers and sets it as the source or background-image of the target element
         *
         * @private
         * @param renderSettings Renderer settings
         */


        function render(renderSettings) {
          var image = null;
          var mode = renderSettings.mode;
          var el = renderSettings.el;
          var holderSettings = renderSettings.holderSettings;
          var engineSettings = renderSettings.engineSettings;

          switch (engineSettings.renderer) {
            case 'svg':
              if (!App.setup.supportsSVG) return;
              break;

            case 'canvas':
              if (!App.setup.supportsCanvas) return;
              break;

            default:
              return;
          } //todo: move generation of scene up to flag generation to reduce extra object creation


          var scene = {
            width: holderSettings.dimensions.width,
            height: holderSettings.dimensions.height,
            theme: holderSettings.theme,
            flags: holderSettings.flags
          };
          var sceneGraph = buildSceneGraph(scene);

          function getRenderedImage() {
            var image = null;

            switch (engineSettings.renderer) {
              case 'canvas':
                image = sgCanvasRenderer(sceneGraph, renderSettings);
                break;

              case 'svg':
                image = svgRenderer(sceneGraph, renderSettings);
                break;

              default:
                throw 'Holder: invalid renderer: ' + engineSettings.renderer;
            }

            return image;
          }

          image = getRenderedImage();

          if (image == null) {
            throw 'Holder: couldn\'t render placeholder';
          } //todo: add <object> canvas rendering


          if (mode == 'background') {
            el.style.backgroundImage = 'url(' + image + ')';

            if (!engineSettings.noBackgroundSize) {
              el.style.backgroundSize = scene.width + 'px ' + scene.height + 'px';
            }
          } else {
            if (el.nodeName.toLowerCase() === 'img') {
              DOM.setAttr(el, {
                'src': image
              });
            } else if (el.nodeName.toLowerCase() === 'object') {
              DOM.setAttr(el, {
                'data': image,
                'type': 'image/svg+xml'
              });
            }

            if (engineSettings.reRender) {
              global.setTimeout(function () {
                var image = getRenderedImage();

                if (image == null) {
                  throw 'Holder: couldn\'t render placeholder';
                } //todo: refactor this code into a function


                if (el.nodeName.toLowerCase() === 'img') {
                  DOM.setAttr(el, {
                    'src': image
                  });
                } else if (el.nodeName.toLowerCase() === 'object') {
                  DOM.setAttr(el, {
                    'data': image,
                    'type': 'image/svg+xml'
                  });
                }
              }, 150);
            }
          } //todo: account for re-rendering


          DOM.setAttr(el, {
            'data-holder-rendered': true
          });
        }
        /**
         * Core function that takes a Holder scene description and builds a scene graph
         *
         * @private
         * @param scene Holder scene object
         */
        //todo: make this function reusable
        //todo: merge app defaults and setup properties into the scene argument


        function buildSceneGraph(scene) {
          var fontSize = App.defaults.size;

          if (parseFloat(scene.theme.size)) {
            fontSize = scene.theme.size;
          } else if (parseFloat(scene.flags.size)) {
            fontSize = scene.flags.size;
          }

          scene.font = {
            family: scene.theme.font ? scene.theme.font : 'Arial, Helvetica, Open Sans, sans-serif',
            size: textSize(scene.width, scene.height, fontSize, App.defaults.scale),
            units: scene.theme.units ? scene.theme.units : App.defaults.units,
            weight: scene.theme.fontweight ? scene.theme.fontweight : 'bold'
          };
          scene.text = scene.theme.text || Math.floor(scene.width) + 'x' + Math.floor(scene.height);
          scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;
          scene.align = scene.theme.align || scene.flags.align || 'center';

          switch (scene.flags.textmode) {
            case 'literal':
              scene.text = scene.flags.dimensions.width + 'x' + scene.flags.dimensions.height;
              break;

            case 'exact':
              if (!scene.flags.exactDimensions) break;
              scene.text = Math.floor(scene.flags.exactDimensions.width) + 'x' + Math.floor(scene.flags.exactDimensions.height);
              break;
          }

          var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;
          var sceneMargin = scene.width * lineWrap;
          var maxLineWidth = sceneMargin;
          var sceneGraph = new SceneGraph({
            width: scene.width,
            height: scene.height
          });
          var Shape = sceneGraph.Shape;
          var holderBg = new Shape.Rect('holderBg', {
            fill: scene.theme.bg
          });
          holderBg.resize(scene.width, scene.height);
          sceneGraph.root.add(holderBg);

          if (scene.flags.outline) {
            var outlineColor = new Color(holderBg.properties.fill);
            outlineColor = outlineColor.lighten(outlineColor.lighterThan('7f7f7f') ? -0.1 : 0.1);
            holderBg.properties.outline = {
              fill: outlineColor.toHex(true),
              width: 2
            };
          }

          var holderTextColor = scene.theme.fg;

          if (scene.flags.autoFg) {
            var holderBgColor = new Color(holderBg.properties.fill);
            var lightColor = new Color('fff');
            var darkColor = new Color('000', {
              'alpha': 0.285714
            });
            holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan('7f7f7f') ? darkColor : lightColor).toHex(true);
          }

          var holderTextGroup = new Shape.Group('holderTextGroup', {
            text: scene.text,
            align: scene.align,
            font: scene.font,
            fill: holderTextColor
          });
          holderTextGroup.moveTo(null, null, 1);
          sceneGraph.root.add(holderTextGroup);
          var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);

          if (!tpdata) {
            throw 'Holder: staging fallback not supported yet.';
          }

          holderTextGroup.properties.leading = tpdata.boundingBox.height;
          var textNode = null;
          var line = null;

          function finalizeLine(parent, line, width, height) {
            line.width = width;
            line.height = height;
            parent.width = Math.max(parent.width, line.width);
            parent.height += line.height;
          }

          if (tpdata.lineCount > 1) {
            var offsetX = 0;
            var offsetY = 0;
            var lineIndex = 0;
            var lineKey;
            line = new Shape.Group('line' + lineIndex); //Double margin so that left/right-aligned next is not flush with edge of image

            if (scene.align === 'left' || scene.align === 'right') {
              maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);
            }

            for (var i = 0; i < tpdata.words.length; i++) {
              var word = tpdata.words[i];
              textNode = new Shape.Text(word.text);
              var newline = word.text == '\\n';

              if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {
                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                holderTextGroup.add(line);
                offsetX = 0;
                offsetY += holderTextGroup.properties.leading;
                lineIndex += 1;
                line = new Shape.Group('line' + lineIndex);
                line.y = offsetY;
              }

              if (newline === true) {
                continue;
              }

              textNode.moveTo(offsetX, 0);
              offsetX += tpdata.spaceWidth + word.width;
              line.add(textNode);
            }

            finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
            holderTextGroup.add(line);

            if (scene.align === 'left') {
              holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
            } else if (scene.align === 'right') {
              for (lineKey in holderTextGroup.children) {
                line = holderTextGroup.children[lineKey];
                line.moveTo(scene.width - line.width, null, null);
              }

              holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
            } else {
              for (lineKey in holderTextGroup.children) {
                line = holderTextGroup.children[lineKey];
                line.moveTo((holderTextGroup.width - line.width) / 2, null, null);
              }

              holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);
            }

            holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null); //If the text exceeds vertical space, move it down so the first line is visible

            if ((scene.height - holderTextGroup.height) / 2 < 0) {
              holderTextGroup.moveTo(null, 0, null);
            }
          } else {
            textNode = new Shape.Text(scene.text);
            line = new Shape.Group('line0');
            line.add(textNode);
            holderTextGroup.add(line);

            if (scene.align === 'left') {
              holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
            } else if (scene.align === 'right') {
              holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
            } else {
              holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);
            }

            holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);
          } //todo: renderlist


          return sceneGraph;
        }
        /**
         * Adaptive text sizing function
         *
         * @private
         * @param width Parent width
         * @param height Parent height
         * @param fontSize Requested text size
         * @param scale Proportional scale of text
         */


        function textSize(width, height, fontSize, scale) {
          var stageWidth = parseInt(width, 10);
          var stageHeight = parseInt(height, 10);
          var bigSide = Math.max(stageWidth, stageHeight);
          var smallSide = Math.min(stageWidth, stageHeight);
          var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);
          return Math.round(Math.max(fontSize, newHeight));
        }
        /**
         * Iterates over resizable (fluid or auto) placeholders and renders them
         *
         * @private
         * @param element Optional element selector, specified only if a specific element needs to be re-rendered
         */


        function updateResizableElements(element) {
          var images;

          if (element == null || element.nodeType == null) {
            images = App.vars.resizableImages;
          } else {
            images = [element];
          }

          for (var i = 0, l = images.length; i < l; i++) {
            var el = images[i];

            if (el.holderData) {
              var flags = el.holderData.flags;
              var dimensions = dimensionCheck(el);

              if (dimensions) {
                if (!el.holderData.resizeUpdate) {
                  continue;
                }

                if (flags.fluid && flags.auto) {
                  var fluidConfig = el.holderData.fluidConfig;

                  switch (fluidConfig.mode) {
                    case 'width':
                      dimensions.height = dimensions.width / fluidConfig.ratio;
                      break;

                    case 'height':
                      dimensions.width = dimensions.height * fluidConfig.ratio;
                      break;
                  }
                }

                var settings = {
                  mode: 'image',
                  holderSettings: {
                    dimensions: dimensions,
                    theme: flags.theme,
                    flags: flags
                  },
                  el: el,
                  engineSettings: el.holderData.engineSettings
                };

                if (flags.textmode == 'exact') {
                  flags.exactDimensions = dimensions;
                  settings.holderSettings.dimensions = flags.dimensions;
                }

                render(settings);
              } else {
                setInvisible(el);
              }
            }
          }
        }
        /**
         * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing
         *
         * @private
         * @param el Image DOM element
         */


        function setInitialDimensions(el) {
          if (el.holderData) {
            var dimensions = dimensionCheck(el);

            if (dimensions) {
              var flags = el.holderData.flags;
              var fluidConfig = {
                fluidHeight: flags.dimensions.height.slice(-1) == '%',
                fluidWidth: flags.dimensions.width.slice(-1) == '%',
                mode: null,
                initialDimensions: dimensions
              };

              if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {
                fluidConfig.mode = 'width';
                fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);
              } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {
                fluidConfig.mode = 'height';
                fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;
              }

              el.holderData.fluidConfig = fluidConfig;
            } else {
              setInvisible(el);
            }
          }
        }
        /**
         * Iterates through all current invisible images, and if they're visible, renders them and removes them from further checks. Runs every animation frame.
         *
         * @private
         */


        function visibilityCheck() {
          var renderableImages = [];
          var keys = Object.keys(App.vars.invisibleImages);
          var el;
          keys.forEach(function (key) {
            el = App.vars.invisibleImages[key];

            if (dimensionCheck(el) && el.nodeName.toLowerCase() == 'img') {
              renderableImages.push(el);
              delete App.vars.invisibleImages[key];
            }
          });

          if (renderableImages.length) {
            Holder.run({
              images: renderableImages
            });
          } // Done to prevent 100% CPU usage via aggressive calling of requestAnimationFrame


          setTimeout(function () {
            global.requestAnimationFrame(visibilityCheck);
          }, 10);
        }
        /**
         * Starts checking for invisible placeholders if not doing so yet. Does nothing otherwise.
         *
         * @private
         */


        function startVisibilityCheck() {
          if (!App.vars.visibilityCheckStarted) {
            global.requestAnimationFrame(visibilityCheck);
            App.vars.visibilityCheckStarted = true;
          }
        }
        /**
         * Sets a unique ID for an image detected to be invisible and adds it to the map of invisible images checked by visibilityCheck
         *
         * @private
         * @param el Invisible DOM element
         */


        function setInvisible(el) {
          if (!el.holderData.invisibleId) {
            App.vars.invisibleId += 1;
            App.vars.invisibleImages['i' + App.vars.invisibleId] = el;
            el.holderData.invisibleId = App.vars.invisibleId;
          }
        } //todo: see if possible to convert stagingRenderer to use HTML only


        var stagingRenderer = function () {
          var svg = null,
              stagingText = null,
              stagingTextNode = null;
          return function (graph) {
            var rootNode = graph.root;

            if (App.setup.supportsSVG) {
              var firstTimeSetup = false;

              var tnode = function tnode(text) {
                return document.createTextNode(text);
              };

              if (svg == null || svg.parentNode !== document.body) {
                firstTimeSetup = true;
              }

              svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height); //Show staging element before staging

              svg.style.display = 'block';

              if (firstTimeSetup) {
                stagingText = DOM.newEl('text', SVG_NS);
                stagingTextNode = tnode(null);
                DOM.setAttr(stagingText, {
                  x: 0
                });
                stagingText.appendChild(stagingTextNode);
                svg.appendChild(stagingText);
                document.body.appendChild(svg);
                svg.style.visibility = 'hidden';
                svg.style.position = 'absolute';
                svg.style.top = '-100%';
                svg.style.left = '-100%'; //todo: workaround for zero-dimension <svg> tag in Opera 12
                //svg.setAttribute('width', 0);
                //svg.setAttribute('height', 0);
              }

              var holderTextGroup = rootNode.children.holderTextGroup;
              var htgProps = holderTextGroup.properties;
              DOM.setAttr(stagingText, {
                'y': htgProps.font.size,
                'style': utils.cssProps({
                  'font-weight': htgProps.font.weight,
                  'font-size': htgProps.font.size + htgProps.font.units,
                  'font-family': htgProps.font.family
                })
              }); //Unescape HTML entities to get approximately the right width

              var txt = DOM.newEl('textarea');
              txt.innerHTML = htgProps.text;
              stagingTextNode.nodeValue = txt.value; //Get bounding box for the whole string (total width and height)

              var stagingTextBBox = stagingText.getBBox(); //Get line count and split the string into words

              var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);
              var words = htgProps.text.split(' ');
              var newlines = htgProps.text.match(/\\n/g);
              lineCount += newlines == null ? 0 : newlines.length; //Get bounding box for the string with spaces removed

              stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, '');
              var computedNoSpaceLength = stagingText.getComputedTextLength(); //Compute average space width

              var diffLength = stagingTextBBox.width - computedNoSpaceLength;
              var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1)); //Get widths for every word with space only if there is more than one line

              var wordWidths = [];

              if (lineCount > 1) {
                stagingTextNode.nodeValue = '';

                for (var i = 0; i < words.length; i++) {
                  if (words[i].length === 0) continue;
                  stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);
                  var bbox = stagingText.getBBox();
                  wordWidths.push({
                    text: words[i],
                    width: bbox.width
                  });
                }
              } //Hide staging element after staging


              svg.style.display = 'none';
              return {
                spaceWidth: spaceWidth,
                lineCount: lineCount,
                boundingBox: stagingTextBBox,
                words: wordWidths
              };
            } else {
              //todo: canvas fallback for measuring text on android 2.3
              return false;
            }
          };
        }(); //Helpers

        /**
         * Prevents a function from being called too often, waits until a timer elapses to call it again
         *
         * @param fn Function to call
         */


        function debounce(fn) {
          if (!App.vars.debounceTimer) fn.call(this);
          if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);
          App.vars.debounceTimer = global.setTimeout(function () {
            App.vars.debounceTimer = null;
            fn.call(this);
          }, App.setup.debounce);
        }
        /**
         * Holder-specific resize/orientation change callback, debounced to prevent excessive execution
         */


        function resizeEvent() {
          debounce(function () {
            updateResizableElements(null);
          });
        } //Set up flags


        for (var flag in App.flags) {
          if (!App.flags.hasOwnProperty(flag)) continue;

          App.flags[flag].match = function (val) {
            return val.match(this.regex);
          };
        } //Properties set once on setup


        App.setup = {
          renderer: 'html',
          debounce: 100,
          ratio: 1,
          supportsCanvas: false,
          supportsSVG: false,
          lineWrapRatio: 0.9,
          dataAttr: 'data-src',
          renderers: ['html', 'canvas', 'svg']
        }; //Properties modified during runtime

        App.vars = {
          preempted: false,
          resizableImages: [],
          invisibleImages: {},
          invisibleId: 0,
          visibilityCheckStarted: false,
          debounceTimer: null,
          cache: {}
        }; //Pre-flight

        (function () {
          var canvas = DOM.newEl('canvas');

          if (canvas.getContext) {
            if (canvas.toDataURL('image/png').indexOf('data:image/png') != -1) {
              App.setup.renderer = 'canvas';
              App.setup.supportsCanvas = true;
            }
          }

          if (!!document.createElementNS && !!document.createElementNS(SVG_NS, 'svg').createSVGRect) {
            App.setup.renderer = 'svg';
            App.setup.supportsSVG = true;
          }
        })(); //Starts checking for invisible placeholders


        startVisibilityCheck();

        if (onDomReady) {
          onDomReady(function () {
            if (!App.vars.preempted) {
              Holder.run();
            }

            if (global.addEventListener) {
              global.addEventListener('resize', resizeEvent, false);
              global.addEventListener('orientationchange', resizeEvent, false);
            } else {
              global.attachEvent('onresize', resizeEvent);
            }

            if (_typeof(global.Turbolinks) == 'object') {
              global.document.addEventListener('page:change', function () {
                Holder.run();
              });
            }
          });
        }

        module.exports = Holder;
        /* WEBPACK VAR INJECTION */
      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 2 */

    /***/
    function (module, exports) {
      /*!
       * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license
       *
       * Specially modified to work with Holder.js
       */
      function _onDomReady(win) {
        //Lazy loading fix for Firefox < 3.6
        //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
        if (document.readyState == null && document.addEventListener) {
          document.addEventListener("DOMContentLoaded", function DOMContentLoaded() {
            document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
            document.readyState = "complete";
          }, false);
          document.readyState = "loading";
        }

        var doc = win.document,
            docElem = doc.documentElement,
            LOAD = "load",
            FALSE = false,
            ONLOAD = "on" + LOAD,
            COMPLETE = "complete",
            READYSTATE = "readyState",
            ATTACHEVENT = "attachEvent",
            DETACHEVENT = "detachEvent",
            ADDEVENTLISTENER = "addEventListener",
            DOMCONTENTLOADED = "DOMContentLoaded",
            ONREADYSTATECHANGE = "onreadystatechange",
            REMOVEEVENTLISTENER = "removeEventListener",
            // W3C Event model
        w3c = ADDEVENTLISTENER in doc,
            _top = FALSE,
            // isReady: Is the DOM ready to be used? Set to true once it occurs.
        isReady = FALSE,
            // Callbacks pending execution until DOM is ready
        callbacks = []; // Handle when the DOM is ready

        function ready(fn) {
          if (!isReady) {
            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!doc.body) {
              return defer(ready);
            } // Remember that the DOM is ready


            isReady = true; // Execute all callbacks

            while (fn = callbacks.shift()) {
              defer(fn);
            }
          }
        } // The ready event handler


        function completed(event) {
          // readyState === "complete" is good enough for us to call the dom ready in oldIE
          if (w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE) {
            detach();
            ready();
          }
        } // Clean-up method for dom ready events


        function detach() {
          if (w3c) {
            doc[REMOVEEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
            win[REMOVEEVENTLISTENER](LOAD, completed, FALSE);
          } else {
            doc[DETACHEVENT](ONREADYSTATECHANGE, completed);
            win[DETACHEVENT](ONLOAD, completed);
          }
        } // Defers a function, scheduling it to run after the current call stack has cleared.


        function defer(fn, wait) {
          // Allow 0 to be passed
          setTimeout(fn, +wait >= 0 ? wait : 1);
        } // Attach the listeners:
        // Catch cases where onDomReady is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15


        if (doc[READYSTATE] === COMPLETE) {
          // Handle it asynchronously to allow scripts the opportunity to delay ready
          defer(ready); // Standards-based browsers support DOMContentLoaded
        } else if (w3c) {
          // Use the handy event callback
          doc[ADDEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE); // A fallback to window.onload, that will always work

          win[ADDEVENTLISTENER](LOAD, completed, FALSE); // If IE event model is used
        } else {
          // Ensure firing before onload, maybe late but safe also for iframes
          doc[ATTACHEVENT](ONREADYSTATECHANGE, completed); // A fallback to window.onload, that will always work

          win[ATTACHEVENT](ONLOAD, completed); // If IE and not a frame
          // continually check to see if the document is ready

          try {
            _top = win.frameElement == null && docElem;
          } catch (e) {}

          if (_top && _top.doScroll) {
            (function doScrollCheck() {
              if (!isReady) {
                try {
                  // Use the trick by Diego Perini
                  // http://javascript.nwbox.com/IEContentLoaded/
                  _top.doScroll("left");
                } catch (e) {
                  return defer(doScrollCheck, 50);
                } // detach all dom ready events


                detach(); // and execute any waiting functions

                ready();
              }
            })();
          }
        }

        function onDomReady(fn) {
          // If DOM is ready, execute the function (async), otherwise wait
          isReady ? defer(fn) : callbacks.push(fn);
        } // Add version


        onDomReady.version = "1.4.0"; // Add method to check if DOM is ready

        onDomReady.isReady = function () {
          return isReady;
        };

        return onDomReady;
      }

      module.exports = typeof window !== "undefined" && _onDomReady(window);
      /***/
    },
    /* 3 */

    /***/
    function (module, exports, __webpack_require__) {
      //Modified version of component/querystring
      //Changes: updated dependencies, dot notation parsing, JSHint fixes
      //Fork at https://github.com/imsky/querystring

      /**
       * Module dependencies.
       */
      var encode = encodeURIComponent;
      var decode = decodeURIComponent;

      var trim = __webpack_require__(4);

      var type = __webpack_require__(5);

      var arrayRegex = /(\w+)\[(\d+)\]/;
      var objectRegex = /\w+\.\w+/;
      /**
       * Parse the given query `str`.
       *
       * @param {String} str
       * @return {Object}
       * @api public
       */

      exports.parse = function (str) {
        if ('string' !== typeof str) return {};
        str = trim(str);
        if ('' === str) return {};
        if ('?' === str.charAt(0)) str = str.slice(1);
        var obj = {};
        var pairs = str.split('&');

        for (var i = 0; i < pairs.length; i++) {
          var parts = pairs[i].split('=');
          var key = decode(parts[0]);
          var m, ctx, prop;

          if (m = arrayRegex.exec(key)) {
            obj[m[1]] = obj[m[1]] || [];
            obj[m[1]][m[2]] = decode(parts[1]);
            continue;
          }

          if (m = objectRegex.test(key)) {
            m = key.split('.');
            ctx = obj;

            while (m.length) {
              prop = m.shift();
              if (!prop.length) continue;

              if (!ctx[prop]) {
                ctx[prop] = {};
              } else if (ctx[prop] && _typeof(ctx[prop]) !== 'object') {
                break;
              }

              if (!m.length) {
                ctx[prop] = decode(parts[1]);
              }

              ctx = ctx[prop];
            }

            continue;
          }

          obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);
        }

        return obj;
      };
      /**
       * Stringify the given `obj`.
       *
       * @param {Object} obj
       * @return {String}
       * @api public
       */


      exports.stringify = function (obj) {
        if (!obj) return '';
        var pairs = [];

        for (var key in obj) {
          var value = obj[key];

          if ('array' == type(value)) {
            for (var i = 0; i < value.length; ++i) {
              pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));
            }

            continue;
          }

          pairs.push(encode(key) + '=' + encode(obj[key]));
        }

        return pairs.join('&');
      };
      /***/

    },
    /* 4 */

    /***/
    function (module, exports) {
      exports = module.exports = trim;

      function trim(str) {
        return str.replace(/^\s*|\s*$/g, '');
      }

      exports.left = function (str) {
        return str.replace(/^\s*/, '');
      };

      exports.right = function (str) {
        return str.replace(/\s*$/, '');
      };
      /***/

    },
    /* 5 */

    /***/
    function (module, exports) {
      /**
       * toString ref.
       */
      var toString = Object.prototype.toString;
      /**
       * Return the type of `val`.
       *
       * @param {Mixed} val
       * @return {String}
       * @api public
       */

      module.exports = function (val) {
        switch (toString.call(val)) {
          case '[object Date]':
            return 'date';

          case '[object RegExp]':
            return 'regexp';

          case '[object Arguments]':
            return 'arguments';

          case '[object Array]':
            return 'array';

          case '[object Error]':
            return 'error';
        }

        if (val === null) return 'null';
        if (val === undefined) return 'undefined';
        if (val !== val) return 'nan';
        if (val && val.nodeType === 1) return 'element';
        if (isBuffer(val)) return 'buffer';
        val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);
        return _typeof(val);
      }; // code borrowed from https://github.com/feross/is-buffer/blob/master/index.js


      function isBuffer(obj) {
        return !!(obj != null && (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
        obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)));
      }
      /***/

    },
    /* 6 */

    /***/
    function (module, exports) {
      var SceneGraph = function SceneGraph(sceneProperties) {
        var nodeCount = 1; //todo: move merge to helpers section

        function merge(parent, child) {
          for (var prop in child) {
            parent[prop] = child[prop];
          }

          return parent;
        }

        var SceneNode = function SceneNode(name) {
          nodeCount++;
          this.parent = null;
          this.children = {};
          this.id = nodeCount;
          this.name = 'n' + nodeCount;

          if (typeof name !== 'undefined') {
            this.name = name;
          }

          this.x = this.y = this.z = 0;
          this.width = this.height = 0;
        };

        SceneNode.prototype.resize = function (width, height) {
          if (width != null) {
            this.width = width;
          }

          if (height != null) {
            this.height = height;
          }
        };

        SceneNode.prototype.moveTo = function (x, y, z) {
          this.x = x != null ? x : this.x;
          this.y = y != null ? y : this.y;
          this.z = z != null ? z : this.z;
        };

        SceneNode.prototype.add = function (child) {
          var name = child.name;

          if (typeof this.children[name] === 'undefined') {
            this.children[name] = child;
            child.parent = this;
          } else {
            throw 'SceneGraph: child already exists: ' + name;
          }
        };

        var RootNode = function RootNode() {
          SceneNode.call(this, 'root');
          this.properties = sceneProperties;
        };

        RootNode.prototype = new SceneNode();

        var Shape = function Shape(name, props) {
          SceneNode.call(this, name);
          this.properties = {
            'fill': '#000000'
          };

          if (typeof props !== 'undefined') {
            merge(this.properties, props);
          } else if (typeof name !== 'undefined' && typeof name !== 'string') {
            throw 'SceneGraph: invalid node name';
          }
        };

        Shape.prototype = new SceneNode();

        var Group = function Group() {
          Shape.apply(this, arguments);
          this.type = 'group';
        };

        Group.prototype = new Shape();

        var Rect = function Rect() {
          Shape.apply(this, arguments);
          this.type = 'rect';
        };

        Rect.prototype = new Shape();

        var Text = function Text(text) {
          Shape.call(this);
          this.type = 'text';
          this.properties.text = text;
        };

        Text.prototype = new Shape();
        var root = new RootNode();
        this.Shape = {
          'Rect': Rect,
          'Text': Text,
          'Group': Group
        };
        this.root = root;
        return this;
      };

      module.exports = SceneGraph;
      /***/
    },
    /* 7 */

    /***/
    function (module, exports) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        /**
        * Shallow object clone and merge
        *
        * @param a Object A
        * @param b Object B
        * @returns {Object} New object with all of A's properties, and all of B's properties, overwriting A's properties
        */
        exports.extend = function (a, b) {
          var c = {};

          for (var x in a) {
            if (a.hasOwnProperty(x)) {
              c[x] = a[x];
            }
          }

          if (b != null) {
            for (var y in b) {
              if (b.hasOwnProperty(y)) {
                c[y] = b[y];
              }
            }
          }

          return c;
        };
        /**
         * Takes a k/v list of CSS properties and returns a rule
         *
         * @param props CSS properties object
         */


        exports.cssProps = function (props) {
          var ret = [];

          for (var p in props) {
            if (props.hasOwnProperty(p)) {
              ret.push(p + ':' + props[p]);
            }
          }

          return ret.join(';');
        };
        /**
         * Encodes HTML entities in a string
         *
         * @param str Input string
         */


        exports.encodeHtmlEntity = function (str) {
          var buf = [];
          var charCode = 0;

          for (var i = str.length - 1; i >= 0; i--) {
            charCode = str.charCodeAt(i);

            if (charCode > 128) {
              buf.unshift(['&#', charCode, ';'].join(''));
            } else {
              buf.unshift(str[i]);
            }
          }

          return buf.join('');
        };
        /**
         * Checks if an image exists
         *
         * @param src URL of image
         * @param callback Callback to call once image status has been found
         */


        exports.imageExists = function (src, callback) {
          var image = new Image();

          image.onerror = function () {
            callback.call(this, false);
          };

          image.onload = function () {
            callback.call(this, true);
          };

          image.src = src;
        };
        /**
         * Decodes HTML entities in a string
         *
         * @param str Input string
         */


        exports.decodeHtmlEntity = function (str) {
          return str.replace(/&#(\d+);/g, function (match, dec) {
            return String.fromCharCode(dec);
          });
        };
        /**
         * Returns an element's dimensions if it's visible, `false` otherwise.
         *
         * @param el DOM element
         */


        exports.dimensionCheck = function (el) {
          var dimensions = {
            height: el.clientHeight,
            width: el.clientWidth
          };

          if (dimensions.height && dimensions.width) {
            return dimensions;
          } else {
            return false;
          }
        };
        /**
         * Returns true if value is truthy or if it is "semantically truthy"
         * @param val
         */


        exports.truthy = function (val) {
          if (typeof val === 'string') {
            return val === 'true' || val === 'yes' || val === '1' || val === 'on' || val === '✓';
          }

          return !!val;
        };
        /**
         * Parses input into a well-formed CSS color
         * @param val
         */


        exports.parseColor = function (val) {
          var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;
          var rgbre = /^rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
          var rgbare = /^rgba\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0\.\d{1,}|1)\)$/;
          var match = val.match(hexre);
          var retval;

          if (match !== null) {
            retval = match[1] || match[2];

            if (retval[0] !== '#') {
              return '#' + retval;
            } else {
              return retval;
            }
          }

          match = val.match(rgbre);

          if (match !== null) {
            retval = 'rgb(' + match.slice(1).join(',') + ')';
            return retval;
          }

          match = val.match(rgbare);

          if (match !== null) {
            retval = 'rgba(' + match.slice(1).join(',') + ')';
            return retval;
          }

          return null;
        };
        /**
         * Provides the correct scaling ratio for canvas drawing operations on HiDPI screens (e.g. Retina displays)
         */


        exports.canvasRatio = function () {
          var devicePixelRatio = 1;
          var backingStoreRatio = 1;

          if (global.document) {
            var canvas = global.document.createElement('canvas');

            if (canvas.getContext) {
              var ctx = canvas.getContext('2d');
              devicePixelRatio = global.devicePixelRatio || 1;
              backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
            }
          }

          return devicePixelRatio / backingStoreRatio;
        };
        /* WEBPACK VAR INJECTION */

      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 8 */

    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        var DOM = __webpack_require__(9);

        var SVG_NS = 'http://www.w3.org/2000/svg';
        var NODE_TYPE_COMMENT = 8;
        /**
         * Generic SVG element creation function
         *
         * @param svg SVG context, set to null if new
         * @param width Document width
         * @param height Document height
         */

        exports.initSVG = function (svg, width, height) {
          var defs,
              style,
              initialize = false;

          if (svg && svg.querySelector) {
            style = svg.querySelector('style');

            if (style === null) {
              initialize = true;
            }
          } else {
            svg = DOM.newEl('svg', SVG_NS);
            initialize = true;
          }

          if (initialize) {
            defs = DOM.newEl('defs', SVG_NS);
            style = DOM.newEl('style', SVG_NS);
            DOM.setAttr(style, {
              'type': 'text/css'
            });
            defs.appendChild(style);
            svg.appendChild(defs);
          } //IE throws an exception if this is set and Chrome requires it to be set


          if (svg.webkitMatchesSelector) {
            svg.setAttribute('xmlns', SVG_NS);
          } //Remove comment nodes


          for (var i = 0; i < svg.childNodes.length; i++) {
            if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {
              svg.removeChild(svg.childNodes[i]);
            }
          } //Remove CSS


          while (style.childNodes.length) {
            style.removeChild(style.childNodes[0]);
          }

          DOM.setAttr(svg, {
            'width': width,
            'height': height,
            'viewBox': '0 0 ' + width + ' ' + height,
            'preserveAspectRatio': 'none'
          });
          return svg;
        };
        /**
         * Converts serialized SVG to a string suitable for data URI use
         * @param svgString Serialized SVG string
         * @param [base64] Use base64 encoding for data URI
         */


        exports.svgStringToDataURI = function () {
          var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';
          var base64Prefix = 'data:image/svg+xml;charset=UTF-8;base64,';
          return function (svgString, base64) {
            if (base64) {
              return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));
            } else {
              return rawPrefix + encodeURIComponent(svgString);
            }
          };
        }();
        /**
         * Returns serialized SVG with XML processing instructions
         *
         * @param svg SVG context
         * @param stylesheets CSS stylesheets to include
         */


        exports.serializeSVG = function (svg, engineSettings) {
          if (!global.XMLSerializer) return;
          var serializer = new XMLSerializer();
          var svgCSS = '';
          var stylesheets = engineSettings.stylesheets; //External stylesheets: Processing Instruction method

          if (engineSettings.svgXMLStylesheet) {
            var xml = DOM.createXML(); //Add <?xml-stylesheet ?> directives

            for (var i = stylesheets.length - 1; i >= 0; i--) {
              var csspi = xml.createProcessingInstruction('xml-stylesheet', 'href="' + stylesheets[i] + '" rel="stylesheet"');
              xml.insertBefore(csspi, xml.firstChild);
            }

            xml.removeChild(xml.documentElement);
            svgCSS = serializer.serializeToString(xml);
          }

          var svgText = serializer.serializeToString(svg);
          svgText = svgText.replace(/\&amp;(\#[0-9]{2,}\;)/g, '&$1');
          return svgCSS + svgText;
        };
        /* WEBPACK VAR INJECTION */

      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 9 */

    /***/
    function (module, exports) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        /**
        * Generic new DOM element function
        *
        * @param tag Tag to create
        * @param namespace Optional namespace value
        */
        exports.newEl = function (tag, namespace) {
          if (!global.document) return;

          if (namespace == null) {
            return global.document.createElement(tag);
          } else {
            return global.document.createElementNS(namespace, tag);
          }
        };
        /**
         * Generic setAttribute function
         *
         * @param el Reference to DOM element
         * @param attrs Object with attribute keys and values
         */


        exports.setAttr = function (el, attrs) {
          for (var a in attrs) {
            el.setAttribute(a, attrs[a]);
          }
        };
        /**
         * Creates a XML document
         * @private
         */


        exports.createXML = function () {
          if (!global.DOMParser) return;
          return new DOMParser().parseFromString('<xml />', 'application/xml');
        };
        /**
         * Converts a value into an array of DOM nodes
         *
         * @param val A string, a NodeList, a Node, or an HTMLCollection
         */


        exports.getNodeArray = function (val) {
          var retval = null;

          if (typeof val == 'string') {
            retval = document.querySelectorAll(val);
          } else if (global.NodeList && val instanceof global.NodeList) {
            retval = val;
          } else if (global.Node && val instanceof global.Node) {
            retval = [val];
          } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {
            retval = val;
          } else if (val instanceof Array) {
            retval = val;
          } else if (val === null) {
            retval = [];
          }

          retval = Array.prototype.slice.call(retval);
          return retval;
        };
        /* WEBPACK VAR INJECTION */

      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 10 */

    /***/
    function (module, exports) {
      var Color = function Color(color, options) {
        //todo: support rgba, hsla, and rrggbbaa notation
        //todo: use CIELAB internally
        //todo: add clamp function (with sign)
        if (typeof color !== 'string') return;
        this.original = color;

        if (color.charAt(0) === '#') {
          color = color.slice(1);
        }

        if (/[^a-f0-9]+/i.test(color)) return;

        if (color.length === 3) {
          color = color.replace(/./g, '$&$&');
        }

        if (color.length !== 6) return;
        this.alpha = 1;

        if (options && options.alpha) {
          this.alpha = options.alpha;
        }

        this.set(parseInt(color, 16));
      }; //todo: jsdocs


      Color.rgb2hex = function (r, g, b) {
        function format(decimal) {
          var hex = (decimal | 0).toString(16);

          if (decimal < 16) {
            hex = '0' + hex;
          }

          return hex;
        }

        return [r, g, b].map(format).join('');
      }; //todo: jsdocs


      Color.hsl2rgb = function (h, s, l) {
        var H = h / 60;
        var C = (1 - Math.abs(2 * l - 1)) * s;
        var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));
        var m = l - C / 2;
        var r = 0,
            g = 0,
            b = 0;

        if (H >= 0 && H < 1) {
          r = C;
          g = X;
        } else if (H >= 1 && H < 2) {
          r = X;
          g = C;
        } else if (H >= 2 && H < 3) {
          g = C;
          b = X;
        } else if (H >= 3 && H < 4) {
          g = X;
          b = C;
        } else if (H >= 4 && H < 5) {
          r = X;
          b = C;
        } else if (H >= 5 && H < 6) {
          r = C;
          b = X;
        }

        r += m;
        g += m;
        b += m;
        r = parseInt(r * 255);
        g = parseInt(g * 255);
        b = parseInt(b * 255);
        return [r, g, b];
      };
      /**
       * Sets the color from a raw RGB888 integer
       * @param raw RGB888 representation of color
       */
      //todo: refactor into a static method
      //todo: factor out individual color spaces
      //todo: add HSL, CIELAB, and CIELUV


      Color.prototype.set = function (val) {
        this.raw = val;
        var r = (this.raw & 0xFF0000) >> 16;
        var g = (this.raw & 0x00FF00) >> 8;
        var b = this.raw & 0x0000FF; // BT.709

        var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        var u = -0.09991 * r - 0.33609 * g + 0.436 * b;
        var v = 0.615 * r - 0.55861 * g - 0.05639 * b;
        this.rgb = {
          r: r,
          g: g,
          b: b
        };
        this.yuv = {
          y: y,
          u: u,
          v: v
        };
        return this;
      };
      /**
       * Lighten or darken a color
       * @param multiplier Amount to lighten or darken (-1 to 1)
       */


      Color.prototype.lighten = function (multiplier) {
        var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);
        var bm = 255 * cm | 0;
        var cr = Math.min(255, Math.max(0, this.rgb.r + bm));
        var cg = Math.min(255, Math.max(0, this.rgb.g + bm));
        var cb = Math.min(255, Math.max(0, this.rgb.b + bm));
        var hex = Color.rgb2hex(cr, cg, cb);
        return new Color(hex);
      };
      /**
       * Output color in hex format
       * @param addHash Add a hash character to the beginning of the output
       */


      Color.prototype.toHex = function (addHash) {
        return (addHash ? '#' : '') + this.raw.toString(16);
      };
      /**
       * Returns whether or not current color is lighter than another color
       * @param color Color to compare against
       */


      Color.prototype.lighterThan = function (color) {
        if (!(color instanceof Color)) {
          color = new Color(color);
        }

        return this.yuv.y > color.yuv.y;
      };
      /**
       * Returns the result of mixing current color with another color
       * @param color Color to mix with
       * @param multiplier How much to mix with the other color
       */

      /*
      Color.prototype.mix = function (color, multiplier) {
          if (!(color instanceof Color)) {
              color = new Color(color);
          }
           var r = this.rgb.r;
          var g = this.rgb.g;
          var b = this.rgb.b;
          var a = this.alpha;
           var m = typeof multiplier !== 'undefined' ? multiplier : 0.5;
           //todo: write a lerp function
          r = r + m * (color.rgb.r - r);
          g = g + m * (color.rgb.g - g);
          b = b + m * (color.rgb.b - b);
          a = a + m * (color.alpha - a);
           return new Color(Color.rgbToHex(r, g, b), {
              'alpha': a
          });
      };
      */

      /**
       * Returns the result of blending another color on top of current color with alpha
       * @param color Color to blend on top of current color, i.e. "Ca"
       */
      //todo: see if .blendAlpha can be merged into .mix


      Color.prototype.blendAlpha = function (color) {
        if (!(color instanceof Color)) {
          color = new Color(color);
        }

        var Ca = color;
        var Cb = this; //todo: write alpha blending function

        var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;
        var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;
        var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;
        return new Color(Color.rgb2hex(r, g, b));
      };

      module.exports = Color;
      /***/
    },
    /* 11 */

    /***/
    function (module, exports) {
      module.exports = {
        'version': '2.9.6',
        'svg_ns': 'http://www.w3.org/2000/svg'
      };
      /***/
    },
    /* 12 */

    /***/
    function (module, exports, __webpack_require__) {
      var shaven = __webpack_require__(13);

      var SVG = __webpack_require__(8);

      var constants = __webpack_require__(11);

      var utils = __webpack_require__(7);

      var SVG_NS = constants.svg_ns;
      var templates = {
        'element': function element(options) {
          var tag = options.tag;
          var content = options.content || '';
          delete options.tag;
          delete options.content;
          return [tag, content, options];
        }
      }; //todo: deprecate tag arg, infer tag from shape object

      function convertShape(shape, tag) {
        return templates.element({
          'tag': tag,
          'width': shape.width,
          'height': shape.height,
          'fill': shape.properties.fill
        });
      }

      function textCss(properties) {
        return utils.cssProps({
          'fill': properties.fill,
          'font-weight': properties.font.weight,
          'font-family': properties.font.family + ', monospace',
          'font-size': properties.font.size + properties.font.units
        });
      }

      function outlinePath(bgWidth, bgHeight, outlineWidth) {
        var outlineOffsetWidth = outlineWidth / 2;
        return ['M', outlineOffsetWidth, outlineOffsetWidth, 'H', bgWidth - outlineOffsetWidth, 'V', bgHeight - outlineOffsetWidth, 'H', outlineOffsetWidth, 'V', 0, 'M', 0, outlineOffsetWidth, 'L', bgWidth, bgHeight - outlineOffsetWidth, 'M', 0, bgHeight - outlineOffsetWidth, 'L', bgWidth, outlineOffsetWidth].join(' ');
      }

      module.exports = function (sceneGraph, renderSettings) {
        var engineSettings = renderSettings.engineSettings;
        var stylesheets = engineSettings.stylesheets;
        var stylesheetXml = stylesheets.map(function (stylesheet) {
          return '<?xml-stylesheet rel="stylesheet" href="' + stylesheet + '"?>';
        }).join('\n');
        var holderId = 'holder_' + Number(new Date()).toString(16);
        var root = sceneGraph.root;
        var textGroup = root.children.holderTextGroup;
        var css = '#' + holderId + ' text { ' + textCss(textGroup.properties) + ' } '; // push text down to be equally vertically aligned with canvas renderer

        textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;
        var wordTags = [];
        Object.keys(textGroup.children).forEach(function (lineKey) {
          var line = textGroup.children[lineKey];
          Object.keys(line.children).forEach(function (wordKey) {
            var word = line.children[wordKey];
            var x = textGroup.x + line.x + word.x;
            var y = textGroup.y + line.y + word.y;
            var wordTag = templates.element({
              'tag': 'text',
              'content': word.properties.text,
              'x': x,
              'y': y
            });
            wordTags.push(wordTag);
          });
        });
        var text = templates.element({
          'tag': 'g',
          'content': wordTags
        });
        var outline = null;

        if (root.children.holderBg.properties.outline) {
          var outlineProperties = root.children.holderBg.properties.outline;
          outline = templates.element({
            'tag': 'path',
            'd': outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),
            'stroke-width': outlineProperties.width,
            'stroke': outlineProperties.fill,
            'fill': 'none'
          });
        }

        var bg = convertShape(root.children.holderBg, 'rect');
        var sceneContent = [];
        sceneContent.push(bg);

        if (outlineProperties) {
          sceneContent.push(outline);
        }

        sceneContent.push(text);
        var scene = templates.element({
          'tag': 'g',
          'id': holderId,
          'content': sceneContent
        });
        var style = templates.element({
          'tag': 'style',
          //todo: figure out how to add CDATA directive
          'content': css,
          'type': 'text/css'
        });
        var defs = templates.element({
          'tag': 'defs',
          'content': style
        });
        var svg = templates.element({
          'tag': 'svg',
          'content': [defs, scene],
          'width': root.properties.width,
          'height': root.properties.height,
          'xmlns': SVG_NS,
          'viewBox': [0, 0, root.properties.width, root.properties.height].join(' '),
          'preserveAspectRatio': 'none'
        });
        var output = shaven(svg);

        if (/\&amp;(x)?#[0-9A-Fa-f]/.test(output[0])) {
          output[0] = output[0].replace(/&amp;#/gm, '&#');
        }

        output = stylesheetXml + output[0];
        var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === 'background');
        return svgString;
      };
      /***/

    },
    /* 13 */

    /***/
    function (module, exports, __webpack_require__) {
      var escape = __webpack_require__(14); // TODO: remove namespace


      module.exports = function shaven(array, namespace, returnObject) {
        'use strict';

        var i = 1;
        var doesEscape = true;
        var HTMLString;
        var attributeKey;
        var callback;
        var key;
        returnObject = returnObject || {};

        function createElement(sugarString) {
          var tags = sugarString.match(/^[\w-]+/);
          var element = {
            tag: tags ? tags[0] : 'div',
            attr: {},
            children: []
          };
          var id = sugarString.match(/#([\w-]+)/);
          var reference = sugarString.match(/\$([\w-]+)/);
          var classNames = sugarString.match(/\.[\w-]+/g); // Assign id if is set

          if (id) {
            element.attr.id = id[1]; // Add element to the return object

            returnObject[id[1]] = element;
          }

          if (reference) returnObject[reference[1]] = element;
          if (classNames) element.attr.class = classNames.join(' ').replace(/\./g, '');
          if (sugarString.match(/&$/g)) doesEscape = false;
          return element;
        }

        function replacer(key, value) {
          if (value === null || value === false || value === undefined) return;
          if (typeof value !== 'string' && _typeof(value) !== 'object') return String(value);
          return value;
        }

        function escapeAttribute(string) {
          return string || string === 0 ? String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;') : '';
        }

        function escapeHTML(string) {
          return String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        if (typeof array[0] === 'string') array[0] = createElement(array[0]);else if (Array.isArray(array[0])) i = 0;else throw new Error('First element of array must be a string, ' + 'or an array and not ' + JSON.stringify(array[0]));

        for (; i < array.length; i++) {
          // Don't render element if value is false or null
          if (array[i] === false || array[i] === null) {
            array[0] = false;
            break;
          } // Continue with next array value if current value is undefined or true
          else if (array[i] === undefined || array[i] === true) {
              continue;
            } else if (typeof array[i] === 'string') {
              if (doesEscape) array[i] = escapeHTML(array[i]);
              array[0].children.push(array[i]);
            } else if (typeof array[i] === 'number') {
              array[0].children.push(array[i]);
            } else if (Array.isArray(array[i])) {
              if (Array.isArray(array[i][0])) {
                array[i].reverse().forEach(function (subArray) {
                  array.splice(i + 1, 0, subArray);
                });
                if (i !== 0) continue;
                i++;
              }

              shaven(array[i], namespace, returnObject);
              if (array[i][0]) array[0].children.push(array[i][0]);
            } else if (typeof array[i] === 'function') callback = array[i];else if (_typeof(array[i]) === 'object') {
              for (attributeKey in array[i]) {
                if (array[i].hasOwnProperty(attributeKey)) if (array[i][attributeKey] !== null && array[i][attributeKey] !== false) if (attributeKey === 'style' && _typeof(array[i][attributeKey]) === 'object') array[0].attr[attributeKey] = JSON.stringify(array[i][attributeKey], replacer).slice(2, -2).replace(/","/g, ';').replace(/":"/g, ':').replace(/\\"/g, '\'');else array[0].attr[attributeKey] = array[i][attributeKey];
              }
            } else throw new TypeError('"' + array[i] + '" is not allowed as a value.');
        }

        if (array[0] !== false) {
          HTMLString = '<' + array[0].tag;

          for (key in array[0].attr) {
            if (array[0].attr.hasOwnProperty(key)) HTMLString += ' ' + key + '="' + escapeAttribute(array[0].attr[key]) + '"';
          }

          HTMLString += '>';
          array[0].children.forEach(function (child) {
            HTMLString += child;
          });
          HTMLString += '</' + array[0].tag + '>';
          array[0] = HTMLString;
        } // Return root element on index 0


        returnObject[0] = array[0];
        if (callback) callback(array[0]); // returns object containing all elements with an id and the root element

        return returnObject;
      };
      /***/

    },
    /* 14 */

    /***/
    function (module, exports) {
      /*!
       * escape-html
       * Copyright(c) 2012-2013 TJ Holowaychuk
       * Copyright(c) 2015 Andreas Lubbe
       * Copyright(c) 2015 Tiancheng "Timothy" Gu
       * MIT Licensed
       */
      'use strict';
      /**
       * Module variables.
       * @private
       */

      var matchHtmlRegExp = /["'&<>]/;
      /**
       * Module exports.
       * @public
       */

      module.exports = escapeHtml;
      /**
       * Escape special characters in the given string of html.
       *
       * @param  {string} string The string to escape for inserting into HTML
       * @return {string}
       * @public
       */

      function escapeHtml(string) {
        var str = '' + string;
        var match = matchHtmlRegExp.exec(str);

        if (!match) {
          return str;
        }

        var escape;
        var html = '';
        var index = 0;
        var lastIndex = 0;

        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              // "
              escape = '&quot;';
              break;

            case 38:
              // &
              escape = '&amp;';
              break;

            case 39:
              // '
              escape = '&#39;';
              break;

            case 60:
              // <
              escape = '&lt;';
              break;

            case 62:
              // >
              escape = '&gt;';
              break;

            default:
              continue;
          }

          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }

          lastIndex = index + 1;
          html += escape;
        }

        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      /***/

    },
    /* 15 */

    /***/
    function (module, exports, __webpack_require__) {
      var DOM = __webpack_require__(9);

      var utils = __webpack_require__(7);

      module.exports = function () {
        var canvas = DOM.newEl('canvas');
        var ctx = null;
        return function (sceneGraph) {
          if (ctx == null) {
            ctx = canvas.getContext('2d');
          }

          var dpr = utils.canvasRatio();
          var root = sceneGraph.root;
          canvas.width = dpr * root.properties.width;
          canvas.height = dpr * root.properties.height;
          ctx.textBaseline = 'middle';
          var bg = root.children.holderBg;
          var bgWidth = dpr * bg.width;
          var bgHeight = dpr * bg.height; //todo: parametrize outline width (e.g. in scene object)

          var outlineWidth = 2;
          var outlineOffsetWidth = outlineWidth / 2;
          ctx.fillStyle = bg.properties.fill;
          ctx.fillRect(0, 0, bgWidth, bgHeight);

          if (bg.properties.outline) {
            //todo: abstract this into a method
            ctx.strokeStyle = bg.properties.outline.fill;
            ctx.lineWidth = bg.properties.outline.width;
            ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth); // TL, TR, BR, BL

            ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);
            ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);
            ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);
            ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth); // Diagonals

            ctx.moveTo(0, outlineOffsetWidth);
            ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);
            ctx.moveTo(0, bgHeight - outlineOffsetWidth);
            ctx.lineTo(bgWidth, outlineOffsetWidth);
            ctx.stroke();
          }

          var textGroup = root.children.holderTextGroup;
          ctx.font = textGroup.properties.font.weight + ' ' + dpr * textGroup.properties.font.size + textGroup.properties.font.units + ' ' + textGroup.properties.font.family + ', monospace';
          ctx.fillStyle = textGroup.properties.fill;

          for (var lineKey in textGroup.children) {
            var line = textGroup.children[lineKey];

            for (var wordKey in line.children) {
              var word = line.children[wordKey];
              var x = dpr * (textGroup.x + line.x + word.x);
              var y = dpr * (textGroup.y + line.y + word.y + textGroup.properties.leading / 2);
              ctx.fillText(word.properties.text, x, y);
            }
          }

          return canvas.toDataURL('image/png');
        };
      }();
      /***/

    }])
  );
});

;

(function (ctx, isMeteorPackage) {
  if (isMeteorPackage) {
    Holder = ctx.Holder;
  }
})(this, typeof Meteor !== 'undefined' && typeof Package !== 'undefined');
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/less/editor-style.less":
/*!************************************!*\
  !*** ./src/less/editor-style.less ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/less/style.less":
/*!*****************************!*\
  !*** ./src/less/style.less ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/*!***********************************************************************************!*\
  !*** multi ./src/js/bundle.js ./src/less/style.less ./src/less/editor-style.less ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /Users/josiah/Local Sites/homeschool-scene/app/public/wp-content/themes/homeschool-scene/src/js/bundle.js */"./src/js/bundle.js");
__webpack_require__(/*! /Users/josiah/Local Sites/homeschool-scene/app/public/wp-content/themes/homeschool-scene/src/less/style.less */"./src/less/style.less");
module.exports = __webpack_require__(/*! /Users/josiah/Local Sites/homeschool-scene/app/public/wp-content/themes/homeschool-scene/src/less/editor-style.less */"./src/less/editor-style.less");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bmb3J0YXdlc29tZS9mb250YXdlc29tZS1zdmctY29yZS9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZyZWUtYnJhbmRzLXN2Zy1pY29ucy9mYUZhY2Vib29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhRmFjZWJvb2tGLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhSW5zdGFncmFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhTGlua2VkaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFMaW5rZWRpbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhVHdpdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZyZWUtYnJhbmRzLXN2Zy1pY29ucy9mYVlvdXR1YmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvYnVuZGxlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pY29ucy1pbXBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21vZGVybml6ci1jdXN0b20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JhcmViaXJkLWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9sZXNzL2VkaXRvci1zdHlsZS5sZXNzPzVkYjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xlc3Mvc3R5bGUubGVzcz9hODJjIl0sIm5hbWVzIjpbImxpYnJhcnkiLCJhZGQiLCJmYUZhY2Vib29rRiIsImZhRmFjZWJvb2siLCJmYVR3aXR0ZXIiLCJmYUluc3RhZ3JhbSIsImZhTGlua2VkaW4iLCJmYUxpbmtlZGluSW4iLCJmYVlvdXR1YmUiLCJkb20iLCJ3YXRjaCIsImUiLCJ0IiwibiIsInIiLCJzIiwibyIsImkiLCJsIiwiYSIsIlMiLCJoYXNPd25Qcm9wZXJ0eSIsIm5hbWUiLCJwdXNoIiwidG9Mb3dlckNhc2UiLCJvcHRpb25zIiwiYWxpYXNlcyIsImxlbmd0aCIsImZuIiwic3BsaXQiLCJNb2Rlcm5penIiLCJCb29sZWFuIiwiQyIsImpvaW4iLCJ3IiwiY2xhc3NOYW1lIiwiX2NvbmZpZyIsImNsYXNzUHJlZml4IiwiYiIsImJhc2VWYWwiLCJlbmFibGVKU0NsYXNzIiwiUmVnRXhwIiwicmVwbGFjZSIsImVuYWJsZUNsYXNzZXMiLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZUVsZW1lbnQiLCJhcmd1bWVudHMiLCJjcmVhdGVFbGVtZW50TlMiLCJjYWxsIiwiYXBwbHkiLCJpbmRleE9mIiwidSIsImJvZHkiLCJmYWtlIiwiZiIsImQiLCJwIiwiYyIsInBhcnNlSW50IiwiaWQiLCJhcHBlbmRDaGlsZCIsInR5cGUiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwib3ZlcmZsb3ciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJvZmZzZXRIZWlnaHQiLCJtIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNvbnNvbGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZXJyb3IiLCJjdXJyZW50U3R5bGUiLCJnIiwiQ1NTIiwic3VwcG9ydHMiLCJ5IiwiTCIsIm1vZEVsZW0iLCJ2Iiwic2hpZnQiLCJoIiwiY2hhckF0Iiwic2xpY2UiLCJ6IiwiUCIsIngiLCJfdmVyc2lvbiIsInVzZVByZWZpeGVzIiwiX3EiLCJvbiIsInNldFRpbWVvdXQiLCJhZGRUZXN0IiwiYWRkQXN5bmNUZXN0IiwicHJvdG90eXBlIiwiXyIsIl9wcmVmaXhlcyIsImRvY3VtZW50RWxlbWVudCIsIm5vZGVOYW1lIiwiVCIsIl9kb21QcmVmaXhlcyIsInBvc2l0aW9uIiwiayIsIkUiLCJfY3Nzb21QcmVmaXhlcyIsImoiLCJDU1NSdWxlIiwiYXRSdWxlIiwiTiIsInRlc3RTdHlsZXMiLCJlbGVtIiwidW5zaGlmdCIsInRlc3RQcm9wIiwidGVzdEFsbFByb3BzIiwicHJlZml4ZWQiLCJkb2N1bWVudE1vZGUiLCJPIiwid2luZG93IiwiZG9jdW1lbnQiLCJOb2RlTGlzdCIsImZvckVhY2giLCJjYWxsYmFjayIsInRoaXNBcmciLCIkIiwidHJhbnNpdGlvbkVuZCIsImVsIiwidHJhbnNFbmRFdmVudE5hbWVzIiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJPVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJ1bmRlZmluZWQiLCJlbmQiLCJlbXVsYXRlVHJhbnNpdGlvbkVuZCIsImR1cmF0aW9uIiwiY2FsbGVkIiwiJGVsIiwib25lIiwidHJpZ2dlciIsInN1cHBvcnQiLCJldmVudCIsInNwZWNpYWwiLCJic1RyYW5zaXRpb25FbmQiLCJiaW5kVHlwZSIsImRlbGVnYXRlVHlwZSIsImhhbmRsZSIsInRhcmdldCIsImlzIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsImpRdWVyeSIsImRpc21pc3MiLCJBbGVydCIsImNsb3NlIiwiVkVSU0lPTiIsIlRSQU5TSVRJT05fRFVSQVRJT04iLCIkdGhpcyIsInNlbGVjdG9yIiwiYXR0ciIsIiRwYXJlbnQiLCJmaW5kIiwicHJldmVudERlZmF1bHQiLCJjbG9zZXN0IiwiRXZlbnQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyZW1vdmVDbGFzcyIsInJlbW92ZUVsZW1lbnQiLCJkZXRhY2giLCJyZW1vdmUiLCJoYXNDbGFzcyIsIlBsdWdpbiIsIm9wdGlvbiIsImVhY2giLCJkYXRhIiwib2xkIiwiYWxlcnQiLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJNb2RhbCIsImVsZW1lbnQiLCIkYm9keSIsIiRlbGVtZW50IiwiJGRpYWxvZyIsIiRiYWNrZHJvcCIsImlzU2hvd24iLCJvcmlnaW5hbEJvZHlQYWQiLCJzY3JvbGxiYXJXaWR0aCIsImlnbm9yZUJhY2tkcm9wQ2xpY2siLCJyZW1vdGUiLCJsb2FkIiwicHJveHkiLCJCQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OIiwiREVGQVVMVFMiLCJiYWNrZHJvcCIsImtleWJvYXJkIiwic2hvdyIsInRvZ2dsZSIsIl9yZWxhdGVkVGFyZ2V0IiwiaGlkZSIsInRoYXQiLCJyZWxhdGVkVGFyZ2V0IiwiY2hlY2tTY3JvbGxiYXIiLCJzZXRTY3JvbGxiYXIiLCJhZGRDbGFzcyIsImVzY2FwZSIsInJlc2l6ZSIsInBhcmVudCIsImFwcGVuZFRvIiwic2Nyb2xsVG9wIiwiYWRqdXN0RGlhbG9nIiwib2Zmc2V0V2lkdGgiLCJlbmZvcmNlRm9jdXMiLCJvZmYiLCJoaWRlTW9kYWwiLCJoYXMiLCJ3aGljaCIsImhhbmRsZVVwZGF0ZSIsInJlc2V0QWRqdXN0bWVudHMiLCJyZXNldFNjcm9sbGJhciIsInJlbW92ZUJhY2tkcm9wIiwiYW5pbWF0ZSIsImRvQW5pbWF0ZSIsImN1cnJlbnRUYXJnZXQiLCJmb2N1cyIsImNhbGxiYWNrUmVtb3ZlIiwibW9kYWxJc092ZXJmbG93aW5nIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY3NzIiwicGFkZGluZ0xlZnQiLCJib2R5SXNPdmVyZmxvd2luZyIsInBhZGRpbmdSaWdodCIsImZ1bGxXaW5kb3dXaWR0aCIsImlubmVyV2lkdGgiLCJkb2N1bWVudEVsZW1lbnRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmlnaHQiLCJNYXRoIiwiYWJzIiwibGVmdCIsImNsaWVudFdpZHRoIiwibWVhc3VyZVNjcm9sbGJhciIsImJvZHlQYWQiLCJzY3JvbGxEaXYiLCJhcHBlbmQiLCJleHRlbmQiLCJtb2RhbCIsImhyZWYiLCIkdGFyZ2V0IiwidGVzdCIsInNob3dFdmVudCIsIl9NQVAiLCJfS0VZQ09ERV9NQVAiLCJfU0hJRlRfTUFQIiwiX1NQRUNJQUxfQUxJQVNFUyIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiX1JFVkVSU0VfTUFQIiwidG9TdHJpbmciLCJfYWRkRXZlbnQiLCJvYmplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJfY2hhcmFjdGVyRnJvbUV2ZW50IiwiY2hhcmFjdGVyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic2hpZnRLZXkiLCJfbW9kaWZpZXJzTWF0Y2giLCJtb2RpZmllcnMxIiwibW9kaWZpZXJzMiIsInNvcnQiLCJfZXZlbnRNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsIl9wcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwiX3N0b3BQcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsIl9pc01vZGlmaWVyIiwia2V5IiwiX2dldFJldmVyc2VNYXAiLCJfcGlja0Jlc3RBY3Rpb24iLCJhY3Rpb24iLCJfa2V5c0Zyb21TdHJpbmciLCJjb21iaW5hdGlvbiIsIl9nZXRLZXlJbmZvIiwia2V5cyIsIl9iZWxvbmdzVG8iLCJhbmNlc3RvciIsIk1vdXNldHJhcCIsInRhcmdldEVsZW1lbnQiLCJzZWxmIiwiX2NhbGxiYWNrcyIsIl9kaXJlY3RNYXAiLCJfc2VxdWVuY2VMZXZlbHMiLCJfcmVzZXRUaW1lciIsIl9pZ25vcmVOZXh0S2V5dXAiLCJfaWdub3JlTmV4dEtleXByZXNzIiwiX25leHRFeHBlY3RlZEFjdGlvbiIsIl9yZXNldFNlcXVlbmNlcyIsImRvTm90UmVzZXQiLCJhY3RpdmVTZXF1ZW5jZXMiLCJfZ2V0TWF0Y2hlcyIsInNlcXVlbmNlTmFtZSIsImxldmVsIiwibWF0Y2hlcyIsInNlcSIsImRlbGV0ZUNvbWJvIiwiY29tYm8iLCJkZWxldGVTZXF1ZW5jZSIsInNwbGljZSIsIl9maXJlQ2FsbGJhY2siLCJzZXF1ZW5jZSIsInN0b3BDYWxsYmFjayIsInNyY0VsZW1lbnQiLCJfaGFuZGxlS2V5IiwiY2FsbGJhY2tzIiwibWF4TGV2ZWwiLCJwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrIiwibWF4IiwiaWdub3JlVGhpc0tleXByZXNzIiwiX2hhbmRsZUtleUV2ZW50Iiwia2V5Q29kZSIsImhhbmRsZUtleSIsIl9yZXNldFNlcXVlbmNlVGltZXIiLCJjbGVhclRpbWVvdXQiLCJfYmluZFNlcXVlbmNlIiwiX2luY3JlYXNlU2VxdWVuY2UiLCJuZXh0QWN0aW9uIiwiX2NhbGxiYWNrQW5kUmVzZXQiLCJpc0ZpbmFsIiwid3JhcHBlZENhbGxiYWNrIiwiX2JpbmRTaW5nbGUiLCJpbmZvIiwiX2JpbmRNdWx0aXBsZSIsImNvbWJpbmF0aW9ucyIsImJpbmQiLCJBcnJheSIsInVuYmluZCIsInJlc2V0IiwidGFnTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwiYWRkS2V5Y29kZXMiLCJpbml0IiwiZG9jdW1lbnRNb3VzZXRyYXAiLCJtZXRob2QiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiUGFyc2xleUNvbmZpZyIsInZhbGlkYXRvcnMiLCJsdWhuIiwidmFsdWUiLCJkaWdpdCIsIl9qIiwiX2xlbjEiLCJfcmVmMiIsInN1bSIsInJldmVyc2UiLCJwcmlvcml0eSIsIl9zbGljZSIsIl9zbGljZWRUb0FycmF5Iiwic2xpY2VJdGVyYXRvciIsImFyciIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJuZXh0IiwiZG9uZSIsImVyciIsImlzQXJyYXkiLCJPYmplY3QiLCJUeXBlRXJyb3IiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInNvdXJjZSIsIl90b0NvbnN1bWFibGVBcnJheSIsImFycjIiLCJmcm9tIiwiZ2xvYmFsIiwiZmFjdG9yeSIsInJlcXVpcmUiLCJnbG9iYWxJRCIsInBhc3RXYXJuaW5ncyIsIlV0aWxzIiwibmFtZXNwYWNlIiwib2JqIiwiYXR0cmlidXRlIiwiYXR0cmlidXRlcyIsInJlZ2V4Iiwic3BlY2lmaWVkIiwiY2FtZWxpemUiLCJkZXNlcmlhbGl6ZVZhbHVlIiwiY2hlY2tBdHRyIiwiX2NoZWNrQXR0ciIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHIiLCJzZXRBdHRyaWJ1dGUiLCJkYXNoZXJpemUiLCJnZXRUeXBlIiwiZ2V0QXR0cmlidXRlIiwiZ2VuZXJhdGVJRCIsIm51bSIsImlzTmFOIiwiTnVtYmVyIiwiSlNPTiIsInBhcnNlIiwic3RyIiwibWF0Y2giLCJjaHIiLCJ3YXJuIiwiX3dpbmRvdyRjb25zb2xlIiwid2Fybk9uY2UiLCJtc2ciLCJfcmVzZXRXYXJuaW5ncyIsInRyaW1TdHJpbmciLCJzdHJpbmciLCJkYXRlIiwicGFyc2VkIiwiX3BhcnNlZCRtYXAiLCJtYXAiLCJfcGFyc2VkJG1hcDIiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJfc3RyaW5nIiwiaW50ZWdlciIsIm51bWJlciIsInBhcnNlRmxvYXQiLCJfYm9vbGVhbiIsInJlZ2V4cCIsIl9yZWdleHAiLCJmbGFncyIsInBhcnNlUmVxdWlyZW1lbnQiLCJyZXF1aXJlbWVudFR5cGUiLCJjb252ZXJ0ZXIiLCJjb252ZXJ0ZWQiLCJuYW1lc3BhY2VFdmVudHMiLCJldmVudHMiLCJldnQiLCJkaWZmZXJlbmNlIiwiYXJyYXkiLCJyZXN1bHQiLCJhbGwiLCJwcm9taXNlcyIsIndoZW4iLCJjb25jYXQiLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJFcnJvciIsIl9TdWJtaXRTZWxlY3RvciIsIkRlZmF1bHRzIiwiaW5wdXRzIiwiZXhjbHVkZWQiLCJwcmlvcml0eUVuYWJsZWQiLCJtdWx0aXBsZSIsImdyb3VwIiwidWlFbmFibGVkIiwidmFsaWRhdGlvblRocmVzaG9sZCIsInRyaWdnZXJBZnRlckZhaWx1cmUiLCJlcnJvckNsYXNzIiwic3VjY2Vzc0NsYXNzIiwiY2xhc3NIYW5kbGVyIiwiRmllbGQiLCJlcnJvcnNDb250YWluZXIiLCJlcnJvcnNXcmFwcGVyIiwiZXJyb3JUZW1wbGF0ZSIsIkJhc2UiLCJfX2lkX18iLCJhc3luY1N1cHBvcnQiLCJfcGlwZUFjY29yZGluZ1RvVmFsaWRhdGlvblJlc3VsdCIsIl90aGlzIiwicGlwZSIsIkRlZmVycmVkIiwidmFsaWRhdGlvblJlc3VsdCIsInJlamVjdCIsInJlc29sdmUiLCJwcm9taXNlIiwiYWN0dWFsaXplT3B0aW9ucyIsImRvbU9wdGlvbnMiLCJfcmVzZXRPcHRpb25zIiwiaW5pdE9wdGlvbnMiLCJfbGlzdGVuZXJzIiwicXVldWUiLCJzdWJzY3JpYmUiLCJsaXN0ZW5UbyIsInVuc3Vic2NyaWJlIiwidW5zdWJzY3JpYmVUbyIsImV4dHJhQXJnIiwicGFyZW50UmVzdWx0IiwiYXN5bmNJc1ZhbGlkIiwiZm9yY2UiLCJ3aGVuVmFsaWQiLCJfZmluZFJlbGF0ZWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29udmVydEFycmF5UmVxdWlyZW1lbnQiLCJ2YWx1ZXMiLCJjb252ZXJ0RXh0cmFPcHRpb25SZXF1aXJlbWVudCIsInJlcXVpcmVtZW50U3BlYyIsImV4dHJhT3B0aW9uUmVhZGVyIiwibWFpbiIsImV4dHJhIiwiVmFsaWRhdG9yIiwic3BlYyIsInZhbGlkYXRlIiwicmVxdWlyZW1lbnRGaXJzdEFyZyIsInZhbGlkYXRlTXVsdGlwbGUiLCJpbnN0YW5jZSIsInZhbGlkYXRlRGF0ZSIsIl9pc0RhdGVJbnB1dCIsInZhbGlkYXRlTnVtYmVyIiwidmFsaWRhdGVTdHJpbmciLCJwYXJzZVJlcXVpcmVtZW50cyIsInJlcXVpcmVtZW50cyIsImlzUGxhaW5PYmplY3QiLCJWYWxpZGF0b3JSZWdpc3RyeSIsImNhdGFsb2ciLCJfX2NsYXNzX18iLCJsb2NhbGUiLCJ0eXBlVGVzdGVycyIsImVtYWlsIiwiZGlnaXRzIiwiYWxwaGFudW0iLCJ1cmwiLCJyYW5nZSIsImRlY2ltYWxQbGFjZXMiLCJWYWxpZGF0b3JSZWdpc3RyeV9fcGFyc2VBcmd1bWVudHMiLCJhcmdzIiwiVmFsaWRhdG9yUmVnaXN0cnlfX29wZXJhdG9yVG9WYWxpZGF0b3IiLCJvcGVyYXRvciIsIl9sZW4iLCJyZXF1aXJlbWVudHNBbmRJbnB1dCIsIl9rZXkiLCJwb3AiLCJWYWxpZGF0b3JSZWdpc3RyeV9fY29tcGFyaXNvbk9wZXJhdG9yIiwiYWRkVmFsaWRhdG9yIiwiUGFyc2xleSIsInNldExvY2FsZSIsImFkZENhdGFsb2ciLCJtZXNzYWdlcyIsInNldCIsImFkZE1lc3NhZ2UiLCJtZXNzYWdlIiwiYWRkTWVzc2FnZXMiLCJuYW1lTWVzc2FnZU9iamVjdCIsImFyZzEiLCJhcmcyIiwiX3NldFZhbGlkYXRvciIsImhhc1ZhbGlkYXRvciIsInVwZGF0ZVZhbGlkYXRvciIsInJlbW92ZVZhbGlkYXRvciIsInZhbGlkYXRvciIsImdldEVycm9yTWVzc2FnZSIsImNvbnN0cmFpbnQiLCJ0eXBlTWVzc2FnZXMiLCJmb3JtYXRNZXNzYWdlIiwiZGVmYXVsdE1lc3NhZ2UiLCJlbiIsInBhcmFtZXRlcnMiLCJub3RibGFuayIsInJlcXVpcmVkIiwiX3JlZiIsIl9yZWYkc3RlcCIsInN0ZXAiLCJfcmVmJGJhc2UiLCJiYXNlIiwidGVzdGVyIiwibmIiLCJkZWNpbWFscyIsInRvSW50Iiwicm91bmQiLCJwb3ciLCJwYXR0ZXJuIiwibWlubGVuZ3RoIiwicmVxdWlyZW1lbnQiLCJtYXhsZW5ndGgiLCJtaW4iLCJtaW5jaGVjayIsIm1heGNoZWNrIiwiY2hlY2siLCJlcXVhbHRvIiwicmVmT3JWYWx1ZSIsIiRyZWZlcmVuY2UiLCJ2YWwiLCJVSSIsImRpZmZSZXN1bHRzIiwibmV3UmVzdWx0Iiwib2xkUmVzdWx0IiwiZGVlcCIsImFkZGVkIiwia2VwdCIsImZvdW5kIiwiYXNzZXJ0IiwicmVtb3ZlZCIsIkZvcm0iLCJfYWN0dWFsaXplVHJpZ2dlcnMiLCJfdGhpczIiLCJvblN1Ym1pdFZhbGlkYXRlIiwib25TdWJtaXRCdXR0b24iLCJfZm9jdXNlZEZpZWxkIiwiZmllbGRzIiwiZmllbGQiLCJub0ZvY3VzIiwiX2Rlc3Ryb3lVSSIsIl9yZWZsb3dVSSIsIl9idWlsZFVJIiwiX3VpIiwiZGlmZiIsImxhc3RWYWxpZGF0aW9uUmVzdWx0IiwiX21hbmFnZVN0YXR1c0NsYXNzIiwiX21hbmFnZUVycm9yc01lc3NhZ2VzIiwiX2ZhaWxlZE9uY2UiLCJnZXRFcnJvcnNNZXNzYWdlcyIsImVycm9yTWVzc2FnZSIsIl9nZXRFcnJvck1lc3NhZ2UiLCJhZGRFcnJvciIsIl9yZWYyJHVwZGF0ZUNsYXNzIiwidXBkYXRlQ2xhc3MiLCJfYWRkRXJyb3IiLCJfZXJyb3JDbGFzcyIsInVwZGF0ZUVycm9yIiwiX3JlZjMiLCJfcmVmMyR1cGRhdGVDbGFzcyIsIl91cGRhdGVFcnJvciIsInJlbW92ZUVycm9yIiwiX3JlZjQiLCJfcmVmNCR1cGRhdGVDbGFzcyIsIl9yZW1vdmVFcnJvciIsImhhc0NvbnN0cmFpbnRzIiwibmVlZHNWYWxpZGF0aW9uIiwiX3N1Y2Nlc3NDbGFzcyIsIl9yZXNldENsYXNzIiwiZXJyb3JzTWVzc2FnZXNEaXNhYmxlZCIsIl9pbnNlcnRFcnJvcldyYXBwZXIiLCIkZXJyb3JzV3JhcHBlciIsImh0bWwiLCJfcmVmNSIsIiRlcnJvckNsYXNzSGFuZGxlciIsImVycm9yc1dyYXBwZXJJZCIsIl9yZWY2IiwicmVtb3ZlQXR0ciIsImN1c3RvbUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UiLCJfbWFuYWdlQ2xhc3NIYW5kbGVyIiwidmFsaWRhdGlvbkluZm9ybWF0aW9uVmlzaWJsZSIsIiRoYW5kbGVyRnVuY3Rpb24iLCIkaGFuZGxlciIsIl9pbnB1dEhvbGRlciIsIiRlcnJvcnNDb250YWluZXIiLCJhZnRlciIsIl90aGlzMyIsIiR0b0JpbmQiLCJfdmFsaWRhdGVJZk5lZWRlZCIsIl90aGlzNCIsImdldFZhbHVlIiwiZGVib3VuY2UiLCJfZGVib3VuY2VkIiwiX3Jlc2V0VUkiLCJjaGlsZHJlbiIsIkZvcm1fX3N0YXR1c01hcHBpbmciLCJwZW5kaW5nIiwicmVzb2x2ZWQiLCJyZWplY3RlZCIsIl90aGlzNSIsInBhcnNsZXkiLCJzdWJtaXRTb3VyY2UiLCJfc3VibWl0U291cmNlIiwicHJvcCIsIl9yZW1vdGVDYWNoZSIsIndoZW5WYWxpZGF0ZSIsInN0YXRlIiwiX3RyaWdnZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJfc3VibWl0IiwiJHN5bnRoZXRpYyIsIl9hcmd1bWVudHMiLCJfVXRpbHMkYWxsJGRvbmUkZmFpbCRhbHdheXMiLCJfdGhpczYiLCJfcmVmNyIsInN1Ym1pdEV2ZW50IiwiX3JlZnJlc2hGaWVsZHMiLCJfd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9ucyIsImZhaWwiLCJhbHdheXMiLCJpc1ZhbGlkIiwiX2FyZ3VtZW50czIiLCJfdGhpczciLCJfcmVmOCIsInJlZnJlc2giLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIl9iaW5kRmllbGRzIiwiX3RoaXM4Iiwib2xkRmllbGRzIiwiZmllbGRzTWFwcGVkQnlJZCIsIm5vdCIsImZpZWxkSW5zdGFuY2UiLCJGYWN0b3J5IiwidW5pcXVlSWQiLCJvbGRBY3R1YWxpemVPcHRpb25zIiwiZXZlbnROYW1lIiwiQ29uc3RyYWludCIsInBhcnNsZXlGaWVsZCIsImlzRG9tQ29uc3RyYWludCIsInZhbGlkYXRvclNwZWMiLCJfdmFsaWRhdG9yUmVnaXN0cnkiLCJfcGFyc2VSZXF1aXJlbWVudHMiLCJjYXBpdGFsaXplIiwiY2FwIiwiX3ZhbGlkYXRvciIsInJlcXVpcmVtZW50TGlzdCIsIl90aGlzOSIsInBhcnNsZXlGb3JtSW5zdGFuY2UiLCJjb25zdHJhaW50cyIsImNvbnN0cmFpbnRzQnlOYW1lIiwiX2JpbmRDb25zdHJhaW50cyIsInBhcnNsZXlfZmllbGRfX3N0YXR1c01hcHBpbmciLCJfd2hlblZhbGlkJGFsd2F5cyRkb25lJGZhaWwkYWx3YXlzIiwiX3RoaXMxMCIsIl9yZWY5IiwiX2lzSW5Hcm91cCIsIl9yZWZyZXNoZWQiLCJfaXNSZXF1aXJlZCIsInZhbGlkYXRlSWZFbXB0eSIsImluQXJyYXkiLCJfYXJndW1lbnRzMyIsIl90aGlzMTEiLCJfcmVmMTAiLCJfcmVmMTAkZm9yY2UiLCJncm91cGVkQ29uc3RyYWludHMiLCJfZ2V0R3JvdXBlZENvbnN0cmFpbnRzIiwiX3ZhbGlkYXRlQ29uc3RyYWludCIsIl90aGlzMTIiLCJfaGFuZGxlV2hpdGVzcGFjZSIsIl9yZWZyZXNoQ29uc3RyYWludHMiLCJyZWZyZXNoQ29uc3RyYWludHMiLCJhZGRDb25zdHJhaW50IiwicmVtb3ZlQ29uc3RyYWludCIsInVwZGF0ZUNvbnN0cmFpbnQiLCJfYmluZEh0bWw1Q29uc3RyYWludHMiLCJ0cmltVmFsdWUiLCJ3aGl0ZXNwYWNlIiwiaW5kZXgiLCJwYXJzbGV5X2ZpZWxkIiwiTXVsdGlwbGUiLCJhZGRFbGVtZW50IiwiJGVsZW1lbnRzIiwiZmllbGRDb25zdHJhaW50cyIsImZpbHRlciIsIl9pbml0Iiwic2F2ZWRwYXJzbGV5Rm9ybUluc3RhbmNlIiwiX192ZXJzaW9uX18iLCJpc011bHRpcGxlIiwiaGFuZGxlTXVsdGlwbGUiLCJfdGhpczEzIiwicGFyc2xleU11bHRpcGxlSW5zdGFuY2UiLCJpbnB1dCIsIiRwcmV2aW91c2x5UmVsYXRlZCIsImdldCIsImRvTm90U3RvcmUiLCJwYXJzbGV5SW5zdGFuY2UiLCJQYXJzbGV5RXh0ZW5kIiwidmVybnVtcyIsImpxdWVyeSIsInZlcnNpb24iLCJwc2x5IiwiaW5zdGFuY2VzIiwiUGFyc2xleVV0aWxzIiwicmVnaXN0cnkiLCJpMThuIiwiUGFyc2xleVZhbGlkYXRvciIsIl93aW5kb3ckUGFyc2xleSIsIlBhcnNsZXlVSSIsImRvTm90VXBkYXRlQ2xhc3MiLCJhdXRvQmluZCIsImRlcHJlY2F0ZWQiLCJhZGFwdCIsImNvbnRleHQiLCJwYXJzbGV5QWRhcHRlZENhbGxiYWNrIiwiZXZlbnRQcmVmaXgiLCJsYXN0SW5kZXhPZiIsInN1YnN0ciIsImxpc3RlbiIsInVuc3Vic2NyaWJlQWxsIiwiZW1pdCIsIl9pbnN0YW5jZSIsImluc3RhbmNlR2l2ZW4iLCJwdWJzdWIiLCJhc3luY1ZhbGlkYXRvcnMiLCJ4aHIiLCJzdGF0dXMiLCJhZGRBc3luY1ZhbGlkYXRvciIsImFqYXhPcHRpb25zIiwiY3NyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVtb3RlT3B0aW9ucyIsInBhcmFtIiwiYWpheCIsImhhbmRsZVhociIsInRoZW4iLCJJbnB1dEV2ZW50IiwiX3RoaXMxNCIsImdsb2JhbHMiLCJpc05hdGl2ZUV2ZW50Iiwib3JpZ2luYWxFdmVudCIsImlzVHJ1c3RlZCIsImZha2VJbnB1dEV2ZW50IiwibWlzYmVoYXZlcyIsImJlaGF2ZXNPayIsImluc3RhbGwiLCJpbnB1dEV2ZW50UGF0Y2hlZCIsInVuaW5zdGFsbCIsImlucHV0ZXZlbnQiLCJsYXp5U2l6ZXMiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwibGF6eXNpemVzIiwibGF6eVNpemVzQ29uZmlnIiwiZG9jRWxlbSIsInN1cHBvcnRQaWN0dXJlIiwiSFRNTFBpY3R1cmVFbGVtZW50IiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJfZ2V0QXR0cmlidXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInJlZ1BpY3R1cmUiLCJsb2FkRXZlbnRzIiwicmVnQ2xhc3NDYWNoZSIsImVsZSIsImNscyIsInRyaW0iLCJyZWciLCJhZGRSZW1vdmVMb2FkRXZlbnRzIiwidHJpZ2dlckV2ZW50IiwiZGV0YWlsIiwibm9CdWJibGVzIiwibm9DYW5jZWxhYmxlIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwidXBkYXRlUG9seWZpbGwiLCJmdWxsIiwicG9seWZpbGwiLCJwaWN0dXJlZmlsbCIsInBmIiwic3JjIiwicmVldmFsdWF0ZSIsImVsZW1lbnRzIiwiZ2V0Q1NTIiwiZ2V0V2lkdGgiLCJ3aWR0aCIsIm1pblNpemUiLCJfbGF6eXNpemVzV2lkdGgiLCJyQUYiLCJydW5uaW5nIiwid2FpdGluZyIsImZpcnN0Rm5zIiwic2Vjb25kRm5zIiwiZm5zIiwicnVuIiwicnVuRm5zIiwicmFmQmF0Y2giLCJoaWRkZW4iLCJfbHNGbHVzaCIsInJBRkl0Iiwic2ltcGxlIiwidGhyb3R0bGUiLCJsYXN0VGltZSIsImdEZWxheSIsInRocm90dGxlRGVsYXkiLCJySUNUaW1lb3V0IiwicmljVGltZW91dCIsIm5vdyIsImlkbGVDYWxsYmFjayIsInRpbWVvdXQiLCJpc1ByaW9yaXR5IiwiZGVsYXkiLCJmdW5jIiwidGltZXN0YW1wIiwid2FpdCIsImxhdGVyIiwibGFzdCIsImxhenlTaXplc0RlZmF1bHRzIiwibGF6eUNsYXNzIiwibG9hZGVkQ2xhc3MiLCJsb2FkaW5nQ2xhc3MiLCJwcmVsb2FkQ2xhc3MiLCJhdXRvc2l6ZXNDbGFzcyIsInNyY0F0dHIiLCJzcmNzZXRBdHRyIiwic2l6ZXNBdHRyIiwiY3VzdG9tTWVkaWEiLCJleHBGYWN0b3IiLCJoRmFjIiwibG9hZE1vZGUiLCJsb2FkSGlkZGVuIiwibGF6eXNpemVzQ29uZmlnIiwibG9hZGVyIiwicHJlbG9hZEVsZW1zIiwiaXNDb21wbGV0ZWQiLCJyZXNldFByZWxvYWRpbmdUaW1lciIsInN0YXJ0ZWQiLCJlTHZXIiwiZWx2SCIsImVMdG9wIiwiZUxsZWZ0IiwiZUxyaWdodCIsImVMYm90dG9tIiwiZGVmYXVsdEV4cGFuZCIsInByZWxvYWRFeHBhbmQiLCJyZWdJbWciLCJyZWdJZnJhbWUiLCJzdXBwb3J0U2Nyb2xsIiwidXNlckFnZW50Iiwic2hyaW5rRXhwYW5kIiwiY3VycmVudEV4cGFuZCIsImlzTG9hZGluZyIsImxvd1J1bnMiLCJyZXNldFByZWxvYWRpbmciLCJpc05lc3RlZFZpc2libGUiLCJlbGVtRXhwYW5kIiwib3V0ZXJSZWN0IiwidmlzaWJsZSIsIm9mZnNldFBhcmVudCIsInRvcCIsImJvdHRvbSIsImNoZWNrRWxlbWVudHMiLCJlTGxlbiIsInJlY3QiLCJhdXRvTG9hZEVsZW0iLCJsb2FkZWRTb21ldGhpbmciLCJlbGVtTmVnYXRpdmVFeHBhbmQiLCJlbGVtRXhwYW5kVmFsIiwiYmVmb3JlRXhwYW5kVmFsIiwibGF6eWxvYWRFbGVtcyIsImV4cGFuZCIsIl9sYXp5UmFjZSIsInVudmVpbEVsZW1lbnQiLCJpbm5lckhlaWdodCIsInByZWxvYWRBZnRlckxvYWQiLCJ0aHJvdHRsZWRDaGVja0VsZW1lbnRzIiwic3dpdGNoTG9hZGluZ0NsYXNzIiwicmFmU3dpdGNoTG9hZGluZ0NsYXNzIiwicmFmZWRTd2l0Y2hMb2FkaW5nQ2xhc3MiLCJjaGFuZ2VJZnJhbWVTcmMiLCJjb250ZW50V2luZG93IiwibG9jYXRpb24iLCJoYW5kbGVTb3VyY2VzIiwic291cmNlU3Jjc2V0IiwibGF6eVVudmVpbCIsImlzQXV0byIsInNpemVzIiwiaXNJbWciLCJzcmNzZXQiLCJpc1BpY3R1cmUiLCJmaXJlc0xvYWQiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsImF1dG9TaXplciIsInVwZGF0ZUVsZW0iLCJvbmxvYWQiLCJhZnRlclNjcm9sbCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsInNldEludGVydmFsIiwicmVhZHlTdGF0ZSIsImNoZWNrRWxlbXMiLCJ1bnZlaWwiLCJhdXRvc2l6ZXNFbGVtcyIsInNpemVFbGVtZW50Iiwic291cmNlcyIsImxlbiIsImRhdGFBdHRyIiwiZ2V0U2l6ZUVsZW1lbnQiLCJ1cGRhdGVFbGVtZW50c1NpemVzIiwiZGVib3VuY2VkVXBkYXRlRWxlbWVudHNTaXplcyIsImNmZyIsInVQIiwiYUMiLCJyQyIsImhDIiwiZmlyZSIsImdXIiwicGFzc2l2ZUV2ZW50TGlzdGVuZXJPcHRpb25TdXBwb3J0ZWQiLCJvcHRzIiwiZGVmaW5lUHJvcGVydHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJwYXNzaXZlIiwiZG9tTG9hZGVkQ2FsbGJhY2siLCJjbGFzc0xpc3QiLCJkb1Njcm9sbCIsImNsaWNrRGlzcGF0Y2giLCIkY3VzdG9tX3RyaWdnZXJfY2xhc3MiLCJ0b2dnbGVDbGFzcyIsImhhc0FyaWFQcmVzc2VkQXR0ciIsImhhc0FyaWFFeHBhbmRlZEF0dHIiLCIkbm90aWZ5X2NsYXNzIiwiJGN1c3RvbV90YXJnZXRfY2xhc3MiLCJzaWJsaW5ncyIsInJlYWR5IiwiJGdsb2JhbF9oZWFkZXIiLCIkbmF2X291dGVyX3dyYXBwZXIiLCIkbmF2X2FjdGl2ZV9wYXJlbnQiLCIkbmF2X2NoaWxkIiwiJG5hdl9yZXZlYWxfYnV0dG9uIiwib3Blbk1vYmlsZU5hdiIsIm9wZW5OYXYiLCJ0aGVfbWVudSIsImludGVycG9sYXRlZF9zZWxlY3RvciIsImRyYXdlckxpc3RlbkZvckNsb3NpbmdTd2lwZSIsImNsb3NlTmF2IiwiY2xvc2VOYXZNaWxsaXNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJuYXZfY2xvc2VfdGltZXIiLCJjbG9zZVNlYXJjaCIsIiRuYXZfbGlua19vcGVuc19jaGlsZCIsImNsaWNrIiwiJHRoZV9wYXJlbnQiLCIkc2VhcmNoX3JldmVhbF9idXR0b24iLCIkc2VhcmNoX21lbnUiLCIkc2VhcmNoX2lucHV0IiwiJHNlYXJjaF9zdWJtaXQiLCIkc2VhcmNoX2Nsb3NlX2J0biIsIiRzZWFyY2hfdHJpZ2dlciIsIm9wZW5TZWFyY2giLCJzZWxlY3QiLCJzZWxlY3RvcnMiLCJmaXJzdENoaWxkIiwiX3FzYSIsInNjcm9sbEJ5IiwicmVtb3ZlQXR0cmlidXRlIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTmFtZXMiLCJyZXQiLCJmdW4iLCJ0aGlzcCIsIkI2NF9BTFBIQUJFVCIsImF0b2IiLCJvdXRwdXQiLCJidWZmZXIiLCJiaXRzIiwiYnRvYSIsIm91dCIsIm8xIiwibzIiLCJvMyIsImUxIiwiZTIiLCJlMyIsImU0IiwiY2hhckNvZGVBdCIsInByb3RvIiwiX19wcm90b19fIiwiY29uc3RydWN0b3IiLCJwZXJmb3JtYW5jZSIsImdldFRpbWUiLCJub3dPZmZzZXQiLCJ0aW1pbmciLCJuYXZpZ2F0aW9uU3RhcnQiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImxvYWRlZCIsIm9uRG9tUmVhZHkiLCJxdWVyeXN0cmluZyIsIlNjZW5lR3JhcGgiLCJ1dGlscyIsIlNWRyIsIkRPTSIsIkNvbG9yIiwiY29uc3RhbnRzIiwic3ZnUmVuZGVyZXIiLCJzZ0NhbnZhc1JlbmRlcmVyIiwiZGltZW5zaW9uQ2hlY2siLCJTVkdfTlMiLCJzdmdfbnMiLCJIb2xkZXIiLCJhZGRUaGVtZSIsInRoZW1lIiwiQXBwIiwic2V0dGluZ3MiLCJ0aGVtZXMiLCJ2YXJzIiwiY2FjaGUiLCJ0aGVtZUtleXMiLCJhZGRJbWFnZSIsIm5vZGVzIiwiZ2V0Tm9kZUFycmF5Iiwibm9kZSIsImltZyIsIm5ld0VsIiwiZG9tUHJvcHMiLCJzZXR1cCIsInNldFJlc2l6ZVVwZGF0ZSIsImhvbGRlckRhdGEiLCJyZXNpemVVcGRhdGUiLCJ1cGRhdGVSZXNpemFibGVFbGVtZW50cyIsInVzZXJPcHRpb25zIiwiZW5naW5lU2V0dGluZ3MiLCJwcmVlbXB0ZWQiLCJyZW5kZXJlciIsInJlbmRlcmVycyIsInN1cHBvcnRzU1ZHIiwic3VwcG9ydHNDYW52YXMiLCJpbWFnZXMiLCJiZ25vZGVzIiwic3R5bGVub2RlcyIsIm9iamVjdHMiLCJzdHlsZXNoZWV0cyIsInN2Z1hNTFN0eWxlc2hlZXQiLCJub0ZvbnRGYWxsYmFjayIsIm5vQmFja2dyb3VuZFNpemUiLCJzdHlsZU5vZGUiLCJyZWwiLCJwcm94eUxpbmsiLCJzdHlsZXNoZWV0VVJMIiwicHJvdG9jb2wiLCJob3N0IiwicGF0aG5hbWUiLCJzZWFyY2giLCJiZ05vZGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkYXRhQmFja2dyb3VuZEltYWdlIiwicmF3VVJMIiwiaG9sZGVyVVJMIiwiaG9sZGVyU3RyaW5nIiwiZG9tYWluIiwiaG9sZGVyU3RyaW5nSW5kZXgiLCJmcmFnbWVudCIsImhvbGRlckZsYWdzIiwicGFyc2VVUkwiLCJwcmVwYXJlRE9NRWxlbWVudCIsIm1vZGUiLCJvYmplY3RBdHRyIiwiZGF0YVNyYyIsIm9iamVjdEhhc1NyY1VSTCIsIm9iamVjdEhhc0RhdGFTcmNVUkwiLCJwcmVwYXJlSW1hZ2VFbGVtZW50IiwiaW1hZ2UiLCJpbWFnZUF0dHIiLCJyZW5kZXJlZCIsImltYWdlSGFzU3JjIiwiaW1hZ2VIYXNEYXRhU3JjVVJMIiwiaW1hZ2VSZW5kZXJlZCIsImltYWdlRXhpc3RzIiwiZXhpc3RzIiwiYmciLCJmZyIsImRlZmF1bHRzIiwic2l6ZSIsInVuaXRzIiwic2NhbGUiLCJpbnN0YW5jZU9wdGlvbnMiLCJob2xkZXIiLCJncmF5IiwiZmlyc3RRdWVzdGlvbk1hcmsiLCJwYXJ0cyIsImJhc2ljcyIsImRpbWVuc2lvbnMiLCJkaW1lbnNpb25EYXRhIiwiZmx1aWQiLCJoZWlnaHQiLCJ0cnV0aHkiLCJyYXRpbyIsInJhdGlvV2lkdGgiLCJyYXRpb0hlaWdodCIsImZsb29yIiwiYXV0byIsInBhcnNlQ29sb3IiLCJhdXRvRmciLCJ0ZXh0IiwidGV4dG1vZGUiLCJmb250IiwiYWxpZ24iLCJsaW5lV3JhcCIsIm5vd3JhcCIsIm91dGxpbmUiLCJyYW5kb20iLCJfdGhlbWUiLCJwcmVwU2V0dGluZ3MiLCJfZW5naW5lU2V0dGluZ3MiLCJkaW1lbnNpb25zQ2FwdGlvbiIsImhvbGRlclRlbXBsYXRlUmUiLCJkaW1lbnNpb25zSW5UZXh0IiwidGV4dExpbmVzIiwiZW5jb2RlSHRtbEVudGl0eSIsImhvbGRlclRlbXBsYXRlTWF0Y2hlcyIsInJlUmVuZGVyIiwicmVuZGVyU2V0dGluZ3MiLCJob2xkZXJTZXR0aW5ncyIsImJhY2tncm91bmRDb2xvciIsInJlbmRlciIsInJlc2l6YWJsZUltYWdlcyIsImRpc3BsYXkiLCJzZXRJbml0aWFsRGltZW5zaW9ucyIsInNjZW5lIiwic2NlbmVHcmFwaCIsImJ1aWxkU2NlbmVHcmFwaCIsImdldFJlbmRlcmVkSW1hZ2UiLCJiYWNrZ3JvdW5kU2l6ZSIsImZvbnRTaXplIiwiZmFtaWx5IiwidGV4dFNpemUiLCJ3ZWlnaHQiLCJmb250d2VpZ2h0Iiwibm9XcmFwIiwiZXhhY3REaW1lbnNpb25zIiwibGluZVdyYXBSYXRpbyIsInNjZW5lTWFyZ2luIiwibWF4TGluZVdpZHRoIiwiU2hhcGUiLCJob2xkZXJCZyIsIlJlY3QiLCJmaWxsIiwib3V0bGluZUNvbG9yIiwicHJvcGVydGllcyIsImxpZ2h0ZW4iLCJsaWdodGVyVGhhbiIsInRvSGV4IiwiaG9sZGVyVGV4dENvbG9yIiwiaG9sZGVyQmdDb2xvciIsImxpZ2h0Q29sb3IiLCJkYXJrQ29sb3IiLCJibGVuZEFscGhhIiwiaG9sZGVyVGV4dEdyb3VwIiwiR3JvdXAiLCJtb3ZlVG8iLCJ0cGRhdGEiLCJ0ZXh0UG9zaXRpb25EYXRhIiwic3RhZ2luZ1JlbmRlcmVyIiwibGVhZGluZyIsImJvdW5kaW5nQm94IiwidGV4dE5vZGUiLCJsaW5lIiwiZmluYWxpemVMaW5lIiwibGluZUNvdW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJsaW5lSW5kZXgiLCJsaW5lS2V5Iiwid29yZHMiLCJ3b3JkIiwiVGV4dCIsIm5ld2xpbmUiLCJzcGFjZVdpZHRoIiwic3RhZ2VXaWR0aCIsInN0YWdlSGVpZ2h0IiwiYmlnU2lkZSIsInNtYWxsU2lkZSIsIm5ld0hlaWdodCIsIm5vZGVUeXBlIiwiZmx1aWRDb25maWciLCJzZXRJbnZpc2libGUiLCJmbHVpZEhlaWdodCIsImZsdWlkV2lkdGgiLCJpbml0aWFsRGltZW5zaW9ucyIsInZpc2liaWxpdHlDaGVjayIsInJlbmRlcmFibGVJbWFnZXMiLCJpbnZpc2libGVJbWFnZXMiLCJzdGFydFZpc2liaWxpdHlDaGVjayIsInZpc2liaWxpdHlDaGVja1N0YXJ0ZWQiLCJpbnZpc2libGVJZCIsInN2ZyIsInN0YWdpbmdUZXh0Iiwic3RhZ2luZ1RleHROb2RlIiwiZ3JhcGgiLCJyb290Tm9kZSIsImZpcnN0VGltZVNldHVwIiwidG5vZGUiLCJpbml0U1ZHIiwidmlzaWJpbGl0eSIsImh0Z1Byb3BzIiwiY3NzUHJvcHMiLCJ0eHQiLCJpbm5lckhUTUwiLCJub2RlVmFsdWUiLCJzdGFnaW5nVGV4dEJCb3giLCJnZXRCQm94IiwiY2VpbCIsIm5ld2xpbmVzIiwiY29tcHV0ZWROb1NwYWNlTGVuZ3RoIiwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoIiwiZGlmZkxlbmd0aCIsIndvcmRXaWR0aHMiLCJkZWNvZGVIdG1sRW50aXR5IiwiYmJveCIsImRlYm91bmNlVGltZXIiLCJyZXNpemVFdmVudCIsImZsYWciLCJjYW52YXMiLCJnZXRDb250ZXh0IiwidG9EYXRhVVJMIiwiY3JlYXRlU1ZHUmVjdCIsIlR1cmJvbGlua3MiLCJfb25Eb21SZWFkeSIsIndpbiIsIkRPTUNvbnRlbnRMb2FkZWQiLCJkb2MiLCJMT0FEIiwiRkFMU0UiLCJPTkxPQUQiLCJDT01QTEVURSIsIlJFQURZU1RBVEUiLCJBVFRBQ0hFVkVOVCIsIkRFVEFDSEVWRU5UIiwiQURERVZFTlRMSVNURU5FUiIsIkRPTUNPTlRFTlRMT0FERUQiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJSRU1PVkVFVkVOVExJU1RFTkVSIiwidzNjIiwiX3RvcCIsImlzUmVhZHkiLCJkZWZlciIsImNvbXBsZXRlZCIsImZyYW1lRWxlbWVudCIsImRvU2Nyb2xsQ2hlY2siLCJlbmNvZGUiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhcnJheVJlZ2V4Iiwib2JqZWN0UmVnZXgiLCJwYWlycyIsImN0eCIsImV4ZWMiLCJzdHJpbmdpZnkiLCJpc0J1ZmZlciIsInZhbHVlT2YiLCJfaXNCdWZmZXIiLCJzY2VuZVByb3BlcnRpZXMiLCJub2RlQ291bnQiLCJtZXJnZSIsImNoaWxkIiwiU2NlbmVOb2RlIiwiUm9vdE5vZGUiLCJwcm9wcyIsImJ1ZiIsImNoYXJDb2RlIiwiSW1hZ2UiLCJvbmVycm9yIiwiZGVjIiwiaGV4cmUiLCJyZ2JyZSIsInJnYmFyZSIsInJldHZhbCIsImNhbnZhc1JhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJOT0RFX1RZUEVfQ09NTUVOVCIsImRlZnMiLCJpbml0aWFsaXplIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiY2hpbGROb2RlcyIsInN2Z1N0cmluZ1RvRGF0YVVSSSIsInJhd1ByZWZpeCIsImJhc2U2NFByZWZpeCIsInN2Z1N0cmluZyIsImJhc2U2NCIsInVuZXNjYXBlIiwic2VyaWFsaXplU1ZHIiwiWE1MU2VyaWFsaXplciIsInNlcmlhbGl6ZXIiLCJzdmdDU1MiLCJ4bWwiLCJjcmVhdGVYTUwiLCJjc3NwaSIsImNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImluc2VydEJlZm9yZSIsInNlcmlhbGl6ZVRvU3RyaW5nIiwic3ZnVGV4dCIsInRhZyIsImF0dHJzIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiTm9kZSIsIkhUTUxDb2xsZWN0aW9uIiwiY29sb3IiLCJvcmlnaW5hbCIsImFscGhhIiwicmdiMmhleCIsImZvcm1hdCIsImRlY2ltYWwiLCJoZXgiLCJoc2wycmdiIiwiSCIsIlgiLCJyYXciLCJyZ2IiLCJ5dXYiLCJtdWx0aXBsaWVyIiwiY20iLCJibSIsImNyIiwiY2ciLCJjYiIsImFkZEhhc2giLCJDYSIsIkNiIiwic2hhdmVuIiwidGVtcGxhdGVzIiwiY29udGVudCIsImNvbnZlcnRTaGFwZSIsInNoYXBlIiwidGV4dENzcyIsIm91dGxpbmVQYXRoIiwiYmdXaWR0aCIsImJnSGVpZ2h0Iiwib3V0bGluZVdpZHRoIiwib3V0bGluZU9mZnNldFdpZHRoIiwic3R5bGVzaGVldFhtbCIsInN0eWxlc2hlZXQiLCJob2xkZXJJZCIsInRleHRHcm91cCIsIndvcmRUYWdzIiwid29yZEtleSIsIndvcmRUYWciLCJvdXRsaW5lUHJvcGVydGllcyIsInNjZW5lQ29udGVudCIsInJldHVybk9iamVjdCIsImRvZXNFc2NhcGUiLCJIVE1MU3RyaW5nIiwiYXR0cmlidXRlS2V5Iiwic3VnYXJTdHJpbmciLCJ0YWdzIiwicmVmZXJlbmNlIiwiY2xhc3MiLCJyZXBsYWNlciIsImVzY2FwZUF0dHJpYnV0ZSIsImVzY2FwZUhUTUwiLCJzdWJBcnJheSIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJsYXN0SW5kZXgiLCJzdWJzdHJpbmciLCJkcHIiLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbFRleHQiLCJpc01ldGVvclBhY2thZ2UiLCJNZXRlb3IiLCJQYWNrYWdlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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QUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7QUFDSDs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ2pDLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDcjJVRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7QUN2THRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pMRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LFdBSjdELEU7Ozs7Ozs7Ozs7OztBQy9zUUEseUM7Ozs7Ozs7Ozs7O0FDQUEseUMiLCJmaWxlIjoiL2Rpc3QvanMvYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIF9XSU5ET1cgPSB7fTtcbnZhciBfRE9DVU1FTlQgPSB7fTtcbnZhciBfTVVUQVRJT05fT0JTRVJWRVIgPSBudWxsO1xudmFyIF9QRVJGT1JNQU5DRSA9IHtcbiAgbWFyazogbm9vcCxcbiAgbWVhc3VyZTogbm9vcFxufTtcblxudHJ5IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBfV0lORE9XID0gd2luZG93O1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgX0RPQ1VNRU5UID0gZG9jdW1lbnQ7XG4gIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIF9NVVRBVElPTl9PQlNFUlZFUiA9IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnKSBfUEVSRk9STUFOQ0UgPSBwZXJmb3JtYW5jZTtcbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciBfcmVmID0gX1dJTkRPVy5uYXZpZ2F0b3IgfHwge30sXG4gICAgX3JlZiR1c2VyQWdlbnQgPSBfcmVmLnVzZXJBZ2VudCxcbiAgICB1c2VyQWdlbnQgPSBfcmVmJHVzZXJBZ2VudCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHVzZXJBZ2VudDtcblxudmFyIFdJTkRPVyA9IF9XSU5ET1c7XG52YXIgRE9DVU1FTlQgPSBfRE9DVU1FTlQ7XG52YXIgTVVUQVRJT05fT0JTRVJWRVIgPSBfTVVUQVRJT05fT0JTRVJWRVI7XG52YXIgUEVSRk9STUFOQ0UgPSBfUEVSRk9STUFOQ0U7XG52YXIgSVNfQlJPV1NFUiA9ICEhV0lORE9XLmRvY3VtZW50O1xudmFyIElTX0RPTSA9ICEhRE9DVU1FTlQuZG9jdW1lbnRFbGVtZW50ICYmICEhRE9DVU1FTlQuaGVhZCAmJiB0eXBlb2YgRE9DVU1FTlQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgRE9DVU1FTlQuY3JlYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJztcbnZhciBJU19JRSA9IH51c2VyQWdlbnQuaW5kZXhPZignTVNJRScpIHx8IH51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudC8nKTtcblxudmFyIE5BTUVTUEFDRV9JREVOVElGSUVSID0gJ19fX0ZPTlRfQVdFU09NRV9fXyc7XG52YXIgVU5JVFNfSU5fR1JJRCA9IDE2O1xudmFyIERFRkFVTFRfRkFNSUxZX1BSRUZJWCA9ICdmYSc7XG52YXIgREVGQVVMVF9SRVBMQUNFTUVOVF9DTEFTUyA9ICdzdmctaW5saW5lLS1mYSc7XG52YXIgREFUQV9GQV9JMlNWRyA9ICdkYXRhLWZhLWkyc3ZnJztcbnZhciBEQVRBX0ZBX1BTRVVET19FTEVNRU5UID0gJ2RhdGEtZmEtcHNldWRvLWVsZW1lbnQnO1xudmFyIERBVEFfRkFfUFNFVURPX0VMRU1FTlRfUEVORElORyA9ICdkYXRhLWZhLXBzZXVkby1lbGVtZW50LXBlbmRpbmcnO1xudmFyIERBVEFfUFJFRklYID0gJ2RhdGEtcHJlZml4JztcbnZhciBEQVRBX0lDT04gPSAnZGF0YS1pY29uJztcbnZhciBIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MgPSAnZm9udGF3ZXNvbWUtaTJzdmcnO1xudmFyIE1VVEFUSU9OX0FQUFJPQUNIX0FTWU5DID0gJ2FzeW5jJztcbnZhciBUQUdOQU1FU19UT19TS0lQX0ZPUl9QU0VVRE9FTEVNRU5UUyA9IFsnSFRNTCcsICdIRUFEJywgJ1NUWUxFJywgJ1NDUklQVCddO1xudmFyIFBST0RVQ1RJT04gPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0oKTtcbnZhciBQUkVGSVhfVE9fU1RZTEUgPSB7XG4gICdmYXMnOiAnc29saWQnLFxuICAnZmFyJzogJ3JlZ3VsYXInLFxuICAnZmFsJzogJ2xpZ2h0JyxcbiAgJ2ZhYic6ICdicmFuZHMnLFxuICAnZmEnOiAnc29saWQnXG59O1xudmFyIFNUWUxFX1RPX1BSRUZJWCA9IHtcbiAgJ3NvbGlkJzogJ2ZhcycsXG4gICdyZWd1bGFyJzogJ2ZhcicsXG4gICdsaWdodCc6ICdmYWwnLFxuICAnYnJhbmRzJzogJ2ZhYidcbn07XG52YXIgTEFZRVJTX1RFWFRfQ0xBU1NOQU1FID0gJ2ZhLWxheWVycy10ZXh0JztcbnZhciBGT05UX0ZBTUlMWV9QQVRURVJOID0gL0ZvbnQgQXdlc29tZSA1IChTb2xpZHxSZWd1bGFyfExpZ2h0fEJyYW5kc3xGcmVlfFBybykvO1xudmFyIEZPTlRfV0VJR0hUX1RPX1BSRUZJWCA9IHtcbiAgJzkwMCc6ICdmYXMnLFxuICAnNDAwJzogJ2ZhcicsXG4gICdub3JtYWwnOiAnZmFyJyxcbiAgJzMwMCc6ICdmYWwnXG59O1xudmFyIG9uZVRvVGVuID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXTtcbnZhciBvbmVUb1R3ZW50eSA9IG9uZVRvVGVuLmNvbmNhdChbMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjBdKTtcbnZhciBBVFRSSUJVVEVTX1dBVENIRURfRk9SX01VVEFUSU9OID0gWydjbGFzcycsICdkYXRhLXByZWZpeCcsICdkYXRhLWljb24nLCAnZGF0YS1mYS10cmFuc2Zvcm0nLCAnZGF0YS1mYS1tYXNrJ107XG52YXIgUkVTRVJWRURfQ0xBU1NFUyA9IFsneHMnLCAnc20nLCAnbGcnLCAnZncnLCAndWwnLCAnbGknLCAnYm9yZGVyJywgJ3B1bGwtbGVmdCcsICdwdWxsLXJpZ2h0JywgJ3NwaW4nLCAncHVsc2UnLCAncm90YXRlLTkwJywgJ3JvdGF0ZS0xODAnLCAncm90YXRlLTI3MCcsICdmbGlwLWhvcml6b250YWwnLCAnZmxpcC12ZXJ0aWNhbCcsICdmbGlwLWJvdGgnLCAnc3RhY2snLCAnc3RhY2stMXgnLCAnc3RhY2stMngnLCAnaW52ZXJzZScsICdsYXllcnMnLCAnbGF5ZXJzLXRleHQnLCAnbGF5ZXJzLWNvdW50ZXInXS5jb25jYXQob25lVG9UZW4ubWFwKGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChuLCBcInhcIik7XG59KSkuY29uY2F0KG9uZVRvVHdlbnR5Lm1hcChmdW5jdGlvbiAobikge1xuICByZXR1cm4gXCJ3LVwiLmNvbmNhdChuKTtcbn0pKTtcblxudmFyIGluaXRpYWwgPSBXSU5ET1cuRm9udEF3ZXNvbWVDb25maWcgfHwge307XG5cbmZ1bmN0aW9uIGdldEF0dHJDb25maWcoYXR0cikge1xuICB2YXIgZWxlbWVudCA9IERPQ1VNRU5ULnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFsnICsgYXR0ciArICddJyk7XG5cbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAvLyBHZXR0aW5nIGFuIGVtcHR5IHN0cmluZyB3aWxsIG9jY3VyIGlmIHRoZSBhdHRyaWJ1dGUgaXMgc2V0IG9uIHRoZSBIVE1MIHRhZyBidXQgd2l0aG91dCBhIHZhbHVlXG4gIC8vIFdlJ2xsIGFzc3VtZSB0aGF0IHRoaXMgaXMgYW4gaW5kaWNhdGlvbiB0aGF0IGl0IHNob3VsZCBiZSB0b2dnbGVkIHRvIHRydWVcbiAgLy8gRm9yIGV4YW1wbGUgPHNjcmlwdCBkYXRhLXNlYXJjaC1wc2V1ZG8tZWxlbWVudHMgc3JjPVwiLi4uXCI+PC9zY3JpcHQ+XG4gIGlmICh2YWwgPT09ICcnKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodmFsID09PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdmFsO1xufVxuXG5pZiAoRE9DVU1FTlQgJiYgdHlwZW9mIERPQ1VNRU5ULnF1ZXJ5U2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgdmFyIGF0dHJzID0gW1snZGF0YS1mYW1pbHktcHJlZml4JywgJ2ZhbWlseVByZWZpeCddLCBbJ2RhdGEtcmVwbGFjZW1lbnQtY2xhc3MnLCAncmVwbGFjZW1lbnRDbGFzcyddLCBbJ2RhdGEtYXV0by1yZXBsYWNlLXN2ZycsICdhdXRvUmVwbGFjZVN2ZyddLCBbJ2RhdGEtYXV0by1hZGQtY3NzJywgJ2F1dG9BZGRDc3MnXSwgWydkYXRhLWF1dG8tYTExeScsICdhdXRvQTExeSddLCBbJ2RhdGEtc2VhcmNoLXBzZXVkby1lbGVtZW50cycsICdzZWFyY2hQc2V1ZG9FbGVtZW50cyddLCBbJ2RhdGEtb2JzZXJ2ZS1tdXRhdGlvbnMnLCAnb2JzZXJ2ZU11dGF0aW9ucyddLCBbJ2RhdGEtbXV0YXRlLWFwcHJvYWNoJywgJ211dGF0ZUFwcHJvYWNoJ10sIFsnZGF0YS1rZWVwLW9yaWdpbmFsLXNvdXJjZScsICdrZWVwT3JpZ2luYWxTb3VyY2UnXSwgWydkYXRhLW1lYXN1cmUtcGVyZm9ybWFuY2UnLCAnbWVhc3VyZVBlcmZvcm1hbmNlJ10sIFsnZGF0YS1zaG93LW1pc3NpbmctaWNvbnMnLCAnc2hvd01pc3NpbmdJY29ucyddXTtcbiAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICBhdHRyID0gX3JlZjJbMF0sXG4gICAgICAgIGtleSA9IF9yZWYyWzFdO1xuXG4gICAgdmFyIHZhbCA9IGNvZXJjZShnZXRBdHRyQ29uZmlnKGF0dHIpKTtcblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGluaXRpYWxba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgX2RlZmF1bHQgPSB7XG4gIGZhbWlseVByZWZpeDogREVGQVVMVF9GQU1JTFlfUFJFRklYLFxuICByZXBsYWNlbWVudENsYXNzOiBERUZBVUxUX1JFUExBQ0VNRU5UX0NMQVNTLFxuICBhdXRvUmVwbGFjZVN2ZzogdHJ1ZSxcbiAgYXV0b0FkZENzczogdHJ1ZSxcbiAgYXV0b0ExMXk6IHRydWUsXG4gIHNlYXJjaFBzZXVkb0VsZW1lbnRzOiBmYWxzZSxcbiAgb2JzZXJ2ZU11dGF0aW9uczogdHJ1ZSxcbiAgbXV0YXRlQXBwcm9hY2g6ICdhc3luYycsXG4gIGtlZXBPcmlnaW5hbFNvdXJjZTogdHJ1ZSxcbiAgbWVhc3VyZVBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgc2hvd01pc3NpbmdJY29uczogdHJ1ZVxufTtcblxudmFyIF9jb25maWcgPSBfb2JqZWN0U3ByZWFkKHt9LCBfZGVmYXVsdCwgaW5pdGlhbCk7XG5cbmlmICghX2NvbmZpZy5hdXRvUmVwbGFjZVN2ZykgX2NvbmZpZy5vYnNlcnZlTXV0YXRpb25zID0gZmFsc2U7XG5cbnZhciBjb25maWcgPSBfb2JqZWN0U3ByZWFkKHt9LCBfY29uZmlnKTtcblxuV0lORE9XLkZvbnRBd2Vzb21lQ29uZmlnID0gY29uZmlnO1xuXG52YXIgdyA9IFdJTkRPVyB8fCB7fTtcbmlmICghd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0pIHdbTkFNRVNQQUNFX0lERU5USUZJRVJdID0ge307XG5pZiAoIXdbTkFNRVNQQUNFX0lERU5USUZJRVJdLnN0eWxlcykgd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uc3R5bGVzID0ge307XG5pZiAoIXdbTkFNRVNQQUNFX0lERU5USUZJRVJdLmhvb2tzKSB3W05BTUVTUEFDRV9JREVOVElGSUVSXS5ob29rcyA9IHt9O1xuaWYgKCF3W05BTUVTUEFDRV9JREVOVElGSUVSXS5zaGltcykgd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uc2hpbXMgPSBbXTtcbnZhciBuYW1lc3BhY2UgPSB3W05BTUVTUEFDRV9JREVOVElGSUVSXTtcblxudmFyIGZ1bmN0aW9ucyA9IFtdO1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgRE9DVU1FTlQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGxpc3RlbmVyKTtcbiAgbG9hZGVkID0gMTtcbiAgZnVuY3Rpb25zLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSk7XG59O1xuXG52YXIgbG9hZGVkID0gZmFsc2U7XG5cbmlmIChJU19ET00pIHtcbiAgbG9hZGVkID0gKERPQ1VNRU5ULmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChET0NVTUVOVC5yZWFkeVN0YXRlKTtcbiAgaWYgKCFsb2FkZWQpIERPQ1VNRU5ULmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBsaXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGRvbXJlYWR5IChmbikge1xuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICBsb2FkZWQgPyBzZXRUaW1lb3V0KGZuLCAwKSA6IGZ1bmN0aW9ucy5wdXNoKGZuKTtcbn1cblxudmFyIFBFTkRJTkcgPSAncGVuZGluZyc7XG52YXIgU0VUVExFRCA9ICdzZXR0bGVkJztcbnZhciBGVUxGSUxMRUQgPSAnZnVsZmlsbGVkJztcbnZhciBSRUpFQ1RFRCA9ICdyZWplY3RlZCc7XG5cbnZhciBOT09QID0gZnVuY3Rpb24gTk9PUCgpIHt9O1xuXG52YXIgaXNOb2RlID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLnByb2Nlc3MuZW1pdCA9PT0gJ2Z1bmN0aW9uJztcbnZhciBhc3luY1NldFRpbWVyID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ3VuZGVmaW5lZCcgPyBzZXRUaW1lb3V0IDogc2V0SW1tZWRpYXRlO1xudmFyIGFzeW5jUXVldWUgPSBbXTtcbnZhciBhc3luY1RpbWVyO1xuXG5mdW5jdGlvbiBhc3luY0ZsdXNoKCkge1xuICAvLyBydW4gcHJvbWlzZSBjYWxsYmFja3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3luY1F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgYXN5bmNRdWV1ZVtpXVswXShhc3luY1F1ZXVlW2ldWzFdKTtcbiAgfSAvLyByZXNldCBhc3luYyBhc3luY1F1ZXVlXG5cblxuICBhc3luY1F1ZXVlID0gW107XG4gIGFzeW5jVGltZXIgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXN5bmNDYWxsKGNhbGxiYWNrLCBhcmcpIHtcbiAgYXN5bmNRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnXSk7XG5cbiAgaWYgKCFhc3luY1RpbWVyKSB7XG4gICAgYXN5bmNUaW1lciA9IHRydWU7XG4gICAgYXN5bmNTZXRUaW1lcihhc3luY0ZsdXNoLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VSZXNvbHZlcihyZXNvbHZlciwgcHJvbWlzZSkge1xuICBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0UHJvbWlzZShlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzdWJzY3JpYmVyKSB7XG4gIHZhciBvd25lciA9IHN1YnNjcmliZXIub3duZXI7XG4gIHZhciBzZXR0bGVkID0gb3duZXIuX3N0YXRlO1xuICB2YXIgdmFsdWUgPSBvd25lci5fZGF0YTtcbiAgdmFyIGNhbGxiYWNrID0gc3Vic2NyaWJlcltzZXR0bGVkXTtcbiAgdmFyIHByb21pc2UgPSBzdWJzY3JpYmVyLnRoZW47XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNldHRsZWQgPSBGVUxGSUxMRUQ7XG5cbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpKSB7XG4gICAgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkge1xuICB2YXIgcmVzb2x2ZWQ7XG5cbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAvLyB0aGVuIHNob3VsZCBiZSByZXRyaWV2ZWQgb25seSBvbmNlXG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW47XG5cbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlIHx8ICFoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHByb21pc2UuX3N0YXRlID0gU0VUVExFRDtcbiAgICBwcm9taXNlLl9kYXRhID0gdmFsdWU7XG4gICAgYXN5bmNDYWxsKHB1Ymxpc2hGdWxmaWxsbWVudCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICBwcm9taXNlLl9zdGF0ZSA9IFNFVFRMRUQ7XG4gICAgcHJvbWlzZS5fZGF0YSA9IHJlYXNvbjtcbiAgICBhc3luY0NhbGwocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHByb21pc2UuX3RoZW4gPSBwcm9taXNlLl90aGVuLmZvckVhY2goaW52b2tlQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwdWJsaXNoRnVsZmlsbG1lbnQocHJvbWlzZSkge1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHB1Ymxpc2gocHJvbWlzZSk7XG5cbiAgaWYgKCFwcm9taXNlLl9oYW5kbGVkICYmIGlzTm9kZSkge1xuICAgIGdsb2JhbC5wcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHByb21pc2UuX2RhdGEsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vdGlmeVJlamVjdGlvbkhhbmRsZWQocHJvbWlzZSkge1xuICBnbG9iYWwucHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG59XG4vKipcbiAqIEBjbGFzc1xuICovXG5cblxuZnVuY3Rpb24gUChyZXNvbHZlcikge1xuICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSByZXNvbHZlciAnICsgcmVzb2x2ZXIgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodGhpcyBpbnN0YW5jZW9mIFAgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdQcm9taXNlXFwnOiBQbGVhc2UgdXNlIHRoZSBcXCduZXdcXCcgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHRoaXMuX3RoZW4gPSBbXTtcbiAgaW52b2tlUmVzb2x2ZXIocmVzb2x2ZXIsIHRoaXMpO1xufVxuXG5QLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFAsXG4gIF9zdGF0ZTogUEVORElORyxcbiAgX3RoZW46IG51bGwsXG4gIF9kYXRhOiB1bmRlZmluZWQsXG4gIF9oYW5kbGVkOiBmYWxzZSxcbiAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgIHZhciBzdWJzY3JpYmVyID0ge1xuICAgICAgb3duZXI6IHRoaXMsXG4gICAgICB0aGVuOiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihOT09QKSxcbiAgICAgIGZ1bGZpbGxlZDogb25GdWxmaWxsbWVudCxcbiAgICAgIHJlamVjdGVkOiBvblJlamVjdGlvblxuICAgIH07XG5cbiAgICBpZiAoKG9uUmVqZWN0aW9uIHx8IG9uRnVsZmlsbG1lbnQpICYmICF0aGlzLl9oYW5kbGVkKSB7XG4gICAgICB0aGlzLl9oYW5kbGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBSRUpFQ1RFRCAmJiBpc05vZGUpIHtcbiAgICAgICAgYXN5bmNDYWxsKG5vdGlmeVJlamVjdGlvbkhhbmRsZWQsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gRlVMRklMTEVEIHx8IHRoaXMuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZCwgY2FsbCBjYWxsYmFjayBhc3luY1xuICAgICAgYXN5bmNDYWxsKGludm9rZUNhbGxiYWNrLCBzdWJzY3JpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3Vic2NyaWJlXG4gICAgICB0aGlzLl90aGVuLnB1c2goc3Vic2NyaWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmliZXIudGhlbjtcbiAgfSxcbiAgY2F0Y2g6IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9XG59O1xuXG5QLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byBQcm9taXNlLmFsbCgpLicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciByZW1haW5pbmcgPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoaW5kZXgpIHtcbiAgICAgIHJlbWFpbmluZysrO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICghIC0tcmVtYWluaW5nKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgcHJvbWlzZTsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZXNbaV07XG5cbiAgICAgIGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmVyKGkpLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IHByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9KTtcbn07XG5cblAucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byBQcm9taXNlLnJhY2UoKS4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG4gICAgICBpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFApIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSk7XG59O1xuXG5QLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgcmV0dXJuIG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG52YXIgcGlja2VkID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlIDogUDtcblxudmFyIGQgPSBVTklUU19JTl9HUklEO1xudmFyIG1lYW5pbmdsZXNzVHJhbnNmb3JtID0ge1xuICBzaXplOiAxNixcbiAgeDogMCxcbiAgeTogMCxcbiAgcm90YXRlOiAwLFxuICBmbGlwWDogZmFsc2UsXG4gIGZsaXBZOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNSZXNlcnZlZChuYW1lKSB7XG4gIHJldHVybiB+UkVTRVJWRURfQ0xBU1NFUy5pbmRleE9mKG5hbWUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0Q3NzKGNzcykge1xuICBpZiAoIWNzcyB8fCAhSVNfRE9NKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gRE9DVU1FTlQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIHN0eWxlLmlubmVySFRNTCA9IGNzcztcbiAgdmFyIGhlYWRDaGlsZHJlbiA9IERPQ1VNRU5ULmhlYWQuY2hpbGROb2RlcztcbiAgdmFyIGJlZm9yZUNoaWxkID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gaGVhZENoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgdmFyIGNoaWxkID0gaGVhZENoaWxkcmVuW2ldO1xuICAgIHZhciB0YWdOYW1lID0gKGNoaWxkLnRhZ05hbWUgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAoWydTVFlMRScsICdMSU5LJ10uaW5kZXhPZih0YWdOYW1lKSA+IC0xKSB7XG4gICAgICBiZWZvcmVDaGlsZCA9IGNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIERPQ1VNRU5ULmhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBiZWZvcmVDaGlsZCk7XG4gIHJldHVybiBjc3M7XG59XG52YXIgaWRQb29sID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJztcbmZ1bmN0aW9uIG5leHRVbmlxdWVJZCgpIHtcbiAgdmFyIHNpemUgPSAxMjtcbiAgdmFyIGlkID0gJyc7XG5cbiAgd2hpbGUgKHNpemUtLSA+IDApIHtcbiAgICBpZCArPSBpZFBvb2xbTWF0aC5yYW5kb20oKSAqIDYyIHwgMF07XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gKG9iaiB8fCBbXSkubGVuZ3RoID4+PiAwOyBpLS07KSB7XG4gICAgYXJyYXlbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjbGFzc0FycmF5KG5vZGUpIHtcbiAgaWYgKG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIHRvQXJyYXkobm9kZS5jbGFzc0xpc3QpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SWNvbk5hbWUoZmFtaWx5UHJlZml4LCBjbHMpIHtcbiAgdmFyIHBhcnRzID0gY2xzLnNwbGl0KCctJyk7XG4gIHZhciBwcmVmaXggPSBwYXJ0c1swXTtcbiAgdmFyIGljb25OYW1lID0gcGFydHMuc2xpY2UoMSkuam9pbignLScpO1xuXG4gIGlmIChwcmVmaXggPT09IGZhbWlseVByZWZpeCAmJiBpY29uTmFtZSAhPT0gJycgJiYgIWlzUmVzZXJ2ZWQoaWNvbk5hbWUpKSB7XG4gICAgcmV0dXJuIGljb25OYW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBodG1sRXNjYXBlKHN0cikge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RyKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmIzM5OycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5mdW5jdGlvbiBqb2luQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBhY2MgKyBcIlwiLmNvbmNhdChhdHRyaWJ1dGVOYW1lLCBcIj1cXFwiXCIpLmNvbmNhdChodG1sRXNjYXBlKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pLCBcIlxcXCIgXCIpO1xuICB9LCAnJykudHJpbSgpO1xufVxuZnVuY3Rpb24gam9pblN0eWxlcyhzdHlsZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlcyB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHN0eWxlTmFtZSkge1xuICAgIHJldHVybiBhY2MgKyBcIlwiLmNvbmNhdChzdHlsZU5hbWUsIFwiOiBcIikuY29uY2F0KHN0eWxlc1tzdHlsZU5hbWVdLCBcIjtcIik7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUlzTWVhbmluZ2Z1bCh0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHRyYW5zZm9ybS5zaXplICE9PSBtZWFuaW5nbGVzc1RyYW5zZm9ybS5zaXplIHx8IHRyYW5zZm9ybS54ICE9PSBtZWFuaW5nbGVzc1RyYW5zZm9ybS54IHx8IHRyYW5zZm9ybS55ICE9PSBtZWFuaW5nbGVzc1RyYW5zZm9ybS55IHx8IHRyYW5zZm9ybS5yb3RhdGUgIT09IG1lYW5pbmdsZXNzVHJhbnNmb3JtLnJvdGF0ZSB8fCB0cmFuc2Zvcm0uZmxpcFggfHwgdHJhbnNmb3JtLmZsaXBZO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRm9yU3ZnKF9yZWYpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgY29udGFpbmVyV2lkdGggPSBfcmVmLmNvbnRhaW5lcldpZHRoLFxuICAgICAgaWNvbldpZHRoID0gX3JlZi5pY29uV2lkdGg7XG4gIHZhciBvdXRlciA9IHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChjb250YWluZXJXaWR0aCAvIDIsIFwiIDI1NilcIilcbiAgfTtcbiAgdmFyIGlubmVyVHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zZm9ybS54ICogMzIsIFwiLCBcIikuY29uY2F0KHRyYW5zZm9ybS55ICogMzIsIFwiKSBcIik7XG4gIHZhciBpbm5lclNjYWxlID0gXCJzY2FsZShcIi5jb25jYXQodHJhbnNmb3JtLnNpemUgLyAxNiAqICh0cmFuc2Zvcm0uZmxpcFggPyAtMSA6IDEpLCBcIiwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0uc2l6ZSAvIDE2ICogKHRyYW5zZm9ybS5mbGlwWSA/IC0xIDogMSksIFwiKSBcIik7XG4gIHZhciBpbm5lclJvdGF0ZSA9IFwicm90YXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ucm90YXRlLCBcIiAwIDApXCIpO1xuICB2YXIgaW5uZXIgPSB7XG4gICAgdHJhbnNmb3JtOiBcIlwiLmNvbmNhdChpbm5lclRyYW5zbGF0ZSwgXCIgXCIpLmNvbmNhdChpbm5lclNjYWxlLCBcIiBcIikuY29uY2F0KGlubmVyUm90YXRlKVxuICB9O1xuICB2YXIgcGF0aCA9IHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChpY29uV2lkdGggLyAyICogLTEsIFwiIC0yNTYpXCIpXG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IG91dGVyLFxuICAgIGlubmVyOiBpbm5lcixcbiAgICBwYXRoOiBwYXRoXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Gb3JDc3MoX3JlZjIpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IF9yZWYyLnRyYW5zZm9ybSxcbiAgICAgIF9yZWYyJHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICB3aWR0aCA9IF9yZWYyJHdpZHRoID09PSB2b2lkIDAgPyBVTklUU19JTl9HUklEIDogX3JlZjIkd2lkdGgsXG4gICAgICBfcmVmMiRoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfcmVmMiRoZWlnaHQgPT09IHZvaWQgMCA/IFVOSVRTX0lOX0dSSUQgOiBfcmVmMiRoZWlnaHQsXG4gICAgICBfcmVmMiRzdGFydENlbnRlcmVkID0gX3JlZjIuc3RhcnRDZW50ZXJlZCxcbiAgICAgIHN0YXJ0Q2VudGVyZWQgPSBfcmVmMiRzdGFydENlbnRlcmVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJHN0YXJ0Q2VudGVyZWQ7XG4gIHZhciB2YWwgPSAnJztcblxuICBpZiAoc3RhcnRDZW50ZXJlZCAmJiBJU19JRSkge1xuICAgIHZhbCArPSBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNmb3JtLnggLyBkIC0gd2lkdGggLyAyLCBcImVtLCBcIikuY29uY2F0KHRyYW5zZm9ybS55IC8gZCAtIGhlaWdodCAvIDIsIFwiZW0pIFwiKTtcbiAgfSBlbHNlIGlmIChzdGFydENlbnRlcmVkKSB7XG4gICAgdmFsICs9IFwidHJhbnNsYXRlKGNhbGMoLTUwJSArIFwiLmNvbmNhdCh0cmFuc2Zvcm0ueCAvIGQsIFwiZW0pLCBjYWxjKC01MCUgKyBcIikuY29uY2F0KHRyYW5zZm9ybS55IC8gZCwgXCJlbSkpIFwiKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgKz0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zZm9ybS54IC8gZCwgXCJlbSwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAvIGQsIFwiZW0pIFwiKTtcbiAgfVxuXG4gIHZhbCArPSBcInNjYWxlKFwiLmNvbmNhdCh0cmFuc2Zvcm0uc2l6ZSAvIGQgKiAodHJhbnNmb3JtLmZsaXBYID8gLTEgOiAxKSwgXCIsIFwiKS5jb25jYXQodHJhbnNmb3JtLnNpemUgLyBkICogKHRyYW5zZm9ybS5mbGlwWSA/IC0xIDogMSksIFwiKSBcIik7XG4gIHZhbCArPSBcInJvdGF0ZShcIi5jb25jYXQodHJhbnNmb3JtLnJvdGF0ZSwgXCJkZWcpIFwiKTtcbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIEFMTF9TUEFDRSA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJSdcbn07XG5mdW5jdGlvbiBtYWtlSWNvbk1hc2tpbmcgKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBtYWluID0gX3JlZi5tYWluLFxuICAgICAgbWFzayA9IF9yZWYubWFzayxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtO1xuICB2YXIgbWFpbldpZHRoID0gbWFpbi53aWR0aCxcbiAgICAgIG1haW5QYXRoID0gbWFpbi5pY29uO1xuICB2YXIgbWFza1dpZHRoID0gbWFzay53aWR0aCxcbiAgICAgIG1hc2tQYXRoID0gbWFzay5pY29uO1xuICB2YXIgdHJhbnMgPSB0cmFuc2Zvcm1Gb3JTdmcoe1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIGNvbnRhaW5lcldpZHRoOiBtYXNrV2lkdGgsXG4gICAgaWNvbldpZHRoOiBtYWluV2lkdGhcbiAgfSk7XG4gIHZhciBtYXNrUmVjdCA9IHtcbiAgICB0YWc6ICdyZWN0JyxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBBTExfU1BBQ0UsIHtcbiAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICB9KVxuICB9O1xuICB2YXIgbWFza0lubmVyR3JvdXAgPSB7XG4gICAgdGFnOiAnZycsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgdHJhbnMuaW5uZXIpLFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgdGFnOiAncGF0aCcsXG4gICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBtYWluUGF0aC5hdHRyaWJ1dGVzLCB0cmFucy5wYXRoLCB7XG4gICAgICAgIGZpbGw6ICdibGFjaydcbiAgICAgIH0pXG4gICAgfV1cbiAgfTtcbiAgdmFyIG1hc2tPdXRlckdyb3VwID0ge1xuICAgIHRhZzogJ2cnLFxuICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIHRyYW5zLm91dGVyKSxcbiAgICBjaGlsZHJlbjogW21hc2tJbm5lckdyb3VwXVxuICB9O1xuICB2YXIgbWFza0lkID0gXCJtYXNrLVwiLmNvbmNhdChuZXh0VW5pcXVlSWQoKSk7XG4gIHZhciBjbGlwSWQgPSBcImNsaXAtXCIuY29uY2F0KG5leHRVbmlxdWVJZCgpKTtcbiAgdmFyIG1hc2tUYWcgPSB7XG4gICAgdGFnOiAnbWFzaycsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgQUxMX1NQQUNFLCB7XG4gICAgICBpZDogbWFza0lkLFxuICAgICAgbWFza1VuaXRzOiAndXNlclNwYWNlT25Vc2UnLFxuICAgICAgbWFza0NvbnRlbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgIH0pLFxuICAgIGNoaWxkcmVuOiBbbWFza1JlY3QsIG1hc2tPdXRlckdyb3VwXVxuICB9O1xuICB2YXIgZGVmcyA9IHtcbiAgICB0YWc6ICdkZWZzJyxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIHRhZzogJ2NsaXBQYXRoJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgaWQ6IGNsaXBJZFxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbbWFza1BhdGhdXG4gICAgfSwgbWFza1RhZ11cbiAgfTtcbiAgY2hpbGRyZW4ucHVzaChkZWZzLCB7XG4gICAgdGFnOiAncmVjdCcsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7XG4gICAgICBmaWxsOiAnY3VycmVudENvbG9yJyxcbiAgICAgICdjbGlwLXBhdGgnOiBcInVybCgjXCIuY29uY2F0KGNsaXBJZCwgXCIpXCIpLFxuICAgICAgbWFzazogXCJ1cmwoI1wiLmNvbmNhdChtYXNrSWQsIFwiKVwiKVxuICAgIH0sIEFMTF9TUEFDRSlcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUljb25TdGFuZGFyZCAoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXR0cmlidXRlcyA9IF9yZWYuYXR0cmlidXRlcyxcbiAgICAgIG1haW4gPSBfcmVmLm1haW4sXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgIHN0eWxlcyA9IF9yZWYuc3R5bGVzO1xuICB2YXIgc3R5bGVTdHJpbmcgPSBqb2luU3R5bGVzKHN0eWxlcyk7XG5cbiAgaWYgKHN0eWxlU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBhdHRyaWJ1dGVzWydzdHlsZSddID0gc3R5bGVTdHJpbmc7XG4gIH1cblxuICBpZiAodHJhbnNmb3JtSXNNZWFuaW5nZnVsKHRyYW5zZm9ybSkpIHtcbiAgICB2YXIgdHJhbnMgPSB0cmFuc2Zvcm1Gb3JTdmcoe1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBjb250YWluZXJXaWR0aDogbWFpbi53aWR0aCxcbiAgICAgIGljb25XaWR0aDogbWFpbi53aWR0aFxuICAgIH0pO1xuICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgdGFnOiAnZycsXG4gICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCB0cmFucy5vdXRlciksXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnOiAnZycsXG4gICAgICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIHRyYW5zLmlubmVyKSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdGFnOiBtYWluLmljb24udGFnLFxuICAgICAgICAgIGNoaWxkcmVuOiBtYWluLmljb24uY2hpbGRyZW4sXG4gICAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgbWFpbi5pY29uLmF0dHJpYnV0ZXMsIHRyYW5zLnBhdGgpXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuLnB1c2gobWFpbi5pY29uKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNJY29uIChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBtYWluID0gX3JlZi5tYWluLFxuICAgICAgbWFzayA9IF9yZWYubWFzayxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBzdHlsZXMgPSBfcmVmLnN0eWxlcyxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtO1xuXG4gIGlmICh0cmFuc2Zvcm1Jc01lYW5pbmdmdWwodHJhbnNmb3JtKSAmJiBtYWluLmZvdW5kICYmICFtYXNrLmZvdW5kKSB7XG4gICAgdmFyIHdpZHRoID0gbWFpbi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gbWFpbi5oZWlnaHQ7XG4gICAgdmFyIG9mZnNldCA9IHtcbiAgICAgIHg6IHdpZHRoIC8gaGVpZ2h0IC8gMixcbiAgICAgIHk6IDAuNVxuICAgIH07XG4gICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IGpvaW5TdHlsZXMoX29iamVjdFNwcmVhZCh7fSwgc3R5bGVzLCB7XG4gICAgICAndHJhbnNmb3JtLW9yaWdpbic6IFwiXCIuY29uY2F0KG9mZnNldC54ICsgdHJhbnNmb3JtLnggLyAxNiwgXCJlbSBcIikuY29uY2F0KG9mZnNldC55ICsgdHJhbnNmb3JtLnkgLyAxNiwgXCJlbVwiKVxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBbe1xuICAgIHRhZzogJ3N2ZycsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfV07XG59XG5cbmZ1bmN0aW9uIGFzU3ltYm9sIChfcmVmKSB7XG4gIHZhciBwcmVmaXggPSBfcmVmLnByZWZpeCxcbiAgICAgIGljb25OYW1lID0gX3JlZi5pY29uTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBzeW1ib2wgPSBfcmVmLnN5bWJvbDtcbiAgdmFyIGlkID0gc3ltYm9sID09PSB0cnVlID8gXCJcIi5jb25jYXQocHJlZml4LCBcIi1cIikuY29uY2F0KGNvbmZpZy5mYW1pbHlQcmVmaXgsIFwiLVwiKS5jb25jYXQoaWNvbk5hbWUpIDogc3ltYm9sO1xuICByZXR1cm4gW3tcbiAgICB0YWc6ICdzdmcnLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHN0eWxlOiAnZGlzcGxheTogbm9uZTsnXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIHRhZzogJ3N5bWJvbCcsXG4gICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICAgIGlkOiBpZFxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9XVxuICB9XTtcbn1cblxuZnVuY3Rpb24gbWFrZUlubGluZVN2Z0Fic3RyYWN0KHBhcmFtcykge1xuICB2YXIgX3BhcmFtcyRpY29ucyA9IHBhcmFtcy5pY29ucyxcbiAgICAgIG1haW4gPSBfcGFyYW1zJGljb25zLm1haW4sXG4gICAgICBtYXNrID0gX3BhcmFtcyRpY29ucy5tYXNrLFxuICAgICAgcHJlZml4ID0gcGFyYW1zLnByZWZpeCxcbiAgICAgIGljb25OYW1lID0gcGFyYW1zLmljb25OYW1lLFxuICAgICAgdHJhbnNmb3JtID0gcGFyYW1zLnRyYW5zZm9ybSxcbiAgICAgIHN5bWJvbCA9IHBhcmFtcy5zeW1ib2wsXG4gICAgICB0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIGV4dHJhID0gcGFyYW1zLmV4dHJhLFxuICAgICAgX3BhcmFtcyR3YXRjaGFibGUgPSBwYXJhbXMud2F0Y2hhYmxlLFxuICAgICAgd2F0Y2hhYmxlID0gX3BhcmFtcyR3YXRjaGFibGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhcmFtcyR3YXRjaGFibGU7XG5cbiAgdmFyIF9yZWYgPSBtYXNrLmZvdW5kID8gbWFzayA6IG1haW4sXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICB2YXIgd2lkdGhDbGFzcyA9IFwiZmEtdy1cIi5jb25jYXQoTWF0aC5jZWlsKHdpZHRoIC8gaGVpZ2h0ICogMTYpKTtcbiAgdmFyIGF0dHJDbGFzcyA9IFtjb25maWcucmVwbGFjZW1lbnRDbGFzcywgaWNvbk5hbWUgPyBcIlwiLmNvbmNhdChjb25maWcuZmFtaWx5UHJlZml4LCBcIi1cIikuY29uY2F0KGljb25OYW1lKSA6ICcnLCB3aWR0aENsYXNzXS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gZXh0cmEuY2xhc3Nlcy5pbmRleE9mKGMpID09PSAtMTtcbiAgfSkuY29uY2F0KGV4dHJhLmNsYXNzZXMpLmpvaW4oJyAnKTtcbiAgdmFyIGNvbnRlbnQgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIGV4dHJhLmF0dHJpYnV0ZXMsIHtcbiAgICAgICdkYXRhLXByZWZpeCc6IHByZWZpeCxcbiAgICAgICdkYXRhLWljb24nOiBpY29uTmFtZSxcbiAgICAgICdjbGFzcyc6IGF0dHJDbGFzcyxcbiAgICAgICdyb2xlJzogZXh0cmEuYXR0cmlidXRlcy5yb2xlIHx8ICdpbWcnLFxuICAgICAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICd2aWV3Qm94JzogXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodClcbiAgICB9KVxuICB9O1xuXG4gIGlmICh3YXRjaGFibGUpIHtcbiAgICBjb250ZW50LmF0dHJpYnV0ZXNbREFUQV9GQV9JMlNWR10gPSAnJztcbiAgfVxuXG4gIGlmICh0aXRsZSkgY29udGVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICB0YWc6ICd0aXRsZScsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgaWQ6IGNvbnRlbnQuYXR0cmlidXRlc1snYXJpYS1sYWJlbGxlZGJ5J10gfHwgXCJ0aXRsZS1cIi5jb25jYXQobmV4dFVuaXF1ZUlkKCkpXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3RpdGxlXVxuICB9KTtcblxuICB2YXIgYXJncyA9IF9vYmplY3RTcHJlYWQoe30sIGNvbnRlbnQsIHtcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBpY29uTmFtZTogaWNvbk5hbWUsXG4gICAgbWFpbjogbWFpbixcbiAgICBtYXNrOiBtYXNrLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIHN5bWJvbDogc3ltYm9sLFxuICAgIHN0eWxlczogZXh0cmEuc3R5bGVzXG4gIH0pO1xuXG4gIHZhciBfcmVmMiA9IG1hc2suZm91bmQgJiYgbWFpbi5mb3VuZCA/IG1ha2VJY29uTWFza2luZyhhcmdzKSA6IG1ha2VJY29uU3RhbmRhcmQoYXJncyksXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuLFxuICAgICAgYXR0cmlidXRlcyA9IF9yZWYyLmF0dHJpYnV0ZXM7XG5cbiAgYXJncy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICBhcmdzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gIGlmIChzeW1ib2wpIHtcbiAgICByZXR1cm4gYXNTeW1ib2woYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzSWNvbihhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFrZUxheWVyc1RleHRBYnN0cmFjdChwYXJhbXMpIHtcbiAgdmFyIGNvbnRlbnQgPSBwYXJhbXMuY29udGVudCxcbiAgICAgIHdpZHRoID0gcGFyYW1zLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCxcbiAgICAgIHRyYW5zZm9ybSA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICB0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIGV4dHJhID0gcGFyYW1zLmV4dHJhLFxuICAgICAgX3BhcmFtcyR3YXRjaGFibGUyID0gcGFyYW1zLndhdGNoYWJsZSxcbiAgICAgIHdhdGNoYWJsZSA9IF9wYXJhbXMkd2F0Y2hhYmxlMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGFyYW1zJHdhdGNoYWJsZTI7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBfb2JqZWN0U3ByZWFkKHt9LCBleHRyYS5hdHRyaWJ1dGVzLCB0aXRsZSA/IHtcbiAgICAndGl0bGUnOiB0aXRsZVxuICB9IDoge30sIHtcbiAgICAnY2xhc3MnOiBleHRyYS5jbGFzc2VzLmpvaW4oJyAnKVxuICB9KTtcblxuICBpZiAod2F0Y2hhYmxlKSB7XG4gICAgYXR0cmlidXRlc1tEQVRBX0ZBX0kyU1ZHXSA9ICcnO1xuICB9XG5cbiAgdmFyIHN0eWxlcyA9IF9vYmplY3RTcHJlYWQoe30sIGV4dHJhLnN0eWxlcyk7XG5cbiAgaWYgKHRyYW5zZm9ybUlzTWVhbmluZ2Z1bCh0cmFuc2Zvcm0pKSB7XG4gICAgc3R5bGVzWyd0cmFuc2Zvcm0nXSA9IHRyYW5zZm9ybUZvckNzcyh7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHN0YXJ0Q2VudGVyZWQ6IHRydWUsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0pO1xuICAgIHN0eWxlc1snLXdlYmtpdC10cmFuc2Zvcm0nXSA9IHN0eWxlc1sndHJhbnNmb3JtJ107XG4gIH1cblxuICB2YXIgc3R5bGVTdHJpbmcgPSBqb2luU3R5bGVzKHN0eWxlcyk7XG5cbiAgaWYgKHN0eWxlU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBhdHRyaWJ1dGVzWydzdHlsZSddID0gc3R5bGVTdHJpbmc7XG4gIH1cblxuICB2YXIgdmFsID0gW107XG4gIHZhbC5wdXNoKHtcbiAgICB0YWc6ICdzcGFuJyxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuOiBbY29udGVudF1cbiAgfSk7XG5cbiAgaWYgKHRpdGxlKSB7XG4gICAgdmFsLnB1c2goe1xuICAgICAgdGFnOiAnc3BhbicsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGNsYXNzOiAnc3Itb25seSdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogW3RpdGxlXVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIG1ha2VMYXllcnNDb3VudGVyQWJzdHJhY3QocGFyYW1zKSB7XG4gIHZhciBjb250ZW50ID0gcGFyYW1zLmNvbnRlbnQsXG4gICAgICB0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIGV4dHJhID0gcGFyYW1zLmV4dHJhO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gX29iamVjdFNwcmVhZCh7fSwgZXh0cmEuYXR0cmlidXRlcywgdGl0bGUgPyB7XG4gICAgJ3RpdGxlJzogdGl0bGVcbiAgfSA6IHt9LCB7XG4gICAgJ2NsYXNzJzogZXh0cmEuY2xhc3Nlcy5qb2luKCcgJylcbiAgfSk7XG5cbiAgdmFyIHN0eWxlU3RyaW5nID0gam9pblN0eWxlcyhleHRyYS5zdHlsZXMpO1xuXG4gIGlmIChzdHlsZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IHN0eWxlU3RyaW5nO1xuICB9XG5cbiAgdmFyIHZhbCA9IFtdO1xuICB2YWwucHVzaCh7XG4gICAgdGFnOiAnc3BhbicsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogW2NvbnRlbnRdXG4gIH0pO1xuXG4gIGlmICh0aXRsZSkge1xuICAgIHZhbC5wdXNoKHtcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBjbGFzczogJ3NyLW9ubHknXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFt0aXRsZV1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbnZhciBub29wJDEgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBwID0gY29uZmlnLm1lYXN1cmVQZXJmb3JtYW5jZSAmJiBQRVJGT1JNQU5DRSAmJiBQRVJGT1JNQU5DRS5tYXJrICYmIFBFUkZPUk1BTkNFLm1lYXN1cmUgPyBQRVJGT1JNQU5DRSA6IHtcbiAgbWFyazogbm9vcCQxLFxuICBtZWFzdXJlOiBub29wJDFcbn07XG52YXIgcHJlYW1ibGUgPSBcIkZBIFxcXCI1LjkuMFxcXCJcIjtcblxudmFyIGJlZ2luID0gZnVuY3Rpb24gYmVnaW4obmFtZSkge1xuICBwLm1hcmsoXCJcIi5jb25jYXQocHJlYW1ibGUsIFwiIFwiKS5jb25jYXQobmFtZSwgXCIgYmVnaW5zXCIpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZW5kKG5hbWUpO1xuICB9O1xufTtcblxudmFyIGVuZCA9IGZ1bmN0aW9uIGVuZChuYW1lKSB7XG4gIHAubWFyayhcIlwiLmNvbmNhdChwcmVhbWJsZSwgXCIgXCIpLmNvbmNhdChuYW1lLCBcIiBlbmRzXCIpKTtcbiAgcC5tZWFzdXJlKFwiXCIuY29uY2F0KHByZWFtYmxlLCBcIiBcIikuY29uY2F0KG5hbWUpLCBcIlwiLmNvbmNhdChwcmVhbWJsZSwgXCIgXCIpLmNvbmNhdChuYW1lLCBcIiBiZWdpbnNcIiksIFwiXCIuY29uY2F0KHByZWFtYmxlLCBcIiBcIikuY29uY2F0KG5hbWUsIFwiIGVuZHNcIikpO1xufTtcblxudmFyIHBlcmYgPSB7XG4gIGJlZ2luOiBiZWdpbixcbiAgZW5kOiBlbmRcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIHRvIGJpbmQgYSBmdW5jdGlvbiBrbm93biB0byBoYXZlIDQgYXJndW1lbnRzXG4gKiB0byBhIGdpdmVuIGNvbnRleHQuXG4gKi9cblxudmFyIGJpbmRJbnRlcm5hbDQgPSBmdW5jdGlvbiBiaW5kSW50ZXJuYWw0KGZ1bmMsIHRoaXNDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0NvbnRleHQsIGEsIGIsIGMsIGQpO1xuICB9O1xufTtcblxuLyoqXG4gKiAjIFJlZHVjZVxuICpcbiAqIEEgZmFzdCBvYmplY3QgYC5yZWR1Y2UoKWAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHN1YmplY3QgICAgICBUaGUgb2JqZWN0IHRvIHJlZHVjZSBvdmVyLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgICAgICBUaGUgcmVkdWNlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSAge21peGVkfSAgICBpbml0aWFsVmFsdWUgVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSByZWR1Y2VyLCBkZWZhdWx0cyB0byBzdWJqZWN0WzBdLlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHRoaXNDb250ZXh0ICBUaGUgY29udGV4dCBmb3IgdGhlIHJlZHVjZXIuXG4gKiBAcmV0dXJuIHttaXhlZH0gICAgICAgICAgICAgICAgIFRoZSBmaW5hbCByZXN1bHQuXG4gKi9cblxuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24gZmFzdFJlZHVjZU9iamVjdChzdWJqZWN0LCBmbiwgaW5pdGlhbFZhbHVlLCB0aGlzQ29udGV4dCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN1YmplY3QpLFxuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICBpdGVyYXRvciA9IHRoaXNDb250ZXh0ICE9PSB1bmRlZmluZWQgPyBiaW5kSW50ZXJuYWw0KGZuLCB0aGlzQ29udGV4dCkgOiBmbixcbiAgICAgIGksXG4gICAgICBrZXksXG4gICAgICByZXN1bHQ7XG5cbiAgaWYgKGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDE7XG4gICAgcmVzdWx0ID0gc3ViamVjdFtrZXlzWzBdXTtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgICByZXN1bHQgPSBpbml0aWFsVmFsdWU7XG4gIH1cblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICByZXN1bHQgPSBpdGVyYXRvcihyZXN1bHQsIHN1YmplY3Rba2V5XSwga2V5LCBzdWJqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiB0b0hleCh1bmljb2RlKSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaGV4ID0gdW5pY29kZS5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICByZXN1bHQgKz0gKCcwMDAnICsgaGV4KS5zbGljZSgtNCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVJY29ucyhwcmVmaXgsIGljb25zKSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgX3BhcmFtcyRza2lwSG9va3MgPSBwYXJhbXMuc2tpcEhvb2tzLFxuICAgICAgc2tpcEhvb2tzID0gX3BhcmFtcyRza2lwSG9va3MgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhcmFtcyRza2lwSG9va3M7XG4gIHZhciBub3JtYWxpemVkID0gT2JqZWN0LmtleXMoaWNvbnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpY29uTmFtZSkge1xuICAgIHZhciBpY29uID0gaWNvbnNbaWNvbk5hbWVdO1xuICAgIHZhciBleHBhbmRlZCA9ICEhaWNvbi5pY29uO1xuXG4gICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICBhY2NbaWNvbi5pY29uTmFtZV0gPSBpY29uLmljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1tpY29uTmFtZV0gPSBpY29uO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBpZiAodHlwZW9mIG5hbWVzcGFjZS5ob29rcy5hZGRQYWNrID09PSAnZnVuY3Rpb24nICYmICFza2lwSG9va3MpIHtcbiAgICBuYW1lc3BhY2UuaG9va3MuYWRkUGFjayhwcmVmaXgsIG5vcm1hbGl6ZWQpO1xuICB9IGVsc2Uge1xuICAgIG5hbWVzcGFjZS5zdHlsZXNbcHJlZml4XSA9IF9vYmplY3RTcHJlYWQoe30sIG5hbWVzcGFjZS5zdHlsZXNbcHJlZml4XSB8fCB7fSwgbm9ybWFsaXplZCk7XG4gIH1cbiAgLyoqXG4gICAqIEZvbnQgQXdlc29tZSA0IHVzZWQgdGhlIHByZWZpeCBvZiBgZmFgIGZvciBhbGwgaWNvbnMuIFdpdGggdGhlIGludHJvZHVjdGlvblxuICAgKiBvZiBuZXcgc3R5bGVzIHdlIG5lZWRlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlbS4gUHJlZml4IGBmYWAgaXMgbm93IGFuIGFsaWFzXG4gICAqIGZvciBgZmFzYCBzbyB3ZSdsbCBlYXN5IHRoZSB1cGdyYWRlIHByb2Nlc3MgZm9yIG91ciB1c2VycyBieSBhdXRvbWF0aWNhbGx5IGRlZmluaW5nXG4gICAqIHRoaXMgYXMgd2VsbC5cbiAgICovXG5cblxuICBpZiAocHJlZml4ID09PSAnZmFzJykge1xuICAgIGRlZmluZUljb25zKCdmYScsIGljb25zKTtcbiAgfVxufVxuXG52YXIgc3R5bGVzID0gbmFtZXNwYWNlLnN0eWxlcyxcbiAgICBzaGltcyA9IG5hbWVzcGFjZS5zaGltcztcbnZhciBfYnlVbmljb2RlID0ge307XG52YXIgX2J5TGlnYXR1cmUgPSB7fTtcbnZhciBfYnlPbGROYW1lID0ge307XG52YXIgYnVpbGQgPSBmdW5jdGlvbiBidWlsZCgpIHtcbiAgdmFyIGxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChyZWR1Y2VyKSB7XG4gICAgcmV0dXJuIHJlZHVjZShzdHlsZXMsIGZ1bmN0aW9uIChvLCBzdHlsZSwgcHJlZml4KSB7XG4gICAgICBvW3ByZWZpeF0gPSByZWR1Y2Uoc3R5bGUsIHJlZHVjZXIsIHt9KTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICBfYnlVbmljb2RlID0gbG9va3VwKGZ1bmN0aW9uIChhY2MsIGljb24sIGljb25OYW1lKSB7XG4gICAgaWYgKGljb25bM10pIHtcbiAgICAgIGFjY1tpY29uWzNdXSA9IGljb25OYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0pO1xuICBfYnlMaWdhdHVyZSA9IGxvb2t1cChmdW5jdGlvbiAoYWNjLCBpY29uLCBpY29uTmFtZSkge1xuICAgIHZhciBsaWdhdHVyZXMgPSBpY29uWzJdO1xuICAgIGFjY1tpY29uTmFtZV0gPSBpY29uTmFtZTtcbiAgICBsaWdhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAobGlnYXR1cmUpIHtcbiAgICAgIGFjY1tsaWdhdHVyZV0gPSBpY29uTmFtZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9KTtcbiAgdmFyIGhhc1JlZ3VsYXIgPSAnZmFyJyBpbiBzdHlsZXM7XG4gIF9ieU9sZE5hbWUgPSByZWR1Y2Uoc2hpbXMsIGZ1bmN0aW9uIChhY2MsIHNoaW0pIHtcbiAgICB2YXIgb2xkTmFtZSA9IHNoaW1bMF07XG4gICAgdmFyIHByZWZpeCA9IHNoaW1bMV07XG4gICAgdmFyIGljb25OYW1lID0gc2hpbVsyXTtcblxuICAgIGlmIChwcmVmaXggPT09ICdmYXInICYmICFoYXNSZWd1bGFyKSB7XG4gICAgICBwcmVmaXggPSAnZmFzJztcbiAgICB9XG5cbiAgICBhY2Nbb2xkTmFtZV0gPSB7XG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIGljb25OYW1lOiBpY29uTmFtZVxuICAgIH07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcbmJ1aWxkKCk7XG5mdW5jdGlvbiBieVVuaWNvZGUocHJlZml4LCB1bmljb2RlKSB7XG4gIHJldHVybiAoX2J5VW5pY29kZVtwcmVmaXhdIHx8IHt9KVt1bmljb2RlXTtcbn1cbmZ1bmN0aW9uIGJ5TGlnYXR1cmUocHJlZml4LCBsaWdhdHVyZSkge1xuICByZXR1cm4gKF9ieUxpZ2F0dXJlW3ByZWZpeF0gfHwge30pW2xpZ2F0dXJlXTtcbn1cbmZ1bmN0aW9uIGJ5T2xkTmFtZShuYW1lKSB7XG4gIHJldHVybiBfYnlPbGROYW1lW25hbWVdIHx8IHtcbiAgICBwcmVmaXg6IG51bGwsXG4gICAgaWNvbk5hbWU6IG51bGxcbiAgfTtcbn1cblxudmFyIHN0eWxlcyQxID0gbmFtZXNwYWNlLnN0eWxlcztcbnZhciBlbXB0eUNhbm9uaWNhbEljb24gPSBmdW5jdGlvbiBlbXB0eUNhbm9uaWNhbEljb24oKSB7XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBudWxsLFxuICAgIGljb25OYW1lOiBudWxsLFxuICAgIHJlc3Q6IFtdXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0Q2Fub25pY2FsSWNvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2xzKSB7XG4gICAgdmFyIGljb25OYW1lID0gZ2V0SWNvbk5hbWUoY29uZmlnLmZhbWlseVByZWZpeCwgY2xzKTtcblxuICAgIGlmIChzdHlsZXMkMVtjbHNdKSB7XG4gICAgICBhY2MucHJlZml4ID0gY2xzO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmF1dG9GZXRjaFN2ZyAmJiBbJ2ZhcycsICdmYXInLCAnZmFsJywgJ2ZhYicsICdmYSddLmluZGV4T2YoY2xzKSA+IC0xKSB7XG4gICAgICBhY2MucHJlZml4ID0gY2xzO1xuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUpIHtcbiAgICAgIHZhciBzaGltID0gYWNjLnByZWZpeCA9PT0gJ2ZhJyA/IGJ5T2xkTmFtZShpY29uTmFtZSkgOiB7fTtcbiAgICAgIGFjYy5pY29uTmFtZSA9IHNoaW0uaWNvbk5hbWUgfHwgaWNvbk5hbWU7XG4gICAgICBhY2MucHJlZml4ID0gc2hpbS5wcmVmaXggfHwgYWNjLnByZWZpeDtcbiAgICB9IGVsc2UgaWYgKGNscyAhPT0gY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MgJiYgY2xzLmluZGV4T2YoJ2ZhLXctJykgIT09IDApIHtcbiAgICAgIGFjYy5yZXN0LnB1c2goY2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCBlbXB0eUNhbm9uaWNhbEljb24oKSk7XG59XG5mdW5jdGlvbiBpY29uRnJvbU1hcHBpbmcobWFwcGluZywgcHJlZml4LCBpY29uTmFtZSkge1xuICBpZiAobWFwcGluZyAmJiBtYXBwaW5nW3ByZWZpeF0gJiYgbWFwcGluZ1twcmVmaXhdW2ljb25OYW1lXSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICAgIGljb246IG1hcHBpbmdbcHJlZml4XVtpY29uTmFtZV1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvSHRtbChhYnN0cmFjdE5vZGVzKSB7XG4gIHZhciB0YWcgPSBhYnN0cmFjdE5vZGVzLnRhZyxcbiAgICAgIF9hYnN0cmFjdE5vZGVzJGF0dHJpYiA9IGFic3RyYWN0Tm9kZXMuYXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfYWJzdHJhY3ROb2RlcyRhdHRyaWIgPT09IHZvaWQgMCA/IHt9IDogX2Fic3RyYWN0Tm9kZXMkYXR0cmliLFxuICAgICAgX2Fic3RyYWN0Tm9kZXMkY2hpbGRyID0gYWJzdHJhY3ROb2Rlcy5jaGlsZHJlbixcbiAgICAgIGNoaWxkcmVuID0gX2Fic3RyYWN0Tm9kZXMkY2hpbGRyID09PSB2b2lkIDAgPyBbXSA6IF9hYnN0cmFjdE5vZGVzJGNoaWxkcjtcblxuICBpZiAodHlwZW9mIGFic3RyYWN0Tm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGh0bWxFc2NhcGUoYWJzdHJhY3ROb2Rlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiPFwiLmNvbmNhdCh0YWcsIFwiIFwiKS5jb25jYXQoam9pbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyksIFwiPlwiKS5jb25jYXQoY2hpbGRyZW4ubWFwKHRvSHRtbCkuam9pbignJyksIFwiPC9cIikuY29uY2F0KHRhZywgXCI+XCIpO1xuICB9XG59XG5cbnZhciBub29wJDIgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmZ1bmN0aW9uIGlzV2F0Y2hlZChub2RlKSB7XG4gIHZhciBpMnN2ZyA9IG5vZGUuZ2V0QXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoREFUQV9GQV9JMlNWRykgOiBudWxsO1xuICByZXR1cm4gdHlwZW9mIGkyc3ZnID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gZ2V0TXV0YXRvcigpIHtcbiAgaWYgKGNvbmZpZy5hdXRvUmVwbGFjZVN2ZyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBtdXRhdG9ycy5yZXBsYWNlO1xuICB9XG5cbiAgdmFyIG11dGF0b3IgPSBtdXRhdG9yc1tjb25maWcuYXV0b1JlcGxhY2VTdmddO1xuICByZXR1cm4gbXV0YXRvciB8fCBtdXRhdG9ycy5yZXBsYWNlO1xufVxuXG52YXIgbXV0YXRvcnMgPSB7XG4gIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobXV0YXRpb24pIHtcbiAgICB2YXIgbm9kZSA9IG11dGF0aW9uWzBdO1xuICAgIHZhciBhYnN0cmFjdCA9IG11dGF0aW9uWzFdO1xuICAgIHZhciBuZXdPdXRlckhUTUwgPSBhYnN0cmFjdC5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiB0b0h0bWwoYSk7XG4gICAgfSkuam9pbignXFxuJyk7XG5cbiAgICBpZiAobm9kZS5wYXJlbnROb2RlICYmIG5vZGUub3V0ZXJIVE1MKSB7XG4gICAgICBub2RlLm91dGVySFRNTCA9IG5ld091dGVySFRNTCArIChjb25maWcua2VlcE9yaWdpbmFsU291cmNlICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJyA/IFwiPCEtLSBcIi5jb25jYXQobm9kZS5vdXRlckhUTUwsIFwiIC0tPlwiKSA6ICcnKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIG5ld05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIG5vZGUpO1xuICAgICAgbmV3Tm9kZS5vdXRlckhUTUwgPSBuZXdPdXRlckhUTUw7XG4gICAgfVxuICB9LFxuICBuZXN0OiBmdW5jdGlvbiBuZXN0KG11dGF0aW9uKSB7XG4gICAgdmFyIG5vZGUgPSBtdXRhdGlvblswXTtcbiAgICB2YXIgYWJzdHJhY3QgPSBtdXRhdGlvblsxXTsgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVwbGFjZWQgbm9kZSB3ZSBkbyBub3Qgd2FudCB0byBjb250aW51ZSBuZXN0aW5nIHdpdGhpbiBpdC5cbiAgICAvLyBTaG9ydC1jaXJjdWl0IHRvIHRoZSBzdGFuZGFyZCByZXBsYWNlbWVudFxuXG4gICAgaWYgKH5jbGFzc0FycmF5KG5vZGUpLmluZGV4T2YoY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MpKSB7XG4gICAgICByZXR1cm4gbXV0YXRvcnMucmVwbGFjZShtdXRhdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIGZvclN2ZyA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoY29uZmlnLmZhbWlseVByZWZpeCwgXCItLipcIikpO1xuICAgIGRlbGV0ZSBhYnN0cmFjdFswXS5hdHRyaWJ1dGVzLnN0eWxlO1xuICAgIHZhciBzcGxpdENsYXNzZXMgPSBhYnN0cmFjdFswXS5hdHRyaWJ1dGVzLmNsYXNzLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNscykge1xuICAgICAgaWYgKGNscyA9PT0gY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MgfHwgY2xzLm1hdGNoKGZvclN2ZykpIHtcbiAgICAgICAgYWNjLnRvU3ZnLnB1c2goY2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjYy50b05vZGUucHVzaChjbHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHtcbiAgICAgIHRvTm9kZTogW10sXG4gICAgICB0b1N2ZzogW11cbiAgICB9KTtcbiAgICBhYnN0cmFjdFswXS5hdHRyaWJ1dGVzLmNsYXNzID0gc3BsaXRDbGFzc2VzLnRvU3ZnLmpvaW4oJyAnKTtcbiAgICB2YXIgbmV3SW5uZXJIVE1MID0gYWJzdHJhY3QubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gdG9IdG1sKGEpO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIHNwbGl0Q2xhc3Nlcy50b05vZGUuam9pbignICcpKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShEQVRBX0ZBX0kyU1ZHLCAnJyk7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBuZXdJbm5lckhUTUw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBlcmZvcm1PcGVyYXRpb25TeW5jKG9wKSB7XG4gIG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm0obXV0YXRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgY2FsbGJhY2tGdW5jdGlvbiA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbm9vcCQyO1xuXG4gIGlmIChtdXRhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgY2FsbGJhY2tGdW5jdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmcmFtZSA9IHBlcmZvcm1PcGVyYXRpb25TeW5jO1xuXG4gICAgaWYgKGNvbmZpZy5tdXRhdGVBcHByb2FjaCA9PT0gTVVUQVRJT05fQVBQUk9BQ0hfQVNZTkMpIHtcbiAgICAgIGZyYW1lID0gV0lORE9XLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBwZXJmb3JtT3BlcmF0aW9uU3luYztcbiAgICB9XG5cbiAgICBmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbXV0YXRvciA9IGdldE11dGF0b3IoKTtcbiAgICAgIHZhciBtYXJrID0gcGVyZi5iZWdpbignbXV0YXRlJyk7XG4gICAgICBtdXRhdGlvbnMubWFwKG11dGF0b3IpO1xuICAgICAgbWFyaygpO1xuICAgICAgY2FsbGJhY2tGdW5jdGlvbigpO1xuICAgIH0pO1xuICB9XG59XG52YXIgZGlzYWJsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRpc2FibGVPYnNlcnZhdGlvbigpIHtcbiAgZGlzYWJsZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5hYmxlT2JzZXJ2YXRpb24oKSB7XG4gIGRpc2FibGVkID0gZmFsc2U7XG59XG52YXIgbW8gPSBudWxsO1xuZnVuY3Rpb24gb2JzZXJ2ZShvcHRpb25zKSB7XG4gIGlmICghTVVUQVRJT05fT0JTRVJWRVIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWNvbmZpZy5vYnNlcnZlTXV0YXRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyZWVDYWxsYmFjayA9IG9wdGlvbnMudHJlZUNhbGxiYWNrLFxuICAgICAgbm9kZUNhbGxiYWNrID0gb3B0aW9ucy5ub2RlQ2FsbGJhY2ssXG4gICAgICBwc2V1ZG9FbGVtZW50c0NhbGxiYWNrID0gb3B0aW9ucy5wc2V1ZG9FbGVtZW50c0NhbGxiYWNrLFxuICAgICAgX29wdGlvbnMkb2JzZXJ2ZU11dGF0ID0gb3B0aW9ucy5vYnNlcnZlTXV0YXRpb25zUm9vdCxcbiAgICAgIG9ic2VydmVNdXRhdGlvbnNSb290ID0gX29wdGlvbnMkb2JzZXJ2ZU11dGF0ID09PSB2b2lkIDAgPyBET0NVTUVOVCA6IF9vcHRpb25zJG9ic2VydmVNdXRhdDtcbiAgbW8gPSBuZXcgTVVUQVRJT05fT0JTRVJWRVIoZnVuY3Rpb24gKG9iamVjdHMpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICB0b0FycmF5KG9iamVjdHMpLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uUmVjb3JkKSB7XG4gICAgICBpZiAobXV0YXRpb25SZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcgJiYgbXV0YXRpb25SZWNvcmQuYWRkZWROb2Rlcy5sZW5ndGggPiAwICYmICFpc1dhdGNoZWQobXV0YXRpb25SZWNvcmQuYWRkZWROb2Rlc1swXSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5zZWFyY2hQc2V1ZG9FbGVtZW50cykge1xuICAgICAgICAgIHBzZXVkb0VsZW1lbnRzQ2FsbGJhY2sobXV0YXRpb25SZWNvcmQudGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyZWVDYWxsYmFjayhtdXRhdGlvblJlY29yZC50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXV0YXRpb25SZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uUmVjb3JkLnRhcmdldC5wYXJlbnROb2RlICYmIGNvbmZpZy5zZWFyY2hQc2V1ZG9FbGVtZW50cykge1xuICAgICAgICBwc2V1ZG9FbGVtZW50c0NhbGxiYWNrKG11dGF0aW9uUmVjb3JkLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiBpc1dhdGNoZWQobXV0YXRpb25SZWNvcmQudGFyZ2V0KSAmJiB+QVRUUklCVVRFU19XQVRDSEVEX0ZPUl9NVVRBVElPTi5pbmRleE9mKG11dGF0aW9uUmVjb3JkLmF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChtdXRhdGlvblJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgdmFyIF9nZXRDYW5vbmljYWxJY29uID0gZ2V0Q2Fub25pY2FsSWNvbihjbGFzc0FycmF5KG11dGF0aW9uUmVjb3JkLnRhcmdldCkpLFxuICAgICAgICAgICAgICBwcmVmaXggPSBfZ2V0Q2Fub25pY2FsSWNvbi5wcmVmaXgsXG4gICAgICAgICAgICAgIGljb25OYW1lID0gX2dldENhbm9uaWNhbEljb24uaWNvbk5hbWU7XG5cbiAgICAgICAgICBpZiAocHJlZml4KSBtdXRhdGlvblJlY29yZC50YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXByZWZpeCcsIHByZWZpeCk7XG4gICAgICAgICAgaWYgKGljb25OYW1lKSBtdXRhdGlvblJlY29yZC50YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLWljb24nLCBpY29uTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZUNhbGxiYWNrKG11dGF0aW9uUmVjb3JkLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGlmICghSVNfRE9NKSByZXR1cm47XG4gIG1vLm9ic2VydmUob2JzZXJ2ZU11dGF0aW9uc1Jvb3QsIHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICBpZiAoIW1vKSByZXR1cm47XG4gIG1vLmRpc2Nvbm5lY3QoKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVQYXJzZXIgKG5vZGUpIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIHZhciB2YWwgPSBbXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICB2YWwgPSBzdHlsZS5zcGxpdCgnOycpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzdHlsZSkge1xuICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIgcHJvcCA9IHN0eWxlc1swXTtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlcy5zbGljZSgxKTtcblxuICAgICAgaWYgKHByb3AgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBhY2NbcHJvcF0gPSB2YWx1ZS5qb2luKCc6JykudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGNsYXNzUGFyc2VyIChub2RlKSB7XG4gIHZhciBleGlzdGluZ1ByZWZpeCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXByZWZpeCcpO1xuICB2YXIgZXhpc3RpbmdJY29uTmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWljb24nKTtcbiAgdmFyIGlubmVyVGV4dCA9IG5vZGUuaW5uZXJUZXh0ICE9PSB1bmRlZmluZWQgPyBub2RlLmlubmVyVGV4dC50cmltKCkgOiAnJztcbiAgdmFyIHZhbCA9IGdldENhbm9uaWNhbEljb24oY2xhc3NBcnJheShub2RlKSk7XG5cbiAgaWYgKGV4aXN0aW5nUHJlZml4ICYmIGV4aXN0aW5nSWNvbk5hbWUpIHtcbiAgICB2YWwucHJlZml4ID0gZXhpc3RpbmdQcmVmaXg7XG4gICAgdmFsLmljb25OYW1lID0gZXhpc3RpbmdJY29uTmFtZTtcbiAgfVxuXG4gIGlmICh2YWwucHJlZml4ICYmIGlubmVyVGV4dC5sZW5ndGggPiAxKSB7XG4gICAgdmFsLmljb25OYW1lID0gYnlMaWdhdHVyZSh2YWwucHJlZml4LCBub2RlLmlubmVyVGV4dCk7XG4gIH0gZWxzZSBpZiAodmFsLnByZWZpeCAmJiBpbm5lclRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsLmljb25OYW1lID0gYnlVbmljb2RlKHZhbC5wcmVmaXgsIHRvSGV4KG5vZGUuaW5uZXJUZXh0KSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG52YXIgcGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1TdHJpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICBzaXplOiAxNixcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgZmxpcFg6IGZhbHNlLFxuICAgIGZsaXBZOiBmYWxzZSxcbiAgICByb3RhdGU6IDBcbiAgfTtcblxuICBpZiAoIXRyYW5zZm9ybVN0cmluZykge1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG4pIHtcbiAgICAgIHZhciBwYXJ0cyA9IG4udG9Mb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgdmFyIGZpcnN0ID0gcGFydHNbMF07XG4gICAgICB2YXIgcmVzdCA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJy0nKTtcblxuICAgICAgaWYgKGZpcnN0ICYmIHJlc3QgPT09ICdoJykge1xuICAgICAgICBhY2MuZmxpcFggPSB0cnVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgJiYgcmVzdCA9PT0gJ3YnKSB7XG4gICAgICAgIGFjYy5mbGlwWSA9IHRydWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIHJlc3QgPSBwYXJzZUZsb2F0KHJlc3QpO1xuXG4gICAgICBpZiAoaXNOYU4ocmVzdCkpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlICdncm93JzpcbiAgICAgICAgICBhY2Muc2l6ZSA9IGFjYy5zaXplICsgcmVzdDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzaHJpbmsnOlxuICAgICAgICAgIGFjYy5zaXplID0gYWNjLnNpemUgLSByZXN0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGFjYy54ID0gYWNjLnggLSByZXN0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBhY2MueCA9IGFjYy54ICsgcmVzdDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgYWNjLnkgPSBhY2MueSAtIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgICAgYWNjLnkgPSBhY2MueSArIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICBhY2Mucm90YXRlID0gYWNjLnJvdGF0ZSArIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdHJhbnNmb3JtKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBhcnNlciAobm9kZSkge1xuICByZXR1cm4gcGFyc2VUcmFuc2Zvcm1TdHJpbmcobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtdHJhbnNmb3JtJykpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2xQYXJzZXIgKG5vZGUpIHtcbiAgdmFyIHN5bWJvbCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZhLXN5bWJvbCcpO1xuICByZXR1cm4gc3ltYm9sID09PSBudWxsID8gZmFsc2UgOiBzeW1ib2wgPT09ICcnID8gdHJ1ZSA6IHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlc1BhcnNlciAobm9kZSkge1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVzID0gdG9BcnJheShub2RlLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgaWYgKGFjYy5uYW1lICE9PSAnY2xhc3MnICYmIGFjYy5uYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICBhY2NbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgdGl0bGUgPSBub2RlLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcblxuICBpZiAoY29uZmlnLmF1dG9BMTF5KSB7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNbJ2FyaWEtbGFiZWxsZWRieSddID0gXCJcIi5jb25jYXQoY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MsIFwiLXRpdGxlLVwiKS5jb25jYXQobmV4dFVuaXF1ZUlkKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNbJ2FyaWEtaGlkZGVuJ10gPSAndHJ1ZSc7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNbJ2ZvY3VzYWJsZSddID0gJ2ZhbHNlJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXh0cmFBdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBtYXNrUGFyc2VyIChub2RlKSB7XG4gIHZhciBtYXNrID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtbWFzaycpO1xuXG4gIGlmICghbWFzaykge1xuICAgIHJldHVybiBlbXB0eUNhbm9uaWNhbEljb24oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0Q2Fub25pY2FsSWNvbihtYXNrLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaS50cmltKCk7XG4gICAgfSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJsYW5rTWV0YSgpIHtcbiAgcmV0dXJuIHtcbiAgICBpY29uTmFtZTogbnVsbCxcbiAgICB0aXRsZTogbnVsbCxcbiAgICBwcmVmaXg6IG51bGwsXG4gICAgdHJhbnNmb3JtOiBtZWFuaW5nbGVzc1RyYW5zZm9ybSxcbiAgICBzeW1ib2w6IGZhbHNlLFxuICAgIG1hc2s6IG51bGwsXG4gICAgZXh0cmE6IHtcbiAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VNZXRhKG5vZGUpIHtcbiAgdmFyIF9jbGFzc1BhcnNlciA9IGNsYXNzUGFyc2VyKG5vZGUpLFxuICAgICAgaWNvbk5hbWUgPSBfY2xhc3NQYXJzZXIuaWNvbk5hbWUsXG4gICAgICBwcmVmaXggPSBfY2xhc3NQYXJzZXIucHJlZml4LFxuICAgICAgZXh0cmFDbGFzc2VzID0gX2NsYXNzUGFyc2VyLnJlc3Q7XG5cbiAgdmFyIGV4dHJhU3R5bGVzID0gc3R5bGVQYXJzZXIobm9kZSk7XG4gIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1QYXJzZXIobm9kZSk7XG4gIHZhciBzeW1ib2wgPSBzeW1ib2xQYXJzZXIobm9kZSk7XG4gIHZhciBleHRyYUF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzUGFyc2VyKG5vZGUpO1xuICB2YXIgbWFzayA9IG1hc2tQYXJzZXIobm9kZSk7XG4gIHJldHVybiB7XG4gICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgIHRpdGxlOiBub2RlLmdldEF0dHJpYnV0ZSgndGl0bGUnKSxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICBtYXNrOiBtYXNrLFxuICAgIGV4dHJhOiB7XG4gICAgICBjbGFzc2VzOiBleHRyYUNsYXNzZXMsXG4gICAgICBzdHlsZXM6IGV4dHJhU3R5bGVzLFxuICAgICAgYXR0cmlidXRlczogZXh0cmFBdHRyaWJ1dGVzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBNaXNzaW5nSWNvbihlcnJvcikge1xuICB0aGlzLm5hbWUgPSAnTWlzc2luZ0ljb24nO1xuICB0aGlzLm1lc3NhZ2UgPSBlcnJvciB8fCAnSWNvbiB1bmF2YWlsYWJsZSc7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbn1cbk1pc3NpbmdJY29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbk1pc3NpbmdJY29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1pc3NpbmdJY29uO1xuXG52YXIgRklMTCA9IHtcbiAgZmlsbDogJ2N1cnJlbnRDb2xvcidcbn07XG52YXIgQU5JTUFUSU9OX0JBU0UgPSB7XG4gIGF0dHJpYnV0ZVR5cGU6ICdYTUwnLFxuICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnLFxuICBkdXI6ICcycydcbn07XG52YXIgUklORyA9IHtcbiAgdGFnOiAncGF0aCcsXG4gIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIEZJTEwsIHtcbiAgICBkOiAnTTE1Ni41LDQ0Ny43bC0xMi42LDI5LjVjLTE4LjctOS41LTM1LjktMjEuMi01MS41LTM0LjlsMjIuNy0yMi43QzEyNy42LDQzMC41LDE0MS41LDQ0MCwxNTYuNSw0NDcuN3ogTTQwLjYsMjcySDguNSBjMS40LDIxLjIsNS40LDQxLjcsMTEuNyw2MS4xTDUwLDMyMS4yQzQ1LjEsMzA1LjUsNDEuOCwyODksNDAuNiwyNzJ6IE00MC42LDI0MGMxLjQtMTguOCw1LjItMzcsMTEuMS01NC4xbC0yOS41LTEyLjYgQzE0LjcsMTk0LjMsMTAsMjE2LjcsOC41LDI0MEg0MC42eiBNNjQuMywxNTYuNWM3LjgtMTQuOSwxNy4yLTI4LjgsMjguMS00MS41TDY5LjcsOTIuM2MtMTMuNywxNS42LTI1LjUsMzIuOC0zNC45LDUxLjUgTDY0LjMsMTU2LjV6IE0zOTcsNDE5LjZjLTEzLjksMTItMjkuNCwyMi4zLTQ2LjEsMzAuNGwxMS45LDI5LjhjMjAuNy05LjksMzkuOC0yMi42LDU2LjktMzcuNkwzOTcsNDE5LjZ6IE0xMTUsOTIuNCBjMTMuOS0xMiwyOS40LTIyLjMsNDYuMS0zMC40bC0xMS45LTI5LjhjLTIwLjcsOS45LTM5LjgsMjIuNi01Ni44LDM3LjZMMTE1LDkyLjR6IE00NDcuNywzNTUuNWMtNy44LDE0LjktMTcuMiwyOC44LTI4LjEsNDEuNSBsMjIuNywyMi43YzEzLjctMTUuNiwyNS41LTMyLjksMzQuOS01MS41TDQ0Ny43LDM1NS41eiBNNDcxLjQsMjcyYy0xLjQsMTguOC01LjIsMzctMTEuMSw1NC4xbDI5LjUsMTIuNiBjNy41LTIxLjEsMTIuMi00My41LDEzLjYtNjYuOEg0NzEuNHogTTMyMS4yLDQ2MmMtMTUuNyw1LTMyLjIsOC4yLTQ5LjIsOS40djMyLjFjMjEuMi0xLjQsNDEuNy01LjQsNjEuMS0xMS43TDMyMS4yLDQ2MnogTTI0MCw0NzEuNGMtMTguOC0xLjQtMzctNS4yLTU0LjEtMTEuMWwtMTIuNiwyOS41YzIxLjEsNy41LDQzLjUsMTIuMiw2Ni44LDEzLjZWNDcxLjR6IE00NjIsMTkwLjhjNSwxNS43LDguMiwzMi4yLDkuNCw0OS4yaDMyLjEgYy0xLjQtMjEuMi01LjQtNDEuNy0xMS43LTYxLjFMNDYyLDE5MC44eiBNOTIuNCwzOTdjLTEyLTEzLjktMjIuMy0yOS40LTMwLjQtNDYuMWwtMjkuOCwxMS45YzkuOSwyMC43LDIyLjYsMzkuOCwzNy42LDU2LjkgTDkyLjQsMzk3eiBNMjcyLDQwLjZjMTguOCwxLjQsMzYuOSw1LjIsNTQuMSwxMS4xbDEyLjYtMjkuNUMzMTcuNywxNC43LDI5NS4zLDEwLDI3Miw4LjVWNDAuNnogTTE5MC44LDUwIGMxNS43LTUsMzIuMi04LjIsNDkuMi05LjRWOC41Yy0yMS4yLDEuNC00MS43LDUuNC02MS4xLDExLjdMMTkwLjgsNTB6IE00NDIuMyw5Mi4zTDQxOS42LDExNWMxMiwxMy45LDIyLjMsMjkuNCwzMC41LDQ2LjEgbDI5LjgtMTEuOUM0NzAsMTI4LjUsNDU3LjMsMTA5LjQsNDQyLjMsOTIuM3ogTTM5Nyw5Mi40bDIyLjctMjIuN2MtMTUuNi0xMy43LTMyLjgtMjUuNS01MS41LTM0LjlsLTEyLjYsMjkuNSBDMzcwLjQsNzIuMSwzODQuNCw4MS41LDM5Nyw5Mi40eidcbiAgfSlcbn07XG5cbnZhciBPUEFDSVRZX0FOSU1BVEUgPSBfb2JqZWN0U3ByZWFkKHt9LCBBTklNQVRJT05fQkFTRSwge1xuICBhdHRyaWJ1dGVOYW1lOiAnb3BhY2l0eSdcbn0pO1xuXG52YXIgRE9UID0ge1xuICB0YWc6ICdjaXJjbGUnLFxuICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBGSUxMLCB7XG4gICAgY3g6ICcyNTYnLFxuICAgIGN5OiAnMzY0JyxcbiAgICByOiAnMjgnXG4gIH0pLFxuICBjaGlsZHJlbjogW3tcbiAgICB0YWc6ICdhbmltYXRlJyxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBBTklNQVRJT05fQkFTRSwge1xuICAgICAgYXR0cmlidXRlTmFtZTogJ3InLFxuICAgICAgdmFsdWVzOiAnMjg7MTQ7Mjg7Mjg7MTQ7Mjg7J1xuICAgIH0pXG4gIH0sIHtcbiAgICB0YWc6ICdhbmltYXRlJyxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBPUEFDSVRZX0FOSU1BVEUsIHtcbiAgICAgIHZhbHVlczogJzE7MDsxOzE7MDsxOydcbiAgICB9KVxuICB9XVxufTtcbnZhciBRVUVTVElPTiA9IHtcbiAgdGFnOiAncGF0aCcsXG4gIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIEZJTEwsIHtcbiAgICBvcGFjaXR5OiAnMScsXG4gICAgZDogJ00yNjMuNywzMTJoLTE2Yy02LjYsMC0xMi01LjQtMTItMTJjMC03MSw3Ny40LTYzLjksNzcuNC0xMDcuOGMwLTIwLTE3LjgtNDAuMi01Ny40LTQwLjJjLTI5LjEsMC00NC4zLDkuNi01OS4yLDI4LjcgYy0zLjksNS0xMS4xLDYtMTYuMiwyLjRsLTEzLjEtOS4yYy01LjYtMy45LTYuOS0xMS44LTIuNi0xNy4yYzIxLjItMjcuMiw0Ni40LTQ0LjcsOTEuMi00NC43YzUyLjMsMCw5Ny40LDI5LjgsOTcuNCw4MC4yIGMwLDY3LjYtNzcuNCw2My41LTc3LjQsMTA3LjhDMjc1LjcsMzA2LjYsMjcwLjMsMzEyLDI2My43LDMxMnonXG4gIH0pLFxuICBjaGlsZHJlbjogW3tcbiAgICB0YWc6ICdhbmltYXRlJyxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBPUEFDSVRZX0FOSU1BVEUsIHtcbiAgICAgIHZhbHVlczogJzE7MDswOzA7MDsxOydcbiAgICB9KVxuICB9XVxufTtcbnZhciBFWENMQU1BVElPTiA9IHtcbiAgdGFnOiAncGF0aCcsXG4gIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIEZJTEwsIHtcbiAgICBvcGFjaXR5OiAnMCcsXG4gICAgZDogJ00yMzIuNSwxMzQuNWw3LDE2OGMwLjMsNi40LDUuNiwxMS41LDEyLDExLjVoOWM2LjQsMCwxMS43LTUuMSwxMi0xMS41bDctMTY4YzAuMy02LjgtNS4yLTEyLjUtMTItMTIuNWgtMjMgQzIzNy43LDEyMiwyMzIuMiwxMjcuNywyMzIuNSwxMzQuNXonXG4gIH0pLFxuICBjaGlsZHJlbjogW3tcbiAgICB0YWc6ICdhbmltYXRlJyxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBPUEFDSVRZX0FOSU1BVEUsIHtcbiAgICAgIHZhbHVlczogJzA7MDsxOzE7MDswOydcbiAgICB9KVxuICB9XVxufTtcbnZhciBtaXNzaW5nID0ge1xuICB0YWc6ICdnJyxcbiAgY2hpbGRyZW46IFtSSU5HLCBET1QsIFFVRVNUSU9OLCBFWENMQU1BVElPTl1cbn07XG5cbnZhciBzdHlsZXMkMiA9IG5hbWVzcGFjZS5zdHlsZXM7XG5mdW5jdGlvbiBmaW5kSWNvbihpY29uTmFtZSwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgcGlja2VkKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdmFsID0ge1xuICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgd2lkdGg6IDUxMixcbiAgICAgIGhlaWdodDogNTEyLFxuICAgICAgaWNvbjogbWlzc2luZ1xuICAgIH07XG5cbiAgICBpZiAoaWNvbk5hbWUgJiYgcHJlZml4ICYmIHN0eWxlcyQyW3ByZWZpeF0gJiYgc3R5bGVzJDJbcHJlZml4XVtpY29uTmFtZV0pIHtcbiAgICAgIHZhciBpY29uID0gc3R5bGVzJDJbcHJlZml4XVtpY29uTmFtZV07XG4gICAgICB2YXIgd2lkdGggPSBpY29uWzBdO1xuICAgICAgdmFyIGhlaWdodCA9IGljb25bMV07XG4gICAgICB2YXIgdmVjdG9yRGF0YSA9IGljb24uc2xpY2UoNCk7XG4gICAgICB2YWwgPSB7XG4gICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgdGFnOiAncGF0aCcsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgICAgICBkOiB2ZWN0b3JEYXRhWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc29sdmUodmFsKTtcbiAgICB9XG5cbiAgICBpZiAoaWNvbk5hbWUgJiYgcHJlZml4ICYmICFjb25maWcuc2hvd01pc3NpbmdJY29ucykge1xuICAgICAgcmVqZWN0KG5ldyBNaXNzaW5nSWNvbihcIkljb24gaXMgbWlzc2luZyBmb3IgcHJlZml4IFwiLmNvbmNhdChwcmVmaXgsIFwiIHdpdGggaWNvbiBuYW1lIFwiKS5jb25jYXQoaWNvbk5hbWUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUodmFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgc3R5bGVzJDMgPSBuYW1lc3BhY2Uuc3R5bGVzO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVN2Z1JlcGxhY2VtZW50TXV0YXRpb24obm9kZSwgbm9kZU1ldGEpIHtcbiAgdmFyIGljb25OYW1lID0gbm9kZU1ldGEuaWNvbk5hbWUsXG4gICAgICB0aXRsZSA9IG5vZGVNZXRhLnRpdGxlLFxuICAgICAgcHJlZml4ID0gbm9kZU1ldGEucHJlZml4LFxuICAgICAgdHJhbnNmb3JtID0gbm9kZU1ldGEudHJhbnNmb3JtLFxuICAgICAgc3ltYm9sID0gbm9kZU1ldGEuc3ltYm9sLFxuICAgICAgbWFzayA9IG5vZGVNZXRhLm1hc2ssXG4gICAgICBleHRyYSA9IG5vZGVNZXRhLmV4dHJhO1xuICByZXR1cm4gbmV3IHBpY2tlZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcGlja2VkLmFsbChbZmluZEljb24oaWNvbk5hbWUsIHByZWZpeCksIGZpbmRJY29uKG1hc2suaWNvbk5hbWUsIG1hc2sucHJlZml4KV0pLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgIG1haW4gPSBfcmVmMlswXSxcbiAgICAgICAgICBtYXNrID0gX3JlZjJbMV07XG5cbiAgICAgIHJlc29sdmUoW25vZGUsIG1ha2VJbmxpbmVTdmdBYnN0cmFjdCh7XG4gICAgICAgIGljb25zOiB7XG4gICAgICAgICAgbWFpbjogbWFpbixcbiAgICAgICAgICBtYXNrOiBtYXNrXG4gICAgICAgIH0sXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBpY29uTmFtZTogaWNvbk5hbWUsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICAgICAgbWFzazogbWFzayxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIHdhdGNoYWJsZTogdHJ1ZVxuICAgICAgfSldKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTGF5ZXJzVGV4dChub2RlLCBub2RlTWV0YSkge1xuICB2YXIgdGl0bGUgPSBub2RlTWV0YS50aXRsZSxcbiAgICAgIHRyYW5zZm9ybSA9IG5vZGVNZXRhLnRyYW5zZm9ybSxcbiAgICAgIGV4dHJhID0gbm9kZU1ldGEuZXh0cmE7XG4gIHZhciB3aWR0aCA9IG51bGw7XG4gIHZhciBoZWlnaHQgPSBudWxsO1xuXG4gIGlmIChJU19JRSkge1xuICAgIHZhciBjb21wdXRlZEZvbnRTaXplID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5mb250U2l6ZSwgMTApO1xuICAgIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHdpZHRoID0gYm91bmRpbmdDbGllbnRSZWN0LndpZHRoIC8gY29tcHV0ZWRGb250U2l6ZTtcbiAgICBoZWlnaHQgPSBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IC8gY29tcHV0ZWRGb250U2l6ZTtcbiAgfVxuXG4gIGlmIChjb25maWcuYXV0b0ExMXkgJiYgIXRpdGxlKSB7XG4gICAgZXh0cmEuYXR0cmlidXRlc1snYXJpYS1oaWRkZW4nXSA9ICd0cnVlJztcbiAgfVxuXG4gIHJldHVybiBwaWNrZWQucmVzb2x2ZShbbm9kZSwgbWFrZUxheWVyc1RleHRBYnN0cmFjdCh7XG4gICAgY29udGVudDogbm9kZS5pbm5lckhUTUwsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIHRpdGxlOiB0aXRsZSxcbiAgICBleHRyYTogZXh0cmEsXG4gICAgd2F0Y2hhYmxlOiB0cnVlXG4gIH0pXSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTXV0YXRpb24obm9kZSkge1xuICB2YXIgbm9kZU1ldGEgPSBwYXJzZU1ldGEobm9kZSk7XG5cbiAgaWYgKH5ub2RlTWV0YS5leHRyYS5jbGFzc2VzLmluZGV4T2YoTEFZRVJTX1RFWFRfQ0xBU1NOQU1FKSkge1xuICAgIHJldHVybiBnZW5lcmF0ZUxheWVyc1RleHQobm9kZSwgbm9kZU1ldGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5lcmF0ZVN2Z1JlcGxhY2VtZW50TXV0YXRpb24obm9kZSwgbm9kZU1ldGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uVHJlZShyb290KSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgaWYgKCFJU19ET00pIHJldHVybjtcbiAgdmFyIGh0bWxDbGFzc0xpc3QgPSBET0NVTUVOVC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0O1xuXG4gIHZhciBoY2xBZGQgPSBmdW5jdGlvbiBoY2xBZGQoc3VmZml4KSB7XG4gICAgcmV0dXJuIGh0bWxDbGFzc0xpc3QuYWRkKFwiXCIuY29uY2F0KEhUTUxfQ0xBU1NfSTJTVkdfQkFTRV9DTEFTUywgXCItXCIpLmNvbmNhdChzdWZmaXgpKTtcbiAgfTtcblxuICB2YXIgaGNsUmVtb3ZlID0gZnVuY3Rpb24gaGNsUmVtb3ZlKHN1ZmZpeCkge1xuICAgIHJldHVybiBodG1sQ2xhc3NMaXN0LnJlbW92ZShcIlwiLmNvbmNhdChIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MsIFwiLVwiKS5jb25jYXQoc3VmZml4KSk7XG4gIH07XG5cbiAgdmFyIHByZWZpeGVzID0gY29uZmlnLmF1dG9GZXRjaFN2ZyA/IE9iamVjdC5rZXlzKFBSRUZJWF9UT19TVFlMRSkgOiBPYmplY3Qua2V5cyhzdHlsZXMkMyk7XG4gIHZhciBwcmVmaXhlc0RvbVF1ZXJ5ID0gW1wiLlwiLmNvbmNhdChMQVlFUlNfVEVYVF9DTEFTU05BTUUsIFwiOm5vdChbXCIpLmNvbmNhdChEQVRBX0ZBX0kyU1ZHLCBcIl0pXCIpXS5jb25jYXQocHJlZml4ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIFwiLlwiLmNvbmNhdChwLCBcIjpub3QoW1wiKS5jb25jYXQoREFUQV9GQV9JMlNWRywgXCJdKVwiKTtcbiAgfSkpLmpvaW4oJywgJyk7XG5cbiAgaWYgKHByZWZpeGVzRG9tUXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcblxuICB0cnkge1xuICAgIGNhbmRpZGF0ZXMgPSB0b0FycmF5KHJvb3QucXVlcnlTZWxlY3RvckFsbChwcmVmaXhlc0RvbVF1ZXJ5KSk7XG4gIH0gY2F0Y2ggKGUpIHsvLyBub29wXG4gIH1cblxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgaGNsQWRkKCdwZW5kaW5nJyk7XG4gICAgaGNsUmVtb3ZlKCdjb21wbGV0ZScpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrID0gcGVyZi5iZWdpbignb25UcmVlJyk7XG4gIHZhciBtdXRhdGlvbnMgPSBjYW5kaWRhdGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtdXRhdGlvbiA9IGdlbmVyYXRlTXV0YXRpb24obm9kZSk7XG5cbiAgICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICBhY2MucHVzaChtdXRhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFQUk9EVUNUSU9OKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTWlzc2luZ0ljb24pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gbmV3IHBpY2tlZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcGlja2VkLmFsbChtdXRhdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkTXV0YXRpb25zKSB7XG4gICAgICBwZXJmb3JtKHJlc29sdmVkTXV0YXRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhjbEFkZCgnYWN0aXZlJyk7XG4gICAgICAgIGhjbEFkZCgnY29tcGxldGUnKTtcbiAgICAgICAgaGNsUmVtb3ZlKCdwZW5kaW5nJyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIG1hcmsoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgbWFyaygpO1xuICAgICAgcmVqZWN0KCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gb25Ob2RlKG5vZGUpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICBnZW5lcmF0ZU11dGF0aW9uKG5vZGUpLnRoZW4oZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICBwZXJmb3JtKFttdXRhdGlvbl0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRm9yUG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgdmFyIHBlbmRpbmdBdHRyaWJ1dGUgPSBcIlwiLmNvbmNhdChEQVRBX0ZBX1BTRVVET19FTEVNRU5UX1BFTkRJTkcpLmNvbmNhdChwb3NpdGlvbi5yZXBsYWNlKCc6JywgJy0nKSk7XG4gIHJldHVybiBuZXcgcGlja2VkKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUocGVuZGluZ0F0dHJpYnV0ZSkgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBpcyBhbHJlYWR5IGJlaW5nIHByb2Nlc3NlZFxuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0b0FycmF5KG5vZGUuY2hpbGRyZW4pO1xuICAgIHZhciBhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudCA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMuZ2V0QXR0cmlidXRlKERBVEFfRkFfUFNFVURPX0VMRU1FTlQpID09PSBwb3NpdGlvbjtcbiAgICB9KVswXTtcbiAgICB2YXIgc3R5bGVzID0gV0lORE9XLmdldENvbXB1dGVkU3R5bGUobm9kZSwgcG9zaXRpb24pO1xuICAgIHZhciBmb250RmFtaWx5ID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtZmFtaWx5JykubWF0Y2goRk9OVF9GQU1JTFlfUEFUVEVSTik7XG4gICAgdmFyIGZvbnRXZWlnaHQgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC13ZWlnaHQnKTtcblxuICAgIGlmIChhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudCAmJiAhZm9udEZhbWlseSkge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBwcm9jZXNzZWQgaXQgYnV0IHRoZSBjdXJyZW50IGNvbXB1dGVkIHN0eWxlIGRvZXMgbm90IHJlc3VsdCBpbiBhIGZvbnQtZmFtaWx5LFxuICAgICAgLy8gdGhhdCBwcm9iYWJseSBtZWFucyB0aGF0IGEgY2xhc3MgbmFtZSB0aGF0IHdhcyBwcmV2aW91c2x5IHByZXNlbnQgdG8gbWFrZSB0aGUgaWNvbiBoYXMgYmVlblxuICAgICAgLy8gcmVtb3ZlZC4gU28gd2Ugbm93IHNob3VsZCBkZWxldGUgdGhlIGljb24uXG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50KTtcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfSBlbHNlIGlmIChmb250RmFtaWx5KSB7XG4gICAgICB2YXIgY29udGVudCA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdjb250ZW50Jyk7XG4gICAgICB2YXIgcHJlZml4ID0gflsnTGlnaHQnLCAnUmVndWxhcicsICdTb2xpZCcsICdCcmFuZHMnXS5pbmRleE9mKGZvbnRGYW1pbHlbMV0pID8gU1RZTEVfVE9fUFJFRklYW2ZvbnRGYW1pbHlbMV0udG9Mb3dlckNhc2UoKV0gOiBGT05UX1dFSUdIVF9UT19QUkVGSVhbZm9udFdlaWdodF07XG4gICAgICB2YXIgaGV4VmFsdWUgPSB0b0hleChjb250ZW50Lmxlbmd0aCA9PT0gMyA/IGNvbnRlbnQuc3Vic3RyKDEsIDEpIDogY29udGVudCk7XG4gICAgICB2YXIgaWNvbk5hbWUgPSBieVVuaWNvZGUocHJlZml4LCBoZXhWYWx1ZSk7XG4gICAgICB2YXIgaWNvbklkZW50aWZpZXIgPSBpY29uTmFtZTsgLy8gT25seSBjb252ZXJ0IHRoZSBwc2V1ZG8gZWxlbWVudCBpbiB0aGlzIDpiZWZvcmUvOmFmdGVyIHBvc2l0aW9uIGludG8gYW4gaWNvbiBpZiB3ZSBoYXZlbid0XG4gICAgICAvLyBhbHJlYWR5IGRvbmUgc28gd2l0aCB0aGUgc2FtZSBwcmVmaXggYW5kIGljb25OYW1lXG5cbiAgICAgIGlmIChpY29uTmFtZSAmJiAoIWFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50IHx8IGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50LmdldEF0dHJpYnV0ZShEQVRBX1BSRUZJWCkgIT09IHByZWZpeCB8fCBhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoREFUQV9JQ09OKSAhPT0gaWNvbklkZW50aWZpZXIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHBlbmRpbmdBdHRyaWJ1dGUsIGljb25JZGVudGlmaWVyKTtcblxuICAgICAgICBpZiAoYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQpIHtcbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9sZCBvbmUsIHNpbmNlIHdlJ3JlIHJlcGxhY2luZyBpdCB3aXRoIGEgbmV3IG9uZVxuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldGEgPSBibGFua01ldGEoKTtcbiAgICAgICAgdmFyIGV4dHJhID0gbWV0YS5leHRyYTtcbiAgICAgICAgZXh0cmEuYXR0cmlidXRlc1tEQVRBX0ZBX1BTRVVET19FTEVNRU5UXSA9IHBvc2l0aW9uO1xuICAgICAgICBmaW5kSWNvbihpY29uTmFtZSwgcHJlZml4KS50aGVuKGZ1bmN0aW9uIChtYWluKSB7XG4gICAgICAgICAgdmFyIGFic3RyYWN0ID0gbWFrZUlubGluZVN2Z0Fic3RyYWN0KF9vYmplY3RTcHJlYWQoe30sIG1ldGEsIHtcbiAgICAgICAgICAgIGljb25zOiB7XG4gICAgICAgICAgICAgIG1haW46IG1haW4sXG4gICAgICAgICAgICAgIG1hc2s6IGVtcHR5Q2Fub25pY2FsSWNvbigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICBpY29uTmFtZTogaWNvbklkZW50aWZpZXIsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgICAgICB3YXRjaGFibGU6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBET0NVTUVOVC5jcmVhdGVFbGVtZW50KCdzdmcnKTtcblxuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJzpiZWZvcmUnKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQub3V0ZXJIVE1MID0gYWJzdHJhY3QubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9IdG1sKGEpO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHBlbmRpbmdBdHRyaWJ1dGUpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2Uobm9kZSkge1xuICByZXR1cm4gcGlja2VkLmFsbChbcmVwbGFjZUZvclBvc2l0aW9uKG5vZGUsICc6YmVmb3JlJyksIHJlcGxhY2VGb3JQb3NpdGlvbihub2RlLCAnOmFmdGVyJyldKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc2FibGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5oZWFkICYmICF+VEFHTkFNRVNfVE9fU0tJUF9GT1JfUFNFVURPRUxFTUVOVFMuaW5kZXhPZihub2RlLnRhZ05hbWUudG9VcHBlckNhc2UoKSkgJiYgIW5vZGUuZ2V0QXR0cmlidXRlKERBVEFfRkFfUFNFVURPX0VMRU1FTlQpICYmICghbm9kZS5wYXJlbnROb2RlIHx8IG5vZGUucGFyZW50Tm9kZS50YWdOYW1lICE9PSAnc3ZnJyk7XG59XG5cbmZ1bmN0aW9uIHNlYXJjaFBzZXVkb0VsZW1lbnRzIChyb290KSB7XG4gIGlmICghSVNfRE9NKSByZXR1cm47XG4gIHJldHVybiBuZXcgcGlja2VkKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IHRvQXJyYXkocm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpLmZpbHRlcihwcm9jZXNzYWJsZSkubWFwKHJlcGxhY2UpO1xuICAgIHZhciBlbmQgPSBwZXJmLmJlZ2luKCdzZWFyY2hQc2V1ZG9FbGVtZW50cycpO1xuICAgIGRpc2FibGVPYnNlcnZhdGlvbigpO1xuICAgIHBpY2tlZC5hbGwob3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBlbmQoKTtcbiAgICAgIGVuYWJsZU9ic2VydmF0aW9uKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgZW5kKCk7XG4gICAgICBlbmFibGVPYnNlcnZhdGlvbigpO1xuICAgICAgcmVqZWN0KCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgYmFzZVN0eWxlcyA9IFwic3ZnOm5vdCg6cm9vdCkuc3ZnLWlubGluZS0tZmEge1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi5zdmctaW5saW5lLS1mYSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjEyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtbGcge1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjIyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xIHtcXG4gIHdpZHRoOiAwLjA2MjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMiB7XFxuICB3aWR0aDogMC4xMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMyB7XFxuICB3aWR0aDogMC4xODc1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTQge1xcbiAgd2lkdGg6IDAuMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctNSB7XFxuICB3aWR0aDogMC4zMTI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTYge1xcbiAgd2lkdGg6IDAuMzc1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTcge1xcbiAgd2lkdGg6IDAuNDM3NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy04IHtcXG4gIHdpZHRoOiAwLjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctOSB7XFxuICB3aWR0aDogMC41NjI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTEwIHtcXG4gIHdpZHRoOiAwLjYyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xMSB7XFxuICB3aWR0aDogMC42ODc1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTEyIHtcXG4gIHdpZHRoOiAwLjc1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTEzIHtcXG4gIHdpZHRoOiAwLjgxMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTQge1xcbiAgd2lkdGg6IDAuODc1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTE1IHtcXG4gIHdpZHRoOiAwLjkzNzVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTYge1xcbiAgd2lkdGg6IDFlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTcge1xcbiAgd2lkdGg6IDEuMDYyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xOCB7XFxuICB3aWR0aDogMS4xMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTkge1xcbiAgd2lkdGg6IDEuMTg3NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0yMCB7XFxuICB3aWR0aDogMS4yNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtcHVsbC1sZWZ0IHtcXG4gIG1hcmdpbi1yaWdodDogMC4zZW07XFxuICB3aWR0aDogYXV0bztcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXB1bGwtcmlnaHQge1xcbiAgbWFyZ2luLWxlZnQ6IDAuM2VtO1xcbiAgd2lkdGg6IGF1dG87XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS1ib3JkZXIge1xcbiAgaGVpZ2h0OiAxLjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLWxpIHtcXG4gIHdpZHRoOiAyZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS1mdyB7XFxuICB3aWR0aDogMS4yNWVtO1xcbn1cXG5cXG4uZmEtbGF5ZXJzIHN2Zy5zdmctaW5saW5lLS1mYSB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxufVxcblxcbi5mYS1sYXllcnMge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuMTI1ZW07XFxuICB3aWR0aDogMWVtO1xcbn1cXG4uZmEtbGF5ZXJzIHN2Zy5zdmctaW5saW5lLS1mYSB7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxufVxcblxcbi5mYS1sYXllcnMtY291bnRlciwgLmZhLWxheWVycy10ZXh0IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmZhLWxheWVycy10ZXh0IHtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRvcDogNTAlO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxufVxcblxcbi5mYS1sYXllcnMtY291bnRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYyNTNhO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY29sb3I6ICNmZmY7XFxuICBoZWlnaHQ6IDEuNWVtO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBtYXgtd2lkdGg6IDVlbTtcXG4gIG1pbi13aWR0aDogMS41ZW07XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgcGFkZGluZzogMC4yNWVtO1xcbiAgcmlnaHQ6IDA7XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gIHRvcDogMDtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjI1KTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjI1KTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogdG9wIHJpZ2h0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgcmlnaHQ7XFxufVxcblxcbi5mYS1sYXllcnMtYm90dG9tLXJpZ2h0IHtcXG4gIGJvdHRvbTogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiBhdXRvO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gcmlnaHQ7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSByaWdodDtcXG59XFxuXFxuLmZhLWxheWVycy1ib3R0b20tbGVmdCB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IGF1dG87XFxuICB0b3A6IGF1dG87XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSBsZWZ0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gbGVmdDtcXG59XFxuXFxuLmZhLWxheWVycy10b3AtcmlnaHQge1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IHRvcCByaWdodDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIHJpZ2h0O1xcbn1cXG5cXG4uZmEtbGF5ZXJzLXRvcC1sZWZ0IHtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogYXV0bztcXG4gIHRvcDogMDtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjI1KTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjI1KTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xcbn1cXG5cXG4uZmEtbGcge1xcbiAgZm9udC1zaXplOiAxLjMzMzMzMzMzMzNlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjc1ZW07XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuMDY2N2VtO1xcbn1cXG5cXG4uZmEteHMge1xcbiAgZm9udC1zaXplOiAwLjc1ZW07XFxufVxcblxcbi5mYS1zbSB7XFxuICBmb250LXNpemU6IDAuODc1ZW07XFxufVxcblxcbi5mYS0xeCB7XFxuICBmb250LXNpemU6IDFlbTtcXG59XFxuXFxuLmZhLTJ4IHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbn1cXG5cXG4uZmEtM3gge1xcbiAgZm9udC1zaXplOiAzZW07XFxufVxcblxcbi5mYS00eCB7XFxuICBmb250LXNpemU6IDRlbTtcXG59XFxuXFxuLmZhLTV4IHtcXG4gIGZvbnQtc2l6ZTogNWVtO1xcbn1cXG5cXG4uZmEtNngge1xcbiAgZm9udC1zaXplOiA2ZW07XFxufVxcblxcbi5mYS03eCB7XFxuICBmb250LXNpemU6IDdlbTtcXG59XFxuXFxuLmZhLTh4IHtcXG4gIGZvbnQtc2l6ZTogOGVtO1xcbn1cXG5cXG4uZmEtOXgge1xcbiAgZm9udC1zaXplOiA5ZW07XFxufVxcblxcbi5mYS0xMHgge1xcbiAgZm9udC1zaXplOiAxMGVtO1xcbn1cXG5cXG4uZmEtZncge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd2lkdGg6IDEuMjVlbTtcXG59XFxuXFxuLmZhLXVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIG1hcmdpbi1sZWZ0OiAyLjVlbTtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG59XFxuLmZhLXVsID4gbGkge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uZmEtbGkge1xcbiAgbGVmdDogLTJlbTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHdpZHRoOiAyZW07XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG59XFxuXFxuLmZhLWJvcmRlciB7XFxuICBib3JkZXI6IHNvbGlkIDAuMDhlbSAjZWVlO1xcbiAgYm9yZGVyLXJhZGl1czogMC4xZW07XFxuICBwYWRkaW5nOiAwLjJlbSAwLjI1ZW0gMC4xNWVtO1xcbn1cXG5cXG4uZmEtcHVsbC1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uZmEtcHVsbC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbi5mYS5mYS1wdWxsLWxlZnQsXFxuLmZhcy5mYS1wdWxsLWxlZnQsXFxuLmZhci5mYS1wdWxsLWxlZnQsXFxuLmZhbC5mYS1wdWxsLWxlZnQsXFxuLmZhYi5mYS1wdWxsLWxlZnQge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjNlbTtcXG59XFxuLmZhLmZhLXB1bGwtcmlnaHQsXFxuLmZhcy5mYS1wdWxsLXJpZ2h0LFxcbi5mYXIuZmEtcHVsbC1yaWdodCxcXG4uZmFsLmZhLXB1bGwtcmlnaHQsXFxuLmZhYi5mYS1wdWxsLXJpZ2h0IHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjNlbTtcXG59XFxuXFxuLmZhLXNwaW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb246IGZhLXNwaW4gMnMgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICBhbmltYXRpb246IGZhLXNwaW4gMnMgaW5maW5pdGUgbGluZWFyO1xcbn1cXG5cXG4uZmEtcHVsc2Uge1xcbiAgLXdlYmtpdC1hbmltYXRpb246IGZhLXNwaW4gMXMgaW5maW5pdGUgc3RlcHMoOCk7XFxuICAgICAgICAgIGFuaW1hdGlvbjogZmEtc3BpbiAxcyBpbmZpbml0ZSBzdGVwcyg4KTtcXG59XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhLXNwaW4ge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIGZhLXNwaW4ge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG4uZmEtcm90YXRlLTkwIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0xKVxcXCI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbn1cXG5cXG4uZmEtcm90YXRlLTE4MCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MilcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbn1cXG5cXG4uZmEtcm90YXRlLTI3MCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MylcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbn1cXG5cXG4uZmEtZmxpcC1ob3Jpem9udGFsIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0wLCBtaXJyb3I9MSlcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKC0xLCAxKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XFxufVxcblxcbi5mYS1mbGlwLXZlcnRpY2FsIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0yLCBtaXJyb3I9MSlcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEsIC0xKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7XFxufVxcblxcbi5mYS1mbGlwLWJvdGgsIC5mYS1mbGlwLWhvcml6b250YWwuZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MiwgbWlycm9yPTEpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgtMSwgLTEpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKC0xLCAtMSk7XFxufVxcblxcbjpyb290IC5mYS1yb3RhdGUtOTAsXFxuOnJvb3QgLmZhLXJvdGF0ZS0xODAsXFxuOnJvb3QgLmZhLXJvdGF0ZS0yNzAsXFxuOnJvb3QgLmZhLWZsaXAtaG9yaXpvbnRhbCxcXG46cm9vdCAuZmEtZmxpcC12ZXJ0aWNhbCxcXG46cm9vdCAuZmEtZmxpcC1ib3RoIHtcXG4gIC13ZWJraXQtZmlsdGVyOiBub25lO1xcbiAgICAgICAgICBmaWx0ZXI6IG5vbmU7XFxufVxcblxcbi5mYS1zdGFjayB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBoZWlnaHQ6IDJlbTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAyLjVlbTtcXG59XFxuXFxuLmZhLXN0YWNrLTF4LFxcbi5mYS1zdGFjay0yeCB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxufVxcblxcbi5zdmctaW5saW5lLS1mYS5mYS1zdGFjay0xeCB7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIHdpZHRoOiAxLjI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS1zdGFjay0yeCB7XFxuICBoZWlnaHQ6IDJlbTtcXG4gIHdpZHRoOiAyLjVlbTtcXG59XFxuXFxuLmZhLWludmVyc2Uge1xcbiAgY29sb3I6ICNmZmY7XFxufVxcblxcbi5zci1vbmx5IHtcXG4gIGJvcmRlcjogMDtcXG4gIGNsaXA6IHJlY3QoMCwgMCwgMCwgMCk7XFxuICBoZWlnaHQ6IDFweDtcXG4gIG1hcmdpbjogLTFweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDFweDtcXG59XFxuXFxuLnNyLW9ubHktZm9jdXNhYmxlOmFjdGl2ZSwgLnNyLW9ubHktZm9jdXNhYmxlOmZvY3VzIHtcXG4gIGNsaXA6IGF1dG87XFxuICBoZWlnaHQ6IGF1dG87XFxuICBtYXJnaW46IDA7XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIHBvc2l0aW9uOiBzdGF0aWM7XFxuICB3aWR0aDogYXV0bztcXG59XCI7XG5cbmZ1bmN0aW9uIGNzcyAoKSB7XG4gIHZhciBkZnAgPSBERUZBVUxUX0ZBTUlMWV9QUkVGSVg7XG4gIHZhciBkcmMgPSBERUZBVUxUX1JFUExBQ0VNRU5UX0NMQVNTO1xuICB2YXIgZnAgPSBjb25maWcuZmFtaWx5UHJlZml4O1xuICB2YXIgcmMgPSBjb25maWcucmVwbGFjZW1lbnRDbGFzcztcbiAgdmFyIHMgPSBiYXNlU3R5bGVzO1xuXG4gIGlmIChmcCAhPT0gZGZwIHx8IHJjICE9PSBkcmMpIHtcbiAgICB2YXIgZFBhdHQgPSBuZXcgUmVnRXhwKFwiXFxcXC5cIi5jb25jYXQoZGZwLCBcIlxcXFwtXCIpLCAnZycpO1xuICAgIHZhciByUGF0dCA9IG5ldyBSZWdFeHAoXCJcXFxcLlwiLmNvbmNhdChkcmMpLCAnZycpO1xuICAgIHMgPSBzLnJlcGxhY2UoZFBhdHQsIFwiLlwiLmNvbmNhdChmcCwgXCItXCIpKS5yZXBsYWNlKHJQYXR0LCBcIi5cIi5jb25jYXQocmMpKTtcbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG52YXIgTGlicmFyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpYnJhcnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpYnJhcnkpO1xuXG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpYnJhcnksIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGVmaW5pdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGRlZmluaXRpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWRkaXRpb25zID0gZGVmaW5pdGlvbnMucmVkdWNlKHRoaXMuX3B1bGxEZWZpbml0aW9ucywge30pO1xuICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX3RoaXMuZGVmaW5pdGlvbnNba2V5XSA9IF9vYmplY3RTcHJlYWQoe30sIF90aGlzLmRlZmluaXRpb25zW2tleV0gfHwge30sIGFkZGl0aW9uc1trZXldKTtcbiAgICAgICAgZGVmaW5lSWNvbnMoa2V5LCBhZGRpdGlvbnNba2V5XSk7XG4gICAgICAgIGJ1aWxkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmRlZmluaXRpb25zID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wdWxsRGVmaW5pdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1bGxEZWZpbml0aW9ucyhhZGRpdGlvbnMsIGRlZmluaXRpb24pIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0gZGVmaW5pdGlvbi5wcmVmaXggJiYgZGVmaW5pdGlvbi5pY29uTmFtZSAmJiBkZWZpbml0aW9uLmljb24gPyB7XG4gICAgICAgIDA6IGRlZmluaXRpb25cbiAgICAgIH0gOiBkZWZpbml0aW9uO1xuICAgICAgT2JqZWN0LmtleXMobm9ybWFsaXplZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9ub3JtYWxpemVkJGtleSA9IG5vcm1hbGl6ZWRba2V5XSxcbiAgICAgICAgICAgIHByZWZpeCA9IF9ub3JtYWxpemVkJGtleS5wcmVmaXgsXG4gICAgICAgICAgICBpY29uTmFtZSA9IF9ub3JtYWxpemVkJGtleS5pY29uTmFtZSxcbiAgICAgICAgICAgIGljb24gPSBfbm9ybWFsaXplZCRrZXkuaWNvbjtcbiAgICAgICAgaWYgKCFhZGRpdGlvbnNbcHJlZml4XSkgYWRkaXRpb25zW3ByZWZpeF0gPSB7fTtcbiAgICAgICAgYWRkaXRpb25zW3ByZWZpeF1baWNvbk5hbWVdID0gaWNvbjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFkZGl0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlicmFyeTtcbn0oKTtcblxuZnVuY3Rpb24gcHJlcEljb24oaWNvbikge1xuICB2YXIgd2lkdGggPSBpY29uWzBdO1xuICB2YXIgaGVpZ2h0ID0gaWNvblsxXTtcbiAgdmFyIHZlY3RvckRhdGEgPSBpY29uLnNsaWNlKDQpO1xuICByZXR1cm4ge1xuICAgIGZvdW5kOiB0cnVlLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBpY29uOiB7XG4gICAgICB0YWc6ICdwYXRoJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgIGQ6IHZlY3RvckRhdGFbMF1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNzcygpIHtcbiAgaWYgKGNvbmZpZy5hdXRvQWRkQ3NzICYmICFfY3NzSW5zZXJ0ZWQpIHtcbiAgICBpbnNlcnRDc3MoY3NzKCkpO1xuXG4gICAgX2Nzc0luc2VydGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcGlPYmplY3QodmFsLCBhYnN0cmFjdENyZWF0b3IpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ2Fic3RyYWN0Jywge1xuICAgIGdldDogYWJzdHJhY3RDcmVhdG9yXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsLCAnaHRtbCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWwuYWJzdHJhY3QubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0b0h0bWwoYSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsLCAnbm9kZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSVNfRE9NKSByZXR1cm47XG4gICAgICB2YXIgY29udGFpbmVyID0gRE9DVU1FTlQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdmFsLmh0bWw7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGZpbmRJY29uRGVmaW5pdGlvbihpY29uTG9va3VwKSB7XG4gIHZhciBfaWNvbkxvb2t1cCRwcmVmaXggPSBpY29uTG9va3VwLnByZWZpeCxcbiAgICAgIHByZWZpeCA9IF9pY29uTG9va3VwJHByZWZpeCA9PT0gdm9pZCAwID8gJ2ZhJyA6IF9pY29uTG9va3VwJHByZWZpeCxcbiAgICAgIGljb25OYW1lID0gaWNvbkxvb2t1cC5pY29uTmFtZTtcbiAgaWYgKCFpY29uTmFtZSkgcmV0dXJuO1xuICByZXR1cm4gaWNvbkZyb21NYXBwaW5nKGxpYnJhcnkuZGVmaW5pdGlvbnMsIHByZWZpeCwgaWNvbk5hbWUpIHx8IGljb25Gcm9tTWFwcGluZyhuYW1lc3BhY2Uuc3R5bGVzLCBwcmVmaXgsIGljb25OYW1lKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUljb25zKG5leHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXliZUljb25EZWZpbml0aW9uKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGljb25EZWZpbml0aW9uID0gKG1heWJlSWNvbkRlZmluaXRpb24gfHwge30pLmljb24gPyBtYXliZUljb25EZWZpbml0aW9uIDogZmluZEljb25EZWZpbml0aW9uKG1heWJlSWNvbkRlZmluaXRpb24gfHwge30pO1xuICAgIHZhciBtYXNrID0gcGFyYW1zLm1hc2s7XG5cbiAgICBpZiAobWFzaykge1xuICAgICAgbWFzayA9IChtYXNrIHx8IHt9KS5pY29uID8gbWFzayA6IGZpbmRJY29uRGVmaW5pdGlvbihtYXNrIHx8IHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dChpY29uRGVmaW5pdGlvbiwgX29iamVjdFNwcmVhZCh7fSwgcGFyYW1zLCB7XG4gICAgICBtYXNrOiBtYXNrXG4gICAgfSkpO1xuICB9O1xufVxuXG52YXIgbGlicmFyeSA9IG5ldyBMaWJyYXJ5KCk7XG52YXIgbm9BdXRvID0gZnVuY3Rpb24gbm9BdXRvKCkge1xuICBjb25maWcuYXV0b1JlcGxhY2VTdmcgPSBmYWxzZTtcbiAgY29uZmlnLm9ic2VydmVNdXRhdGlvbnMgPSBmYWxzZTtcbiAgZGlzY29ubmVjdCgpO1xufTtcbnZhciBfY3NzSW5zZXJ0ZWQgPSBmYWxzZTtcbnZhciBkb20gPSB7XG4gIGkyc3ZnOiBmdW5jdGlvbiBpMnN2ZygpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmIChJU19ET00pIHtcbiAgICAgIGVuc3VyZUNzcygpO1xuICAgICAgdmFyIF9wYXJhbXMkbm9kZSA9IHBhcmFtcy5ub2RlLFxuICAgICAgICAgIG5vZGUgPSBfcGFyYW1zJG5vZGUgPT09IHZvaWQgMCA/IERPQ1VNRU5UIDogX3BhcmFtcyRub2RlLFxuICAgICAgICAgIF9wYXJhbXMkY2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2ssXG4gICAgICAgICAgY2FsbGJhY2sgPSBfcGFyYW1zJGNhbGxiYWNrID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF9wYXJhbXMkY2FsbGJhY2s7XG5cbiAgICAgIGlmIChjb25maWcuc2VhcmNoUHNldWRvRWxlbWVudHMpIHtcbiAgICAgICAgc2VhcmNoUHNldWRvRWxlbWVudHMobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvblRyZWUobm9kZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGlja2VkLnJlamVjdCgnT3BlcmF0aW9uIHJlcXVpcmVzIGEgRE9NIG9mIHNvbWUga2luZC4nKTtcbiAgICB9XG4gIH0sXG4gIGNzczogY3NzLFxuICBpbnNlcnRDc3M6IGZ1bmN0aW9uIGluc2VydENzcyQkMSgpIHtcbiAgICBpZiAoIV9jc3NJbnNlcnRlZCkge1xuICAgICAgaW5zZXJ0Q3NzKGNzcygpKTtcblxuICAgICAgX2Nzc0luc2VydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiBmdW5jdGlvbiB3YXRjaCgpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYXV0b1JlcGxhY2VTdmdSb290ID0gcGFyYW1zLmF1dG9SZXBsYWNlU3ZnUm9vdCxcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uc1Jvb3QgPSBwYXJhbXMub2JzZXJ2ZU11dGF0aW9uc1Jvb3Q7XG5cbiAgICBpZiAoY29uZmlnLmF1dG9SZXBsYWNlU3ZnID09PSBmYWxzZSkge1xuICAgICAgY29uZmlnLmF1dG9SZXBsYWNlU3ZnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25maWcub2JzZXJ2ZU11dGF0aW9ucyA9IHRydWU7XG4gICAgZG9tcmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgYXV0b1JlcGxhY2Uoe1xuICAgICAgICBhdXRvUmVwbGFjZVN2Z1Jvb3Q6IGF1dG9SZXBsYWNlU3ZnUm9vdFxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlKHtcbiAgICAgICAgdHJlZUNhbGxiYWNrOiBvblRyZWUsXG4gICAgICAgIG5vZGVDYWxsYmFjazogb25Ob2RlLFxuICAgICAgICBwc2V1ZG9FbGVtZW50c0NhbGxiYWNrOiBzZWFyY2hQc2V1ZG9FbGVtZW50cyxcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uc1Jvb3Q6IG9ic2VydmVNdXRhdGlvbnNSb290XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBwYXJzZSA9IHtcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0odHJhbnNmb3JtU3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhcnNlVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybVN0cmluZyk7XG4gIH1cbn07XG52YXIgaWNvbiA9IHJlc29sdmVJY29ucyhmdW5jdGlvbiAoaWNvbkRlZmluaXRpb24pIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfcGFyYW1zJHRyYW5zZm9ybSA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcGFyYW1zJHRyYW5zZm9ybSA9PT0gdm9pZCAwID8gbWVhbmluZ2xlc3NUcmFuc2Zvcm0gOiBfcGFyYW1zJHRyYW5zZm9ybSxcbiAgICAgIF9wYXJhbXMkc3ltYm9sID0gcGFyYW1zLnN5bWJvbCxcbiAgICAgIHN5bWJvbCA9IF9wYXJhbXMkc3ltYm9sID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJhbXMkc3ltYm9sLFxuICAgICAgX3BhcmFtcyRtYXNrID0gcGFyYW1zLm1hc2ssXG4gICAgICBtYXNrID0gX3BhcmFtcyRtYXNrID09PSB2b2lkIDAgPyBudWxsIDogX3BhcmFtcyRtYXNrLFxuICAgICAgX3BhcmFtcyR0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIHRpdGxlID0gX3BhcmFtcyR0aXRsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkdGl0bGUsXG4gICAgICBfcGFyYW1zJGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcyxcbiAgICAgIGNsYXNzZXMgPSBfcGFyYW1zJGNsYXNzZXMgPT09IHZvaWQgMCA/IFtdIDogX3BhcmFtcyRjbGFzc2VzLFxuICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX3BhcmFtcyRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkYXR0cmlidXRlcyxcbiAgICAgIF9wYXJhbXMkc3R5bGVzID0gcGFyYW1zLnN0eWxlcyxcbiAgICAgIHN0eWxlcyA9IF9wYXJhbXMkc3R5bGVzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkc3R5bGVzO1xuICBpZiAoIWljb25EZWZpbml0aW9uKSByZXR1cm47XG4gIHZhciBwcmVmaXggPSBpY29uRGVmaW5pdGlvbi5wcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IGljb25EZWZpbml0aW9uLmljb25OYW1lLFxuICAgICAgaWNvbiA9IGljb25EZWZpbml0aW9uLmljb247XG4gIHJldHVybiBhcGlPYmplY3QoX29iamVjdFNwcmVhZCh7XG4gICAgdHlwZTogJ2ljb24nXG4gIH0sIGljb25EZWZpbml0aW9uKSwgZnVuY3Rpb24gKCkge1xuICAgIGVuc3VyZUNzcygpO1xuXG4gICAgaWYgKGNvbmZpZy5hdXRvQTExeSkge1xuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbJ2FyaWEtbGFiZWxsZWRieSddID0gXCJcIi5jb25jYXQoY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MsIFwiLXRpdGxlLVwiKS5jb25jYXQobmV4dFVuaXF1ZUlkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1snYXJpYS1oaWRkZW4nXSA9ICd0cnVlJztcbiAgICAgICAgYXR0cmlidXRlc1snZm9jdXNhYmxlJ10gPSAnZmFsc2UnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlSW5saW5lU3ZnQWJzdHJhY3Qoe1xuICAgICAgaWNvbnM6IHtcbiAgICAgICAgbWFpbjogcHJlcEljb24oaWNvbiksXG4gICAgICAgIG1hc2s6IG1hc2sgPyBwcmVwSWNvbihtYXNrLmljb24pIDoge1xuICAgICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgaWNvbjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgICAgdHJhbnNmb3JtOiBfb2JqZWN0U3ByZWFkKHt9LCBtZWFuaW5nbGVzc1RyYW5zZm9ybSwgdHJhbnNmb3JtKSxcbiAgICAgIHN5bWJvbDogc3ltYm9sLFxuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgZXh0cmE6IHtcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICAgIGNsYXNzZXM6IGNsYXNzZXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbnZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dChjb250ZW50KSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX3BhcmFtcyR0cmFuc2Zvcm0yID0gcGFyYW1zLnRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybSA9IF9wYXJhbXMkdHJhbnNmb3JtMiA9PT0gdm9pZCAwID8gbWVhbmluZ2xlc3NUcmFuc2Zvcm0gOiBfcGFyYW1zJHRyYW5zZm9ybTIsXG4gICAgICBfcGFyYW1zJHRpdGxlMiA9IHBhcmFtcy50aXRsZSxcbiAgICAgIHRpdGxlID0gX3BhcmFtcyR0aXRsZTIgPT09IHZvaWQgMCA/IG51bGwgOiBfcGFyYW1zJHRpdGxlMixcbiAgICAgIF9wYXJhbXMkY2xhc3NlczIgPSBwYXJhbXMuY2xhc3NlcyxcbiAgICAgIGNsYXNzZXMgPSBfcGFyYW1zJGNsYXNzZXMyID09PSB2b2lkIDAgPyBbXSA6IF9wYXJhbXMkY2xhc3NlczIsXG4gICAgICBfcGFyYW1zJGF0dHJpYnV0ZXMyID0gcGFyYW1zLmF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX3BhcmFtcyRhdHRyaWJ1dGVzMiA9PT0gdm9pZCAwID8ge30gOiBfcGFyYW1zJGF0dHJpYnV0ZXMyLFxuICAgICAgX3BhcmFtcyRzdHlsZXMyID0gcGFyYW1zLnN0eWxlcyxcbiAgICAgIHN0eWxlcyA9IF9wYXJhbXMkc3R5bGVzMiA9PT0gdm9pZCAwID8ge30gOiBfcGFyYW1zJHN0eWxlczI7XG4gIHJldHVybiBhcGlPYmplY3Qoe1xuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBjb250ZW50OiBjb250ZW50XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBlbnN1cmVDc3MoKTtcbiAgICByZXR1cm4gbWFrZUxheWVyc1RleHRBYnN0cmFjdCh7XG4gICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgdHJhbnNmb3JtOiBfb2JqZWN0U3ByZWFkKHt9LCBtZWFuaW5nbGVzc1RyYW5zZm9ybSwgdHJhbnNmb3JtKSxcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICBjbGFzc2VzOiBbXCJcIi5jb25jYXQoY29uZmlnLmZhbWlseVByZWZpeCwgXCItbGF5ZXJzLXRleHRcIildLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NlcykpXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcbnZhciBjb3VudGVyID0gZnVuY3Rpb24gY291bnRlcihjb250ZW50KSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX3BhcmFtcyR0aXRsZTMgPSBwYXJhbXMudGl0bGUsXG4gICAgICB0aXRsZSA9IF9wYXJhbXMkdGl0bGUzID09PSB2b2lkIDAgPyBudWxsIDogX3BhcmFtcyR0aXRsZTMsXG4gICAgICBfcGFyYW1zJGNsYXNzZXMzID0gcGFyYW1zLmNsYXNzZXMsXG4gICAgICBjbGFzc2VzID0gX3BhcmFtcyRjbGFzc2VzMyA9PT0gdm9pZCAwID8gW10gOiBfcGFyYW1zJGNsYXNzZXMzLFxuICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzMyA9IHBhcmFtcy5hdHRyaWJ1dGVzLFxuICAgICAgYXR0cmlidXRlcyA9IF9wYXJhbXMkYXR0cmlidXRlczMgPT09IHZvaWQgMCA/IHt9IDogX3BhcmFtcyRhdHRyaWJ1dGVzMyxcbiAgICAgIF9wYXJhbXMkc3R5bGVzMyA9IHBhcmFtcy5zdHlsZXMsXG4gICAgICBzdHlsZXMgPSBfcGFyYW1zJHN0eWxlczMgPT09IHZvaWQgMCA/IHt9IDogX3BhcmFtcyRzdHlsZXMzO1xuICByZXR1cm4gYXBpT2JqZWN0KHtcbiAgICB0eXBlOiAnY291bnRlcicsXG4gICAgY29udGVudDogY29udGVudFxuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgZW5zdXJlQ3NzKCk7XG4gICAgcmV0dXJuIG1ha2VMYXllcnNDb3VudGVyQWJzdHJhY3Qoe1xuICAgICAgY29udGVudDogY29udGVudC50b1N0cmluZygpLFxuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgZXh0cmE6IHtcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICAgIGNsYXNzZXM6IFtcIlwiLmNvbmNhdChjb25maWcuZmFtaWx5UHJlZml4LCBcIi1sYXllcnMtY291bnRlclwiKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjbGFzc2VzKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xudmFyIGxheWVyID0gZnVuY3Rpb24gbGF5ZXIoYXNzZW1ibGVyKSB7XG4gIHJldHVybiBhcGlPYmplY3Qoe1xuICAgIHR5cGU6ICdsYXllcidcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIGVuc3VyZUNzcygpO1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIGFzc2VtYmxlcihmdW5jdGlvbiAoYXJncykge1xuICAgICAgQXJyYXkuaXNBcnJheShhcmdzKSA/IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KGEuYWJzdHJhY3QpO1xuICAgICAgfSkgOiBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChhcmdzLmFic3RyYWN0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3tcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBjbGFzczogXCJcIi5jb25jYXQoY29uZmlnLmZhbWlseVByZWZpeCwgXCItbGF5ZXJzXCIpXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfV07XG4gIH0pO1xufTtcbnZhciBhcGkgPSB7XG4gIG5vQXV0bzogbm9BdXRvLFxuICBjb25maWc6IGNvbmZpZyxcbiAgZG9tOiBkb20sXG4gIGxpYnJhcnk6IGxpYnJhcnksXG4gIHBhcnNlOiBwYXJzZSxcbiAgZmluZEljb25EZWZpbml0aW9uOiBmaW5kSWNvbkRlZmluaXRpb24sXG4gIGljb246IGljb24sXG4gIHRleHQ6IHRleHQsXG4gIGNvdW50ZXI6IGNvdW50ZXIsXG4gIGxheWVyOiBsYXllcixcbiAgdG9IdG1sOiB0b0h0bWxcbn07XG5cbnZhciBhdXRvUmVwbGFjZSA9IGZ1bmN0aW9uIGF1dG9SZXBsYWNlKCkge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkYXV0b1JlcGxhY2VTdiA9IHBhcmFtcy5hdXRvUmVwbGFjZVN2Z1Jvb3QsXG4gICAgICBhdXRvUmVwbGFjZVN2Z1Jvb3QgPSBfcGFyYW1zJGF1dG9SZXBsYWNlU3YgPT09IHZvaWQgMCA/IERPQ1VNRU5UIDogX3BhcmFtcyRhdXRvUmVwbGFjZVN2O1xuICBpZiAoKE9iamVjdC5rZXlzKG5hbWVzcGFjZS5zdHlsZXMpLmxlbmd0aCA+IDAgfHwgY29uZmlnLmF1dG9GZXRjaFN2ZykgJiYgSVNfRE9NICYmIGNvbmZpZy5hdXRvUmVwbGFjZVN2ZykgYXBpLmRvbS5pMnN2Zyh7XG4gICAgbm9kZTogYXV0b1JlcGxhY2VTdmdSb290XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgaWNvbiwgbm9BdXRvLCBjb25maWcsIHRvSHRtbCwgbGF5ZXIsIHRleHQsIGNvdW50ZXIsIGxpYnJhcnksIGRvbSwgcGFyc2UsIGZpbmRJY29uRGVmaW5pdGlvbiB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVmaXggPSAnZmFiJztcbnZhciBpY29uTmFtZSA9ICdmYWNlYm9vayc7XG52YXIgd2lkdGggPSA1MTI7XG52YXIgaGVpZ2h0ID0gNTEyO1xudmFyIGxpZ2F0dXJlcyA9IFtdO1xudmFyIHVuaWNvZGUgPSAnZjA5YSc7XG52YXIgc3ZnUGF0aERhdGEgPSAnTTUwNCAyNTZDNTA0IDExOSAzOTMgOCAyNTYgOFM4IDExOSA4IDI1NmMwIDEyMy43OCA5MC42OSAyMjYuMzggMjA5LjI1IDI0NVYzMjcuNjloLTYzVjI1Nmg2M3YtNTQuNjRjMC02Mi4xNSAzNy05Ni40OCA5My42Ny05Ni40OCAyNy4xNCAwIDU1LjUyIDQuODQgNTUuNTIgNC44NHY2MWgtMzEuMjhjLTMwLjggMC00MC40MSAxOS4xMi00MC40MSAzOC43M1YyNTZoNjguNzhsLTExIDcxLjY5aC01Ny43OFY1MDFDNDEzLjMxIDQ4Mi4zOCA1MDQgMzc5Ljc4IDUwNCAyNTZ6JztcblxuZXhwb3J0cy5kZWZpbml0aW9uID0ge1xuICBwcmVmaXg6IHByZWZpeCxcbiAgaWNvbk5hbWU6IGljb25OYW1lLFxuICBpY29uOiBbXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxpZ2F0dXJlcyxcbiAgICB1bmljb2RlLFxuICAgIHN2Z1BhdGhEYXRhXG4gIF19O1xuXG5leHBvcnRzLmZhRmFjZWJvb2sgPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAnZmFjZWJvb2stZic7XG52YXIgd2lkdGggPSAzMjA7XG52YXIgaGVpZ2h0ID0gNTEyO1xudmFyIGxpZ2F0dXJlcyA9IFtdO1xudmFyIHVuaWNvZGUgPSAnZjM5ZSc7XG52YXIgc3ZnUGF0aERhdGEgPSAnTTI3OS4xNCAyODhsMTQuMjItOTIuNjZoLTg4Ljkxdi02MC4xM2MwLTI1LjM1IDEyLjQyLTUwLjA2IDUyLjI0LTUwLjA2aDQwLjQyVjYuMjZTMjYwLjQzIDAgMjI1LjM2IDBjLTczLjIyIDAtMTIxLjA4IDQ0LjM4LTEyMS4wOCAxMjQuNzJ2NzAuNjJIMjIuODlWMjg4aDgxLjM5djIyNGgxMDAuMTdWMjg4eic7XG5cbmV4cG9ydHMuZGVmaW5pdGlvbiA9IHtcbiAgcHJlZml4OiBwcmVmaXgsXG4gIGljb25OYW1lOiBpY29uTmFtZSxcbiAgaWNvbjogW1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsaWdhdHVyZXMsXG4gICAgdW5pY29kZSxcbiAgICBzdmdQYXRoRGF0YVxuICBdfTtcblxuZXhwb3J0cy5mYUZhY2Vib29rRiA9IGV4cG9ydHMuZGVmaW5pdGlvbjtcbmV4cG9ydHMucHJlZml4ID0gcHJlZml4O1xuZXhwb3J0cy5pY29uTmFtZSA9IGljb25OYW1lO1xuZXhwb3J0cy53aWR0aCA9IHdpZHRoO1xuZXhwb3J0cy5oZWlnaHQgPSBoZWlnaHQ7XG5leHBvcnRzLmxpZ2F0dXJlcyA9IGxpZ2F0dXJlcztcbmV4cG9ydHMudW5pY29kZSA9IHVuaWNvZGU7XG5leHBvcnRzLnN2Z1BhdGhEYXRhID0gc3ZnUGF0aERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVmaXggPSAnZmFiJztcbnZhciBpY29uTmFtZSA9ICdpbnN0YWdyYW0nO1xudmFyIHdpZHRoID0gNDQ4O1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2YxNmQnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ00yMjQuMSAxNDFjLTYzLjYgMC0xMTQuOSA1MS4zLTExNC45IDExNC45czUxLjMgMTE0LjkgMTE0LjkgMTE0LjlTMzM5IDMxOS41IDMzOSAyNTUuOSAyODcuNyAxNDEgMjI0LjEgMTQxem0wIDE4OS42Yy00MS4xIDAtNzQuNy0zMy41LTc0LjctNzQuN3MzMy41LTc0LjcgNzQuNy03NC43IDc0LjcgMzMuNSA3NC43IDc0LjctMzMuNiA3NC43LTc0LjcgNzQuN3ptMTQ2LjQtMTk0LjNjMCAxNC45LTEyIDI2LjgtMjYuOCAyNi44LTE0LjkgMC0yNi44LTEyLTI2LjgtMjYuOHMxMi0yNi44IDI2LjgtMjYuOCAyNi44IDEyIDI2LjggMjYuOHptNzYuMSAyNy4yYy0xLjctMzUuOS05LjktNjcuNy0zNi4yLTkzLjktMjYuMi0yNi4yLTU4LTM0LjQtOTMuOS0zNi4yLTM3LTIuMS0xNDcuOS0yLjEtMTg0LjkgMC0zNS44IDEuNy02Ny42IDkuOS05My45IDM2LjFzLTM0LjQgNTgtMzYuMiA5My45Yy0yLjEgMzctMi4xIDE0Ny45IDAgMTg0LjkgMS43IDM1LjkgOS45IDY3LjcgMzYuMiA5My45czU4IDM0LjQgOTMuOSAzNi4yYzM3IDIuMSAxNDcuOSAyLjEgMTg0LjkgMCAzNS45LTEuNyA2Ny43LTkuOSA5My45LTM2LjIgMjYuMi0yNi4yIDM0LjQtNTggMzYuMi05My45IDIuMS0zNyAyLjEtMTQ3LjggMC0xODQuOHpNMzk4LjggMzg4Yy03LjggMTkuNi0yMi45IDM0LjctNDIuNiA0Mi42LTI5LjUgMTEuNy05OS41IDktMTMyLjEgOXMtMTAyLjcgMi42LTEzMi4xLTljLTE5LjYtNy44LTM0LjctMjIuOS00Mi42LTQyLjYtMTEuNy0yOS41LTktOTkuNS05LTEzMi4xcy0yLjYtMTAyLjcgOS0xMzIuMWM3LjgtMTkuNiAyMi45LTM0LjcgNDIuNi00Mi42IDI5LjUtMTEuNyA5OS41LTkgMTMyLjEtOXMxMDIuNy0yLjYgMTMyLjEgOWMxOS42IDcuOCAzNC43IDIyLjkgNDIuNiA0Mi42IDExLjcgMjkuNSA5IDk5LjUgOSAxMzIuMXMyLjcgMTAyLjctOSAxMzIuMXonO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFJbnN0YWdyYW0gPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAnbGlua2VkaW4nO1xudmFyIHdpZHRoID0gNDQ4O1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2YwOGMnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ000MTYgMzJIMzEuOUMxNC4zIDMyIDAgNDYuNSAwIDY0LjN2MzgzLjRDMCA0NjUuNSAxNC4zIDQ4MCAzMS45IDQ4MEg0MTZjMTcuNiAwIDMyLTE0LjUgMzItMzIuM1Y2NC4zYzAtMTcuOC0xNC40LTMyLjMtMzItMzIuM3pNMTM1LjQgNDE2SDY5VjIwMi4yaDY2LjVWNDE2em0tMzMuMi0yNDNjLTIxLjMgMC0zOC41LTE3LjMtMzguNS0zOC41UzgwLjkgOTYgMTAyLjIgOTZjMjEuMiAwIDM4LjUgMTcuMyAzOC41IDM4LjUgMCAyMS4zLTE3LjIgMzguNS0zOC41IDM4LjV6bTI4Mi4xIDI0M2gtNjYuNFYzMTJjMC0yNC44LS41LTU2LjctMzQuNS01Ni43LTM0LjYgMC0zOS45IDI3LTM5LjkgNTQuOVY0MTZoLTY2LjRWMjAyLjJoNjMuN3YyOS4yaC45YzguOS0xNi44IDMwLjYtMzQuNSA2Mi45LTM0LjUgNjcuMiAwIDc5LjcgNDQuMyA3OS43IDEwMS45VjQxNnonO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFMaW5rZWRpbiA9IGV4cG9ydHMuZGVmaW5pdGlvbjtcbmV4cG9ydHMucHJlZml4ID0gcHJlZml4O1xuZXhwb3J0cy5pY29uTmFtZSA9IGljb25OYW1lO1xuZXhwb3J0cy53aWR0aCA9IHdpZHRoO1xuZXhwb3J0cy5oZWlnaHQgPSBoZWlnaHQ7XG5leHBvcnRzLmxpZ2F0dXJlcyA9IGxpZ2F0dXJlcztcbmV4cG9ydHMudW5pY29kZSA9IHVuaWNvZGU7XG5leHBvcnRzLnN2Z1BhdGhEYXRhID0gc3ZnUGF0aERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVmaXggPSAnZmFiJztcbnZhciBpY29uTmFtZSA9ICdsaW5rZWRpbi1pbic7XG52YXIgd2lkdGggPSA0NDg7XG52YXIgaGVpZ2h0ID0gNTEyO1xudmFyIGxpZ2F0dXJlcyA9IFtdO1xudmFyIHVuaWNvZGUgPSAnZjBlMSc7XG52YXIgc3ZnUGF0aERhdGEgPSAnTTEwMC4yOCA0NDhINy40VjE0OC45aDkyLjg4ek01My43OSAxMDguMUMyNC4wOSAxMDguMSAwIDgzLjUgMCA1My44YTUzLjc5IDUzLjc5IDAgMCAxIDEwNy41OCAwYzAgMjkuNy0yNC4xIDU0LjMtNTMuNzkgNTQuM3pNNDQ3LjkgNDQ4aC05Mi42OFYzMDIuNGMwLTM0LjctLjctNzkuMi00OC4yOS03OS4yLTQ4LjI5IDAtNTUuNjkgMzcuNy01NS42OSA3Ni43VjQ0OGgtOTIuNzhWMTQ4LjloODkuMDh2NDAuOGgxLjNjMTIuNC0yMy41IDQyLjY5LTQ4LjMgODcuODgtNDguMyA5NCAwIDExMS4yOCA2MS45IDExMS4yOCAxNDIuM1Y0NDh6JztcblxuZXhwb3J0cy5kZWZpbml0aW9uID0ge1xuICBwcmVmaXg6IHByZWZpeCxcbiAgaWNvbk5hbWU6IGljb25OYW1lLFxuICBpY29uOiBbXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxpZ2F0dXJlcyxcbiAgICB1bmljb2RlLFxuICAgIHN2Z1BhdGhEYXRhXG4gIF19O1xuXG5leHBvcnRzLmZhTGlua2VkaW5JbiA9IGV4cG9ydHMuZGVmaW5pdGlvbjtcbmV4cG9ydHMucHJlZml4ID0gcHJlZml4O1xuZXhwb3J0cy5pY29uTmFtZSA9IGljb25OYW1lO1xuZXhwb3J0cy53aWR0aCA9IHdpZHRoO1xuZXhwb3J0cy5oZWlnaHQgPSBoZWlnaHQ7XG5leHBvcnRzLmxpZ2F0dXJlcyA9IGxpZ2F0dXJlcztcbmV4cG9ydHMudW5pY29kZSA9IHVuaWNvZGU7XG5leHBvcnRzLnN2Z1BhdGhEYXRhID0gc3ZnUGF0aERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVmaXggPSAnZmFiJztcbnZhciBpY29uTmFtZSA9ICd0d2l0dGVyJztcbnZhciB3aWR0aCA9IDUxMjtcbnZhciBoZWlnaHQgPSA1MTI7XG52YXIgbGlnYXR1cmVzID0gW107XG52YXIgdW5pY29kZSA9ICdmMDk5JztcbnZhciBzdmdQYXRoRGF0YSA9ICdNNDU5LjM3IDE1MS43MTZjLjMyNSA0LjU0OC4zMjUgOS4wOTcuMzI1IDEzLjY0NSAwIDEzOC43Mi0xMDUuNTgzIDI5OC41NTgtMjk4LjU1OCAyOTguNTU4LTU5LjQ1MiAwLTExNC42OC0xNy4yMTktMTYxLjEzNy00Ny4xMDYgOC40NDcuOTc0IDE2LjU2OCAxLjI5OSAyNS4zNCAxLjI5OSA0OS4wNTUgMCA5NC4yMTMtMTYuNTY4IDEzMC4yNzQtNDQuODMyLTQ2LjEzMi0uOTc1LTg0Ljc5Mi0zMS4xODgtOTguMTEyLTcyLjc3MiA2LjQ5OC45NzQgMTIuOTk1IDEuNjI0IDE5LjgxOCAxLjYyNCA5LjQyMSAwIDE4Ljg0My0xLjMgMjcuNjE0LTMuNTczLTQ4LjA4MS05Ljc0Ny04NC4xNDMtNTEuOTgtODQuMTQzLTEwMi45ODV2LTEuMjk5YzEzLjk2OSA3Ljc5NyAzMC4yMTQgMTIuNjcgNDcuNDMxIDEzLjMxOS0yOC4yNjQtMTguODQzLTQ2Ljc4MS01MS4wMDUtNDYuNzgxLTg3LjM5MSAwLTE5LjQ5MiA1LjE5Ny0zNy4zNiAxNC4yOTQtNTIuOTU0IDUxLjY1NSA2My42NzUgMTI5LjMgMTA1LjI1OCAyMTYuMzY1IDEwOS44MDctMS42MjQtNy43OTctMi41OTktMTUuOTE4LTIuNTk5LTI0LjA0IDAtNTcuODI4IDQ2Ljc4Mi0xMDQuOTM0IDEwNC45MzQtMTA0LjkzNCAzMC4yMTMgMCA1Ny41MDIgMTIuNjcgNzYuNjcgMzMuMTM3IDIzLjcxNS00LjU0OCA0Ni40NTYtMTMuMzIgNjYuNTk5LTI1LjM0LTcuNzk4IDI0LjM2Ni0yNC4zNjYgNDQuODMzLTQ2LjEzMiA1Ny44MjcgMjEuMTE3LTIuMjczIDQxLjU4NC04LjEyMiA2MC40MjYtMTYuMjQzLTE0LjI5MiAyMC43OTEtMzIuMTYxIDM5LjMwOC01Mi42MjggNTQuMjUzeic7XG5cbmV4cG9ydHMuZGVmaW5pdGlvbiA9IHtcbiAgcHJlZml4OiBwcmVmaXgsXG4gIGljb25OYW1lOiBpY29uTmFtZSxcbiAgaWNvbjogW1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsaWdhdHVyZXMsXG4gICAgdW5pY29kZSxcbiAgICBzdmdQYXRoRGF0YVxuICBdfTtcblxuZXhwb3J0cy5mYVR3aXR0ZXIgPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAneW91dHViZSc7XG52YXIgd2lkdGggPSA1NzY7XG52YXIgaGVpZ2h0ID0gNTEyO1xudmFyIGxpZ2F0dXJlcyA9IFtdO1xudmFyIHVuaWNvZGUgPSAnZjE2Nyc7XG52YXIgc3ZnUGF0aERhdGEgPSAnTTU0OS42NTUgMTI0LjA4M2MtNi4yODEtMjMuNjUtMjQuNzg3LTQyLjI3Ni00OC4yODQtNDguNTk3QzQ1OC43ODEgNjQgMjg4IDY0IDI4OCA2NFMxMTcuMjIgNjQgNzQuNjI5IDc1LjQ4NmMtMjMuNDk3IDYuMzIyLTQyLjAwMyAyNC45NDctNDguMjg0IDQ4LjU5Ny0xMS40MTIgNDIuODY3LTExLjQxMiAxMzIuMzA1LTExLjQxMiAxMzIuMzA1czAgODkuNDM4IDExLjQxMiAxMzIuMzA1YzYuMjgxIDIzLjY1IDI0Ljc4NyA0MS41IDQ4LjI4NCA0Ny44MjFDMTE3LjIyIDQ0OCAyODggNDQ4IDI4OCA0NDhzMTcwLjc4IDAgMjEzLjM3MS0xMS40ODZjMjMuNDk3LTYuMzIxIDQyLjAwMy0yNC4xNzEgNDguMjg0LTQ3LjgyMSAxMS40MTItNDIuODY3IDExLjQxMi0xMzIuMzA1IDExLjQxMi0xMzIuMzA1czAtODkuNDM4LTExLjQxMi0xMzIuMzA1em0tMzE3LjUxIDIxMy41MDhWMTc1LjE4NWwxNDIuNzM5IDgxLjIwNS0xNDIuNzM5IDgxLjIwMXonO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFZb3V0dWJlID0gZXhwb3J0cy5kZWZpbml0aW9uO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLmljb25OYW1lID0gaWNvbk5hbWU7XG5leHBvcnRzLndpZHRoID0gd2lkdGg7XG5leHBvcnRzLmhlaWdodCA9IGhlaWdodDtcbmV4cG9ydHMubGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbmV4cG9ydHMuc3ZnUGF0aERhdGEgPSBzdmdQYXRoRGF0YTsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJpbXBvcnQgJy4vbW9kZXJuaXpyLWN1c3RvbSc7XG5pbXBvcnQgJy4vcmFyZWJpcmQtaW5jbHVkZXMnO1xuaW1wb3J0ICcuL2ljb25zLWltcG9ydCc7IiwiLy9cbi8vIEljb25zIGltcG9ydCBmaWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVXNlcyBGb250IEF3ZXNvbWUgNSBpY29ucyArIEFQSTpcbi8vIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2hvdy10by11c2Uvb24tdGhlLXdlYi9hZHZhbmNlZC9zdmctamF2YXNjcmlwdC1jb3JlXG4vLyBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9ob3ctdG8tdXNlL3dpdGgtdGhlLWFwaS9zZXR1cC9nZXR0aW5nLXN0YXJ0ZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHdWxwIGlzIHVzZWQgdG8gY29tbWFuZCBSb2xsdXAgdG8gdHVybiB0aGlzIGltcG9ydFxuLy8gZmlsZSBpbiB0byBhIHJlbmRlcmVkLCB0cmVlLXNoYWtlbiBmaWxlLCB0aGF0IG9ubHlcbi8vIGluY2x1ZGVzIHRoZSBpY29ucyBkZXNpcmVkLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBbU3RlcCAxXSBJbXBvcnQgZGVzaXJlZCBpY29ucy4uLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEZpcnN0LCBpbXBvcnQgdGhlIGxpYnJhcnkgYW5kIERPTSBtYW5pcHVsYXRpb24gdXRpbGl0aWVzXG5pbXBvcnQgeyBsaWJyYXJ5LCBkb20gfSBmcm9tICdAZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtc3ZnLWNvcmUnO1xuXG5cbi8vIEFkZCB0aGUgaWNvbnMgeW91IHdhbnQgdG8gdXNlIGhlcmUsIEFORCBpbmNsdWRlIHRoZW0gaW4gdGhlIExpYnJhcnkgLmFkZCgpIGZ1bmN0aW9uIGJlbG93XG5cbi8vIENvbW1vbiBCcmFuZHMgX19fX19fX19fXG5pbXBvcnQgeyBmYUZhY2Vib29rRiB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFGYWNlYm9va0YnO1xuaW1wb3J0IHsgZmFGYWNlYm9vayB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFGYWNlYm9vayc7XG5cbmltcG9ydCB7IGZhVHdpdHRlciB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFUd2l0dGVyJztcbi8vIGltcG9ydCB7IGZhUGludGVyZXN0IH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtYnJhbmRzLXN2Zy1pY29ucyc7XG5pbXBvcnQgeyBmYUluc3RhZ3JhbSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFJbnN0YWdyYW0nO1xuaW1wb3J0IHsgZmFMaW5rZWRpbiB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFMaW5rZWRpbic7XG5pbXBvcnQgeyBmYUxpbmtlZGluSW4gfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhTGlua2VkaW5Jbic7XG5pbXBvcnQgeyBmYVlvdXR1YmUgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhWW91dHViZSc7XG5cbi8vIERlbW86IExpZ2h0LCBTb2xpZCwgYW5kIFJlZ3VsYXIgdmVyc2lvbnMgb2YgdGhlIHNhbWUgaWNvbiBfX19fX19fX19cbi8vIGltcG9ydCB7IGZhRW52ZWxvcGUgYXMgZmFsRW52ZWxvcGUgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLWxpZ2h0LXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUVudmVsb3BlIGFzIGZhc0VudmVsb3BlIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1zb2xpZC1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFFbnZlbG9wZSBhcyBmYXJFbnZlbG9wZSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuXG4vLyBDb21tb24gSWNvbnMgdGhhdCBSQiB1c2VzIG9uIHNpdGVzIF9fX19fX19fX1xuLy8gaW1wb3J0IHsgZmFFbnZlbG9wZSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFGaWx0ZXIgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhRmlsZVBkZiB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFFeGNsYW1hdGlvblRyaWFuZ2xlIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUluZm9DaXJjbGUgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhTGluayB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFTZWFyY2ggfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhUHJpbnQgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhUGx1cyB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFNaW51cyB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFUaW1lcyB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFDaGV2cm9uVXAgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhQ2hldnJvblJpZ2h0IH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUNoZXZyb25Eb3duIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUNoZXZyb25MZWZ0IH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG5cblxuLy8gW1N0ZXAgMl0gQWRkIGRlc2lyZWQgaWNvbnMgdG8gbGlicmFyeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5saWJyYXJ5LmFkZChcblx0Ly8gZmFFbnZlbG9wZSxcblx0ZmFGYWNlYm9va0YsXG5cdGZhRmFjZWJvb2ssXG5cdGZhVHdpdHRlcixcblx0Ly8gZmFQaW50ZXJlc3QsXG5cdGZhSW5zdGFncmFtLFxuXHRmYUxpbmtlZGluLFxuXHRmYUxpbmtlZGluSW4sXG5cdGZhWW91dHViZSxcblx0Ly8gZmFsRW52ZWxvcGUsXG5cdC8vIGZhc0VudmVsb3BlLFxuXHQvLyBmYXJFbnZlbG9wZSxcblx0Ly8gZmFGaWx0ZXIsXG5cdC8vIGZhRmlsZVBkZixcblx0Ly8gZmFFeGNsYW1hdGlvblRyaWFuZ2xlLFxuXHQvLyBmYUluZm9DaXJjbGUsXG5cdC8vIGZhTGluayxcblx0Ly8gZmFTZWFyY2gsXG5cdC8vIGZhUHJpbnQsXG5cdC8vIGZhUGx1cyxcblx0Ly8gZmFNaW51cyxcblx0Ly8gZmFUaW1lcyxcblx0Ly8gZmFDaGV2cm9uVXAsXG5cdC8vIGZhQ2hldnJvblJpZ2h0LFxuXHQvLyBmYUNoZXZyb25Eb3duLFxuXHQvLyBmYUNoZXZyb25MZWZ0LFxuKTtcblxuXG4vLyBSZXBsYWNlIGFueSBleGlzdGluZyA8aT4gdGFncyB3aXRoIDxzdmc+IGFuZCBzZXQgdXAgYSBNdXRhdGlvbk9ic2VydmVyIHRvXG4vLyBjb250aW51ZSBkb2luZyB0aGlzIGFzIHRoZSBET00gY2hhbmdlcy5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZG9tLndhdGNoKCk7XG4iLCIvKiEgbW9kZXJuaXpyIDMuNi4wIChDdXN0b20gQnVpbGQpIHwgTUlUICpcbiAqIGh0dHBzOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZC8/LWJhY2tkcm9wZmlsdGVyLWJhY2tncm91bmRjbGlwdGV4dC1jc3NmaWx0ZXJzLWNzc2dyaWRfY3NzZ3JpZGxlZ2FjeS1jc3Nwb3NpdGlvbnN0aWNreS1waWN0dXJlLWRvbXByZWZpeGVzLXByZWZpeGVkLXByZWZpeGVzLXNldGNsYXNzZXMtdGVzdGFsbHByb3BzLXRlc3Rwcm9wLXRlc3RzdHlsZXMtY3NzY2xhc3NwcmVmaXg6bW9kLSAhKi9cbiFmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlLHQpe3JldHVybiB0eXBlb2YgZT09PXR9ZnVuY3Rpb24gcygpe3ZhciBlLHQsbixzLG8saSxsO2Zvcih2YXIgYSBpbiBTKWlmKFMuaGFzT3duUHJvcGVydHkoYSkpe2lmKGU9W10sdD1TW2FdLHQubmFtZSYmKGUucHVzaCh0Lm5hbWUudG9Mb3dlckNhc2UoKSksdC5vcHRpb25zJiZ0Lm9wdGlvbnMuYWxpYXNlcyYmdC5vcHRpb25zLmFsaWFzZXMubGVuZ3RoKSlmb3Iobj0wO248dC5vcHRpb25zLmFsaWFzZXMubGVuZ3RoO24rKyllLnB1c2godC5vcHRpb25zLmFsaWFzZXNbbl0udG9Mb3dlckNhc2UoKSk7Zm9yKHM9cih0LmZuLFwiZnVuY3Rpb25cIik/dC5mbigpOnQuZm4sbz0wO288ZS5sZW5ndGg7bysrKWk9ZVtvXSxsPWkuc3BsaXQoXCIuXCIpLDE9PT1sLmxlbmd0aD9Nb2Rlcm5penJbbFswXV09czooIU1vZGVybml6cltsWzBdXXx8TW9kZXJuaXpyW2xbMF1daW5zdGFuY2VvZiBCb29sZWFufHwoTW9kZXJuaXpyW2xbMF1dPW5ldyBCb29sZWFuKE1vZGVybml6cltsWzBdXSkpLE1vZGVybml6cltsWzBdXVtsWzFdXT1zKSxDLnB1c2goKHM/XCJcIjpcIm5vLVwiKStsLmpvaW4oXCItXCIpKX19ZnVuY3Rpb24gbyhlKXt2YXIgdD13LmNsYXNzTmFtZSxuPU1vZGVybml6ci5fY29uZmlnLmNsYXNzUHJlZml4fHxcIlwiO2lmKGImJih0PXQuYmFzZVZhbCksTW9kZXJuaXpyLl9jb25maWcuZW5hYmxlSlNDbGFzcyl7dmFyIHI9bmV3IFJlZ0V4cChcIihefFxcXFxzKVwiK24rXCJuby1qcyhcXFxcc3wkKVwiKTt0PXQucmVwbGFjZShyLFwiJDFcIituK1wianMkMlwiKX1Nb2Rlcm5penIuX2NvbmZpZy5lbmFibGVDbGFzc2VzJiYodCs9XCIgXCIrbitlLmpvaW4oXCIgXCIrbiksYj93LmNsYXNzTmFtZS5iYXNlVmFsPXQ6dy5jbGFzc05hbWU9dCl9ZnVuY3Rpb24gaShlKXtyZXR1cm4gZS5yZXBsYWNlKC8oW2Etel0pLShbYS16XSkvZyxmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQrbi50b1VwcGVyQ2FzZSgpfSkucmVwbGFjZSgvXi0vLFwiXCIpfWZ1bmN0aW9uIGwoKXtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiB0LmNyZWF0ZUVsZW1lbnQ/dC5jcmVhdGVFbGVtZW50KGFyZ3VtZW50c1swXSk6Yj90LmNyZWF0ZUVsZW1lbnROUy5jYWxsKHQsXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGFyZ3VtZW50c1swXSk6dC5jcmVhdGVFbGVtZW50LmFwcGx5KHQsYXJndW1lbnRzKX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuISF+KFwiXCIrZSkuaW5kZXhPZih0KX1mdW5jdGlvbiB1KCl7dmFyIGU9dC5ib2R5O3JldHVybiBlfHwoZT1sKGI/XCJzdmdcIjpcImJvZHlcIiksZS5mYWtlPSEwKSxlfWZ1bmN0aW9uIGYoZSxuLHIscyl7dmFyIG8saSxhLGYsZD1cIm1vZGVybml6clwiLHA9bChcImRpdlwiKSxjPXUoKTtpZihwYXJzZUludChyLDEwKSlmb3IoO3ItLTspYT1sKFwiZGl2XCIpLGEuaWQ9cz9zW3JdOmQrKHIrMSkscC5hcHBlbmRDaGlsZChhKTtyZXR1cm4gbz1sKFwic3R5bGVcIiksby50eXBlPVwidGV4dC9jc3NcIixvLmlkPVwic1wiK2QsKGMuZmFrZT9jOnApLmFwcGVuZENoaWxkKG8pLGMuYXBwZW5kQ2hpbGQocCksby5zdHlsZVNoZWV0P28uc3R5bGVTaGVldC5jc3NUZXh0PWU6by5hcHBlbmRDaGlsZCh0LmNyZWF0ZVRleHROb2RlKGUpKSxwLmlkPWQsYy5mYWtlJiYoYy5zdHlsZS5iYWNrZ3JvdW5kPVwiXCIsYy5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLGY9dy5zdHlsZS5vdmVyZmxvdyx3LnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsdy5hcHBlbmRDaGlsZChjKSksaT1uKHAsZSksYy5mYWtlPyhjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksdy5zdHlsZS5vdmVyZmxvdz1mLHcub2Zmc2V0SGVpZ2h0KTpwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocCksISFpfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseSh0LGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHAoZSx0LG4pe3ZhciBzO2Zvcih2YXIgbyBpbiBlKWlmKGVbb11pbiB0KXJldHVybiBuPT09ITE/ZVtvXToocz10W2Vbb11dLHIocyxcImZ1bmN0aW9uXCIpP2QocyxufHx0KTpzKTtyZXR1cm4hMX1mdW5jdGlvbiBjKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbQS1aXSkvZyxmdW5jdGlvbihlLHQpe3JldHVyblwiLVwiK3QudG9Mb3dlckNhc2UoKX0pLnJlcGxhY2UoL15tcy0vLFwiLW1zLVwiKX1mdW5jdGlvbiBtKHQsbixyKXt2YXIgcztpZihcImdldENvbXB1dGVkU3R5bGVcImluIGUpe3M9Z2V0Q29tcHV0ZWRTdHlsZS5jYWxsKGUsdCxuKTt2YXIgbz1lLmNvbnNvbGU7aWYobnVsbCE9PXMpciYmKHM9cy5nZXRQcm9wZXJ0eVZhbHVlKHIpKTtlbHNlIGlmKG8pe3ZhciBpPW8uZXJyb3I/XCJlcnJvclwiOlwibG9nXCI7b1tpXS5jYWxsKG8sXCJnZXRDb21wdXRlZFN0eWxlIHJldHVybmluZyBudWxsLCBpdHMgcG9zc2libGUgbW9kZXJuaXpyIHRlc3QgcmVzdWx0cyBhcmUgaW5hY2N1cmF0ZVwiKX19ZWxzZSBzPSFuJiZ0LmN1cnJlbnRTdHlsZSYmdC5jdXJyZW50U3R5bGVbcl07cmV0dXJuIHN9ZnVuY3Rpb24gZyh0LHIpe3ZhciBzPXQubGVuZ3RoO2lmKFwiQ1NTXCJpbiBlJiZcInN1cHBvcnRzXCJpbiBlLkNTUyl7Zm9yKDtzLS07KWlmKGUuQ1NTLnN1cHBvcnRzKGModFtzXSkscikpcmV0dXJuITA7cmV0dXJuITF9aWYoXCJDU1NTdXBwb3J0c1J1bGVcImluIGUpe2Zvcih2YXIgbz1bXTtzLS07KW8ucHVzaChcIihcIitjKHRbc10pK1wiOlwiK3IrXCIpXCIpO3JldHVybiBvPW8uam9pbihcIiBvciBcIiksZihcIkBzdXBwb3J0cyAoXCIrbytcIikgeyAjbW9kZXJuaXpyIHsgcG9zaXRpb246IGFic29sdXRlOyB9IH1cIixmdW5jdGlvbihlKXtyZXR1cm5cImFic29sdXRlXCI9PW0oZSxudWxsLFwicG9zaXRpb25cIil9KX1yZXR1cm4gbn1mdW5jdGlvbiB5KGUsdCxzLG8pe2Z1bmN0aW9uIHUoKXtkJiYoZGVsZXRlIEwuc3R5bGUsZGVsZXRlIEwubW9kRWxlbSl9aWYobz1yKG8sXCJ1bmRlZmluZWRcIik/ITE6bywhcihzLFwidW5kZWZpbmVkXCIpKXt2YXIgZj1nKGUscyk7aWYoIXIoZixcInVuZGVmaW5lZFwiKSlyZXR1cm4gZn1mb3IodmFyIGQscCxjLG0seSx2PVtcIm1vZGVybml6clwiLFwidHNwYW5cIixcInNhbXBcIl07IUwuc3R5bGUmJnYubGVuZ3RoOylkPSEwLEwubW9kRWxlbT1sKHYuc2hpZnQoKSksTC5zdHlsZT1MLm1vZEVsZW0uc3R5bGU7Zm9yKGM9ZS5sZW5ndGgscD0wO2M+cDtwKyspaWYobT1lW3BdLHk9TC5zdHlsZVttXSxhKG0sXCItXCIpJiYobT1pKG0pKSxMLnN0eWxlW21dIT09bil7aWYob3x8cihzLFwidW5kZWZpbmVkXCIpKXJldHVybiB1KCksXCJwZnhcIj09dD9tOiEwO3RyeXtMLnN0eWxlW21dPXN9Y2F0Y2goaCl7fWlmKEwuc3R5bGVbbV0hPXkpcmV0dXJuIHUoKSxcInBmeFwiPT10P206ITB9cmV0dXJuIHUoKSwhMX1mdW5jdGlvbiB2KGUsdCxuLHMsbyl7dmFyIGk9ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLGw9KGUrXCIgXCIrei5qb2luKGkrXCIgXCIpK2kpLnNwbGl0KFwiIFwiKTtyZXR1cm4gcih0LFwic3RyaW5nXCIpfHxyKHQsXCJ1bmRlZmluZWRcIik/eShsLHQscyxvKToobD0oZStcIiBcIitQLmpvaW4oaStcIiBcIikraSkuc3BsaXQoXCIgXCIpLHAobCx0LG4pKX1mdW5jdGlvbiBoKGUsdCxyKXtyZXR1cm4gdihlLG4sbix0LHIpfXZhciBDPVtdLFM9W10seD17X3ZlcnNpb246XCIzLjYuMFwiLF9jb25maWc6e2NsYXNzUHJlZml4OlwibW9kLVwiLGVuYWJsZUNsYXNzZXM6ITAsZW5hYmxlSlNDbGFzczohMCx1c2VQcmVmaXhlczohMH0sX3E6W10sb246ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0KG5bZV0pfSwwKX0sYWRkVGVzdDpmdW5jdGlvbihlLHQsbil7Uy5wdXNoKHtuYW1lOmUsZm46dCxvcHRpb25zOm59KX0sYWRkQXN5bmNUZXN0OmZ1bmN0aW9uKGUpe1MucHVzaCh7bmFtZTpudWxsLGZuOmV9KX19LE1vZGVybml6cj1mdW5jdGlvbigpe307TW9kZXJuaXpyLnByb3RvdHlwZT14LE1vZGVybml6cj1uZXcgTW9kZXJuaXpyLE1vZGVybml6ci5hZGRUZXN0KFwicGljdHVyZVwiLFwiSFRNTFBpY3R1cmVFbGVtZW50XCJpbiBlKTt2YXIgXz14Ll9jb25maWcudXNlUHJlZml4ZXM/XCIgLXdlYmtpdC0gLW1vei0gLW8tIC1tcy0gXCIuc3BsaXQoXCIgXCIpOltcIlwiLFwiXCJdO3guX3ByZWZpeGVzPV87dmFyIHc9dC5kb2N1bWVudEVsZW1lbnQsYj1cInN2Z1wiPT09dy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFQ9XCJNb3ogTyBtcyBXZWJraXRcIixQPXguX2NvbmZpZy51c2VQcmVmaXhlcz9ULnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIgXCIpOltdO3guX2RvbVByZWZpeGVzPVAsTW9kZXJuaXpyLmFkZFRlc3QoXCJjc3Nwb3NpdGlvbnN0aWNreVwiLGZ1bmN0aW9uKCl7dmFyIGU9XCJwb3NpdGlvbjpcIix0PVwic3RpY2t5XCIsbj1sKFwiYVwiKSxyPW4uc3R5bGU7cmV0dXJuIHIuY3NzVGV4dD1lK18uam9pbih0K1wiO1wiK2UpLnNsaWNlKDAsLWUubGVuZ3RoKSwtMSE9PXIucG9zaXRpb24uaW5kZXhPZih0KX0pO3ZhciBrPVwiQ1NTXCJpbiBlJiZcInN1cHBvcnRzXCJpbiBlLkNTUyxFPVwic3VwcG9ydHNDU1NcImluIGU7TW9kZXJuaXpyLmFkZFRlc3QoXCJzdXBwb3J0c1wiLGt8fEUpO3ZhciB6PXguX2NvbmZpZy51c2VQcmVmaXhlcz9ULnNwbGl0KFwiIFwiKTpbXTt4Ll9jc3NvbVByZWZpeGVzPXo7dmFyIGo9ZnVuY3Rpb24odCl7dmFyIHIscz1fLmxlbmd0aCxvPWUuQ1NTUnVsZTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgbylyZXR1cm4gbjtpZighdClyZXR1cm4hMTtpZih0PXQucmVwbGFjZSgvXkAvLFwiXCIpLHI9dC5yZXBsYWNlKC8tL2csXCJfXCIpLnRvVXBwZXJDYXNlKCkrXCJfUlVMRVwiLHIgaW4gbylyZXR1cm5cIkBcIit0O2Zvcih2YXIgaT0wO3M+aTtpKyspe3ZhciBsPV9baV0sYT1sLnRvVXBwZXJDYXNlKCkrXCJfXCIrcjtpZihhIGluIG8pcmV0dXJuXCJALVwiK2wudG9Mb3dlckNhc2UoKStcIi1cIit0fXJldHVybiExfTt4LmF0UnVsZT1qO3ZhciBOPSh4LnRlc3RTdHlsZXM9Zix7ZWxlbTpsKFwibW9kZXJuaXpyXCIpfSk7TW9kZXJuaXpyLl9xLnB1c2goZnVuY3Rpb24oKXtkZWxldGUgTi5lbGVtfSk7dmFyIEw9e3N0eWxlOk4uZWxlbS5zdHlsZX07TW9kZXJuaXpyLl9xLnVuc2hpZnQoZnVuY3Rpb24oKXtkZWxldGUgTC5zdHlsZX0pO3gudGVzdFByb3A9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB5KFtlXSxuLHQscil9O3gudGVzdEFsbFByb3BzPXY7eC5wcmVmaXhlZD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIDA9PT1lLmluZGV4T2YoXCJAXCIpP2ooZSk6KC0xIT1lLmluZGV4T2YoXCItXCIpJiYoZT1pKGUpKSx0P3YoZSx0LG4pOnYoZSxcInBmeFwiKSl9O3gudGVzdEFsbFByb3BzPWgsTW9kZXJuaXpyLmFkZFRlc3QoXCJiYWNrZHJvcGZpbHRlclwiLGgoXCJiYWNrZHJvcEZpbHRlclwiKSksTW9kZXJuaXpyLmFkZFRlc3QoXCJiYWNrZ3JvdW5kY2xpcHRleHRcIixmdW5jdGlvbigpe3JldHVybiBoKFwiYmFja2dyb3VuZENsaXBcIixcInRleHRcIil9KSxNb2Rlcm5penIuYWRkVGVzdChcImNzc2dyaWRsZWdhY3lcIixoKFwiZ3JpZC1jb2x1bW5zXCIsXCIxMHB4XCIsITApKSxNb2Rlcm5penIuYWRkVGVzdChcImNzc2dyaWRcIixoKFwiZ3JpZC10ZW1wbGF0ZS1yb3dzXCIsXCJub25lXCIsITApKSxNb2Rlcm5penIuYWRkVGVzdChcImNzc2ZpbHRlcnNcIixmdW5jdGlvbigpe2lmKE1vZGVybml6ci5zdXBwb3J0cylyZXR1cm4gaChcImZpbHRlclwiLFwiYmx1cigycHgpXCIpO3ZhciBlPWwoXCJhXCIpO3JldHVybiBlLnN0eWxlLmNzc1RleHQ9Xy5qb2luKFwiZmlsdGVyOmJsdXIoMnB4KTsgXCIpLCEhZS5zdHlsZS5sZW5ndGgmJih0LmRvY3VtZW50TW9kZT09PW58fHQuZG9jdW1lbnRNb2RlPjkpfSkscygpLG8oQyksZGVsZXRlIHguYWRkVGVzdCxkZWxldGUgeC5hZGRBc3luY1Rlc3Q7Zm9yKHZhciBPPTA7TzxNb2Rlcm5penIuX3EubGVuZ3RoO08rKylNb2Rlcm5penIuX3FbT10oKTtlLk1vZGVybml6cj1Nb2Rlcm5penJ9KHdpbmRvdyxkb2N1bWVudCk7XG4iLCJcbi8vXG4vLyBDb21waWxlZCBTaXRlIFNjcmlwdHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFdhcm5pbmc6IEdsb2JhbC5qcyBpcyBhIENPTVBJTEVEIGZpbGUhIEVkaXQgYSBzb3VyY2UgZmlsZSwgb3IgY3JlYXRlIGEgbmV3XG4vLyBvbmUuIFNlZSBndWxwZmlsZS5qcyFcbi8vXG4vLyAgIyMjIyMjI1xuLy8gICAgICMgICAgIyAgICAjICMgICMjIyMgICAgICAjICAjIyMjICAgICAgICAjI1xuLy8gICAgICMgICAgIyAgICAjICMgIyAgICAgICAgICAjICMgICAgICAgICAgICMgICNcbi8vICAgICAjICAgICMjIyMjIyAjICAjIyMjICAgICAgIyAgIyMjIyAgICAgICMgICAgI1xuLy8gICAgICMgICAgIyAgICAjICMgICAgICAjICAgICAjICAgICAgIyAgICAgIyMjIyMjXG4vLyAgICAgIyAgICAjICAgICMgIyAjICAgICMgICAgICMgIyAgICAjICAgICAjICAgICNcbi8vICAgICAjICAgICMgICAgIyAjICAjIyMjICAgICAgIyAgIyMjIyAgICAgICMgICAgI1xuXG4vLyAgIyMjIyMgICMjIyMjIyMgIyAgICAgIyAjIyMjIyMgICMjIyAjICAgICAgICMjIyMjIyMgIyMjIyMjXG4vLyAjICAgICAjICMgICAgICMgIyMgICAjIyAjICAgICAjICAjICAjICAgICAgICMgICAgICAgIyAgICAgI1xuLy8gIyAgICAgICAjICAgICAjICMgIyAjICMgIyAgICAgIyAgIyAgIyAgICAgICAjICAgICAgICMgICAgICNcbi8vICMgICAgICAgIyAgICAgIyAjICAjICAjICMjIyMjIyAgICMgICMgICAgICAgIyMjIyMgICAjICAgICAjXG4vLyAjICAgICAgICMgICAgICMgIyAgICAgIyAjICAgICAgICAjICAjICAgICAgICMgICAgICAgIyAgICAgI1xuLy8gIyAgICAgIyAjICAgICAjICMgICAgICMgIyAgICAgICAgIyAgIyAgICAgICAjICAgICAgICMgICAgICNcbi8vICAjIyMjIyAgIyMjIyMjIyAjICAgICAjICMgICAgICAgIyMjICMjIyMjIyMgIyMjIyMjIyAjIyMjIyNcbi8vXG4vLyAjIyMjIyMjICMjIyAjICAgICAgICMjIyMjIyNcbi8vICMgICAgICAgICMgICMgICAgICAgI1xuLy8gIyAgICAgICAgIyAgIyAgICAgICAjXG4vLyAjIyMjIyAgICAjICAjICAgICAgICMjIyMjXG4vLyAjICAgICAgICAjICAjICAgICAgICNcbi8vICMgICAgICAgICMgICMgICAgICAgI1xuLy8gIyAgICAgICAjIyMgIyMjIyMjIyAjIyMjIyMjXG4vL1xuLy8gV2FybmluZzogR2xvYmFsLmpzIGlzIGEgQ09NUElMRUQgZmlsZSEgRWRpdCBhIHNvdXJjZSBmaWxlLCBvciBjcmVhdGUgYSBuZXdcbi8vIG9uZS4gU2VlIGd1bHBmaWxlLmJhYmVsLmpzIVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuXG4vL1xuLy8gUG9seWZpbGwgZm9yIHVzaW5nIGZvckVhY2goKSBvbiBOb2RlTGlzdHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHN1cHBvcnQgZm9yIElFIDExIHdpdGhvdXQgY2FsbGluZyBpbiBhIFxuLy8gQmFiZWwgZHVtcHRydWNrLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZpYSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZUxpc3QvZm9yRWFjaCNQb2x5ZmlsbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmlmICh3aW5kb3cuTm9kZUxpc3QgJiYgIU5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gIE5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdGhpc0FyZyA9IHRoaXNBcmcgfHwgd2luZG93O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzW2ldLCBpLCB0aGlzKTtcbiAgICB9XG4gIH07XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjQuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFsZXJ0LmpzIHYzLjQuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWxlcnRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUxFUlQgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGRpc21pc3MgPSAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB2YXIgQWxlcnQgICA9IGZ1bmN0aW9uIChlbCkge1xuICAgICQoZWwpLm9uKCdjbGljaycsIGRpc21pc3MsIHRoaXMuY2xvc2UpXG4gIH1cblxuICBBbGVydC5WRVJTSU9OID0gJzMuNC4wJ1xuXG4gIEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgICA9ICQodGhpcylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHNlbGVjdG9yICAgID0gc2VsZWN0b3IgPT09ICcjJyA/IFtdIDogc2VsZWN0b3JcbiAgICB2YXIgJHBhcmVudCA9ICQoZG9jdW1lbnQpLmZpbmQoc2VsZWN0b3IpXG5cbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBpZiAoISRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAkcGFyZW50ID0gJHRoaXMuY2xvc2VzdCgnLmFsZXJ0JylcbiAgICB9XG5cbiAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ2Nsb3NlLmJzLmFsZXJ0JykpXG5cbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KCkge1xuICAgICAgLy8gZGV0YWNoIGZyb20gcGFyZW50LCBmaXJlIGV2ZW50IHRoZW4gY2xlYW4gdXAgZGF0YVxuICAgICAgJHBhcmVudC5kZXRhY2goKS50cmlnZ2VyKCdjbG9zZWQuYnMuYWxlcnQnKS5yZW1vdmUoKVxuICAgIH1cblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICRwYXJlbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkcGFyZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIHJlbW92ZUVsZW1lbnQpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChBbGVydC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICByZW1vdmVFbGVtZW50KClcbiAgfVxuXG5cbiAgLy8gQUxFUlQgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5hbGVydCcpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYWxlcnQnLCAoZGF0YSA9IG5ldyBBbGVydCh0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmFsZXJ0XG5cbiAgJC5mbi5hbGVydCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmFsZXJ0LkNvbnN0cnVjdG9yID0gQWxlcnRcblxuXG4gIC8vIEFMRVJUIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5hbGVydC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYWxlcnQgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBTEVSVCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5hbGVydC5kYXRhLWFwaScsIGRpc21pc3MsIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuNC4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBNT0RBTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLiRib2R5ICAgICAgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kZWxlbWVudCAgICAgICAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGRpYWxvZyAgICAgICAgICAgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLm1vZGFsLWRpYWxvZycpXG4gICAgdGhpcy4kYmFja2Ryb3AgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuaXNTaG93biAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLm9yaWdpbmFsQm9keVBhZCAgICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCAgICAgID0gMFxuICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZC5icy5tb2RhbCcpXG4gICAgICAgIH0sIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuNC4wJ1xuXG4gIE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzMDBcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIE1vZGFsLkRFRkFVTFRTID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNob3c6IHRydWVcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBlICAgID0gJC5FdmVudCgnc2hvdy5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuc2V0U2Nyb2xsYmFyKClcbiAgICB0aGlzLiRib2R5LmFkZENsYXNzKCdtb2RhbC1vcGVuJylcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsICQucHJveHkodGhpcy5oaWRlLCB0aGlzKSlcblxuICAgIHRoaXMuJGRpYWxvZy5vbignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9uZSgnbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoYXQuJGVsZW1lbnQpKSB0aGF0Lmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgIGlmICghdGhhdC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMClcblxuICAgICAgdGhhdC5hZGp1c3REaWFsb2coKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGF0LiRlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50LmFkZENsYXNzKCdpbicpXG5cbiAgICAgIHRoYXQuZW5mb3JjZUZvY3VzKClcblxuICAgICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93bi5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgICAgdHJhbnNpdGlvbiA/XG4gICAgICAgIHRoYXQuJGRpYWxvZyAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgJChkb2N1bWVudCkub2ZmKCdmb2N1c2luLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5yZW1vdmVDbGFzcygnaW4nKVxuICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAub2ZmKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9mZignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVNb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVNb2RhbCgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCAhPT0gZS50YXJnZXQgJiZcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmXG4gICAgICAgICAgICAhdGhpcy4kZWxlbWVudC5oYXMoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS53aGljaCA9PSAyNyAmJiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbigncmVzaXplLmJzLm1vZGFsJywgJC5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSwgdGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kYm9keS5yZW1vdmVDbGFzcygnbW9kYWwtb3BlbicpXG4gICAgICB0aGF0LnJlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgLmFkZENsYXNzKCdtb2RhbC1iYWNrZHJvcCAnICsgYW5pbWF0ZSlcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGJvZHkpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSByZXR1cm5cbiAgICAgICAgdGhpcy5vcHRpb25zLmJhY2tkcm9wID09ICdzdGF0aWMnXG4gICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzKClcbiAgICAgICAgICA6IHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcblxuICAgICAgaWYgKGRvQW5pbWF0ZSkgdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wLmFkZENsYXNzKCdpbicpXG5cbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVyblxuXG4gICAgICBkb0FuaW1hdGUgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrKClcblxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93biAmJiB0aGlzLiRiYWNrZHJvcCkge1xuICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnJlbW92ZUJhY2tkcm9wKClcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG5cbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgLy8gdGhlc2UgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuXG4gIE1vZGFsLnByb3RvdHlwZS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGp1c3REaWFsb2coKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmFkanVzdERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kYWxJc092ZXJmbG93aW5nID0gdGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogICF0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmIG1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmdWxsV2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGlmICghZnVsbFdpbmRvd1dpZHRoKSB7IC8vIHdvcmthcm91bmQgZm9yIG1pc3Npbmcgd2luZG93LmlubmVyV2lkdGggaW4gSUU4XG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgZnVsbFdpbmRvd1dpZHRoID0gZG9jdW1lbnRFbGVtZW50UmVjdC5yaWdodCAtIE1hdGguYWJzKGRvY3VtZW50RWxlbWVudFJlY3QubGVmdClcbiAgICB9XG4gICAgdGhpcy5ib2R5SXNPdmVyZmxvd2luZyA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggPCBmdWxsV2luZG93V2lkdGhcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCB8fCAnJ1xuICAgIGlmICh0aGlzLmJvZHlJc092ZXJmbG93aW5nKSB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIGJvZHlQYWQgKyB0aGlzLnNjcm9sbGJhcldpZHRoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgdGhpcy5vcmlnaW5hbEJvZHlQYWQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUubWVhc3VyZVNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHsgLy8gdGh4IHdhbHNoXG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSdcbiAgICB0aGlzLiRib2R5LmFwcGVuZChzY3JvbGxEaXYpXG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoXG4gICAgdGhpcy4kYm9keVswXS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpXG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoXG4gIH1cblxuXG4gIC8vIE1PREFMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbiwgX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5tb2RhbCcpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5tb2RhbCcsIChkYXRhID0gbmV3IE1vZGFsKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oX3JlbGF0ZWRUYXJnZXQpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLnNob3cpIGRhdGEuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4ubW9kYWxcblxuICAkLmZuLm1vZGFsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ubW9kYWwuQ29uc3RydWN0b3IgPSBNb2RhbFxuXG5cbiAgLy8gTU9EQUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLm1vZGFsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5tb2RhbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIE1PREFMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgaHJlZiAgICA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgIHZhciB0YXJnZXQgID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fFxuICAgICAgKGhyZWYgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpIC8vIHN0cmlwIGZvciBpZTdcblxuICAgIHZhciAkdGFyZ2V0ID0gJChkb2N1bWVudCkuZmluZCh0YXJnZXQpXG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuXG4gICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgJHRhcmdldC5vbmUoJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm4gLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRoaXMuaXMoJzp2aXNpYmxlJykgJiYgJHRoaXMudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbiwgdGhpcylcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNyBDcmFpZyBDYW1wYmVsbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIE1vdXNldHJhcCBpcyBhIHNpbXBsZSBrZXlib2FyZCBzaG9ydGN1dCBsaWJyYXJ5IGZvciBKYXZhc2NyaXB0IHdpdGhcbiAqIG5vIGV4dGVybmFsIGRlcGVuZGVuY2llc1xuICpcbiAqIEB2ZXJzaW9uIDEuNi4yXG4gKiBAdXJsIGNyYWlnLmlzL2tpbGxpbmcvbWljZVxuICovXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICAvLyBDaGVjayBpZiBtb3VzZXRyYXAgaXMgdXNlZCBpbnNpZGUgYnJvd3NlciwgaWYgbm90LCByZXR1cm5cbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFwcGluZyBvZiBzcGVjaWFsIGtleWNvZGVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcga2V5c1xuICAgICAqXG4gICAgICogZXZlcnl0aGluZyBpbiB0aGlzIGRpY3Rpb25hcnkgY2Fubm90IHVzZSBrZXlwcmVzcyBldmVudHNcbiAgICAgKiBzbyBpdCBoYXMgdG8gYmUgaGVyZSB0byBtYXAgdG8gdGhlIGNvcnJlY3Qga2V5Y29kZXMgZm9yXG4gICAgICoga2V5dXAva2V5ZG93biBldmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9NQVAgPSB7XG4gICAgICAgIDg6ICdiYWNrc3BhY2UnLFxuICAgICAgICA5OiAndGFiJyxcbiAgICAgICAgMTM6ICdlbnRlcicsXG4gICAgICAgIDE2OiAnc2hpZnQnLFxuICAgICAgICAxNzogJ2N0cmwnLFxuICAgICAgICAxODogJ2FsdCcsXG4gICAgICAgIDIwOiAnY2Fwc2xvY2snLFxuICAgICAgICAyNzogJ2VzYycsXG4gICAgICAgIDMyOiAnc3BhY2UnLFxuICAgICAgICAzMzogJ3BhZ2V1cCcsXG4gICAgICAgIDM0OiAncGFnZWRvd24nLFxuICAgICAgICAzNTogJ2VuZCcsXG4gICAgICAgIDM2OiAnaG9tZScsXG4gICAgICAgIDM3OiAnbGVmdCcsXG4gICAgICAgIDM4OiAndXAnLFxuICAgICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgICAgNDA6ICdkb3duJyxcbiAgICAgICAgNDU6ICdpbnMnLFxuICAgICAgICA0NjogJ2RlbCcsXG4gICAgICAgIDkxOiAnbWV0YScsXG4gICAgICAgIDkzOiAnbWV0YScsXG4gICAgICAgIDIyNDogJ21ldGEnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1hcHBpbmcgZm9yIHNwZWNpYWwgY2hhcmFjdGVycyBzbyB0aGV5IGNhbiBzdXBwb3J0XG4gICAgICpcbiAgICAgKiB0aGlzIGRpY3Rpb25hcnkgaXMgb25seSB1c2VkIGluY2FzZSB5b3Ugd2FudCB0byBiaW5kIGFcbiAgICAgKiBrZXl1cCBvciBrZXlkb3duIGV2ZW50IHRvIG9uZSBvZiB0aGVzZSBrZXlzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfS0VZQ09ERV9NQVAgPSB7XG4gICAgICAgIDEwNjogJyonLFxuICAgICAgICAxMDc6ICcrJyxcbiAgICAgICAgMTA5OiAnLScsXG4gICAgICAgIDExMDogJy4nLFxuICAgICAgICAxMTEgOiAnLycsXG4gICAgICAgIDE4NjogJzsnLFxuICAgICAgICAxODc6ICc9JyxcbiAgICAgICAgMTg4OiAnLCcsXG4gICAgICAgIDE4OTogJy0nLFxuICAgICAgICAxOTA6ICcuJyxcbiAgICAgICAgMTkxOiAnLycsXG4gICAgICAgIDE5MjogJ2AnLFxuICAgICAgICAyMTk6ICdbJyxcbiAgICAgICAgMjIwOiAnXFxcXCcsXG4gICAgICAgIDIyMTogJ10nLFxuICAgICAgICAyMjI6ICdcXCcnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRoaXMgaXMgYSBtYXBwaW5nIG9mIGtleXMgdGhhdCByZXF1aXJlIHNoaWZ0IG9uIGEgVVMga2V5cGFkXG4gICAgICogYmFjayB0byB0aGUgbm9uIHNoaWZ0IGVxdWl2ZWxlbnRzXG4gICAgICpcbiAgICAgKiB0aGlzIGlzIHNvIHlvdSBjYW4gdXNlIGtleXVwIGV2ZW50cyB3aXRoIHRoZXNlIGtleXNcbiAgICAgKlxuICAgICAqIG5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIHJlbGlhYmx5IG9uIFVTIGtleWJvYXJkc1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX1NISUZUX01BUCA9IHtcbiAgICAgICAgJ34nOiAnYCcsXG4gICAgICAgICchJzogJzEnLFxuICAgICAgICAnQCc6ICcyJyxcbiAgICAgICAgJyMnOiAnMycsXG4gICAgICAgICckJzogJzQnLFxuICAgICAgICAnJSc6ICc1JyxcbiAgICAgICAgJ14nOiAnNicsXG4gICAgICAgICcmJzogJzcnLFxuICAgICAgICAnKic6ICc4JyxcbiAgICAgICAgJygnOiAnOScsXG4gICAgICAgICcpJzogJzAnLFxuICAgICAgICAnXyc6ICctJyxcbiAgICAgICAgJysnOiAnPScsXG4gICAgICAgICc6JzogJzsnLFxuICAgICAgICAnXFxcIic6ICdcXCcnLFxuICAgICAgICAnPCc6ICcsJyxcbiAgICAgICAgJz4nOiAnLicsXG4gICAgICAgICc/JzogJy8nLFxuICAgICAgICAnfCc6ICdcXFxcJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGEgbGlzdCBvZiBzcGVjaWFsIHN0cmluZ3MgeW91IGNhbiB1c2UgdG8gbWFwXG4gICAgICogdG8gbW9kaWZpZXIga2V5cyB3aGVuIHlvdSBzcGVjaWZ5IHlvdXIga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfU1BFQ0lBTF9BTElBU0VTID0ge1xuICAgICAgICAnb3B0aW9uJzogJ2FsdCcsXG4gICAgICAgICdjb21tYW5kJzogJ21ldGEnLFxuICAgICAgICAncmV0dXJuJzogJ2VudGVyJyxcbiAgICAgICAgJ2VzY2FwZSc6ICdlc2MnLFxuICAgICAgICAncGx1cyc6ICcrJyxcbiAgICAgICAgJ21vZCc6IC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pID8gJ21ldGEnIDogJ2N0cmwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBmbGlwcGVkIHZlcnNpb24gb2YgX01BUCBmcm9tIGFib3ZlXG4gICAgICogbmVlZGVkIHRvIGNoZWNrIGlmIHdlIHNob3VsZCB1c2Uga2V5cHJlc3Mgb3Igbm90IHdoZW4gbm8gYWN0aW9uXG4gICAgICogaXMgc3BlY2lmaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB2YXIgX1JFVkVSU0VfTUFQO1xuXG4gICAgLyoqXG4gICAgICogbG9vcCB0aHJvdWdoIHRoZSBmIGtleXMsIGYxIHRvIGYxOSBhbmQgYWRkIHRoZW0gdG8gdGhlIG1hcFxuICAgICAqIHByb2dyYW1hdGljYWxseVxuICAgICAqL1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMjA7ICsraSkge1xuICAgICAgICBfTUFQWzExMSArIGldID0gJ2YnICsgaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb29wIHRocm91Z2ggdG8gbWFwIG51bWJlcnMgb24gdGhlIG51bWVyaWMga2V5cGFkXG4gICAgICovXG4gICAgZm9yIChpID0gMDsgaSA8PSA5OyArK2kpIHtcblxuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIHVzZSBhIHN0cmluZyBjYXVzZSBvdGhlcndpc2Ugc2luY2UgMCBpcyBmYWxzZXlcbiAgICAgICAgLy8gbW91c2V0cmFwIHdpbGwgbmV2ZXIgZmlyZSBmb3IgbnVtcGFkIDAgcHJlc3NlZCBhcyBwYXJ0IG9mIGEga2V5ZG93blxuICAgICAgICAvLyBldmVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2NhbXBiZWxsL21vdXNldHJhcC9wdWxsLzI1OFxuICAgICAgICBfTUFQW2kgKyA5Nl0gPSBpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3Jvc3MgYnJvd3NlciBhZGQgZXZlbnQgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8SFRNTERvY3VtZW50fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hZGRFdmVudChvYmplY3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRha2VzIHRoZSBldmVudCBhbmQgcmV0dXJucyB0aGUga2V5IGNoYXJhY3RlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY2hhcmFjdGVyRnJvbUV2ZW50KGUpIHtcblxuICAgICAgICAvLyBmb3Iga2V5cHJlc3MgZXZlbnRzIHdlIHNob3VsZCByZXR1cm4gdGhlIGNoYXJhY3RlciBhcyBpc1xuICAgICAgICBpZiAoZS50eXBlID09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgc2hpZnQga2V5IGlzIG5vdCBwcmVzc2VkIHRoZW4gaXQgaXMgc2FmZSB0byBhc3N1bWVcbiAgICAgICAgICAgIC8vIHRoYXQgd2Ugd2FudCB0aGUgY2hhcmFjdGVyIHRvIGJlIGxvd2VyY2FzZS4gIHRoaXMgbWVhbnMgaWZcbiAgICAgICAgICAgIC8vIHlvdSBhY2NpZGVudGFsbHkgaGF2ZSBjYXBzIGxvY2sgb24gdGhlbiB5b3VyIGtleSBiaW5kaW5nc1xuICAgICAgICAgICAgLy8gd2lsbCBjb250aW51ZSB0byB3b3JrXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgc2lkZSBlZmZlY3QgdGhhdCBtaWdodCBub3QgYmUgZGVzaXJlZCBpcyBpZiB5b3VcbiAgICAgICAgICAgIC8vIGJpbmQgc29tZXRoaW5nIGxpa2UgJ0EnIGNhdXNlIHlvdSB3YW50IHRvIHRyaWdnZXIgYW5cbiAgICAgICAgICAgIC8vIGV2ZW50IHdoZW4gY2FwaXRhbCBBIGlzIHByZXNzZWQgY2FwcyBsb2NrIHdpbGwgbm8gbG9uZ2VyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBldmVudC4gIHNoaWZ0K2Egd2lsbCB0aG91Z2guXG4gICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBub24ga2V5cHJlc3MgZXZlbnRzIHRoZSBzcGVjaWFsIG1hcHMgYXJlIG5lZWRlZFxuICAgICAgICBpZiAoX01BUFtlLndoaWNoXSkge1xuICAgICAgICAgICAgcmV0dXJuIF9NQVBbZS53aGljaF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX0tFWUNPREVfTUFQW2Uud2hpY2hdKSB7XG4gICAgICAgICAgICByZXR1cm4gX0tFWUNPREVfTUFQW2Uud2hpY2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgbm90IGluIHRoZSBzcGVjaWFsIG1hcFxuXG4gICAgICAgIC8vIHdpdGgga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzIHRoZSBjaGFyYWN0ZXIgc2VlbXMgdG8gYWx3YXlzXG4gICAgICAgIC8vIGNvbWUgaW4gYXMgYW4gdXBwZXJjYXNlIGNoYXJhY3RlciB3aGV0aGVyIHlvdSBhcmUgcHJlc3Npbmcgc2hpZnRcbiAgICAgICAgLy8gb3Igbm90LiAgd2Ugc2hvdWxkIG1ha2Ugc3VyZSBpdCBpcyBhbHdheXMgbG93ZXJjYXNlIGZvciBjb21wYXJpc29uc1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiB0d28gYXJyYXlzIGFyZSBlcXVhbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzMVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyczJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbW9kaWZpZXJzTWF0Y2gobW9kaWZpZXJzMSwgbW9kaWZpZXJzMikge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzMS5zb3J0KCkuam9pbignLCcpID09PSBtb2RpZmllcnMyLnNvcnQoKS5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgYSBrZXkgZXZlbnQgYW5kIGZpZ3VyZXMgb3V0IHdoYXQgdGhlIG1vZGlmaWVycyBhcmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V2ZW50TW9kaWZpZXJzKGUpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFtdO1xuXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnc2hpZnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ2FsdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ2N0cmwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdtZXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXZlbnRzIGRlZmF1bHQgZm9yIHRoaXMgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3ByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdG9wcyBwcm9wb2dhdGlvbiBmb3IgdGhpcyBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfc3RvcFByb3BhZ2F0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZXMgaWYgdGhlIGtleWNvZGUgc3BlY2lmaWVkIGlzIGEgbW9kaWZpZXIga2V5IG9yIG5vdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9pc01vZGlmaWVyKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzaGlmdCcgfHwga2V5ID09ICdjdHJsJyB8fCBrZXkgPT0gJ2FsdCcgfHwga2V5ID09ICdtZXRhJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXZlcnNlcyB0aGUgbWFwIGxvb2t1cCBzbyB0aGF0IHdlIGNhbiBsb29rIGZvciBzcGVjaWZpYyBrZXlzXG4gICAgICogdG8gc2VlIHdoYXQgY2FuIGFuZCBjYW4ndCB1c2Uga2V5cHJlc3NcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZ2V0UmV2ZXJzZU1hcCgpIHtcbiAgICAgICAgaWYgKCFfUkVWRVJTRV9NQVApIHtcbiAgICAgICAgICAgIF9SRVZFUlNFX01BUCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF9NQVApIHtcblxuICAgICAgICAgICAgICAgIC8vIHB1bGwgb3V0IHRoZSBudW1lcmljIGtleXBhZCBmcm9tIGhlcmUgY2F1c2Uga2V5cHJlc3Mgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgYWJsZSB0byBkZXRlY3QgdGhlIGtleXMgZnJvbSB0aGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA+IDk1ICYmIGtleSA8IDExMikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX01BUC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9SRVZFUlNFX01BUFtfTUFQW2tleV1dID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX1JFVkVSU0VfTUFQO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBpY2tzIHRoZSBiZXN0IGFjdGlvbiBiYXNlZCBvbiB0aGUga2V5IGNvbWJpbmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gY2hhcmFjdGVyIGZvciBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvbiBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcGlja0Jlc3RBY3Rpb24oa2V5LCBtb2RpZmllcnMsIGFjdGlvbikge1xuXG4gICAgICAgIC8vIGlmIG5vIGFjdGlvbiB3YXMgcGlja2VkIGluIHdlIHNob3VsZCB0cnkgdG8gcGljayB0aGUgb25lXG4gICAgICAgIC8vIHRoYXQgd2UgdGhpbmsgd291bGQgd29yayBiZXN0IGZvciB0aGlzIGtleVxuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uID0gX2dldFJldmVyc2VNYXAoKVtrZXldID8gJ2tleWRvd24nIDogJ2tleXByZXNzJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vZGlmaWVyIGtleXMgZG9uJ3Qgd29yayBhcyBleHBlY3RlZCB3aXRoIGtleXByZXNzLFxuICAgICAgICAvLyBzd2l0Y2ggdG8ga2V5ZG93blxuICAgICAgICBpZiAoYWN0aW9uID09ICdrZXlwcmVzcycgJiYgbW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0aW9uID0gJ2tleWRvd24nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBmcm9tIGEgc3RyaW5nIGtleSBjb21iaW5hdGlvbiB0byBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb21iaW5hdGlvbiBsaWtlIFwiY29tbWFuZCtzaGlmdCtsXCJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfa2V5c0Zyb21TdHJpbmcoY29tYmluYXRpb24pIHtcbiAgICAgICAgaWYgKGNvbWJpbmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJldHVybiBbJysnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbWJpbmF0aW9uID0gY29tYmluYXRpb24ucmVwbGFjZSgvXFwrezJ9L2csICcrcGx1cycpO1xuICAgICAgICByZXR1cm4gY29tYmluYXRpb24uc3BsaXQoJysnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm8gZm9yIGEgc3BlY2lmaWMga2V5IGNvbWJpbmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbWJpbmF0aW9uIGtleSBjb21iaW5hdGlvbiAoXCJjb21tYW5kK3NcIiBvciBcImFcIiBvciBcIipcIilcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRLZXlJbmZvKGNvbWJpbmF0aW9uLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIGtleXM7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gW107XG5cbiAgICAgICAgLy8gdGFrZSB0aGUga2V5cyBmcm9tIHRoaXMgcGF0dGVybiBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBhY3R1YWxcbiAgICAgICAgLy8gcGF0dGVybiBpcyBhbGwgYWJvdXRcbiAgICAgICAga2V5cyA9IF9rZXlzRnJvbVN0cmluZyhjb21iaW5hdGlvbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBrZXkgbmFtZXNcbiAgICAgICAgICAgIGlmIChfU1BFQ0lBTF9BTElBU0VTW2tleV0pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBfU1BFQ0lBTF9BTElBU0VTW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEga2V5cHJlc3MgZXZlbnQgdGhlbiB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHNtYXJ0IGFib3V0IHVzaW5nIHNoaWZ0IGtleXNcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBvbmx5IHdvcmsgZm9yIFVTIGtleWJvYXJkcyBob3dldmVyXG4gICAgICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbiAhPSAna2V5cHJlc3MnICYmIF9TSElGVF9NQVBba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleSA9IF9TSElGVF9NQVBba2V5XTtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnc2hpZnQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBrZXkgaXMgYSBtb2RpZmllciB0aGVuIGFkZCBpdCB0byB0aGUgbGlzdCBvZiBtb2RpZmllcnNcbiAgICAgICAgICAgIGlmIChfaXNNb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBrZXkgY29tYmluYXRpb24gaXNcbiAgICAgICAgLy8gd2Ugd2lsbCB0cnkgdG8gcGljayB0aGUgYmVzdCBldmVudCBmb3IgaXRcbiAgICAgICAgYWN0aW9uID0gX3BpY2tCZXN0QWN0aW9uKGtleSwgbW9kaWZpZXJzLCBhY3Rpb24pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYmVsb25nc1RvKGVsZW1lbnQsIGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9iZWxvbmdzVG8oZWxlbWVudC5wYXJlbnROb2RlLCBhbmNlc3Rvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTW91c2V0cmFwKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50IHx8IGRvY3VtZW50O1xuXG4gICAgICAgIGlmICghKHNlbGYgaW5zdGFuY2VvZiBNb3VzZXRyYXApKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNldHJhcCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbGVtZW50IHRvIGF0dGFjaCBrZXkgZXZlbnRzIHRvXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi50YXJnZXQgPSB0YXJnZXRFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhIGxpc3Qgb2YgYWxsIHRoZSBjYWxsYmFja3Mgc2V0dXAgdmlhIE1vdXNldHJhcC5iaW5kKClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2NhbGxiYWNrcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXJlY3QgbWFwIG9mIHN0cmluZyBjb21iaW5hdGlvbnMgdG8gY2FsbGJhY2tzIHVzZWQgZm9yIHRyaWdnZXIoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5fZGlyZWN0TWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGtlZXBzIHRyYWNrIG9mIHdoYXQgbGV2ZWwgZWFjaCBzZXF1ZW5jZSBpcyBhdCBzaW5jZSBtdWx0aXBsZVxuICAgICAgICAgKiBzZXF1ZW5jZXMgY2FuIHN0YXJ0IG91dCB3aXRoIHRoZSBzYW1lIHNlcXVlbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3NlcXVlbmNlTGV2ZWxzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBzZXRUaW1lb3V0IGNhbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bGx8bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9yZXNldFRpbWVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0ZW1wb3Jhcnkgc3RhdGUgd2hlcmUgd2Ugd2lsbCBpZ25vcmUgdGhlIG5leHQga2V5dXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9pZ25vcmVOZXh0S2V5dXAgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGVtcG9yYXJ5IHN0YXRlIHdoZXJlIHdlIHdpbGwgaWdub3JlIHRoZSBuZXh0IGtleXByZXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9pZ25vcmVOZXh0S2V5cHJlc3MgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXJlIHdlIGN1cnJlbnRseSBpbnNpZGUgb2YgYSBzZXF1ZW5jZT9cbiAgICAgICAgICogdHlwZSBvZiBhY3Rpb24gKFwia2V5dXBcIiBvciBcImtleWRvd25cIiBvciBcImtleXByZXNzXCIpIG9yIGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfbmV4dEV4cGVjdGVkQWN0aW9uID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlc2V0cyBhbGwgc2VxdWVuY2UgY291bnRlcnMgZXhjZXB0IGZvciB0aGUgb25lcyBwYXNzZWQgaW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRvTm90UmVzZXRcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX3Jlc2V0U2VxdWVuY2VzKGRvTm90UmVzZXQpIHtcbiAgICAgICAgICAgIGRvTm90UmVzZXQgPSBkb05vdFJlc2V0IHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgYWN0aXZlU2VxdWVuY2VzID0gZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBfc2VxdWVuY2VMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9Ob3RSZXNldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlcXVlbmNlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfc2VxdWVuY2VMZXZlbHNba2V5XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWN0aXZlU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICAgICAgX25leHRFeHBlY3RlZEFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbmRzIGFsbCBjYWxsYmFja3MgdGhhdCBtYXRjaCBiYXNlZCBvbiB0aGUga2V5Y29kZSwgbW9kaWZpZXJzLFxuICAgICAgICAgKiBhbmQgYWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR8T2JqZWN0fSBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VxdWVuY2VOYW1lIC0gbmFtZSBvZiB0aGUgc2VxdWVuY2Ugd2UgYXJlIGxvb2tpbmcgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gY29tYmluYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBsZXZlbFxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZ2V0TWF0Y2hlcyhjaGFyYWN0ZXIsIG1vZGlmaWVycywgZSwgc2VxdWVuY2VOYW1lLCBjb21iaW5hdGlvbiwgbGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrO1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBlLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBldmVudHMgcmVsYXRlZCB0byB0aGlzIGtleWNvZGVcbiAgICAgICAgICAgIGlmICghc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGEgbW9kaWZpZXIga2V5IGlzIGNvbWluZyB1cCBvbiBpdHMgb3duIHdlIHNob3VsZCBhbGxvdyBpdFxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAna2V5dXAnICYmIF9pc01vZGlmaWVyKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMgPSBbY2hhcmFjdGVyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBrZXkgdGhhdCB3YXMgcHJlc3NlZFxuICAgICAgICAgICAgLy8gYW5kIHNlZSBpZiBhbnkgb2YgdGhlbSBtYXRjaFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxmLl9jYWxsYmFja3NbY2hhcmFjdGVyXVtpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGEgc2VxdWVuY2UgbmFtZSBpcyBub3Qgc3BlY2lmaWVkLCBidXQgdGhpcyBpcyBhIHNlcXVlbmNlIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHdyb25nIGxldmVsIHRoZW4gbW92ZSBvbnRvIHRoZSBuZXh0IG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKCFzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2suc2VxICYmIF9zZXF1ZW5jZUxldmVsc1tjYWxsYmFjay5zZXFdICE9IGNhbGxiYWNrLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhY3Rpb24gd2UgYXJlIGxvb2tpbmcgZm9yIGRvZXNuJ3QgbWF0Y2ggdGhlIGFjdGlvbiB3ZSBnb3RcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIHNob3VsZCBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPSBjYWxsYmFjay5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGtleXByZXNzIGV2ZW50IGFuZCB0aGUgbWV0YSBrZXkgYW5kIGNvbnRyb2wga2V5XG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCBwcmVzc2VkIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIG9ubHkgbG9vayBhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG90aGVyd2lzZSBjaGVjayB0aGUgbW9kaWZpZXJzIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGNocm9tZSB3aWxsIG5vdCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBjb250cm9sIGlzIGRvd25cbiAgICAgICAgICAgICAgICAvLyBzYWZhcmkgd2lsbCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBtZXRhK3NoaWZ0IGlzIGRvd25cbiAgICAgICAgICAgICAgICAvLyBmaXJlZm94IHdpbGwgZmlyZSBhIGtleXByZXNzIGlmIG1ldGEgb3IgY29udHJvbCBpcyBkb3duXG4gICAgICAgICAgICAgICAgaWYgKChhY3Rpb24gPT0gJ2tleXByZXNzJyAmJiAhZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkpIHx8IF9tb2RpZmllcnNNYXRjaChtb2RpZmllcnMsIGNhbGxiYWNrLm1vZGlmaWVycykpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHlvdSBiaW5kIGEgY29tYmluYXRpb24gb3Igc2VxdWVuY2UgYSBzZWNvbmQgdGltZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmUuICBpZiBhIHNlcXVlbmNlTmFtZSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQgaW4gdGhpcyBjYWxsIGl0IGRvZXMganVzdCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIG1ha2UgZGVsZXRpbmcgaXRzIG93biBtZXRob2Q/XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVDb21ibyA9ICFzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2suY29tYm8gPT0gY29tYmluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVTZXF1ZW5jZSA9IHNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5zZXEgPT0gc2VxdWVuY2VOYW1lICYmIGNhbGxiYWNrLmxldmVsID09IGxldmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQ29tYm8gfHwgZGVsZXRlU2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhY3R1YWxseSBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogaWYgeW91ciBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIHRoaXMgd2lsbCB1c2UgdGhlIGpxdWVyeVxuICAgICAgICAgKiBjb252ZW50aW9uIC0gcHJldmVudCBkZWZhdWx0IGFuZCBzdG9wIHByb3BvZ2F0aW9uIG9uIHRoZSBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUsIGNvbWJvLCBzZXF1ZW5jZSkge1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGV2ZW50IHNob3VsZCBub3QgaGFwcGVuIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKHNlbGYuc3RvcENhbGxiYWNrKGUsIGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCwgY29tYm8sIHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGUsIGNvbWJvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgX3N0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYW5kbGVzIGEgY2hhcmFjdGVyIGtleSBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2hhbmRsZUtleSA9IGZ1bmN0aW9uKGNoYXJhY3RlciwgbW9kaWZpZXJzLCBlKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gX2dldE1hdGNoZXMoY2hhcmFjdGVyLCBtb2RpZmllcnMsIGUpO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgZG9Ob3RSZXNldCA9IHt9O1xuICAgICAgICAgICAgdmFyIG1heExldmVsID0gMDtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4TGV2ZWwgZm9yIHNlcXVlbmNlcyBzbyB3ZSBjYW4gb25seSBleGVjdXRlIHRoZSBsb25nZXN0IGNhbGxiYWNrIHNlcXVlbmNlXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXS5zZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4TGV2ZWwgPSBNYXRoLm1heChtYXhMZXZlbCwgY2FsbGJhY2tzW2ldLmxldmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBtYXRjaGluZyBjYWxsYmFja3MgZm9yIHRoaXMga2V5IGV2ZW50XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJlIGZvciBhbGwgc2VxdWVuY2UgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIGlmIGZvciBleGFtcGxlIHlvdSBoYXZlIG11bHRpcGxlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIGJvdW5kIHN1Y2ggYXMgXCJnIGlcIiBhbmQgXCJnIHRcIiB0aGV5IGJvdGggbmVlZCB0byBmaXJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIGZvciBtYXRjaGluZyBnIGNhdXNlIG90aGVyd2lzZSB5b3UgY2FuIG9ubHkgZXZlclxuICAgICAgICAgICAgICAgIC8vIG1hdGNoIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLnNlcSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZmlyZSBjYWxsYmFja3MgZm9yIHRoZSBtYXhMZXZlbCB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbmNlcyBmcm9tIGFsc28gZmlyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlICdhIG9wdGlvbiBiJyBzaG91bGQgbm90IGNhdXNlICdvcHRpb24gYicgdG8gZmlyZVxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCAnb3B0aW9uIGInIGlzIHBhcnQgb2YgdGhlIG90aGVyIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueSBzZXF1ZW5jZXMgdGhhdCBkbyBub3QgbWF0Y2ggaGVyZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWxvdyBieSB0aGUgX3Jlc2V0U2VxdWVuY2VzIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXS5sZXZlbCAhPSBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgbGlzdCBvZiB3aGljaCBzZXF1ZW5jZXMgd2VyZSBtYXRjaGVzIGZvciBsYXRlclxuICAgICAgICAgICAgICAgICAgICBkb05vdFJlc2V0W2NhbGxiYWNrc1tpXS5zZXFdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFja3NbaV0uY2FsbGJhY2ssIGUsIGNhbGxiYWNrc1tpXS5jb21ibywgY2FsbGJhY2tzW2ldLnNlcSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdlcmUgbm8gc2VxdWVuY2UgbWF0Y2hlcyBidXQgd2UgYXJlIHN0aWxsIGhlcmVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IG1lYW5zIHRoaXMgaXMgYSByZWd1bGFyIG1hdGNoIHNvIHdlIHNob3VsZCBmaXJlIHRoYXRcbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFja3NbaV0uY2FsbGJhY2ssIGUsIGNhbGxiYWNrc1tpXS5jb21ibyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUga2V5IHlvdSBwcmVzc2VkIG1hdGNoZXMgdGhlIHR5cGUgb2Ygc2VxdWVuY2Ugd2l0aG91dFxuICAgICAgICAgICAgLy8gYmVpbmcgYSBtb2RpZmllciAoaWUgXCJrZXl1cFwiIG9yIFwia2V5cHJlc3NcIikgdGhlbiB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIHJlc2V0IGFsbCBzZXF1ZW5jZXMgdGhhdCB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoaXMgZXZlbnRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHNvLCBmb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgdGhlIHNlcXVlbmNlIFwiaCBhIHRcIiBhbmQgeW91XG4gICAgICAgICAgICAvLyB0eXBlIFwiaCBlIGEgciB0XCIgaXQgZG9lcyBub3QgbWF0Y2guICBpbiB0aGlzIGNhc2UgdGhlIFwiZVwiIHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIHRoZSBzZXF1ZW5jZSB0byByZXNldFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIG1vZGlmaWVyIGtleXMgYXJlIGlnbm9yZWQgYmVjYXVzZSB5b3UgY2FuIGhhdmUgYSBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gdGhhdCBjb250YWlucyBtb2RpZmllcnMgc3VjaCBhcyBcImVudGVyIGN0cmwrc3BhY2VcIiBhbmQgaW4gbW9zdFxuICAgICAgICAgICAgLy8gY2FzZXMgdGhlIG1vZGlmaWVyIGtleSB3aWxsIGJlIHByZXNzZWQgYmVmb3JlIHRoZSBuZXh0IGtleVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGFsc28gaWYgeW91IGhhdmUgYSBzZXF1ZW5jZSBzdWNoIGFzIFwiY3RybCtiIGFcIiB0aGVuIHByZXNzaW5nIHRoZVxuICAgICAgICAgICAgLy8gXCJiXCIga2V5IHdpbGwgdHJpZ2dlciBhIFwia2V5cHJlc3NcIiBhbmQgYSBcImtleWRvd25cIlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoZSBcImtleWRvd25cIiBpcyBleHBlY3RlZCB3aGVuIHRoZXJlIGlzIGEgbW9kaWZpZXIsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIFwia2V5cHJlc3NcIiBlbmRzIHVwIG1hdGNoaW5nIHRoZSBfbmV4dEV4cGVjdGVkQWN0aW9uIHNpbmNlIGl0IG9jY3Vyc1xuICAgICAgICAgICAgLy8gYWZ0ZXIgYW5kIHRoYXQgY2F1c2VzIHRoZSBzZXF1ZW5jZSB0byByZXNldFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHdlIGlnbm9yZSBrZXlwcmVzc2VzIGluIGEgc2VxdWVuY2UgdGhhdCBkaXJlY3RseSBmb2xsb3cgYSBrZXlkb3duXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHNhbWUgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YXIgaWdub3JlVGhpc0tleXByZXNzID0gZS50eXBlID09ICdrZXlwcmVzcycgJiYgX2lnbm9yZU5leHRLZXlwcmVzcztcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gX25leHRFeHBlY3RlZEFjdGlvbiAmJiAhX2lzTW9kaWZpZXIoY2hhcmFjdGVyKSAmJiAhaWdub3JlVGhpc0tleXByZXNzKSB7XG4gICAgICAgICAgICAgICAgX3Jlc2V0U2VxdWVuY2VzKGRvTm90UmVzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaWdub3JlTmV4dEtleXByZXNzID0gcHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjayAmJiBlLnR5cGUgPT0gJ2tleWRvd24nO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYW5kbGVzIGEga2V5ZG93biBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9oYW5kbGVLZXlFdmVudChlKSB7XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBlLndoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI4NTYyNy9qYXZhc2NyaXB0LWtleWNvZGUtdnMtY2hhcmNvZGUtdXR0ZXItY29uZnVzaW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUud2hpY2ggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZS53aGljaCA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSk7XG5cbiAgICAgICAgICAgIC8vIG5vIGNoYXJhY3RlciBmb3VuZCB0aGVuIHN0b3BcbiAgICAgICAgICAgIGlmICghY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHVzZSA9PT0gZm9yIHRoZSBjaGFyYWN0ZXIgY2hlY2sgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGNhbiBiZSAwXG4gICAgICAgICAgICBpZiAoZS50eXBlID09ICdrZXl1cCcgJiYgX2lnbm9yZU5leHRLZXl1cCA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgX2lnbm9yZU5leHRLZXl1cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5oYW5kbGVLZXkoY2hhcmFjdGVyLCBfZXZlbnRNb2RpZmllcnMoZSksIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxlZCB0byBzZXQgYSAxIHNlY29uZCB0aW1lb3V0IG9uIHRoZSBzcGVjaWZpZWQgc2VxdWVuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogdGhpcyBpcyBzbyBhZnRlciBlYWNoIGtleSBwcmVzcyBpbiB0aGUgc2VxdWVuY2UgeW91IGhhdmUgMSBzZWNvbmRcbiAgICAgICAgICogdG8gcHJlc3MgdGhlIG5leHQga2V5IGJlZm9yZSB5b3UgaGF2ZSB0byBzdGFydCBvdmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9yZXNldFNlcXVlbmNlVGltZXIoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Jlc2V0VGltZXIpO1xuICAgICAgICAgICAgX3Jlc2V0VGltZXIgPSBzZXRUaW1lb3V0KF9yZXNldFNlcXVlbmNlcywgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYmluZHMgYSBrZXkgc2VxdWVuY2UgdG8gYW4gZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbWJvIC0gY29tYm8gc3BlY2lmaWVkIGluIGJpbmQgY2FsbFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5kU2VxdWVuY2UoY29tYm8sIGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcblxuICAgICAgICAgICAgLy8gc3RhcnQgb2ZmIGJ5IGFkZGluZyBhIHNlcXVlbmNlIGxldmVsIHJlY29yZCBmb3IgdGhpcyBjb21iaW5hdGlvblxuICAgICAgICAgICAgLy8gYW5kIHNldHRpbmcgdGhlIGxldmVsIHRvIDBcbiAgICAgICAgICAgIF9zZXF1ZW5jZUxldmVsc1tjb21ib10gPSAwO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGNhbGxiYWNrIHRvIGluY3JlYXNlIHRoZSBzZXF1ZW5jZSBsZXZlbCBmb3IgdGhpcyBzZXF1ZW5jZSBhbmQgcmVzZXRcbiAgICAgICAgICAgICAqIGFsbCBvdGhlciBzZXF1ZW5jZXMgdGhhdCB3ZXJlIGFjdGl2ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0QWN0aW9uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbmNyZWFzZVNlcXVlbmNlKG5leHRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF9uZXh0RXhwZWN0ZWRBY3Rpb24gPSBuZXh0QWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICArK19zZXF1ZW5jZUxldmVsc1tjb21ib107XG4gICAgICAgICAgICAgICAgICAgIF9yZXNldFNlcXVlbmNlVGltZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHdyYXBzIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW5zaWRlIG9mIGFub3RoZXIgZnVuY3Rpb24gaW4gb3JkZXJcbiAgICAgICAgICAgICAqIHRvIHJlc2V0IGFsbCBzZXF1ZW5jZSBjb3VudGVycyBhcyBzb29uIGFzIHRoaXMgc2VxdWVuY2UgaXMgZG9uZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2NhbGxiYWNrQW5kUmVzZXQoZSkge1xuICAgICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUsIGNvbWJvKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBpZ25vcmUgdGhlIG5leHQga2V5IHVwIGlmIHRoZSBhY3Rpb24gaXMga2V5IGRvd25cbiAgICAgICAgICAgICAgICAvLyBvciBrZXlwcmVzcy4gIHRoaXMgaXMgc28gaWYgeW91IGZpbmlzaCBhIHNlcXVlbmNlIGFuZFxuICAgICAgICAgICAgICAgIC8vIHJlbGVhc2UgdGhlIGtleSB0aGUgZmluYWwga2V5IHdpbGwgbm90IHRyaWdnZXIgYSBrZXl1cFxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdrZXl1cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgX2lnbm9yZU5leHRLZXl1cCA9IF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2VpcmQgcmFjZSBjb25kaXRpb24gaWYgYSBzZXF1ZW5jZSBlbmRzIHdpdGggdGhlIGtleVxuICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgc2VxdWVuY2UgYmVnaW5zIHdpdGhcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF9yZXNldFNlcXVlbmNlcywgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2gga2V5cyBvbmUgYXQgYSB0aW1lIGFuZCBiaW5kIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24uICBmb3IgYW55IGtleSBsZWFkaW5nIHVwIHRvIHRoZSBmaW5hbCBvbmUgaXQgc2hvdWxkXG4gICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2VxdWVuY2UuIGFmdGVyIHRoZSBmaW5hbCwgaXQgc2hvdWxkIHJlc2V0IGFsbCBzZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiBhbiBhY3Rpb24gaXMgc3BlY2lmaWVkIGluIHRoZSBvcmlnaW5hbCBiaW5kIGNhbGwgdGhlbiB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgdGhyb3VnaG91dC4gIG90aGVyd2lzZSB3ZSB3aWxsIHBhc3MgdGhlIGFjdGlvbiB0aGF0IHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBrZXkgaW4gdGhlIHNlcXVlbmNlIHNob3VsZCBtYXRjaC4gIHRoaXMgYWxsb3dzIGEgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIHRvIG1peCBhbmQgbWF0Y2gga2V5cHJlc3MgYW5kIGtleWRvd24gZXZlbnRzIGRlcGVuZGluZyBvbiB3aGljaFxuICAgICAgICAgICAgLy8gb25lcyBhcmUgYmV0dGVyIHN1aXRlZCB0byB0aGUga2V5IHByb3ZpZGVkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGaW5hbCA9IGkgKyAxID09PSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZENhbGxiYWNrID0gaXNGaW5hbCA/IF9jYWxsYmFja0FuZFJlc2V0IDogX2luY3JlYXNlU2VxdWVuY2UoYWN0aW9uIHx8IF9nZXRLZXlJbmZvKGtleXNbaSArIDFdKS5hY3Rpb24pO1xuICAgICAgICAgICAgICAgIF9iaW5kU2luZ2xlKGtleXNbaV0sIHdyYXBwZWRDYWxsYmFjaywgYWN0aW9uLCBjb21ibywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYmluZHMgYSBzaW5nbGUga2V5Ym9hcmQgY29tYmluYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbWJpbmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VxdWVuY2VOYW1lIC0gbmFtZSBvZiBzZXF1ZW5jZSBpZiBwYXJ0IG9mIHNlcXVlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGV2ZWwgLSB3aGF0IHBhcnQgb2YgdGhlIHNlcXVlbmNlIHRoZSBjb21tYW5kIGlzXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5kU2luZ2xlKGNvbWJpbmF0aW9uLCBjYWxsYmFjaywgYWN0aW9uLCBzZXF1ZW5jZU5hbWUsIGxldmVsKSB7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIGEgZGlyZWN0IG1hcHBlZCByZWZlcmVuY2UgZm9yIHVzZSB3aXRoIE1vdXNldHJhcC50cmlnZ2VyXG4gICAgICAgICAgICBzZWxmLl9kaXJlY3RNYXBbY29tYmluYXRpb24gKyAnOicgKyBhY3Rpb25dID0gY2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBtdWx0aXBsZSBzcGFjZXMgaW4gYSByb3cgYmVjb21lIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gY29tYmluYXRpb24uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHZhciBpbmZvO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIHBhdHRlcm4gaXMgYSBzZXF1ZW5jZSBvZiBrZXlzIHRoZW4gcnVuIHRocm91Z2ggdGhpcyBtZXRob2RcbiAgICAgICAgICAgIC8vIHRvIHJlcHJvY2VzcyBlYWNoIHBhdHRlcm4gb25lIGtleSBhdCBhIHRpbWVcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgX2JpbmRTZXF1ZW5jZShjb21iaW5hdGlvbiwgc2VxdWVuY2UsIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5mbyA9IF9nZXRLZXlJbmZvKGNvbWJpbmF0aW9uLCBhY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW5pdGlhbGl6ZSBhcnJheSBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICAvLyBhIGNhbGxiYWNrIGlzIGFkZGVkIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tzW2luZm8ua2V5XSA9IHNlbGYuX2NhbGxiYWNrc1tpbmZvLmtleV0gfHwgW107XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbiBleGlzdGluZyBtYXRjaCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgIF9nZXRNYXRjaGVzKGluZm8ua2V5LCBpbmZvLm1vZGlmaWVycywge3R5cGU6IGluZm8uYWN0aW9ufSwgc2VxdWVuY2VOYW1lLCBjb21iaW5hdGlvbiwgbGV2ZWwpO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhpcyBjYWxsIGJhY2sgdG8gdGhlIGFycmF5XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHNlcXVlbmNlIHB1dCBpdCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAvLyBpZiBub3QgcHV0IGl0IGF0IHRoZSBlbmRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSB3YXkgdGhlc2UgYXJlIHByb2Nlc3NlZCBleHBlY3RzXG4gICAgICAgICAgICAvLyB0aGUgc2VxdWVuY2Ugb25lcyB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICBzZWxmLl9jYWxsYmFja3NbaW5mby5rZXldW3NlcXVlbmNlTmFtZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IGluZm8ubW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogaW5mby5hY3Rpb24sXG4gICAgICAgICAgICAgICAgc2VxOiBzZXF1ZW5jZU5hbWUsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIGNvbWJvOiBjb21iaW5hdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYmluZHMgbXVsdGlwbGUgY29tYmluYXRpb25zIHRvIHRoZSBzYW1lIGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbWJpbmF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGFjdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLl9iaW5kTXVsdGlwbGUgPSBmdW5jdGlvbihjb21iaW5hdGlvbnMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgX2JpbmRTaW5nbGUoY29tYmluYXRpb25zW2ldLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGFydCFcbiAgICAgICAgX2FkZEV2ZW50KHRhcmdldEVsZW1lbnQsICdrZXlwcmVzcycsIF9oYW5kbGVLZXlFdmVudCk7XG4gICAgICAgIF9hZGRFdmVudCh0YXJnZXRFbGVtZW50LCAna2V5ZG93bicsIF9oYW5kbGVLZXlFdmVudCk7XG4gICAgICAgIF9hZGRFdmVudCh0YXJnZXRFbGVtZW50LCAna2V5dXAnLCBfaGFuZGxlS2V5RXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmRzIGFuIGV2ZW50IHRvIG1vdXNldHJhcFxuICAgICAqXG4gICAgICogY2FuIGJlIGEgc2luZ2xlIGtleSwgYSBjb21iaW5hdGlvbiBvZiBrZXlzIHNlcGFyYXRlZCB3aXRoICssXG4gICAgICogYW4gYXJyYXkgb2Yga2V5cywgb3IgYSBzZXF1ZW5jZSBvZiBrZXlzIHNlcGFyYXRlZCBieSBzcGFjZXNcbiAgICAgKlxuICAgICAqIGJlIHN1cmUgdG8gbGlzdCB0aGUgbW9kaWZpZXIga2V5cyBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgKiBjb3JyZWN0IGtleSBlbmRzIHVwIGdldHRpbmcgYm91bmQgKHRoZSBsYXN0IGtleSBpbiB0aGUgcGF0dGVybilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvbiAtICdrZXlwcmVzcycsICdrZXlkb3duJywgb3IgJ2tleXVwJ1xuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihrZXlzLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBba2V5c107XG4gICAgICAgIHNlbGYuX2JpbmRNdWx0aXBsZS5jYWxsKHNlbGYsIGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdW5iaW5kcyBhbiBldmVudCB0byBtb3VzZXRyYXBcbiAgICAgKlxuICAgICAqIHRoZSB1bmJpbmRpbmcgc2V0cyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIHNwZWNpZmllZCBrZXkgY29tYm9cbiAgICAgKiB0byBhbiBlbXB0eSBmdW5jdGlvbiBhbmQgZGVsZXRlcyB0aGUgY29ycmVzcG9uZGluZyBrZXkgaW4gdGhlXG4gICAgICogX2RpcmVjdE1hcCBkaWN0LlxuICAgICAqXG4gICAgICogVE9ETzogYWN0dWFsbHkgcmVtb3ZlIHRoaXMgZnJvbSB0aGUgX2NhbGxiYWNrcyBkaWN0aW9uYXJ5IGluc3RlYWRcbiAgICAgKiBvZiBiaW5kaW5nIGFuIGVtcHR5IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiB0aGUga2V5Y29tYm8rYWN0aW9uIGhhcyB0byBiZSBleGFjdGx5IHRoZSBzYW1lIGFzXG4gICAgICogaXQgd2FzIGRlZmluZWQgaW4gdGhlIGJpbmQgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihrZXlzLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZi5iaW5kLmNhbGwoc2VsZiwga2V5cywgZnVuY3Rpb24oKSB7fSwgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHJpZ2dlcnMgYW4gZXZlbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGtleXMsIGFjdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLl9kaXJlY3RNYXBba2V5cyArICc6JyArIGFjdGlvbl0pIHtcbiAgICAgICAgICAgIHNlbGYuX2RpcmVjdE1hcFtrZXlzICsgJzonICsgYWN0aW9uXSh7fSwga2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlc2V0cyB0aGUgbGlicmFyeSBiYWNrIHRvIGl0cyBpbml0aWFsIHN0YXRlLiAgdGhpcyBpcyB1c2VmdWxcbiAgICAgKiBpZiB5b3Ugd2FudCB0byBjbGVhciBvdXQgdGhlIGN1cnJlbnQga2V5Ym9hcmQgc2hvcnRjdXRzIGFuZCBiaW5kXG4gICAgICogbmV3IG9uZXMgLSBmb3IgZXhhbXBsZSBpZiB5b3Ugc3dpdGNoIHRvIGFub3RoZXIgcGFnZVxuICAgICAqXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgc2VsZi5fZGlyZWN0TWFwID0ge307XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgd2Ugc3RvcCB0aGlzIGV2ZW50IGJlZm9yZSBmaXJpbmcgb2ZmIGNhbGxiYWNrc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5zdG9wQ2FsbGJhY2sgPSBmdW5jdGlvbihlLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIFwibW91c2V0cmFwXCIgdGhlbiBubyBuZWVkIHRvIHN0b3BcbiAgICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2JlbG9uZ3NUbyhlbGVtZW50LCBzZWxmLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgZm9yIGlucHV0LCBzZWxlY3QsIGFuZCB0ZXh0YXJlYVxuICAgICAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09ICdJTlBVVCcgfHwgZWxlbWVudC50YWdOYW1lID09ICdTRUxFQ1QnIHx8IGVsZW1lbnQudGFnTmFtZSA9PSAnVEVYVEFSRUEnIHx8IGVsZW1lbnQuaXNDb250ZW50RWRpdGFibGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGV4cG9zZXMgX2hhbmRsZUtleSBwdWJsaWNseSBzbyBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgZXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUuaGFuZGxlS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYuX2hhbmRsZUtleS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhbGxvdyBjdXN0b20ga2V5IG1hcHBpbmdzXG4gICAgICovXG4gICAgTW91c2V0cmFwLmFkZEtleWNvZGVzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIF9NQVBba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9SRVZFUlNFX01BUCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIGdsb2JhbCBtb3VzZXRyYXAgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBuZWVkZWQgdG8gYWxsb3cgdGhlIGdsb2JhbCBtb3VzZXRyYXAgZnVuY3Rpb25zIHRvIHdvcmtcbiAgICAgKiBub3cgdGhhdCBtb3VzZXRyYXAgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBNb3VzZXRyYXAuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9jdW1lbnRNb3VzZXRyYXAgPSBNb3VzZXRyYXAoZG9jdW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBtZXRob2QgaW4gZG9jdW1lbnRNb3VzZXRyYXApIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QuY2hhckF0KDApICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICBNb3VzZXRyYXBbbWV0aG9kXSA9IChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TW91c2V0cmFwW21ldGhvZF0uYXBwbHkoZG9jdW1lbnRNb3VzZXRyYXAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSAobWV0aG9kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTW91c2V0cmFwLmluaXQoKTtcblxuICAgIC8vIGV4cG9zZSBtb3VzZXRyYXAgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICB3aW5kb3cuTW91c2V0cmFwID0gTW91c2V0cmFwO1xuXG4gICAgLy8gZXhwb3NlIGFzIGEgY29tbW9uIGpzIG1vZHVsZVxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1vdXNldHJhcDtcbiAgICB9XG5cbiAgICAvLyBleHBvc2UgbW91c2V0cmFwIGFzIGFuIEFNRCBtb2R1bGVcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBNb3VzZXRyYXA7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGwsIHR5cGVvZiAgd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XG5cbi8vIGx1aG4gZXh0cmEgdmFsaWRhdG9yc1xud2luZG93LlBhcnNsZXlDb25maWcgPSB3aW5kb3cuUGFyc2xleUNvbmZpZyB8fCB7fTtcbndpbmRvdy5QYXJzbGV5Q29uZmlnLnZhbGlkYXRvcnMgPSB3aW5kb3cuUGFyc2xleUNvbmZpZy52YWxpZGF0b3JzIHx8IHt9O1xuXG53aW5kb3cuUGFyc2xleUNvbmZpZy52YWxpZGF0b3JzLmx1aG4gPSB7XG4gIGZuOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgLV0vZywgJycpO1xuICAgIHZhciBkaWdpdDtcbiAgICB2YXIgbjtcbiAgICB2YXIgX2o7XG4gICAgdmFyIF9sZW4xO1xuICAgIHZhciBfcmVmMjtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBfcmVmMiA9IHZhbHVlLnNwbGl0KCcnKS5yZXZlcnNlKCk7XG4gICAgZm9yIChuID0gX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgbiA9ICsrX2opIHtcbiAgICAgIGRpZ2l0ID0gX3JlZjJbbl07XG4gICAgICBkaWdpdCA9ICtkaWdpdDtcbiAgICAgIGlmIChuICUgMikge1xuICAgICAgICBkaWdpdCAqPSAyO1xuICAgICAgICBpZiAoZGlnaXQgPCAxMCkge1xuICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdW0gKz0gZGlnaXQgLSA5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbiAgfSxcbiAgcHJpb3JpdHk6IDMyXG59O1xuXG4vKiFcbiogUGFyc2xleS5qc1xuKiBWZXJzaW9uIDIuOC4xIC0gYnVpbHQgU2F0LCBGZWIgM3JkIDIwMTgsIDI6MjcgcG1cbiogaHR0cDovL3BhcnNsZXlqcy5vcmdcbiogR3VpbGxhdW1lIFBvdGllciAtIDxndWlsbGF1bWVAd2lzZW1ibHkuY29tPlxuKiBNYXJjLUFuZHJlIExhZm9ydHVuZSAtIDxwZXRyb3NlbGludW1AbWFyYy1hbmRyZS5jYT5cbiogTUlUIExpY2Vuc2VkXG4qL1xuXG4vLyBUaGUgc291cmNlIGNvZGUgYmVsb3cgaXMgZ2VuZXJhdGVkIGJ5IGJhYmVsIGFzXG4vLyBQYXJzbGV5IGlzIHdyaXR0ZW4gaW4gRUNNQVNjcmlwdCA2XG4vL1xudmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSkgOiBnbG9iYWwucGFyc2xleSA9IGZhY3RvcnkoZ2xvYmFsLmpRdWVyeSk7XG59KSh0aGlzLCBmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGdsb2JhbElEID0gMTtcbiAgdmFyIHBhc3RXYXJuaW5ncyA9IHt9O1xuXG4gIHZhciBVdGlscyA9IHtcbiAgICAvLyBQYXJzbGV5IERPTS1BUElcbiAgICAvLyByZXR1cm5zIG9iamVjdCBmcm9tIGRvbSBhdHRyaWJ1dGVzIGFuZCB2YWx1ZXNcbiAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGVsZW1lbnQsIG5hbWVzcGFjZSwgb2JqKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBhdHRyaWJ1dGU7XG4gICAgICB2YXIgYXR0cmlidXRlcztcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlLCAnaScpO1xuXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBvYmopIG9iaiA9IHt9O2Vsc2Uge1xuICAgICAgICAvLyBDbGVhciBhbGwgb3duIHByb3BlcnRpZXMuIFRoaXMgd29uJ3QgYWZmZWN0IHByb3RvdHlwZSdzIHZhbHVlc1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgZGVsZXRlIG9ialtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQpIHJldHVybiBvYmo7XG5cbiAgICAgIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGkgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLnNwZWNpZmllZCAmJiByZWdleC50ZXN0KGF0dHJpYnV0ZS5uYW1lKSkge1xuICAgICAgICAgIG9ialt0aGlzLmNhbWVsaXplKGF0dHJpYnV0ZS5uYW1lLnNsaWNlKG5hbWVzcGFjZS5sZW5ndGgpKV0gPSB0aGlzLmRlc2VyaWFsaXplVmFsdWUoYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICBjaGVja0F0dHI6IGZ1bmN0aW9uIGNoZWNrQXR0cihlbGVtZW50LCBuYW1lc3BhY2UsIF9jaGVja0F0dHIpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShuYW1lc3BhY2UgKyBfY2hlY2tBdHRyKTtcbiAgICB9LFxuXG4gICAgc2V0QXR0cjogZnVuY3Rpb24gc2V0QXR0cihlbGVtZW50LCBuYW1lc3BhY2UsIGF0dHIsIHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLmRhc2hlcml6ZShuYW1lc3BhY2UgKyBhdHRyKSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfSxcblxuICAgIGdldFR5cGU6IGZ1bmN0aW9uIGdldFR5cGUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJykgfHwgJ3RleHQnO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZUlEOiBmdW5jdGlvbiBnZW5lcmF0ZUlEKCkge1xuICAgICAgcmV0dXJuICcnICsgZ2xvYmFsSUQrKztcbiAgICB9LFxuXG4gICAgLyoqIFRoaXJkIHBhcnR5IGZ1bmN0aW9ucyAqKi9cbiAgICBkZXNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgbnVtO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA9PSBcInRydWVcIiB8fCAodmFsdWUgPT0gXCJmYWxzZVwiID8gZmFsc2UgOiB2YWx1ZSA9PSBcIm51bGxcIiA/IG51bGwgOiAhaXNOYU4obnVtID0gTnVtYmVyKHZhbHVlKSkgPyBudW0gOiAvXltcXFtcXHtdLy50ZXN0KHZhbHVlKSA/IEpTT04ucGFyc2UodmFsdWUpIDogdmFsdWUpIDogdmFsdWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gWmVwdG8gY2FtZWxpemUgZnVuY3Rpb25cbiAgICBjYW1lbGl6ZTogZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGNocikge1xuICAgICAgICByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBaZXB0byBkYXNoZXJpemUgZnVuY3Rpb25cbiAgICBkYXNoZXJpemU6IGZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvOjovZywgJy8nKS5yZXBsYWNlKC8oW0EtWl0rKShbQS1aXVthLXpdKS9nLCAnJDFfJDInKS5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKS5yZXBsYWNlKC9fL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgd2FybjogZnVuY3Rpb24gd2FybigpIHtcbiAgICAgIHZhciBfd2luZG93JGNvbnNvbGU7XG5cbiAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2Ygd2luZG93LmNvbnNvbGUud2FybikgKF93aW5kb3ckY29uc29sZSA9IHdpbmRvdy5jb25zb2xlKS53YXJuLmFwcGx5KF93aW5kb3ckY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgd2Fybk9uY2U6IGZ1bmN0aW9uIHdhcm5PbmNlKG1zZykge1xuICAgICAgaWYgKCFwYXN0V2FybmluZ3NbbXNnXSkge1xuICAgICAgICBwYXN0V2FybmluZ3NbbXNnXSA9IHRydWU7XG4gICAgICAgIHRoaXMud2Fybi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVzZXRXYXJuaW5nczogZnVuY3Rpb24gX3Jlc2V0V2FybmluZ3MoKSB7XG4gICAgICBwYXN0V2FybmluZ3MgPSB7fTtcbiAgICB9LFxuXG4gICAgdHJpbVN0cmluZzogZnVuY3Rpb24gdHJpbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgIH0sXG5cbiAgICBwYXJzZToge1xuICAgICAgZGF0ZTogZnVuY3Rpb24gZGF0ZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHN0cmluZy5tYXRjaCgvXihcXGR7NCx9KS0oXFxkXFxkKS0oXFxkXFxkKSQvKTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBfcGFyc2VkJG1hcCA9IHBhcnNlZC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgX3BhcnNlZCRtYXAyID0gX3NsaWNlZFRvQXJyYXkoX3BhcnNlZCRtYXAsIDQpO1xuXG4gICAgICAgIHZhciBfID0gX3BhcnNlZCRtYXAyWzBdO1xuICAgICAgICB2YXIgeWVhciA9IF9wYXJzZWQkbWFwMlsxXTtcbiAgICAgICAgdmFyIG1vbnRoID0gX3BhcnNlZCRtYXAyWzJdO1xuICAgICAgICB2YXIgZGF5ID0gX3BhcnNlZCRtYXAyWzNdO1xuXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICAgICAgICBpZiAoZGF0ZS5nZXRGdWxsWWVhcigpICE9PSB5ZWFyIHx8IGRhdGUuZ2V0TW9udGgoKSArIDEgIT09IG1vbnRoIHx8IGRhdGUuZ2V0RGF0ZSgpICE9PSBkYXkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH0sXG4gICAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBfc3RyaW5nO1xuICAgICAgfSxcbiAgICAgIGludGVnZXI6IGZ1bmN0aW9uIGludGVnZXIoc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc05hTihzdHJpbmcpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xuICAgICAgfSxcbiAgICAgIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKHN0cmluZykge1xuICAgICAgICBpZiAoaXNOYU4oc3RyaW5nKSkgdGhyb3cgbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgICAgIH0sXG4gICAgICAnYm9vbGVhbic6IGZ1bmN0aW9uIF9ib29sZWFuKHN0cmluZykge1xuICAgICAgICByZXR1cm4gIS9eXFxzKmZhbHNlXFxzKiQvaS50ZXN0KHN0cmluZyk7XG4gICAgICB9LFxuICAgICAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3Qoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5kZXNlcmlhbGl6ZVZhbHVlKHN0cmluZyk7XG4gICAgICB9LFxuICAgICAgcmVnZXhwOiBmdW5jdGlvbiByZWdleHAoX3JlZ2V4cCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSAnJztcblxuICAgICAgICAvLyBUZXN0IGlmIFJlZ0V4cCBpcyBsaXRlcmFsLCBpZiBub3QsIG5vdGhpbmcgdG8gYmUgZG9uZSwgb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGlzb2xhdGUgZmxhZ3MgYW5kIHBhdHRlcm5cbiAgICAgICAgaWYgKC9eXFwvLipcXC8oPzpbZ2lteV0qKSQvLnRlc3QoX3JlZ2V4cCkpIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByZWdleHAgbGl0ZXJhbCBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgbWF0Y2ggZ3JvdXA6IChbZ2lteV0qKVxuICAgICAgICAgIC8vIElmIG5vIGZsYWcgaXMgcHJlc2VudCwgdGhpcyB3aWxsIGJlIGEgYmxhbmsgc3RyaW5nXG4gICAgICAgICAgZmxhZ3MgPSBfcmVnZXhwLnJlcGxhY2UoLy4qXFwvKFtnaW15XSopJC8sICckMScpO1xuICAgICAgICAgIC8vIEFnYWluLCByZXBsYWNlIHRoZSByZWdleHAgbGl0ZXJhbCBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgbWF0Y2ggZ3JvdXA6XG4gICAgICAgICAgLy8gZXZlcnl0aGluZyBleGNsdWRpbmcgdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc2xhc2hlcyBhbmQgdGhlIGZsYWdzXG4gICAgICAgICAgX3JlZ2V4cCA9IF9yZWdleHAucmVwbGFjZShuZXcgUmVnRXhwKCdeLyguKj8pLycgKyBmbGFncyArICckJyksICckMScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuY2hvciByZWdleHA6XG4gICAgICAgICAgX3JlZ2V4cCA9ICdeJyArIF9yZWdleHAgKyAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoX3JlZ2V4cCwgZmxhZ3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZVJlcXVpcmVtZW50OiBmdW5jdGlvbiBwYXJzZVJlcXVpcmVtZW50KHJlcXVpcmVtZW50VHlwZSwgc3RyaW5nKSB7XG4gICAgICB2YXIgY29udmVydGVyID0gdGhpcy5wYXJzZVtyZXF1aXJlbWVudFR5cGUgfHwgJ3N0cmluZyddO1xuICAgICAgaWYgKCFjb252ZXJ0ZXIpIHRocm93ICdVbmtub3duIHJlcXVpcmVtZW50IHNwZWNpZmljYXRpb246IFwiJyArIHJlcXVpcmVtZW50VHlwZSArICdcIic7XG4gICAgICB2YXIgY29udmVydGVkID0gY29udmVydGVyKHN0cmluZyk7XG4gICAgICBpZiAoY29udmVydGVkID09PSBudWxsKSB0aHJvdyAnUmVxdWlyZW1lbnQgaXMgbm90IGEgJyArIHJlcXVpcmVtZW50VHlwZSArICc6IFwiJyArIHN0cmluZyArICdcIic7XG4gICAgICByZXR1cm4gY29udmVydGVkO1xuICAgIH0sXG5cbiAgICBuYW1lc3BhY2VFdmVudHM6IGZ1bmN0aW9uIG5hbWVzcGFjZUV2ZW50cyhldmVudHMsIG5hbWVzcGFjZSkge1xuICAgICAgZXZlbnRzID0gdGhpcy50cmltU3RyaW5nKGV2ZW50cyB8fCAnJykuc3BsaXQoL1xccysvKTtcbiAgICAgIGlmICghZXZlbnRzWzBdKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gJC5tYXAoZXZlbnRzLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiBldnQgKyAnLicgKyBuYW1lc3BhY2U7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIGRpZmZlcmVuY2UoYXJyYXksIHJlbW92ZSkge1xuICAgICAgLy8gVGhpcyBpcyBPKE5eMiksIHNob3VsZCBiZSBvcHRpbWl6ZWRcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICQuZWFjaChhcnJheSwgZnVuY3Rpb24gKF8sIGVsZW0pIHtcbiAgICAgICAgaWYgKHJlbW92ZS5pbmRleE9mKGVsZW0pID09IC0xKSByZXN1bHQucHVzaChlbGVtKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gQWx0ZXItZWdvIHRvIG5hdGl2ZSBQcm9taXNlLmFsbCwgYnV0IGZvciBqUXVlcnlcbiAgICBhbGw6IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgICAgLy8galF1ZXJ5IHRyZWF0cyAkLndoZW4oKSBhbmQgJC53aGVuKHNpbmdsZVByb21pc2UpIGRpZmZlcmVudGx5OyBsZXQncyBhdm9pZCB0aGF0IGFuZCBhZGQgc3B1cmlvdXMgZWxlbWVudHNcbiAgICAgIHJldHVybiAkLndoZW4uYXBwbHkoJCwgX3RvQ29uc3VtYWJsZUFycmF5KHByb21pc2VzKS5jb25jYXQoWzQyLCA0Ml0pKTtcbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0LmNyZWF0ZSBwb2x5ZmlsbCwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUjUG9seWZpbGxcbiAgICBvYmplY3RDcmVhdGU6IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBPYmplY3QgPSBmdW5jdGlvbiBPYmplY3QoKSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KSgpLFxuXG4gICAgX1N1Ym1pdFNlbGVjdG9yOiAnaW5wdXRbdHlwZT1cInN1Ym1pdFwiXSwgYnV0dG9uOnN1Ym1pdCdcbiAgfTtcblxuICAvLyBBbGwgdGhlc2Ugb3B0aW9ucyBjb3VsZCBiZSBvdmVycmlkZW4gYW5kIHNwZWNpZmllZCBkaXJlY3RseSBpbiBET00gdXNpbmdcbiAgLy8gYGRhdGEtcGFyc2xleS1gIGRlZmF1bHQgRE9NLUFQSVxuICAvLyBlZzogYGlucHV0c2AgY2FuIGJlIHNldCBpbiBET00gdXNpbmcgYGRhdGEtcGFyc2xleS1pbnB1dHM9XCJpbnB1dCwgdGV4dGFyZWFcImBcbiAgLy8gZWc6IGBkYXRhLXBhcnNsZXktc3RvcC1vbi1maXJzdC1mYWlsaW5nLWNvbnN0cmFpbnQ9XCJmYWxzZVwiYFxuXG4gIHZhciBEZWZhdWx0cyA9IHtcbiAgICAvLyAjIyMgR2VuZXJhbFxuXG4gICAgLy8gRGVmYXVsdCBkYXRhLW5hbWVzcGFjZSBmb3IgRE9NIEFQSVxuICAgIG5hbWVzcGFjZTogJ2RhdGEtcGFyc2xleS0nLFxuXG4gICAgLy8gU3VwcG9ydGVkIGlucHV0cyBieSBkZWZhdWx0XG4gICAgaW5wdXRzOiAnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnLFxuXG4gICAgLy8gRXhjbHVkZWQgaW5wdXRzIGJ5IGRlZmF1bHRcbiAgICBleGNsdWRlZDogJ2lucHV0W3R5cGU9YnV0dG9uXSwgaW5wdXRbdHlwZT1zdWJtaXRdLCBpbnB1dFt0eXBlPXJlc2V0XSwgaW5wdXRbdHlwZT1oaWRkZW5dJyxcblxuICAgIC8vIFN0b3AgdmFsaWRhdGluZyBmaWVsZCBvbiBoaWdoZXN0IHByaW9yaXR5IGZhaWxpbmcgY29uc3RyYWludFxuICAgIHByaW9yaXR5RW5hYmxlZDogdHJ1ZSxcblxuICAgIC8vICMjIyBGaWVsZCBvbmx5XG5cbiAgICAvLyBpZGVudGlmaWVyIHVzZWQgdG8gZ3JvdXAgdG9nZXRoZXIgaW5wdXRzIChlLmcuIHJhZGlvIGJ1dHRvbnMuLi4pXG4gICAgbXVsdGlwbGU6IG51bGwsXG5cbiAgICAvLyBpZGVudGlmaWVyIChvciBhcnJheSBvZiBpZGVudGlmaWVycykgdXNlZCB0byB2YWxpZGF0ZSBvbmx5IGEgc2VsZWN0IGdyb3VwIG9mIGlucHV0c1xuICAgIGdyb3VwOiBudWxsLFxuXG4gICAgLy8gIyMjIFVJXG4gICAgLy8gRW5hYmxlXFxEaXNhYmxlIGVycm9yIG1lc3NhZ2VzXG4gICAgdWlFbmFibGVkOiB0cnVlLFxuXG4gICAgLy8gS2V5IGV2ZW50cyB0aHJlc2hvbGQgYmVmb3JlIHZhbGlkYXRpb25cbiAgICB2YWxpZGF0aW9uVGhyZXNob2xkOiAzLFxuXG4gICAgLy8gRm9jdXNlZCBmaWVsZCBvbiBmb3JtIHZhbGlkYXRpb24gZXJyb3IuICdmaXJzdCd8J2xhc3QnfCdub25lJ1xuICAgIGZvY3VzOiAnZmlyc3QnLFxuXG4gICAgLy8gZXZlbnQocykgdGhhdCB3aWxsIHRyaWdnZXIgdmFsaWRhdGlvbiBiZWZvcmUgZmlyc3QgZmFpbHVyZS4gZWc6IGBpbnB1dGAuLi5cbiAgICB0cmlnZ2VyOiBmYWxzZSxcblxuICAgIC8vIGV2ZW50KHMpIHRoYXQgd2lsbCB0cmlnZ2VyIHZhbGlkYXRpb24gYWZ0ZXIgZmlyc3QgZmFpbHVyZS5cbiAgICB0cmlnZ2VyQWZ0ZXJGYWlsdXJlOiAnaW5wdXQnLFxuXG4gICAgLy8gQ2xhc3MgdGhhdCB3b3VsZCBiZSBhZGRlZCBvbiBldmVyeSBmYWlsaW5nIHZhbGlkYXRpb24gUGFyc2xleSBmaWVsZFxuICAgIGVycm9yQ2xhc3M6ICdwYXJzbGV5LWVycm9yJyxcblxuICAgIC8vIFNhbWUgZm9yIHN1Y2Nlc3MgdmFsaWRhdGlvblxuICAgIHN1Y2Nlc3NDbGFzczogJ3BhcnNsZXktc3VjY2VzcycsXG5cbiAgICAvLyBSZXR1cm4gdGhlIGAkZWxlbWVudGAgdGhhdCB3aWxsIHJlY2VpdmUgdGhlc2UgYWJvdmUgc3VjY2VzcyBvciBlcnJvciBjbGFzc2VzXG4gICAgLy8gQ291bGQgYWxzbyBiZSAoYW5kIGdpdmVuIGRpcmVjdGx5IGZyb20gRE9NKSBhIHZhbGlkIHNlbGVjdG9yIGxpa2UgYCcjZGl2J2BcbiAgICBjbGFzc0hhbmRsZXI6IGZ1bmN0aW9uIGNsYXNzSGFuZGxlcihGaWVsZCkge30sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGAkZWxlbWVudGAgd2hlcmUgZXJyb3JzIHdpbGwgYmUgYXBwZW5kZWRcbiAgICAvLyBDb3VsZCBhbHNvIGJlIChhbmQgZ2l2ZW4gZGlyZWN0bHkgZnJvbSBET00pIGEgdmFsaWQgc2VsZWN0b3IgbGlrZSBgJyNkaXYnYFxuICAgIGVycm9yc0NvbnRhaW5lcjogZnVuY3Rpb24gZXJyb3JzQ29udGFpbmVyKEZpZWxkKSB7fSxcblxuICAgIC8vIHVsIGVsZW0gdGhhdCB3b3VsZCByZWNlaXZlIGVycm9ycycgbGlzdFxuICAgIGVycm9yc1dyYXBwZXI6ICc8dWwgY2xhc3M9XCJwYXJzbGV5LWVycm9ycy1saXN0XCI+PC91bD4nLFxuXG4gICAgLy8gbGkgZWxlbSB0aGF0IHdvdWxkIHJlY2VpdmUgZXJyb3IgbWVzc2FnZVxuICAgIGVycm9yVGVtcGxhdGU6ICc8bGk+PC9saT4nXG4gIH07XG5cbiAgdmFyIEJhc2UgPSBmdW5jdGlvbiBCYXNlKCkge1xuICAgIHRoaXMuX19pZF9fID0gVXRpbHMuZ2VuZXJhdGVJRCgpO1xuICB9O1xuXG4gIEJhc2UucHJvdG90eXBlID0ge1xuICAgIGFzeW5jU3VwcG9ydDogdHJ1ZSwgLy8gRGVwcmVjYXRlZFxuXG4gICAgX3BpcGVBY2NvcmRpbmdUb1ZhbGlkYXRpb25SZXN1bHQ6IGZ1bmN0aW9uIF9waXBlQWNjb3JkaW5nVG9WYWxpZGF0aW9uUmVzdWx0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xuICAgICAgICB2YXIgciA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgaWYgKHRydWUgIT09IF90aGlzLnZhbGlkYXRpb25SZXN1bHQpIHIucmVqZWN0KCk7XG4gICAgICAgIHJldHVybiByLnJlc29sdmUoKS5wcm9taXNlKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFtwaXBlLCBwaXBlXTtcbiAgICB9LFxuXG4gICAgYWN0dWFsaXplT3B0aW9uczogZnVuY3Rpb24gYWN0dWFsaXplT3B0aW9ucygpIHtcbiAgICAgIFV0aWxzLmF0dHIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMubmFtZXNwYWNlLCB0aGlzLmRvbU9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmFjdHVhbGl6ZU9wdGlvbnMpIHRoaXMucGFyZW50LmFjdHVhbGl6ZU9wdGlvbnMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzZXRPcHRpb25zOiBmdW5jdGlvbiBfcmVzZXRPcHRpb25zKGluaXRPcHRpb25zKSB7XG4gICAgICB0aGlzLmRvbU9wdGlvbnMgPSBVdGlscy5vYmplY3RDcmVhdGUodGhpcy5wYXJlbnQub3B0aW9ucyk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBVdGlscy5vYmplY3RDcmVhdGUodGhpcy5kb21PcHRpb25zKTtcbiAgICAgIC8vIFNoYWxsb3cgY29weSBvZiBvd25Qcm9wZXJ0aWVzIG9mIGluaXRPcHRpb25zOlxuICAgICAgZm9yICh2YXIgaSBpbiBpbml0T3B0aW9ucykge1xuICAgICAgICBpZiAoaW5pdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHRoaXMub3B0aW9uc1tpXSA9IGluaXRPcHRpb25zW2ldO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3R1YWxpemVPcHRpb25zKCk7XG4gICAgfSxcblxuICAgIF9saXN0ZW5lcnM6IG51bGwsXG5cbiAgICAvLyBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gZXZlbnQgbmFtZVxuICAgIC8vIENhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIGNvbnRleHQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgYHRoaXNgXG4gICAgLy8gVGhlIGNvbnRleHQgaXMgdGhlIGN1cnJlbnQgcGFyc2xleSBpbnN0YW5jZSwgb3Igd2luZG93LlBhcnNsZXkgaWYgZ2xvYmFsXG4gICAgLy8gQSByZXR1cm4gdmFsdWUgb2YgYGZhbHNlYCB3aWxsIGludGVycnVwdCB0aGUgY2FsbHNcbiAgICBvbjogZnVuY3Rpb24gb24obmFtZSwgZm4pIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCB7fTtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMuX2xpc3RlbmVyc1tuYW1lXSA9IHRoaXMuX2xpc3RlbmVyc1tuYW1lXSB8fCBbXTtcbiAgICAgIHF1ZXVlLnB1c2goZm4pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRGVwcmVjYXRlZC4gVXNlIGBvbmAgaW5zdGVhZFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWUsIGZuKSB7XG4gICAgICAkLmxpc3RlblRvKHRoaXMsIG5hbWUudG9Mb3dlckNhc2UoKSwgZm4pO1xuICAgIH0sXG5cbiAgICAvLyBVbnJlZ2lzdGVyIGEgY2FsbGJhY2sgKG9yIGFsbCBpZiBub25lIGlzIGdpdmVuKSBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWVcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihuYW1lLCBmbikge1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbiAgICAgIGlmIChxdWV1ZSkge1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gcXVldWUubGVuZ3RoOyBpLS07KSBpZiAocXVldWVbaV0gPT09IGZuKSBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBEZXByZWNhdGVkLiBVc2UgYG9mZmBcbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUobmFtZSwgZm4pIHtcbiAgICAgICQudW5zdWJzY3JpYmVUbyh0aGlzLCBuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0sXG5cbiAgICAvLyBUcmlnZ2VyIGFuIGV2ZW50IG9mIHRoZSBnaXZlbiBuYW1lXG4gICAgLy8gQSByZXR1cm4gdmFsdWUgb2YgYGZhbHNlYCBpbnRlcnJ1cHRzIHRoZSBjYWxsYmFjayBjaGFpblxuICAgIC8vIFJldHVybnMgZmFsc2UgaWYgZXhlY3V0aW9uIHdhcyBpbnRlcnJ1cHRlZFxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIobmFtZSwgdGFyZ2V0LCBleHRyYUFyZykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG4gICAgICB2YXIgcXVldWUgPSB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW25hbWVdO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHZhciBwYXJlbnRSZXN1bHQ7XG4gICAgICBpZiAocXVldWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHF1ZXVlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHJlc3VsdCA9IHF1ZXVlW2ldLmNhbGwodGFyZ2V0LCB0YXJnZXQsIGV4dHJhQXJnKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC50cmlnZ2VyKG5hbWUsIHRhcmdldCwgZXh0cmFBcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGFzeW5jSXNWYWxpZDogZnVuY3Rpb24gYXN5bmNJc1ZhbGlkKGdyb3VwLCBmb3JjZSkge1xuICAgICAgVXRpbHMud2Fybk9uY2UoXCJhc3luY0lzVmFsaWQgaXMgZGVwcmVjYXRlZDsgcGxlYXNlIHVzZSB3aGVuVmFsaWQgaW5zdGVhZFwiKTtcbiAgICAgIHJldHVybiB0aGlzLndoZW5WYWxpZCh7IGdyb3VwOiBncm91cCwgZm9yY2U6IGZvcmNlIH0pO1xuICAgIH0sXG5cbiAgICBfZmluZFJlbGF0ZWQ6IGZ1bmN0aW9uIF9maW5kUmVsYXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubXVsdGlwbGUgPyAkKHRoaXMucGFyZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnWycgKyB0aGlzLm9wdGlvbnMubmFtZXNwYWNlICsgJ211bHRpcGxlPVwiJyArIHRoaXMub3B0aW9ucy5tdWx0aXBsZSArICdcIl0nKSkgOiB0aGlzLiRlbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICB2YXIgY29udmVydEFycmF5UmVxdWlyZW1lbnQgPSBmdW5jdGlvbiBjb252ZXJ0QXJyYXlSZXF1aXJlbWVudChzdHJpbmcsIGxlbmd0aCkge1xuICAgIHZhciBtID0gc3RyaW5nLm1hdGNoKC9eXFxzKlxcWyguKilcXF1cXHMqJC8pO1xuICAgIGlmICghbSkgdGhyb3cgJ1JlcXVpcmVtZW50IGlzIG5vdCBhbiBhcnJheTogXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICB2YXIgdmFsdWVzID0gbVsxXS5zcGxpdCgnLCcpLm1hcChVdGlscy50cmltU3RyaW5nKTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gbGVuZ3RoKSB0aHJvdyAnUmVxdWlyZW1lbnQgaGFzICcgKyB2YWx1ZXMubGVuZ3RoICsgJyB2YWx1ZXMgd2hlbiAnICsgbGVuZ3RoICsgJyBhcmUgbmVlZGVkJztcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIHZhciBjb252ZXJ0RXh0cmFPcHRpb25SZXF1aXJlbWVudCA9IGZ1bmN0aW9uIGNvbnZlcnRFeHRyYU9wdGlvblJlcXVpcmVtZW50KHJlcXVpcmVtZW50U3BlYywgc3RyaW5nLCBleHRyYU9wdGlvblJlYWRlcikge1xuICAgIHZhciBtYWluID0gbnVsbDtcbiAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcmVxdWlyZW1lbnRTcGVjKSB7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4dHJhT3B0aW9uUmVhZGVyKGtleSk7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlKSB2YWx1ZSA9IFV0aWxzLnBhcnNlUmVxdWlyZW1lbnQocmVxdWlyZW1lbnRTcGVjW2tleV0sIHZhbHVlKTtcbiAgICAgICAgZXh0cmFba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpbiA9IFV0aWxzLnBhcnNlUmVxdWlyZW1lbnQocmVxdWlyZW1lbnRTcGVjW2tleV0sIHN0cmluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWFpbiwgZXh0cmFdO1xuICB9O1xuXG4gIC8vIEEgVmFsaWRhdG9yIG5lZWRzIHRvIGltcGxlbWVudCB0aGUgbWV0aG9kcyBgdmFsaWRhdGVgIGFuZCBgcGFyc2VSZXF1aXJlbWVudHNgXG5cbiAgdmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvcihzcGVjKSB7XG4gICAgJC5leHRlbmQodHJ1ZSwgdGhpcywgc3BlYyk7XG4gIH07XG5cbiAgVmFsaWRhdG9yLnByb3RvdHlwZSA9IHtcbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZmYgdGhlIGdpdmVuIGB2YWx1ZWAgaXMgdmFsaWQgYWNjb3JkaW5nIHRoZSBnaXZlbiByZXF1aXJlbWVudHMuXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCByZXF1aXJlbWVudEZpcnN0QXJnKSB7XG4gICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICAvLyBMZWdhY3kgc3R5bGUgdmFsaWRhdG9yXG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSAvLyBJZiBtb3JlIGFyZ3MgdGhlbiB2YWx1ZSwgcmVxdWlyZW1lbnQsIGluc3RhbmNlLi4uXG4gICAgICAgICAgcmVxdWlyZW1lbnRGaXJzdEFyZyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMSk7IC8vIFNraXAgZmlyc3QgYXJnICh2YWx1ZSkgYW5kIGxhc3QgKGluc3RhbmNlKSwgY29tYmluaW5nIHRoZSByZXN0XG4gICAgICAgIHJldHVybiB0aGlzLmZuKHZhbHVlLCByZXF1aXJlbWVudEZpcnN0QXJnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZU11bHRpcGxlKSB0aHJvdyAnVmFsaWRhdG9yIGAnICsgdGhpcy5uYW1lICsgJ2AgZG9lcyBub3QgaGFuZGxlIG11bHRpcGxlIHZhbHVlcyc7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTXVsdGlwbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlRGF0ZSAmJiBpbnN0YW5jZS5faXNEYXRlSW5wdXQoKSkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IFV0aWxzLnBhcnNlLmRhdGUoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVOdW1iZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gcGFyc2VGbG9hdChhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTnVtYmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVTdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICdWYWxpZGF0b3IgYCcgKyB0aGlzLm5hbWUgKyAnYCBvbmx5IGhhbmRsZXMgbXVsdGlwbGUgdmFsdWVzJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUGFyc2VzIGByZXF1aXJlbWVudHNgIGludG8gYW4gYXJyYXkgb2YgYXJndW1lbnRzLFxuICAgIC8vIGFjY29yZGluZyB0byBgdGhpcy5yZXF1aXJlbWVudFR5cGVgXG4gICAgcGFyc2VSZXF1aXJlbWVudHM6IGZ1bmN0aW9uIHBhcnNlUmVxdWlyZW1lbnRzKHJlcXVpcmVtZW50cywgZXh0cmFPcHRpb25SZWFkZXIpIHtcbiAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHJlcXVpcmVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgcmVxdWlyZW1lbnQgYWxyZWFkeSBwYXJzZWRcbiAgICAgICAgLy8gYnV0IG1ha2Ugc3VyZSB3ZSByZXR1cm4gYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZW1lbnRzKSA/IHJlcXVpcmVtZW50cyA6IFtyZXF1aXJlbWVudHNdO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0aGlzLnJlcXVpcmVtZW50VHlwZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjb252ZXJ0QXJyYXlSZXF1aXJlbWVudChyZXF1aXJlbWVudHMsIHR5cGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHZhbHVlc1tpXSA9IFV0aWxzLnBhcnNlUmVxdWlyZW1lbnQodHlwZVtpXSwgdmFsdWVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0gZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0RXh0cmFPcHRpb25SZXF1aXJlbWVudCh0eXBlLCByZXF1aXJlbWVudHMsIGV4dHJhT3B0aW9uUmVhZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbVXRpbHMucGFyc2VSZXF1aXJlbWVudCh0eXBlLCByZXF1aXJlbWVudHMpXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlZmF1bHRzOlxuICAgIHJlcXVpcmVtZW50VHlwZTogJ3N0cmluZycsXG5cbiAgICBwcmlvcml0eTogMlxuXG4gIH07XG5cbiAgdmFyIFZhbGlkYXRvclJlZ2lzdHJ5ID0gZnVuY3Rpb24gVmFsaWRhdG9yUmVnaXN0cnkodmFsaWRhdG9ycywgY2F0YWxvZykge1xuICAgIHRoaXMuX19jbGFzc19fID0gJ1ZhbGlkYXRvclJlZ2lzdHJ5JztcblxuICAgIC8vIERlZmF1bHQgUGFyc2xleSBsb2NhbGUgaXMgZW5cbiAgICB0aGlzLmxvY2FsZSA9ICdlbic7XG5cbiAgICB0aGlzLmluaXQodmFsaWRhdG9ycyB8fCB7fSwgY2F0YWxvZyB8fCB7fSk7XG4gIH07XG5cbiAgdmFyIHR5cGVUZXN0ZXJzID0ge1xuICAgIGVtYWlsOiAvXigoKFthLXpBLVpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpBLVpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpBLVpdfFxcZHwtfF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC8sXG5cbiAgICAvLyBGb2xsb3cgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjZmxvYXRpbmctcG9pbnQtbnVtYmVyc1xuICAgIG51bWJlcjogL14tPyhcXGQqXFwuKT9cXGQrKGVbLStdP1xcZCspPyQvaSxcblxuICAgIGludGVnZXI6IC9eLT9cXGQrJC8sXG5cbiAgICBkaWdpdHM6IC9eXFxkKyQvLFxuXG4gICAgYWxwaGFudW06IC9eXFx3KyQvaSxcblxuICAgIGRhdGU6IHtcbiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlLmRhdGUodmFsdWUpICE9PSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cmw6IG5ldyBSZWdFeHAoXCJeXCIgK1xuICAgIC8vIHByb3RvY29sIGlkZW50aWZpZXJcbiAgICBcIig/Oig/Omh0dHBzP3xmdHApOi8vKT9cIiArIC8vICoqIG1vZDogbWFrZSBzY2hlbWUgb3B0aW9uYWxcbiAgICAvLyB1c2VyOnBhc3MgYXV0aGVudGljYXRpb25cbiAgICBcIig/OlxcXFxTKyg/OjpcXFxcUyopP0ApP1wiICsgXCIoPzpcIiArXG4gICAgLy8gSVAgYWRkcmVzcyBleGNsdXNpb25cbiAgICAvLyBwcml2YXRlICYgbG9jYWwgbmV0d29ya3NcbiAgICAvLyBcIig/ISg/OjEwfDEyNykoPzpcXFxcLlxcXFxkezEsM30pezN9KVwiICsgICAvLyAqKiBtb2Q6IGFsbG93IGxvY2FsIG5ldHdvcmtzXG4gICAgLy8gXCIoPyEoPzoxNjlcXFxcLjI1NHwxOTJcXFxcLjE2OCkoPzpcXFxcLlxcXFxkezEsM30pezJ9KVwiICsgIC8vICoqIG1vZDogYWxsb3cgbG9jYWwgbmV0d29ya3NcbiAgICAvLyBcIig/ITE3MlxcXFwuKD86MVs2LTldfDJcXFxcZHwzWzAtMV0pKD86XFxcXC5cXFxcZHsxLDN9KXsyfSlcIiArICAvLyAqKiBtb2Q6IGFsbG93IGxvY2FsIG5ldHdvcmtzXG4gICAgLy8gSVAgYWRkcmVzcyBkb3R0ZWQgbm90YXRpb24gb2N0ZXRzXG4gICAgLy8gZXhjbHVkZXMgbG9vcGJhY2sgbmV0d29yayAwLjAuMC4wXG4gICAgLy8gZXhjbHVkZXMgcmVzZXJ2ZWQgc3BhY2UgPj0gMjI0LjAuMC4wXG4gICAgLy8gZXhjbHVkZXMgbmV0d29yayAmIGJyb2FjYXN0IGFkZHJlc3Nlc1xuICAgIC8vIChmaXJzdCAmIGxhc3QgSVAgYWRkcmVzcyBvZiBlYWNoIGNsYXNzKVxuICAgIFwiKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswMV1cXFxcZHwyMlswLTNdKVwiICsgXCIoPzpcXFxcLig/OjE/XFxcXGR7MSwyfXwyWzAtNF1cXFxcZHwyNVswLTVdKSl7Mn1cIiArIFwiKD86XFxcXC4oPzpbMS05XVxcXFxkP3wxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTRdKSlcIiArIFwifFwiICtcbiAgICAvLyBob3N0IG5hbWVcbiAgICAnKD86KD86W2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspJyArXG4gICAgLy8gZG9tYWluIG5hbWVcbiAgICAnKD86XFxcXC4oPzpbYS16QS1aXFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tKikqW2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykqJyArXG4gICAgLy8gVExEIGlkZW50aWZpZXJcbiAgICAnKD86XFxcXC4oPzpbYS16QS1aXFxcXHUwMGExLVxcXFx1ZmZmZl17Mix9KSknICsgXCIpXCIgK1xuICAgIC8vIHBvcnQgbnVtYmVyXG4gICAgXCIoPzo6XFxcXGR7Miw1fSk/XCIgK1xuICAgIC8vIHJlc291cmNlIHBhdGhcbiAgICBcIig/Oi9cXFxcUyopP1wiICsgXCIkXCIpXG4gIH07XG4gIHR5cGVUZXN0ZXJzLnJhbmdlID0gdHlwZVRlc3RlcnMubnVtYmVyO1xuXG4gIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDQ1NDU2MC84Mjc5XG4gIHZhciBkZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhudW0pIHtcbiAgICB2YXIgbWF0Y2ggPSAoJycgKyBudW0pLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoMCxcbiAgICAvLyBOdW1iZXIgb2YgZGlnaXRzIHJpZ2h0IG9mIGRlY2ltYWwgcG9pbnQuXG4gICAgKG1hdGNoWzFdID8gbWF0Y2hbMV0ubGVuZ3RoIDogMCkgLSAoXG4gICAgLy8gQWRqdXN0IGZvciBzY2llbnRpZmljIG5vdGF0aW9uLlxuICAgIG1hdGNoWzJdID8gK21hdGNoWzJdIDogMCkpO1xuICB9O1xuXG4gIC8vIHBhcnNlQXJndW1lbnRzKCdudW1iZXInLCBbJzEnLCAnMiddKSA9PiBbMSwgMl1cbiAgdmFyIFZhbGlkYXRvclJlZ2lzdHJ5X19wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlZ2lzdHJ5X19wYXJzZUFyZ3VtZW50cyh0eXBlLCBhcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MubWFwKFV0aWxzLnBhcnNlW3R5cGVdKTtcbiAgfTtcbiAgLy8gb3BlcmF0b3JUb1ZhbGlkYXRvciByZXR1cm5zIGEgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgYW4gb3BlcmF0b3IgZnVuY3Rpb24sIGFwcGxpZWQgdG8gdGhlIGdpdmVuIHR5cGVcbiAgdmFyIFZhbGlkYXRvclJlZ2lzdHJ5X19vcGVyYXRvclRvVmFsaWRhdG9yID0gZnVuY3Rpb24gVmFsaWRhdG9yUmVnaXN0cnlfX29wZXJhdG9yVG9WYWxpZGF0b3IodHlwZSwgb3BlcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVxdWlyZW1lbnRzQW5kSW5wdXQgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlcXVpcmVtZW50c0FuZElucHV0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmVxdWlyZW1lbnRzQW5kSW5wdXQucG9wKCk7IC8vIEdldCByaWQgb2YgYGlucHV0YCBhcmd1bWVudFxuICAgICAgcmV0dXJuIG9wZXJhdG9yLmFwcGx5KHVuZGVmaW5lZCwgW3ZhbHVlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KFZhbGlkYXRvclJlZ2lzdHJ5X19wYXJzZUFyZ3VtZW50cyh0eXBlLCByZXF1aXJlbWVudHNBbmRJbnB1dCkpKSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgVmFsaWRhdG9yUmVnaXN0cnlfX2NvbXBhcmlzb25PcGVyYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlZ2lzdHJ5X19jb21wYXJpc29uT3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWRhdGVEYXRlOiBWYWxpZGF0b3JSZWdpc3RyeV9fb3BlcmF0b3JUb1ZhbGlkYXRvcignZGF0ZScsIG9wZXJhdG9yKSxcbiAgICAgIHZhbGlkYXRlTnVtYmVyOiBWYWxpZGF0b3JSZWdpc3RyeV9fb3BlcmF0b3JUb1ZhbGlkYXRvcignbnVtYmVyJywgb3BlcmF0b3IpLFxuICAgICAgcmVxdWlyZW1lbnRUeXBlOiBvcGVyYXRvci5sZW5ndGggPD0gMiA/ICdzdHJpbmcnIDogWydzdHJpbmcnLCAnc3RyaW5nJ10sIC8vIFN1cHBvcnQgb3BlcmF0b3JzIHdpdGggYSAxIG9yIDIgcmVxdWlyZW1lbnQocylcbiAgICAgIHByaW9yaXR5OiAzMFxuICAgIH07XG4gIH07XG5cbiAgVmFsaWRhdG9yUmVnaXN0cnkucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodmFsaWRhdG9ycywgY2F0YWxvZykge1xuICAgICAgdGhpcy5jYXRhbG9nID0gY2F0YWxvZztcbiAgICAgIC8vIENvcHkgcHJvdG90eXBlJ3MgdmFsaWRhdG9yczpcbiAgICAgIHRoaXMudmFsaWRhdG9ycyA9IF9leHRlbmRzKHt9LCB0aGlzLnZhbGlkYXRvcnMpO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHZhbGlkYXRvcnMpIHRoaXMuYWRkVmFsaWRhdG9yKG5hbWUsIHZhbGlkYXRvcnNbbmFtZV0uZm4sIHZhbGlkYXRvcnNbbmFtZV0ucHJpb3JpdHkpO1xuXG4gICAgICB3aW5kb3cuUGFyc2xleS50cmlnZ2VyKCdwYXJzbGV5OnZhbGlkYXRvcjppbml0Jyk7XG4gICAgfSxcblxuICAgIC8vIFNldCBuZXcgbWVzc2FnZXMgbG9jYWxlIGlmIHdlIGhhdmUgZGljdGlvbmFyeSBsb2FkZWQgaW4gUGFyc2xleUNvbmZpZy5pMThuXG4gICAgc2V0TG9jYWxlOiBmdW5jdGlvbiBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLmNhdGFsb2dbbG9jYWxlXSkgdGhyb3cgbmV3IEVycm9yKGxvY2FsZSArICcgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgY2F0YWxvZycpO1xuXG4gICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG5ldyBtZXNzYWdlcyBjYXRhbG9nIGZvciBhIGdpdmVuIGxvY2FsZS4gU2V0IGxvY2FsZSBmb3IgdGhpcyBjYXRhbG9nIGlmIHNldCA9PT0gYHRydWVgXG4gICAgYWRkQ2F0YWxvZzogZnVuY3Rpb24gYWRkQ2F0YWxvZyhsb2NhbGUsIG1lc3NhZ2VzLCBzZXQpIHtcbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG1lc3NhZ2VzKSB0aGlzLmNhdGFsb2dbbG9jYWxlXSA9IG1lc3NhZ2VzO1xuXG4gICAgICBpZiAodHJ1ZSA9PT0gc2V0KSByZXR1cm4gdGhpcy5zZXRMb2NhbGUobG9jYWxlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHNwZWNpZmljIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29uc3RyYWludCBpbiBhIGdpdmVuIGxvY2FsZVxuICAgIGFkZE1lc3NhZ2U6IGZ1bmN0aW9uIGFkZE1lc3NhZ2UobG9jYWxlLCBuYW1lLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLmNhdGFsb2dbbG9jYWxlXSkgdGhpcy5jYXRhbG9nW2xvY2FsZV0gPSB7fTtcblxuICAgICAgdGhpcy5jYXRhbG9nW2xvY2FsZV1bbmFtZV0gPSBtZXNzYWdlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIG1lc3NhZ2VzIGZvciBhIGdpdmVuIGxvY2FsZVxuICAgIGFkZE1lc3NhZ2VzOiBmdW5jdGlvbiBhZGRNZXNzYWdlcyhsb2NhbGUsIG5hbWVNZXNzYWdlT2JqZWN0KSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG5hbWVNZXNzYWdlT2JqZWN0KSB0aGlzLmFkZE1lc3NhZ2UobG9jYWxlLCBuYW1lLCBuYW1lTWVzc2FnZU9iamVjdFtuYW1lXSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBuZXcgdmFsaWRhdG9yXG4gICAgLy9cbiAgICAvLyAgICBhZGRWYWxpZGF0b3IoJ2N1c3RvbScsIHtcbiAgICAvLyAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiBbJ2ludGVnZXInLCAnaW50ZWdlciddLFxuICAgIC8vICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24odmFsdWUsIGZyb20sIHRvKSB7fSxcbiAgICAvLyAgICAgICAgcHJpb3JpdHk6IDIyLFxuICAgIC8vICAgICAgICBtZXNzYWdlczoge1xuICAgIC8vICAgICAgICAgIGVuOiBcIkhleSwgdGhhdCdzIG5vIGdvb2RcIixcbiAgICAvLyAgICAgICAgICBmcjogXCJBeWUgYXllLCBwYXMgYm9uIGR1IHRvdXRcIixcbiAgICAvLyAgICAgICAgfVxuICAgIC8vICAgIH0pXG4gICAgLy9cbiAgICAvLyBPbGQgQVBJIHdhcyBhZGRWYWxpZGF0b3IobmFtZSwgZnVuY3Rpb24sIHByaW9yaXR5KVxuICAgIC8vXG4gICAgYWRkVmFsaWRhdG9yOiBmdW5jdGlvbiBhZGRWYWxpZGF0b3IobmFtZSwgYXJnMSwgYXJnMikge1xuICAgICAgaWYgKHRoaXMudmFsaWRhdG9yc1tuYW1lXSkgVXRpbHMud2FybignVmFsaWRhdG9yIFwiJyArIG5hbWUgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkLicpO2Vsc2UgaWYgKERlZmF1bHRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIFV0aWxzLndhcm4oJ1wiJyArIG5hbWUgKyAnXCIgaXMgYSByZXN0cmljdGVkIGtleXdvcmQgYW5kIGlzIG5vdCBhIHZhbGlkIHZhbGlkYXRvciBuYW1lLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VmFsaWRhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGhhc1ZhbGlkYXRvcjogZnVuY3Rpb24gaGFzVmFsaWRhdG9yKG5hbWUpIHtcbiAgICAgIHJldHVybiAhIXRoaXMudmFsaWRhdG9yc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmFsaWRhdG9yOiBmdW5jdGlvbiB1cGRhdGVWYWxpZGF0b3IobmFtZSwgYXJnMSwgYXJnMikge1xuICAgICAgaWYgKCF0aGlzLnZhbGlkYXRvcnNbbmFtZV0pIHtcbiAgICAgICAgVXRpbHMud2FybignVmFsaWRhdG9yIFwiJyArIG5hbWUgKyAnXCIgaXMgbm90IGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmFsaWRhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VmFsaWRhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIHJlbW92ZVZhbGlkYXRvcjogZnVuY3Rpb24gcmVtb3ZlVmFsaWRhdG9yKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy52YWxpZGF0b3JzW25hbWVdKSBVdGlscy53YXJuKCdWYWxpZGF0b3IgXCInICsgbmFtZSArICdcIiBpcyBub3QgZGVmaW5lZC4nKTtcblxuICAgICAgZGVsZXRlIHRoaXMudmFsaWRhdG9yc1tuYW1lXTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zZXRWYWxpZGF0b3I6IGZ1bmN0aW9uIF9zZXRWYWxpZGF0b3IobmFtZSwgdmFsaWRhdG9yLCBwcmlvcml0eSkge1xuICAgICAgaWYgKCdvYmplY3QnICE9PSB0eXBlb2YgdmFsaWRhdG9yKSB7XG4gICAgICAgIC8vIE9sZCBzdHlsZSB2YWxpZGF0b3IsIHdpdGggYGZuYCBhbmQgYHByaW9yaXR5YFxuICAgICAgICB2YWxpZGF0b3IgPSB7XG4gICAgICAgICAgZm46IHZhbGlkYXRvcixcbiAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsaWRhdG9yLnZhbGlkYXRlKSB7XG4gICAgICAgIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IodmFsaWRhdG9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdG9yc1tuYW1lXSA9IHZhbGlkYXRvcjtcblxuICAgICAgZm9yICh2YXIgbG9jYWxlIGluIHZhbGlkYXRvci5tZXNzYWdlcyB8fCB7fSkgdGhpcy5hZGRNZXNzYWdlKGxvY2FsZSwgbmFtZSwgdmFsaWRhdG9yLm1lc3NhZ2VzW2xvY2FsZV0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoY29uc3RyYWludCkge1xuICAgICAgdmFyIG1lc3NhZ2U7XG5cbiAgICAgIC8vIFR5cGUgY29uc3RyYWludHMgYXJlIGEgYml0IGRpZmZlcmVudCwgd2UgaGF2ZSB0byBtYXRjaCB0aGVpciByZXF1aXJlbWVudHMgdG9vIHRvIGZpbmQgcmlnaHQgZXJyb3IgbWVzc2FnZVxuICAgICAgaWYgKCd0eXBlJyA9PT0gY29uc3RyYWludC5uYW1lKSB7XG4gICAgICAgIHZhciB0eXBlTWVzc2FnZXMgPSB0aGlzLmNhdGFsb2dbdGhpcy5sb2NhbGVdW2NvbnN0cmFpbnQubmFtZV0gfHwge307XG4gICAgICAgIG1lc3NhZ2UgPSB0eXBlTWVzc2FnZXNbY29uc3RyYWludC5yZXF1aXJlbWVudHNdO1xuICAgICAgfSBlbHNlIG1lc3NhZ2UgPSB0aGlzLmZvcm1hdE1lc3NhZ2UodGhpcy5jYXRhbG9nW3RoaXMubG9jYWxlXVtjb25zdHJhaW50Lm5hbWVdLCBjb25zdHJhaW50LnJlcXVpcmVtZW50cyk7XG5cbiAgICAgIHJldHVybiBtZXNzYWdlIHx8IHRoaXMuY2F0YWxvZ1t0aGlzLmxvY2FsZV0uZGVmYXVsdE1lc3NhZ2UgfHwgdGhpcy5jYXRhbG9nLmVuLmRlZmF1bHRNZXNzYWdlO1xuICAgIH0sXG5cbiAgICAvLyBLaW5kIG9mIGxpZ2h0IGBzcHJpbnRmKClgIGltcGxlbWVudGF0aW9uXG4gICAgZm9ybWF0TWVzc2FnZTogZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShzdHJpbmcsIHBhcmFtZXRlcnMpIHtcbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwYXJhbWV0ZXJzKSBzdHJpbmcgPSB0aGlzLmZvcm1hdE1lc3NhZ2Uoc3RyaW5nLCBwYXJhbWV0ZXJzW2ldKTtcblxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3N0cmluZycgPT09IHR5cGVvZiBzdHJpbmcgPyBzdHJpbmcucmVwbGFjZSgvJXMvaSwgcGFyYW1ldGVycykgOiAnJztcbiAgICB9LFxuXG4gICAgLy8gSGVyZSBpcyB0aGUgUGFyc2xleSBkZWZhdWx0IHZhbGlkYXRvcnMgbGlzdC5cbiAgICAvLyBBIHZhbGlkYXRvciBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGtleSB2YWx1ZXM6XG4gICAgLy8gIC0gcHJpb3JpdHk6IGFuIGludGVnZXJcbiAgICAvLyAgLSByZXF1aXJlbWVudDogJ3N0cmluZycgKGRlZmF1bHQpLCAnaW50ZWdlcicsICdudW1iZXInLCAncmVnZXhwJyBvciBhbiBBcnJheSBvZiB0aGVzZVxuICAgIC8vICAtIHZhbGlkYXRlU3RyaW5nLCB2YWxpZGF0ZU11bHRpcGxlLCB2YWxpZGF0ZU51bWJlcjogZnVuY3Rpb25zIHJldHVybmluZyBgdHJ1ZWAsIGBmYWxzZWAgb3IgYSBwcm9taXNlXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgYSB2YWxpZGF0b3IgY2FuIGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHN1Y2ggYW4gb2JqZWN0XG4gICAgLy9cbiAgICB2YWxpZGF0b3JzOiB7XG4gICAgICBub3RibGFuazoge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gKC9cXFMvLnRlc3QodmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpb3JpdHk6IDJcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDoge1xuICAgICAgICB2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlKHZhbHVlcykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuICgvXFxTLy50ZXN0KHZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiA1MTJcbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgICB2YXIgX3JlZiRzdGVwID0gX3JlZi5zdGVwO1xuICAgICAgICAgIHZhciBzdGVwID0gX3JlZiRzdGVwID09PSB1bmRlZmluZWQgPyAnYW55JyA6IF9yZWYkc3RlcDtcbiAgICAgICAgICB2YXIgX3JlZiRiYXNlID0gX3JlZi5iYXNlO1xuICAgICAgICAgIHZhciBiYXNlID0gX3JlZiRiYXNlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRiYXNlO1xuXG4gICAgICAgICAgdmFyIHRlc3RlciA9IHR5cGVUZXN0ZXJzW3R5cGVdO1xuICAgICAgICAgIGlmICghdGVzdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRvciB0eXBlIGAnICsgdHlwZSArICdgIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0ZXN0ZXIudGVzdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIGlmICghL15hbnkkL2kudGVzdChzdGVwIHx8ICcnKSkge1xuICAgICAgICAgICAgICB2YXIgbmIgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBNYXRoLm1heChkZWNpbWFsUGxhY2VzKHN0ZXApLCBkZWNpbWFsUGxhY2VzKGJhc2UpKTtcbiAgICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZXMobmIpID4gZGVjaW1hbHMpIC8vIFZhbHVlIGNhbid0IGhhdmUgdG9vIG1hbnkgZGVjaW1hbHNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIC8vIEJlIGNhcmVmdWwgb2Ygcm91bmRpbmcgZXJyb3JzIGJ5IHVzaW5nIGludGVnZXJzLlxuICAgICAgICAgICAgICB2YXIgdG9JbnQgPSBmdW5jdGlvbiB0b0ludChmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZiAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoKHRvSW50KG5iKSAtIHRvSW50KGJhc2UpKSAlIHRvSW50KHN0ZXApICE9IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVtZW50VHlwZToge1xuICAgICAgICAgICcnOiAnc3RyaW5nJyxcbiAgICAgICAgICBzdGVwOiAnc3RyaW5nJyxcbiAgICAgICAgICBiYXNlOiAnbnVtYmVyJ1xuICAgICAgICB9LFxuICAgICAgICBwcmlvcml0eTogMjU2XG4gICAgICB9LFxuICAgICAgcGF0dGVybjoge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIHJlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVtZW50VHlwZTogJ3JlZ2V4cCcsXG4gICAgICAgIHByaW9yaXR5OiA2NFxuICAgICAgfSxcbiAgICAgIG1pbmxlbmd0aDoge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIHJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgIHByaW9yaXR5OiAzMFxuICAgICAgfSxcbiAgICAgIG1heGxlbmd0aDoge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIHJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgIHByaW9yaXR5OiAzMFxuICAgICAgfSxcbiAgICAgIGxlbmd0aDoge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSBtaW4gJiYgdmFsdWUubGVuZ3RoIDw9IG1heDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiBbJ2ludGVnZXInLCAnaW50ZWdlciddLFxuICAgICAgICBwcmlvcml0eTogMzBcbiAgICAgIH0sXG4gICAgICBtaW5jaGVjazoge1xuICAgICAgICB2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlKHZhbHVlcywgcmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgIHByaW9yaXR5OiAzMFxuICAgICAgfSxcbiAgICAgIG1heGNoZWNrOiB7XG4gICAgICAgIHZhbGlkYXRlTXVsdGlwbGU6IGZ1bmN0aW9uIHZhbGlkYXRlTXVsdGlwbGUodmFsdWVzLCByZXF1aXJlbWVudCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoIDw9IHJlcXVpcmVtZW50O1xuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlbWVudFR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgcHJpb3JpdHk6IDMwXG4gICAgICB9LFxuICAgICAgY2hlY2s6IHtcbiAgICAgICAgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZSh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPj0gbWluICYmIHZhbHVlcy5sZW5ndGggPD0gbWF4O1xuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlbWVudFR5cGU6IFsnaW50ZWdlcicsICdpbnRlZ2VyJ10sXG4gICAgICAgIHByaW9yaXR5OiAzMFxuICAgICAgfSxcbiAgICAgIG1pbjogVmFsaWRhdG9yUmVnaXN0cnlfX2NvbXBhcmlzb25PcGVyYXRvcihmdW5jdGlvbiAodmFsdWUsIHJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSByZXF1aXJlbWVudDtcbiAgICAgIH0pLFxuICAgICAgbWF4OiBWYWxpZGF0b3JSZWdpc3RyeV9fY29tcGFyaXNvbk9wZXJhdG9yKGZ1bmN0aW9uICh2YWx1ZSwgcmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHJlcXVpcmVtZW50O1xuICAgICAgfSksXG4gICAgICByYW5nZTogVmFsaWRhdG9yUmVnaXN0cnlfX2NvbXBhcmlzb25PcGVyYXRvcihmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4O1xuICAgICAgfSksXG4gICAgICBlcXVhbHRvOiB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgcmVmT3JWYWx1ZSkge1xuICAgICAgICAgIHZhciAkcmVmZXJlbmNlID0gJChyZWZPclZhbHVlKTtcbiAgICAgICAgICBpZiAoJHJlZmVyZW5jZS5sZW5ndGgpIHJldHVybiB2YWx1ZSA9PT0gJHJlZmVyZW5jZS52YWwoKTtlbHNlIHJldHVybiB2YWx1ZSA9PT0gcmVmT3JWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpb3JpdHk6IDI1NlxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgVUkgPSB7fTtcblxuICB2YXIgZGlmZlJlc3VsdHMgPSBmdW5jdGlvbiBkaWZmUmVzdWx0cyhuZXdSZXN1bHQsIG9sZFJlc3VsdCwgZGVlcCkge1xuICAgIHZhciBhZGRlZCA9IFtdO1xuICAgIHZhciBrZXB0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1Jlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2xkUmVzdWx0Lmxlbmd0aDsgaisrKSBpZiAobmV3UmVzdWx0W2ldLmFzc2VydC5uYW1lID09PSBvbGRSZXN1bHRbal0uYXNzZXJ0Lm5hbWUpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kKSBrZXB0LnB1c2gobmV3UmVzdWx0W2ldKTtlbHNlIGFkZGVkLnB1c2gobmV3UmVzdWx0W2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2VwdDoga2VwdCxcbiAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgIHJlbW92ZWQ6ICFkZWVwID8gZGlmZlJlc3VsdHMob2xkUmVzdWx0LCBuZXdSZXN1bHQsIHRydWUpLmFkZGVkIDogW11cbiAgICB9O1xuICB9O1xuXG4gIFVJLkZvcm0gPSB7XG5cbiAgICBfYWN0dWFsaXplVHJpZ2dlcnM6IGZ1bmN0aW9uIF9hY3R1YWxpemVUcmlnZ2VycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdzdWJtaXQuUGFyc2xleScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgX3RoaXMyLm9uU3VibWl0VmFsaWRhdGUoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suUGFyc2xleScsIFV0aWxzLl9TdWJtaXRTZWxlY3RvciwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBfdGhpczIub25TdWJtaXRCdXR0b24oZXZ0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVSSBjb3VsZCBiZSBkaXNhYmxlZFxuICAgICAgaWYgKGZhbHNlID09PSB0aGlzLm9wdGlvbnMudWlFbmFibGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnLCAnJyk7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIHRoaXMuX2ZvY3VzZWRGaWVsZCA9IG51bGw7XG5cbiAgICAgIGlmICh0cnVlID09PSB0aGlzLnZhbGlkYXRpb25SZXN1bHQgfHwgJ25vbmUnID09PSB0aGlzLm9wdGlvbnMuZm9jdXMpIHJldHVybiBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICBpZiAodHJ1ZSAhPT0gZmllbGQudmFsaWRhdGlvblJlc3VsdCAmJiBmaWVsZC52YWxpZGF0aW9uUmVzdWx0Lmxlbmd0aCA+IDAgJiYgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBmaWVsZC5vcHRpb25zLm5vRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9mb2N1c2VkRmllbGQgPSBmaWVsZC4kZWxlbWVudDtcbiAgICAgICAgICBpZiAoJ2ZpcnN0JyA9PT0gdGhpcy5vcHRpb25zLmZvY3VzKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVsbCA9PT0gdGhpcy5fZm9jdXNlZEZpZWxkKSByZXR1cm4gbnVsbDtcblxuICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWRGaWVsZC5mb2N1cygpO1xuICAgIH0sXG5cbiAgICBfZGVzdHJveVVJOiBmdW5jdGlvbiBfZGVzdHJveVVJKCkge1xuICAgICAgLy8gUmVzZXQgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5QYXJzbGV5Jyk7XG4gICAgfVxuXG4gIH07XG5cbiAgVUkuRmllbGQgPSB7XG5cbiAgICBfcmVmbG93VUk6IGZ1bmN0aW9uIF9yZWZsb3dVSSgpIHtcbiAgICAgIHRoaXMuX2J1aWxkVUkoKTtcblxuICAgICAgLy8gSWYgdGhpcyBmaWVsZCBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIFVJIGRvbid0IGJvdGhlciBkb2luZyBzb21ldGhpbmdcbiAgICAgIGlmICghdGhpcy5fdWkpIHJldHVybjtcblxuICAgICAgLy8gRGlmZiBiZXR3ZWVuIHR3byB2YWxpZGF0aW9uIHJlc3VsdHNcbiAgICAgIHZhciBkaWZmID0gZGlmZlJlc3VsdHModGhpcy52YWxpZGF0aW9uUmVzdWx0LCB0aGlzLl91aS5sYXN0VmFsaWRhdGlvblJlc3VsdCk7XG5cbiAgICAgIC8vIFRoZW4gc3RvcmUgY3VycmVudCB2YWxpZGF0aW9uIHJlc3VsdCBmb3IgbmV4dCByZWZsb3dcbiAgICAgIHRoaXMuX3VpLmxhc3RWYWxpZGF0aW9uUmVzdWx0ID0gdGhpcy52YWxpZGF0aW9uUmVzdWx0O1xuXG4gICAgICAvLyBIYW5kbGUgdmFsaWQgLyBpbnZhbGlkIC8gbm9uZSBmaWVsZCBjbGFzc1xuICAgICAgdGhpcy5fbWFuYWdlU3RhdHVzQ2xhc3MoKTtcblxuICAgICAgLy8gQWRkLCByZW1vdmUsIHVwZGF0ZWQgZXJyb3JzIG1lc3NhZ2VzXG4gICAgICB0aGlzLl9tYW5hZ2VFcnJvcnNNZXNzYWdlcyhkaWZmKTtcblxuICAgICAgLy8gVHJpZ2dlcnMgaW1wbFxuICAgICAgdGhpcy5fYWN0dWFsaXplVHJpZ2dlcnMoKTtcblxuICAgICAgLy8gSWYgZmllbGQgaXMgbm90IHZhbGlkIGZvciB0aGUgZmlyc3QgdGltZSwgYmluZCBrZXl1cCB0cmlnZ2VyIHRvIGVhc2UgVVggYW5kIHF1aWNrbHkgaW5mb3JtIHVzZXJcbiAgICAgIGlmICgoZGlmZi5rZXB0Lmxlbmd0aCB8fCBkaWZmLmFkZGVkLmxlbmd0aCkgJiYgIXRoaXMuX2ZhaWxlZE9uY2UpIHtcbiAgICAgICAgdGhpcy5fZmFpbGVkT25jZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FjdHVhbGl6ZVRyaWdnZXJzKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgZmllbGQncyBlcnJvciBtZXNzYWdlKHMpXG4gICAgZ2V0RXJyb3JzTWVzc2FnZXM6IGZ1bmN0aW9uIGdldEVycm9yc01lc3NhZ2VzKCkge1xuICAgICAgLy8gTm8gZXJyb3IgbWVzc2FnZSwgZmllbGQgaXMgdmFsaWRcbiAgICAgIGlmICh0cnVlID09PSB0aGlzLnZhbGlkYXRpb25SZXN1bHQpIHJldHVybiBbXTtcblxuICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWxpZGF0aW9uUmVzdWx0Lmxlbmd0aDsgaSsrKSBtZXNzYWdlcy5wdXNoKHRoaXMudmFsaWRhdGlvblJlc3VsdFtpXS5lcnJvck1lc3NhZ2UgfHwgdGhpcy5fZ2V0RXJyb3JNZXNzYWdlKHRoaXMudmFsaWRhdGlvblJlc3VsdFtpXS5hc3NlcnQpKTtcblxuICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH0sXG5cbiAgICAvLyBJdCdzIGEgZ29hbCBvZiBQYXJzbGV5IHRoYXQgdGhpcyBtZXRob2QgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIFsjMTA3M11cbiAgICBhZGRFcnJvcjogZnVuY3Rpb24gYWRkRXJyb3IobmFtZSkge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjIubWVzc2FnZTtcbiAgICAgIHZhciBhc3NlcnQgPSBfcmVmMi5hc3NlcnQ7XG4gICAgICB2YXIgX3JlZjIkdXBkYXRlQ2xhc3MgPSBfcmVmMi51cGRhdGVDbGFzcztcbiAgICAgIHZhciB1cGRhdGVDbGFzcyA9IF9yZWYyJHVwZGF0ZUNsYXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjIkdXBkYXRlQ2xhc3M7XG5cbiAgICAgIHRoaXMuX2J1aWxkVUkoKTtcbiAgICAgIHRoaXMuX2FkZEVycm9yKG5hbWUsIHsgbWVzc2FnZTogbWVzc2FnZSwgYXNzZXJ0OiBhc3NlcnQgfSk7XG5cbiAgICAgIGlmICh1cGRhdGVDbGFzcykgdGhpcy5fZXJyb3JDbGFzcygpO1xuICAgIH0sXG5cbiAgICAvLyBJdCdzIGEgZ29hbCBvZiBQYXJzbGV5IHRoYXQgdGhpcyBtZXRob2QgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIFsjMTA3M11cbiAgICB1cGRhdGVFcnJvcjogZnVuY3Rpb24gdXBkYXRlRXJyb3IobmFtZSkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjMubWVzc2FnZTtcbiAgICAgIHZhciBhc3NlcnQgPSBfcmVmMy5hc3NlcnQ7XG4gICAgICB2YXIgX3JlZjMkdXBkYXRlQ2xhc3MgPSBfcmVmMy51cGRhdGVDbGFzcztcbiAgICAgIHZhciB1cGRhdGVDbGFzcyA9IF9yZWYzJHVwZGF0ZUNsYXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjMkdXBkYXRlQ2xhc3M7XG5cbiAgICAgIHRoaXMuX2J1aWxkVUkoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUVycm9yKG5hbWUsIHsgbWVzc2FnZTogbWVzc2FnZSwgYXNzZXJ0OiBhc3NlcnQgfSk7XG5cbiAgICAgIGlmICh1cGRhdGVDbGFzcykgdGhpcy5fZXJyb3JDbGFzcygpO1xuICAgIH0sXG5cbiAgICAvLyBJdCdzIGEgZ29hbCBvZiBQYXJzbGV5IHRoYXQgdGhpcyBtZXRob2QgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkIFsjMTA3M11cbiAgICByZW1vdmVFcnJvcjogZnVuY3Rpb24gcmVtb3ZlRXJyb3IobmFtZSkge1xuICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBfcmVmNCR1cGRhdGVDbGFzcyA9IF9yZWY0LnVwZGF0ZUNsYXNzO1xuICAgICAgdmFyIHVwZGF0ZUNsYXNzID0gX3JlZjQkdXBkYXRlQ2xhc3MgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmNCR1cGRhdGVDbGFzcztcblxuICAgICAgdGhpcy5fYnVpbGRVSSgpO1xuICAgICAgdGhpcy5fcmVtb3ZlRXJyb3IobmFtZSk7XG5cbiAgICAgIC8vIGVkZ2UgY2FzZSBwb3NzaWJsZSBoZXJlOiByZW1vdmUgYSBzdGFuZGFyZCBQYXJzbGV5IGVycm9yIHRoYXQgaXMgc3RpbGwgZmFpbGluZyBpbiB0aGlzLnZhbGlkYXRpb25SZXN1bHRcbiAgICAgIC8vIGJ1dCBoaWdobHkgaW1wcm9iYWJsZSBjdXonIG1hbnVhbGx5IHJlbW92aW5nIGEgd2VsbCBQYXJzbGV5IGhhbmRsZWQgZXJyb3IgbWFrZXMgbm8gc2Vuc2UuXG4gICAgICBpZiAodXBkYXRlQ2xhc3MpIHRoaXMuX21hbmFnZVN0YXR1c0NsYXNzKCk7XG4gICAgfSxcblxuICAgIF9tYW5hZ2VTdGF0dXNDbGFzczogZnVuY3Rpb24gX21hbmFnZVN0YXR1c0NsYXNzKCkge1xuICAgICAgaWYgKHRoaXMuaGFzQ29uc3RyYWludHMoKSAmJiB0aGlzLm5lZWRzVmFsaWRhdGlvbigpICYmIHRydWUgPT09IHRoaXMudmFsaWRhdGlvblJlc3VsdCkgdGhpcy5fc3VjY2Vzc0NsYXNzKCk7ZWxzZSBpZiAodGhpcy52YWxpZGF0aW9uUmVzdWx0Lmxlbmd0aCA+IDApIHRoaXMuX2Vycm9yQ2xhc3MoKTtlbHNlIHRoaXMuX3Jlc2V0Q2xhc3MoKTtcbiAgICB9LFxuXG4gICAgX21hbmFnZUVycm9yc01lc3NhZ2VzOiBmdW5jdGlvbiBfbWFuYWdlRXJyb3JzTWVzc2FnZXMoZGlmZikge1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmVycm9yc01lc3NhZ2VzRGlzYWJsZWQpIHJldHVybjtcblxuICAgICAgLy8gQ2FzZSB3aGVyZSB3ZSBoYXZlIGVycm9yTWVzc2FnZSBvcHRpb24gdGhhdCBjb25maWd1cmUgYW4gdW5pcXVlIGZpZWxkIGVycm9yIG1lc3NhZ2UsIHJlZ2FyZGxlc3MgZmFpbGluZyB2YWxpZGF0b3JzXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGlmIChkaWZmLmFkZGVkLmxlbmd0aCB8fCBkaWZmLmtlcHQubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5faW5zZXJ0RXJyb3JXcmFwcGVyKCk7XG5cbiAgICAgICAgICBpZiAoMCA9PT0gdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIuZmluZCgnLnBhcnNsZXktY3VzdG9tLWVycm9yLW1lc3NhZ2UnKS5sZW5ndGgpIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLmFwcGVuZCgkKHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlKS5hZGRDbGFzcygncGFyc2xleS1jdXN0b20tZXJyb3ItbWVzc2FnZScpKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hZGRDbGFzcygnZmlsbGVkJykuZmluZCgnLnBhcnNsZXktY3VzdG9tLWVycm9yLW1lc3NhZ2UnKS5odG1sKHRoaXMub3B0aW9ucy5lcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnJlbW92ZUNsYXNzKCdmaWxsZWQnKS5maW5kKCcucGFyc2xleS1jdXN0b20tZXJyb3ItbWVzc2FnZScpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaG93LCBoaWRlLCB1cGRhdGUgZmFpbGluZyBjb25zdHJhaW50cyBtZXNzYWdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLnJlbW92ZWQubGVuZ3RoOyBpKyspIHRoaXMuX3JlbW92ZUVycm9yKGRpZmYucmVtb3ZlZFtpXS5hc3NlcnQubmFtZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkaWZmLmFkZGVkLmxlbmd0aDsgaSsrKSB0aGlzLl9hZGRFcnJvcihkaWZmLmFkZGVkW2ldLmFzc2VydC5uYW1lLCB7IG1lc3NhZ2U6IGRpZmYuYWRkZWRbaV0uZXJyb3JNZXNzYWdlLCBhc3NlcnQ6IGRpZmYuYWRkZWRbaV0uYXNzZXJ0IH0pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGlmZi5rZXB0Lmxlbmd0aDsgaSsrKSB0aGlzLl91cGRhdGVFcnJvcihkaWZmLmtlcHRbaV0uYXNzZXJ0Lm5hbWUsIHsgbWVzc2FnZTogZGlmZi5rZXB0W2ldLmVycm9yTWVzc2FnZSwgYXNzZXJ0OiBkaWZmLmtlcHRbaV0uYXNzZXJ0IH0pO1xuICAgIH0sXG5cbiAgICBfYWRkRXJyb3I6IGZ1bmN0aW9uIF9hZGRFcnJvcihuYW1lLCBfcmVmNSkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfcmVmNS5tZXNzYWdlO1xuICAgICAgdmFyIGFzc2VydCA9IF9yZWY1LmFzc2VydDtcblxuICAgICAgdGhpcy5faW5zZXJ0RXJyb3JXcmFwcGVyKCk7XG4gICAgICB0aGlzLl91aS4kZXJyb3JDbGFzc0hhbmRsZXIuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX3VpLmVycm9yc1dyYXBwZXJJZCk7XG4gICAgICB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hZGRDbGFzcygnZmlsbGVkJykuYXBwZW5kKCQodGhpcy5vcHRpb25zLmVycm9yVGVtcGxhdGUpLmFkZENsYXNzKCdwYXJzbGV5LScgKyBuYW1lKS5odG1sKG1lc3NhZ2UgfHwgdGhpcy5fZ2V0RXJyb3JNZXNzYWdlKGFzc2VydCkpKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVycm9yOiBmdW5jdGlvbiBfdXBkYXRlRXJyb3IobmFtZSwgX3JlZjYpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjYubWVzc2FnZTtcbiAgICAgIHZhciBhc3NlcnQgPSBfcmVmNi5hc3NlcnQ7XG5cbiAgICAgIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLmFkZENsYXNzKCdmaWxsZWQnKS5maW5kKCcucGFyc2xleS0nICsgbmFtZSkuaHRtbChtZXNzYWdlIHx8IHRoaXMuX2dldEVycm9yTWVzc2FnZShhc3NlcnQpKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUVycm9yOiBmdW5jdGlvbiBfcmVtb3ZlRXJyb3IobmFtZSkge1xuICAgICAgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnJlbW92ZUNsYXNzKCdmaWxsZWQnKS5maW5kKCcucGFyc2xleS0nICsgbmFtZSkucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIF9nZXRFcnJvck1lc3NhZ2U6IGZ1bmN0aW9uIF9nZXRFcnJvck1lc3NhZ2UoY29uc3RyYWludCkge1xuICAgICAgdmFyIGN1c3RvbUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UgPSBjb25zdHJhaW50Lm5hbWUgKyAnTWVzc2FnZSc7XG5cbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHRoaXMub3B0aW9uc1tjdXN0b21Db25zdHJhaW50RXJyb3JNZXNzYWdlXSkgcmV0dXJuIHdpbmRvdy5QYXJzbGV5LmZvcm1hdE1lc3NhZ2UodGhpcy5vcHRpb25zW2N1c3RvbUNvbnN0cmFpbnRFcnJvck1lc3NhZ2VdLCBjb25zdHJhaW50LnJlcXVpcmVtZW50cyk7XG5cbiAgICAgIHJldHVybiB3aW5kb3cuUGFyc2xleS5nZXRFcnJvck1lc3NhZ2UoY29uc3RyYWludCk7XG4gICAgfSxcblxuICAgIF9idWlsZFVJOiBmdW5jdGlvbiBfYnVpbGRVSSgpIHtcbiAgICAgIC8vIFVJIGNvdWxkIGJlIGFscmVhZHkgYnVpbHQgb3IgZGlzYWJsZWRcbiAgICAgIGlmICh0aGlzLl91aSB8fCBmYWxzZSA9PT0gdGhpcy5vcHRpb25zLnVpRW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICB2YXIgX3VpID0ge307XG5cbiAgICAgIC8vIEdpdmUgZmllbGQgaXRzIFBhcnNsZXkgaWQgaW4gRE9NXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5uYW1lc3BhY2UgKyAnaWQnLCB0aGlzLl9faWRfXyk7XG5cbiAgICAgIC8qKiBHZW5lcmF0ZSBpbXBvcnRhbnQgVUkgZWxlbWVudHMgYW5kIHN0b3JlIHRoZW0gaW4gdGhpcyAqKi9cbiAgICAgIC8vICRlcnJvckNsYXNzSGFuZGxlciBpcyB0aGUgJGVsZW1lbnQgdGhhdCB3b3VsIGhhdmUgcGFyc2xleS1lcnJvciBhbmQgcGFyc2xleS1zdWNjZXNzIGNsYXNzZXNcbiAgICAgIF91aS4kZXJyb3JDbGFzc0hhbmRsZXIgPSB0aGlzLl9tYW5hZ2VDbGFzc0hhbmRsZXIoKTtcblxuICAgICAgLy8gJGVycm9yc1dyYXBwZXIgaXMgYSBkaXYgdGhhdCB3b3VsZCBjb250YWluIHRoZSB2YXJpb3VzIGZpZWxkIGVycm9ycywgaXQgd2lsbCBiZSBhcHBlbmRlZCBpbnRvICRlcnJvcnNDb250YWluZXJcbiAgICAgIF91aS5lcnJvcnNXcmFwcGVySWQgPSAncGFyc2xleS1pZC0nICsgKHRoaXMub3B0aW9ucy5tdWx0aXBsZSA/ICdtdWx0aXBsZS0nICsgdGhpcy5vcHRpb25zLm11bHRpcGxlIDogdGhpcy5fX2lkX18pO1xuICAgICAgX3VpLiRlcnJvcnNXcmFwcGVyID0gJCh0aGlzLm9wdGlvbnMuZXJyb3JzV3JhcHBlcikuYXR0cignaWQnLCBfdWkuZXJyb3JzV3JhcHBlcklkKTtcblxuICAgICAgLy8gVmFsaWRhdGlvblJlc3VsdCBVSSBzdG9yYWdlIHRvIGRldGVjdCB3aGF0IGhhdmUgY2hhbmdlZCBid3QgdHdvIHZhbGlkYXRpb25zLCBhbmQgdXBkYXRlIERPTSBhY2NvcmRpbmdseVxuICAgICAgX3VpLmxhc3RWYWxpZGF0aW9uUmVzdWx0ID0gW107XG4gICAgICBfdWkudmFsaWRhdGlvbkluZm9ybWF0aW9uVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAvLyBTdG9yZSBpdCBpbiB0aGlzIGZvciBsYXRlclxuICAgICAgdGhpcy5fdWkgPSBfdWk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSB3aGljaCBlbGVtZW50IHdpbGwgaGF2ZSBgcGFyc2xleS1lcnJvcmAgYW5kIGBwYXJzbGV5LXN1Y2Nlc3NgIGNsYXNzZXNcbiAgICBfbWFuYWdlQ2xhc3NIYW5kbGVyOiBmdW5jdGlvbiBfbWFuYWdlQ2xhc3NIYW5kbGVyKCkge1xuICAgICAgLy8gQ2xhc3MgaGFuZGxlZCBjb3VsZCBhbHNvIGJlIGRldGVybWluZWQgYnkgZnVuY3Rpb24gZ2l2ZW4gaW4gUGFyc2xleSBvcHRpb25zXG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyICYmICQodGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcikubGVuZ3RoKSByZXR1cm4gJCh0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyKTtcblxuICAgICAgLy8gQ2xhc3MgaGFuZGxlZCBjb3VsZCBhbHNvIGJlIGRldGVybWluZWQgYnkgZnVuY3Rpb24gZ2l2ZW4gaW4gUGFyc2xleSBvcHRpb25zXG4gICAgICB2YXIgJGhhbmRsZXJGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5jbGFzc0hhbmRsZXI7XG5cbiAgICAgIC8vIEl0IG1pZ2h0IGFsc28gYmUgdGhlIGZ1bmN0aW9uIG5hbWUgb2YgYSBnbG9iYWwgZnVuY3Rpb25cbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMub3B0aW9ucy5jbGFzc0hhbmRsZXIgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHdpbmRvd1t0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyXSkgJGhhbmRsZXJGdW5jdGlvbiA9IHdpbmRvd1t0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyXTtcblxuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiAkaGFuZGxlckZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciAkaGFuZGxlciA9ICRoYW5kbGVyRnVuY3Rpb24uY2FsbCh0aGlzLCB0aGlzKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybmVkIGEgdmFsaWQgZXhpc3RpbmcgRE9NIGVsZW1lbnQsIGdvIGZvciBpdFxuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiAkaGFuZGxlciAmJiAkaGFuZGxlci5sZW5ndGgpIHJldHVybiAkaGFuZGxlcjtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiAkaGFuZGxlckZ1bmN0aW9uICYmICRoYW5kbGVyRnVuY3Rpb24gaW5zdGFuY2VvZiBqUXVlcnkgJiYgJGhhbmRsZXJGdW5jdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICRoYW5kbGVyRnVuY3Rpb247XG4gICAgICB9IGVsc2UgaWYgKCRoYW5kbGVyRnVuY3Rpb24pIHtcbiAgICAgICAgVXRpbHMud2FybignVGhlIGNsYXNzIGhhbmRsZXIgYCcgKyAkaGFuZGxlckZ1bmN0aW9uICsgJ2AgZG9lcyBub3QgZXhpc3QgaW4gRE9NIG5vciBhcyBhIGdsb2JhbCBKUyBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faW5wdXRIb2xkZXIoKTtcbiAgICB9LFxuXG4gICAgX2lucHV0SG9sZGVyOiBmdW5jdGlvbiBfaW5wdXRIb2xkZXIoKSB7XG4gICAgICAvLyBpZiBzaW1wbGUgZWxlbWVudCAoaW5wdXQsIHRleGF0cmVhLCBzZWxlY3QuLi4pIGl0IHdpbGwgcGVyZmVjdGx5IGhvc3QgdGhlIGNsYXNzZXMgYW5kIHByZWNlZGUgdGhlIGVycm9yIGNvbnRhaW5lclxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlwbGUgfHwgdGhpcy5lbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJykgcmV0dXJuIHRoaXMuJGVsZW1lbnQ7XG5cbiAgICAgIC8vIEJ1dCBpZiBtdWx0aXBsZSBlbGVtZW50IChyYWRpbywgY2hlY2tib3gpLCB0aGF0IHdvdWxkIGJlIHRoZWlyIHBhcmVudFxuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQucGFyZW50KCk7XG4gICAgfSxcblxuICAgIF9pbnNlcnRFcnJvcldyYXBwZXI6IGZ1bmN0aW9uIF9pbnNlcnRFcnJvcldyYXBwZXIoKSB7XG4gICAgICB2YXIgJGVycm9yc0NvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5lcnJvcnNDb250YWluZXI7XG5cbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaWYgYWxyZWFkeSBpbnNlcnRlZFxuICAgICAgaWYgKDAgIT09IHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnBhcmVudCgpLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnBhcmVudCgpO1xuXG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiAkZXJyb3JzQ29udGFpbmVyKSB7XG4gICAgICAgIGlmICgkKCRlcnJvcnNDb250YWluZXIpLmxlbmd0aCkgcmV0dXJuICQoJGVycm9yc0NvbnRhaW5lcikuYXBwZW5kKHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyKTtlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygd2luZG93WyRlcnJvcnNDb250YWluZXJdKSAkZXJyb3JzQ29udGFpbmVyID0gd2luZG93WyRlcnJvcnNDb250YWluZXJdO2Vsc2UgVXRpbHMud2FybignVGhlIGVycm9ycyBjb250YWluZXIgYCcgKyAkZXJyb3JzQ29udGFpbmVyICsgJ2AgZG9lcyBub3QgZXhpc3QgaW4gRE9NIG5vciBhcyBhIGdsb2JhbCBKUyBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mICRlcnJvcnNDb250YWluZXIpICRlcnJvcnNDb250YWluZXIgPSAkZXJyb3JzQ29udGFpbmVyLmNhbGwodGhpcywgdGhpcyk7XG5cbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mICRlcnJvcnNDb250YWluZXIgJiYgJGVycm9yc0NvbnRhaW5lci5sZW5ndGgpIHJldHVybiAkZXJyb3JzQ29udGFpbmVyLmFwcGVuZCh0aGlzLl91aS4kZXJyb3JzV3JhcHBlcik7XG5cbiAgICAgIHJldHVybiB0aGlzLl9pbnB1dEhvbGRlcigpLmFmdGVyKHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyKTtcbiAgICB9LFxuXG4gICAgX2FjdHVhbGl6ZVRyaWdnZXJzOiBmdW5jdGlvbiBfYWN0dWFsaXplVHJpZ2dlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyICR0b0JpbmQgPSB0aGlzLl9maW5kUmVsYXRlZCgpO1xuICAgICAgdmFyIHRyaWdnZXI7XG5cbiAgICAgIC8vIFJlbW92ZSBQYXJzbGV5IGV2ZW50cyBhbHJlYWR5IGJvdW5kIG9uIHRoaXMgZmllbGRcbiAgICAgICR0b0JpbmQub2ZmKCcuUGFyc2xleScpO1xuICAgICAgaWYgKHRoaXMuX2ZhaWxlZE9uY2UpICR0b0JpbmQub24oVXRpbHMubmFtZXNwYWNlRXZlbnRzKHRoaXMub3B0aW9ucy50cmlnZ2VyQWZ0ZXJGYWlsdXJlLCAnUGFyc2xleScpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5fdmFsaWRhdGVJZk5lZWRlZCgpO1xuICAgICAgfSk7ZWxzZSBpZiAodHJpZ2dlciA9IFV0aWxzLm5hbWVzcGFjZUV2ZW50cyh0aGlzLm9wdGlvbnMudHJpZ2dlciwgJ1BhcnNsZXknKSkge1xuICAgICAgICAkdG9CaW5kLm9uKHRyaWdnZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5fdmFsaWRhdGVJZk5lZWRlZChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdmFsaWRhdGVJZk5lZWRlZDogZnVuY3Rpb24gX3ZhbGlkYXRlSWZOZWVkZWQoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAvLyBGb3Iga2V5dXAsIGtleXByZXNzLCBrZXlkb3duLCBpbnB1dC4uLiBldmVudHMgdGhhdCBjb3VsZCBiZSBhIGxpdHRsZSBiaXQgb2JzdHJ1c2l2ZVxuICAgICAgLy8gZG8gbm90IHZhbGlkYXRlIGlmIHZhbCBsZW5ndGggPCBtaW4gdGhyZXNob2xkIG9uIGZpcnN0IHZhbGlkYXRpb24uIE9uY2UgZmllbGQgaGF2ZSBiZWVuIHZhbGlkYXRlZCBvbmNlIGFuZCBpbmZvXG4gICAgICAvLyBhYm91dCBzdWNjZXNzIG9yIGZhaWx1cmUgaGF2ZSBiZWVuIGRpc3BsYXllZCwgYWx3YXlzIHZhbGlkYXRlIHdpdGggdGhpcyB0cmlnZ2VyIHRvIHJlZmxlY3QgZXZlcnkgeWFsaWRhdGlvbiBjaGFuZ2UuXG4gICAgICBpZiAoZXZlbnQgJiYgL2tleXxpbnB1dC8udGVzdChldmVudC50eXBlKSkgaWYgKCEodGhpcy5fdWkgJiYgdGhpcy5fdWkudmFsaWRhdGlvbkluZm9ybWF0aW9uVmlzaWJsZSkgJiYgdGhpcy5nZXRWYWx1ZSgpLmxlbmd0aCA8PSB0aGlzLm9wdGlvbnMudmFsaWRhdGlvblRocmVzaG9sZCkgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlYm91bmNlKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fZGVib3VuY2VkKTtcbiAgICAgICAgdGhpcy5fZGVib3VuY2VkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQudmFsaWRhdGUoKTtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmRlYm91bmNlKTtcbiAgICAgIH0gZWxzZSB0aGlzLnZhbGlkYXRlKCk7XG4gICAgfSxcblxuICAgIF9yZXNldFVJOiBmdW5jdGlvbiBfcmVzZXRVSSgpIHtcbiAgICAgIC8vIFJlc2V0IGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuX2ZhaWxlZE9uY2UgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdHVhbGl6ZVRyaWdnZXJzKCk7XG5cbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaWYgVUkgbmV2ZXIgaW5pdGlhbGl6ZWQgZm9yIHRoaXMgZmllbGRcbiAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMuX3VpKSByZXR1cm47XG5cbiAgICAgIC8vIFJlc2V0IGFsbCBlcnJvcnMnIGxpXG4gICAgICB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5yZW1vdmVDbGFzcygnZmlsbGVkJykuY2hpbGRyZW4oKS5yZW1vdmUoKTtcblxuICAgICAgLy8gUmVzZXQgdmFsaWRhdGlvbiBjbGFzc1xuICAgICAgdGhpcy5fcmVzZXRDbGFzcygpO1xuXG4gICAgICAvLyBSZXNldCB2YWxpZGF0aW9uIGZsYWdzIGFuZCBsYXN0IHZhbGlkYXRpb24gcmVzdWx0XG4gICAgICB0aGlzLl91aS5sYXN0VmFsaWRhdGlvblJlc3VsdCA9IFtdO1xuICAgICAgdGhpcy5fdWkudmFsaWRhdGlvbkluZm9ybWF0aW9uVmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfZGVzdHJveVVJOiBmdW5jdGlvbiBfZGVzdHJveVVJKCkge1xuICAgICAgdGhpcy5fcmVzZXRVSSgpO1xuXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB0aGlzLl91aSkgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucmVtb3ZlKCk7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl91aTtcbiAgICB9LFxuXG4gICAgX3N1Y2Nlc3NDbGFzczogZnVuY3Rpb24gX3N1Y2Nlc3NDbGFzcygpIHtcbiAgICAgIHRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKTtcbiAgICB9LFxuICAgIF9lcnJvckNsYXNzOiBmdW5jdGlvbiBfZXJyb3JDbGFzcygpIHtcbiAgICAgIHRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdWNjZXNzQ2xhc3MpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKTtcbiAgICB9LFxuICAgIF9yZXNldENsYXNzOiBmdW5jdGlvbiBfcmVzZXRDbGFzcygpIHtcbiAgICAgIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBGb3JtID0gZnVuY3Rpb24gRm9ybShlbGVtZW50LCBkb21PcHRpb25zLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fX2NsYXNzX18gPSAnRm9ybSc7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIHRoaXMuZG9tT3B0aW9ucyA9IGRvbU9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnBhcmVudCA9IHdpbmRvdy5QYXJzbGV5O1xuXG4gICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPSBudWxsO1xuICB9O1xuXG4gIHZhciBGb3JtX19zdGF0dXNNYXBwaW5nID0geyBwZW5kaW5nOiBudWxsLCByZXNvbHZlZDogdHJ1ZSwgcmVqZWN0ZWQ6IGZhbHNlIH07XG5cbiAgRm9ybS5wcm90b3R5cGUgPSB7XG4gICAgb25TdWJtaXRWYWxpZGF0ZTogZnVuY3Rpb24gb25TdWJtaXRWYWxpZGF0ZShldmVudCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBQYXJzbGV5IGdlbmVyYXRlZCBzdWJtaXQgZXZlbnQsIGRvIG5vdCB2YWxpZGF0ZSwgZG8gbm90IHByZXZlbnQsIHNpbXBseSBleGl0IGFuZCBrZWVwIG5vcm1hbCBiZWhhdmlvclxuICAgICAgaWYgKHRydWUgPT09IGV2ZW50LnBhcnNsZXkpIHJldHVybjtcblxuICAgICAgLy8gSWYgd2UgZGlkbid0IGNvbWUgaGVyZSB0aHJvdWdoIGEgc3VibWl0IGJ1dHRvbiwgdXNlIHRoZSBmaXJzdCBvbmUgaW4gdGhlIGZvcm1cbiAgICAgIHZhciBzdWJtaXRTb3VyY2UgPSB0aGlzLl9zdWJtaXRTb3VyY2UgfHwgdGhpcy4kZWxlbWVudC5maW5kKFV0aWxzLl9TdWJtaXRTZWxlY3RvcilbMF07XG4gICAgICB0aGlzLl9zdWJtaXRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCcucGFyc2xleS1zeW50aGV0aWMtc3VibWl0LWJ1dHRvbicpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICBpZiAoc3VibWl0U291cmNlICYmIG51bGwgIT09IHN1Ym1pdFNvdXJjZS5nZXRBdHRyaWJ1dGUoJ2Zvcm1ub3ZhbGlkYXRlJykpIHJldHVybjtcblxuICAgICAgd2luZG93LlBhcnNsZXkuX3JlbW90ZUNhY2hlID0ge307XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy53aGVuVmFsaWRhdGUoeyBldmVudDogZXZlbnQgfSk7XG5cbiAgICAgIGlmICgncmVzb2x2ZWQnID09PSBwcm9taXNlLnN0YXRlKCkgJiYgZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoJ3N1Ym1pdCcpKSB7XG4gICAgICAgIC8vIEFsbCBnb29kLCBsZXQgZXZlbnQgZ28gdGhyb3VnaC4gV2UgbWFrZSB0aGlzIGRpc3RpbmN0aW9uIGJlY2F1c2UgYnJvd3NlcnNcbiAgICAgICAgLy8gZGlmZmVyIGluIHRoZWlyIGhhbmRsaW5nIG9mIGBzdWJtaXRgIGJlaW5nIGNhbGxlZCBmcm9tIGluc2lkZSBhIHN1Ym1pdCBldmVudCBbIzEwNDddXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlamVjdGVkIG9yIHBlbmRpbmc6IGNhbmNlbCB0aGlzIHN1Ym1pdFxuICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKCdwZW5kaW5nJyA9PT0gcHJvbWlzZS5zdGF0ZSgpKSBwcm9taXNlLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1Ll9zdWJtaXQoc3VibWl0U291cmNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblN1Ym1pdEJ1dHRvbjogZnVuY3Rpb24gb25TdWJtaXRCdXR0b24oZXZlbnQpIHtcbiAgICAgIHRoaXMuX3N1Ym1pdFNvdXJjZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgfSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIC8vIF9zdWJtaXQgc3VibWl0cyB0aGUgZm9ybSwgdGhpcyB0aW1lIHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGUgdmFsaWRhdGlvbnMuXG4gICAgLy8gQ2FyZSBtdXN0IGJlIHRha2VuIHRvIFwiZmFrZVwiIHRoZSBhY3R1YWwgc3VibWl0IGJ1dHRvbiBiZWluZyBjbGlja2VkLlxuICAgIF9zdWJtaXQ6IGZ1bmN0aW9uIF9zdWJtaXQoc3VibWl0U291cmNlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuX3RyaWdnZXIoJ3N1Ym1pdCcpKSByZXR1cm47XG4gICAgICAvLyBBZGQgc3VibWl0IGJ1dHRvbidzIGRhdGFcbiAgICAgIGlmIChzdWJtaXRTb3VyY2UpIHtcbiAgICAgICAgdmFyICRzeW50aGV0aWMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5wYXJzbGV5LXN5bnRoZXRpYy1zdWJtaXQtYnV0dG9uJykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgIGlmICgwID09PSAkc3ludGhldGljLmxlbmd0aCkgJHN5bnRoZXRpYyA9ICQoJzxpbnB1dCBjbGFzcz1cInBhcnNsZXktc3ludGhldGljLXN1Ym1pdC1idXR0b25cIiB0eXBlPVwiaGlkZGVuXCI+JykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCk7XG4gICAgICAgICRzeW50aGV0aWMuYXR0cih7XG4gICAgICAgICAgbmFtZTogc3VibWl0U291cmNlLmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICAgICAgIHZhbHVlOiBzdWJtaXRTb3VyY2UuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoX2V4dGVuZHMoJC5FdmVudCgnc3VibWl0JyksIHsgcGFyc2xleTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFBlcmZvcm1zIHZhbGlkYXRpb24gb24gZmllbGRzIHdoaWxlIHRyaWdnZXJpbmcgZXZlbnRzLlxuICAgIC8vIEByZXR1cm5zIGB0cnVlYCBpZiBhbGwgdmFsaWRhdGlvbnMgc3VjY2VlZHMsIGBmYWxzZWBcbiAgICAvLyBpZiBhIGZhaWx1cmUgaXMgaW1tZWRpYXRlbHkgZGV0ZWN0ZWQsIG9yIGBudWxsYFxuICAgIC8vIGlmIGRlcGVuZGFudCBvbiBhIHByb21pc2UuXG4gICAgLy8gQ29uc2lkZXIgdXNpbmcgYHdoZW5WYWxpZGF0ZWAgaW5zdGVhZC5cbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiAhJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIFV0aWxzLndhcm5PbmNlKCdDYWxsaW5nIHZhbGlkYXRlIG9uIGEgcGFyc2xleSBmb3JtIHdpdGhvdXQgcGFzc2luZyBhcmd1bWVudHMgYXMgYW4gb2JqZWN0IGlzIGRlcHJlY2F0ZWQuJyk7XG5cbiAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBncm91cCA9IF9hcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBmb3JjZSA9IF9hcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBldmVudCA9IF9hcmd1bWVudHNbMl07XG5cbiAgICAgICAgb3B0aW9ucyA9IHsgZ3JvdXA6IGdyb3VwLCBmb3JjZTogZm9yY2UsIGV2ZW50OiBldmVudCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZvcm1fX3N0YXR1c01hcHBpbmdbdGhpcy53aGVuVmFsaWRhdGUob3B0aW9ucykuc3RhdGUoKV07XG4gICAgfSxcblxuICAgIHdoZW5WYWxpZGF0ZTogZnVuY3Rpb24gd2hlblZhbGlkYXRlKCkge1xuICAgICAgdmFyIF9VdGlscyRhbGwkZG9uZSRmYWlsJGFsd2F5cyxcbiAgICAgICAgICBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZjcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIGdyb3VwID0gX3JlZjcuZ3JvdXA7XG4gICAgICB2YXIgZm9yY2UgPSBfcmVmNy5mb3JjZTtcbiAgICAgIHZhciBldmVudCA9IF9yZWY3LmV2ZW50O1xuXG4gICAgICB0aGlzLnN1Ym1pdEV2ZW50ID0gZXZlbnQ7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zdWJtaXRFdmVudCA9IF9leHRlbmRzKHt9LCBldmVudCwgeyBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgICBVdGlscy53YXJuT25jZShcIlVzaW5nIGB0aGlzLnN1Ym1pdEV2ZW50LnByZXZlbnREZWZhdWx0KClgIGlzIGRlcHJlY2F0ZWQ7IGluc3RlYWQsIGNhbGwgYHRoaXMudmFsaWRhdGlvblJlc3VsdCA9IGZhbHNlYFwiKTtcbiAgICAgICAgICAgIF90aGlzNi52YWxpZGF0aW9uUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgfSB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGlvblJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGZpcmUgdmFsaWRhdGUgZXZlbnQgdG8gZXZlbnR1YWxseSBtb2RpZnkgdGhpbmdzIGJlZm9yZSBldmVyeSB2YWxpZGF0aW9uXG4gICAgICB0aGlzLl90cmlnZ2VyKCd2YWxpZGF0ZScpO1xuXG4gICAgICAvLyBSZWZyZXNoIGZvcm0gRE9NIG9wdGlvbnMgYW5kIGZvcm0ncyBmaWVsZHMgdGhhdCBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgIHRoaXMuX3JlZnJlc2hGaWVsZHMoKTtcblxuICAgICAgdmFyIHByb21pc2VzID0gdGhpcy5fd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkLm1hcChfdGhpczYuZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGQud2hlblZhbGlkYXRlKHsgZm9yY2U6IGZvcmNlLCBncm91cDogZ3JvdXAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiAoX1V0aWxzJGFsbCRkb25lJGZhaWwkYWx3YXlzID0gVXRpbHMuYWxsKHByb21pc2VzKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM2Ll90cmlnZ2VyKCdzdWNjZXNzJyk7XG4gICAgICB9KS5mYWlsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM2LnZhbGlkYXRpb25SZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM2LmZvY3VzKCk7XG4gICAgICAgIF90aGlzNi5fdHJpZ2dlcignZXJyb3InKTtcbiAgICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi5fdHJpZ2dlcigndmFsaWRhdGVkJyk7XG4gICAgICB9KSkucGlwZS5hcHBseShfVXRpbHMkYWxsJGRvbmUkZmFpbCRhbHdheXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9waXBlQWNjb3JkaW5nVG9WYWxpZGF0aW9uUmVzdWx0KCkpKTtcbiAgICB9LFxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHJlZnJlc2hlZCBmaWVsZHMsIGFuZCBzdG9wIG9uIGZpcnN0IGZhaWx1cmUuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGZpZWxkcyBhcmUgdmFsaWQsIGBmYWxzZWAgaWYgYSBmYWlsdXJlIGlzIGRldGVjdGVkXG4gICAgLy8gb3IgYG51bGxgIGlmIHRoZSByZXN1bHQgZGVwZW5kcyBvbiBhbiB1bnJlc29sdmVkIHByb21pc2UuXG4gICAgLy8gUHJlZmVyIHVzaW5nIGB3aGVuVmFsaWRgIGluc3RlYWQuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZChvcHRpb25zKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmICEkLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgVXRpbHMud2Fybk9uY2UoJ0NhbGxpbmcgaXNWYWxpZCBvbiBhIHBhcnNsZXkgZm9ybSB3aXRob3V0IHBhc3NpbmcgYXJndW1lbnRzIGFzIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLicpO1xuXG4gICAgICAgIHZhciBfYXJndW1lbnRzMiA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gX2FyZ3VtZW50czJbMF07XG4gICAgICAgIHZhciBmb3JjZSA9IF9hcmd1bWVudHMyWzFdO1xuXG4gICAgICAgIG9wdGlvbnMgPSB7IGdyb3VwOiBncm91cCwgZm9yY2U6IGZvcmNlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gRm9ybV9fc3RhdHVzTWFwcGluZ1t0aGlzLndoZW5WYWxpZChvcHRpb25zKS5zdGF0ZSgpXTtcbiAgICB9LFxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHJlZnJlc2hlZCBmaWVsZHMgYW5kIHZhbGlkYXRlIHRoZW0uXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UuXG4gICAgLy8gQSB2YWxpZGF0aW9uIHRoYXQgaW1tZWRpYXRlbHkgZmFpbHMgd2lsbCBpbnRlcnJ1cHQgdGhlIHZhbGlkYXRpb25zLlxuICAgIHdoZW5WYWxpZDogZnVuY3Rpb24gd2hlblZhbGlkKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmOCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgZ3JvdXAgPSBfcmVmOC5ncm91cDtcbiAgICAgIHZhciBmb3JjZSA9IF9yZWY4LmZvcmNlO1xuXG4gICAgICB0aGlzLl9yZWZyZXNoRmllbGRzKCk7XG5cbiAgICAgIHZhciBwcm9taXNlcyA9IHRoaXMuX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJC5tYXAoX3RoaXM3LmZpZWxkcywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkLndoZW5WYWxpZCh7IGdyb3VwOiBncm91cCwgZm9yY2U6IGZvcmNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFV0aWxzLmFsbChwcm9taXNlcyk7XG4gICAgfSxcblxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB0aGlzLl9yZWZyZXNoRmllbGRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVzZXQgVUlcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAvLyBGb3JtIGNhc2U6IGVtaXQgYSByZXNldCBldmVudCBmb3IgZWFjaCBmaWVsZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykgdGhpcy5maWVsZHNbaV0ucmVzZXQoKTtcblxuICAgICAgdGhpcy5fdHJpZ2dlcigncmVzZXQnKTtcbiAgICB9LFxuXG4gICAgLy8gRGVzdHJveSBQYXJzbGV5IGluc3RhbmNlICgrIFVJKVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAvLyBGaWVsZCBjYXNlOiBlbWl0IGRlc3Ryb3kgZXZlbnQgdG8gY2xlYW4gVUkgYW5kIHRoZW4gZGVzdHJveSBzdG9yZWQgaW5zdGFuY2VcbiAgICAgIHRoaXMuX2Rlc3Ryb3lVSSgpO1xuXG4gICAgICAvLyBGb3JtIGNhc2U6IGRlc3Ryb3kgYWxsIGl0cyBmaWVsZHMgYW5kIHRoZW4gZGVzdHJveSBzdG9yZWQgaW5zdGFuY2VcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHRoaXMuZmllbGRzW2ldLmRlc3Ryb3koKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCdQYXJzbGV5Jyk7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdkZXN0cm95Jyk7XG4gICAgfSxcblxuICAgIF9yZWZyZXNoRmllbGRzOiBmdW5jdGlvbiBfcmVmcmVzaEZpZWxkcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMoKS5fYmluZEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICBfYmluZEZpZWxkczogZnVuY3Rpb24gX2JpbmRGaWVsZHMoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgdmFyIG9sZEZpZWxkcyA9IHRoaXMuZmllbGRzO1xuXG4gICAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgdGhpcy5maWVsZHNNYXBwZWRCeUlkID0ge307XG5cbiAgICAgIHRoaXMuX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczguJGVsZW1lbnQuZmluZChfdGhpczgub3B0aW9ucy5pbnB1dHMpLm5vdChfdGhpczgub3B0aW9ucy5leGNsdWRlZCkuZWFjaChmdW5jdGlvbiAoXywgZWxlbWVudCkge1xuICAgICAgICAgIHZhciBmaWVsZEluc3RhbmNlID0gbmV3IHdpbmRvdy5QYXJzbGV5LkZhY3RvcnkoZWxlbWVudCwge30sIF90aGlzOCk7XG5cbiAgICAgICAgICAvLyBPbmx5IGFkZCB2YWxpZCBhbmQgbm90IGV4Y2x1ZGVkIGBGaWVsZGAgYW5kIGBGaWVsZE11bHRpcGxlYCBjaGlsZHJlblxuICAgICAgICAgIGlmICgoJ0ZpZWxkJyA9PT0gZmllbGRJbnN0YW5jZS5fX2NsYXNzX18gfHwgJ0ZpZWxkTXVsdGlwbGUnID09PSBmaWVsZEluc3RhbmNlLl9fY2xhc3NfXykgJiYgdHJ1ZSAhPT0gZmllbGRJbnN0YW5jZS5vcHRpb25zLmV4Y2x1ZGVkKSB7XG4gICAgICAgICAgICB2YXIgdW5pcXVlSWQgPSBmaWVsZEluc3RhbmNlLl9fY2xhc3NfXyArICctJyArIGZpZWxkSW5zdGFuY2UuX19pZF9fO1xuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgX3RoaXM4LmZpZWxkc01hcHBlZEJ5SWRbdW5pcXVlSWRdKSB7XG4gICAgICAgICAgICAgIF90aGlzOC5maWVsZHNNYXBwZWRCeUlkW3VuaXF1ZUlkXSA9IGZpZWxkSW5zdGFuY2U7XG4gICAgICAgICAgICAgIF90aGlzOC5maWVsZHMucHVzaChmaWVsZEluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQuZWFjaChVdGlscy5kaWZmZXJlbmNlKG9sZEZpZWxkcywgX3RoaXM4LmZpZWxkcyksIGZ1bmN0aW9uIChfLCBmaWVsZCkge1xuICAgICAgICAgIGZpZWxkLnJlc2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgb25seS5cbiAgICAvLyBMb29waW5nIG9uIGEgZm9ybSdzIGZpZWxkcyB0byBkbyB2YWxpZGF0aW9uIG9yIHNpbWlsYXJcbiAgICAvLyB3aWxsIHRyaWdnZXIgcmVhY3R1YWxpemluZyBvcHRpb25zIG9uIGFsbCBvZiB0aGVtLCB3aGljaFxuICAgIC8vIGluIHR1cm4gd2lsbCByZWFjdHVhbGl6ZSB0aGUgZm9ybSdzIG9wdGlvbnMuXG4gICAgLy8gVG8gYXZvaWQgY2FsbGluZyBhY3R1YWxpemVPcHRpb25zIHNvIG1hbnkgdGltZXMgb24gdGhlIGZvcm1cbiAgICAvLyBmb3Igbm90aGluZywgX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMgdGVtcG9yYXJpbHkgZGlzYWJsZXNcbiAgICAvLyB0aGUgbWV0aG9kIGFjdHVhbGl6ZU9wdGlvbnMgb24gdGhpcyBmb3JtIHdoaWxlIGBmbmAgaXMgY2FsbGVkLlxuICAgIF93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zOiBmdW5jdGlvbiBfd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9ucyhmbikge1xuICAgICAgdmFyIG9sZEFjdHVhbGl6ZU9wdGlvbnMgPSB0aGlzLmFjdHVhbGl6ZU9wdGlvbnM7XG4gICAgICB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIHZhciByZXN1bHQgPSBmbigpO1xuICAgICAgdGhpcy5hY3R1YWxpemVPcHRpb25zID0gb2xkQWN0dWFsaXplT3B0aW9ucztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG9ubHkuXG4gICAgLy8gU2hvcnRjdXQgdG8gdHJpZ2dlciBhbiBldmVudFxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgZXZlbnQgaXMgbm90IGludGVycnVwdGVkIGFuZCBkZWZhdWx0IG5vdCBwcmV2ZW50ZWQuXG4gICAgX3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignZm9ybTonICsgZXZlbnROYW1lKTtcbiAgICB9XG5cbiAgfTtcblxuICB2YXIgQ29uc3RyYWludCA9IGZ1bmN0aW9uIENvbnN0cmFpbnQocGFyc2xleUZpZWxkLCBuYW1lLCByZXF1aXJlbWVudHMsIHByaW9yaXR5LCBpc0RvbUNvbnN0cmFpbnQpIHtcbiAgICB2YXIgdmFsaWRhdG9yU3BlYyA9IHdpbmRvdy5QYXJzbGV5Ll92YWxpZGF0b3JSZWdpc3RyeS52YWxpZGF0b3JzW25hbWVdO1xuICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHZhbGlkYXRvclNwZWMpO1xuICAgIHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgcGFyc2xleUZpZWxkLm9wdGlvbnNbbmFtZSArICdQcmlvcml0eSddIHx8IHZhbGlkYXRvci5wcmlvcml0eTtcbiAgICBpc0RvbUNvbnN0cmFpbnQgPSB0cnVlID09PSBpc0RvbUNvbnN0cmFpbnQ7XG5cbiAgICBfZXh0ZW5kcyh0aGlzLCB7XG4gICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByZXF1aXJlbWVudHM6IHJlcXVpcmVtZW50cyxcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgIGlzRG9tQ29uc3RyYWludDogaXNEb21Db25zdHJhaW50XG4gICAgfSk7XG4gICAgdGhpcy5fcGFyc2VSZXF1aXJlbWVudHMocGFyc2xleUZpZWxkLm9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgICB2YXIgY2FwID0gc3RyWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGNhcCArIHN0ci5zbGljZSgxKTtcbiAgfTtcblxuICBDb25zdHJhaW50LnByb3RvdHlwZSA9IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIGluc3RhbmNlKSB7XG4gICAgICB2YXIgX3ZhbGlkYXRvcjtcblxuICAgICAgcmV0dXJuIChfdmFsaWRhdG9yID0gdGhpcy52YWxpZGF0b3IpLnZhbGlkYXRlLmFwcGx5KF92YWxpZGF0b3IsIFt2YWx1ZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnJlcXVpcmVtZW50TGlzdCksIFtpbnN0YW5jZV0pKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlUmVxdWlyZW1lbnRzOiBmdW5jdGlvbiBfcGFyc2VSZXF1aXJlbWVudHMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHRoaXMucmVxdWlyZW1lbnRMaXN0ID0gdGhpcy52YWxpZGF0b3IucGFyc2VSZXF1aXJlbWVudHModGhpcy5yZXF1aXJlbWVudHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbX3RoaXM5Lm5hbWUgKyBjYXBpdGFsaXplKGtleSldO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBGaWVsZCA9IGZ1bmN0aW9uIEZpZWxkKGZpZWxkLCBkb21PcHRpb25zLCBvcHRpb25zLCBwYXJzbGV5Rm9ybUluc3RhbmNlKSB7XG4gICAgdGhpcy5fX2NsYXNzX18gPSAnRmllbGQnO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZmllbGQ7XG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZmllbGQpO1xuXG4gICAgLy8gU2V0IHBhcmVudCBpZiB3ZSBoYXZlIG9uZVxuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcnNsZXlGb3JtSW5zdGFuY2UpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyc2xleUZvcm1JbnN0YW5jZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZG9tT3B0aW9ucyA9IGRvbU9wdGlvbnM7XG5cbiAgICAvLyBJbml0aWFsaXplIHNvbWUgcHJvcGVydGllc1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lID0ge307XG4gICAgdGhpcy52YWxpZGF0aW9uUmVzdWx0ID0gdHJ1ZTtcblxuICAgIC8vIEJpbmQgY29uc3RyYWludHNcbiAgICB0aGlzLl9iaW5kQ29uc3RyYWludHMoKTtcbiAgfTtcblxuICB2YXIgcGFyc2xleV9maWVsZF9fc3RhdHVzTWFwcGluZyA9IHsgcGVuZGluZzogbnVsbCwgcmVzb2x2ZWQ6IHRydWUsIHJlamVjdGVkOiBmYWxzZSB9O1xuXG4gIEZpZWxkLnByb3RvdHlwZSA9IHtcbiAgICAvLyAjIFB1YmxpYyBBUElcbiAgICAvLyBWYWxpZGF0ZSBmaWVsZCBhbmQgdHJpZ2dlciBzb21lIGV2ZW50cyBmb3IgbWFpbmx5IGBVSWBcbiAgICAvLyBAcmV0dXJucyBgdHJ1ZWAsIGFuIGFycmF5IG9mIHRoZSB2YWxpZGF0b3JzIHRoYXQgZmFpbGVkLCBvclxuICAgIC8vIGBudWxsYCBpZiB2YWxpZGF0aW9uIGlzIG5vdCBmaW5pc2hlZC4gUHJlZmVyIHVzaW5nIHdoZW5WYWxpZGF0ZVxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmICEkLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgVXRpbHMud2Fybk9uY2UoJ0NhbGxpbmcgdmFsaWRhdGUgb24gYSBwYXJzbGV5IGZpZWxkIHdpdGhvdXQgcGFzc2luZyBhcmd1bWVudHMgYXMgYW4gb2JqZWN0IGlzIGRlcHJlY2F0ZWQuJyk7XG4gICAgICAgIG9wdGlvbnMgPSB7IG9wdGlvbnM6IG9wdGlvbnMgfTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy53aGVuVmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICBpZiAoIXByb21pc2UpIC8vIElmIGV4Y2x1ZGVkIHdpdGggYGdyb3VwYCBvcHRpb25cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBzd2l0Y2ggKHByb21pc2Uuc3RhdGUoKSkge1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAncmVzb2x2ZWQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJlc3VsdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVmFsaWRhdGUgZmllbGQgYW5kIHRyaWdnZXIgc29tZSBldmVudHMgZm9yIG1haW5seSBgVUlgXG4gICAgLy8gQHJldHVybnMgYSBwcm9taXNlIHRoYXQgc3VjY2VlZHMgb25seSB3aGVuIGFsbCB2YWxpZGF0aW9ucyBkb1xuICAgIC8vIG9yIGB1bmRlZmluZWRgIGlmIGZpZWxkIGlzIG5vdCBpbiB0aGUgZ2l2ZW4gYGdyb3VwYC5cbiAgICB3aGVuVmFsaWRhdGU6IGZ1bmN0aW9uIHdoZW5WYWxpZGF0ZSgpIHtcbiAgICAgIHZhciBfd2hlblZhbGlkJGFsd2F5cyRkb25lJGZhaWwkYWx3YXlzLFxuICAgICAgICAgIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZjkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIGZvcmNlID0gX3JlZjkuZm9yY2U7XG4gICAgICB2YXIgZ3JvdXAgPSBfcmVmOS5ncm91cDtcblxuICAgICAgLy8gZG8gbm90IHZhbGlkYXRlIGEgZmllbGQgaWYgbm90IHRoZSBzYW1lIGFzIGdpdmVuIHZhbGlkYXRpb24gZ3JvdXBcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgaWYgKGdyb3VwICYmICF0aGlzLl9pc0luR3JvdXAoZ3JvdXApKSByZXR1cm47XG5cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgICAgIC8vIEZpZWxkIFZhbGlkYXRlIGV2ZW50LiBgdGhpcy52YWx1ZWAgY291bGQgYmUgYWx0ZXJlZCBmb3IgY3VzdG9tIG5lZWRzXG4gICAgICB0aGlzLl90cmlnZ2VyKCd2YWxpZGF0ZScpO1xuXG4gICAgICByZXR1cm4gKF93aGVuVmFsaWQkYWx3YXlzJGRvbmUkZmFpbCRhbHdheXMgPSB0aGlzLndoZW5WYWxpZCh7IGZvcmNlOiBmb3JjZSwgdmFsdWU6IHRoaXMudmFsdWUsIF9yZWZyZXNoZWQ6IHRydWUgfSkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5fcmVmbG93VUkoKTtcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEwLl90cmlnZ2VyKCdzdWNjZXNzJyk7XG4gICAgICB9KS5mYWlsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5fdHJpZ2dlcignZXJyb3InKTtcbiAgICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAuX3RyaWdnZXIoJ3ZhbGlkYXRlZCcpO1xuICAgICAgfSkpLnBpcGUuYXBwbHkoX3doZW5WYWxpZCRhbHdheXMkZG9uZSRmYWlsJGFsd2F5cywgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3BpcGVBY2NvcmRpbmdUb1ZhbGlkYXRpb25SZXN1bHQoKSkpO1xuICAgIH0sXG5cbiAgICBoYXNDb25zdHJhaW50czogZnVuY3Rpb24gaGFzQ29uc3RyYWludHMoKSB7XG4gICAgICByZXR1cm4gMCAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIEFuIGVtcHR5IG9wdGlvbmFsIGZpZWxkIGRvZXMgbm90IG5lZWQgdmFsaWRhdGlvblxuICAgIG5lZWRzVmFsaWRhdGlvbjogZnVuY3Rpb24gbmVlZHNWYWxpZGF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB2YWx1ZSkgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgICAgIC8vIElmIGEgZmllbGQgaXMgZW1wdHkgYW5kIG5vdCByZXF1aXJlZCwgaXQgaXMgdmFsaWRcbiAgICAgIC8vIEV4Y2VwdCBpZiBgZGF0YS1wYXJzbGV5LXZhbGlkYXRlLWlmLWVtcHR5YCBleHBsaWNpdGVseSBhZGRlZCwgdXNlZnVsIGZvciBzb21lIGN1c3RvbSB2YWxpZGF0b3JzXG4gICAgICBpZiAoIXZhbHVlLmxlbmd0aCAmJiAhdGhpcy5faXNSZXF1aXJlZCgpICYmICd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlSWZFbXB0eSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX2lzSW5Hcm91cDogZnVuY3Rpb24gX2lzSW5Hcm91cChncm91cCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmdyb3VwKSkgcmV0dXJuIC0xICE9PSAkLmluQXJyYXkoZ3JvdXAsIHRoaXMub3B0aW9ucy5ncm91cCk7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmdyb3VwID09PSBncm91cDtcbiAgICB9LFxuXG4gICAgLy8gSnVzdCB2YWxpZGF0ZSBmaWVsZC4gRG8gbm90IHRyaWdnZXIgYW55IGV2ZW50LlxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmZiBhbGwgY29uc3RyYWludHMgcGFzcywgYGZhbHNlYCBpZiB0aGVyZSBhcmUgZmFpbHVyZXMsXG4gICAgLy8gb3IgYG51bGxgIGlmIHRoZSByZXN1bHQgY2FuIG5vdCBiZSBkZXRlcm1pbmVkIHlldCAoZGVwZW5kcyBvbiBhIHByb21pc2UpXG4gICAgLy8gU2VlIGFsc28gYHdoZW5WYWxpZGAuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZChvcHRpb25zKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmICEkLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgVXRpbHMud2Fybk9uY2UoJ0NhbGxpbmcgaXNWYWxpZCBvbiBhIHBhcnNsZXkgZmllbGQgd2l0aG91dCBwYXNzaW5nIGFyZ3VtZW50cyBhcyBhbiBvYmplY3QgaXMgZGVwcmVjYXRlZC4nKTtcblxuICAgICAgICB2YXIgX2FyZ3VtZW50czMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBmb3JjZSA9IF9hcmd1bWVudHMzWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBfYXJndW1lbnRzM1sxXTtcblxuICAgICAgICBvcHRpb25zID0geyBmb3JjZTogZm9yY2UsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgfVxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLndoZW5WYWxpZChvcHRpb25zKTtcbiAgICAgIGlmICghcHJvbWlzZSkgLy8gRXhjbHVkZWQgdmlhIGBncm91cGBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gcGFyc2xleV9maWVsZF9fc3RhdHVzTWFwcGluZ1twcm9taXNlLnN0YXRlKCldO1xuICAgIH0sXG5cbiAgICAvLyBKdXN0IHZhbGlkYXRlIGZpZWxkLiBEbyBub3QgdHJpZ2dlciBhbnkgZXZlbnQuXG4gICAgLy8gQHJldHVybnMgYSBwcm9taXNlIHRoYXQgc3VjY2VlZHMgb25seSB3aGVuIGFsbCB2YWxpZGF0aW9ucyBkb1xuICAgIC8vIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBmaWVsZCBpcyBub3QgaW4gdGhlIGdpdmVuIGBncm91cGAuXG4gICAgLy8gVGhlIGFyZ3VtZW50IGBmb3JjZWAgd2lsbCBmb3JjZSB2YWxpZGF0aW9uIG9mIGVtcHR5IGZpZWxkcy5cbiAgICAvLyBJZiBhIGB2YWx1ZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgdmFsaWRhdGVkIGluc3RlYWQgb2YgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAgICB3aGVuVmFsaWQ6IGZ1bmN0aW9uIHdoZW5WYWxpZCgpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYxMCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgX3JlZjEwJGZvcmNlID0gX3JlZjEwLmZvcmNlO1xuICAgICAgdmFyIGZvcmNlID0gX3JlZjEwJGZvcmNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYxMCRmb3JjZTtcbiAgICAgIHZhciB2YWx1ZSA9IF9yZWYxMC52YWx1ZTtcbiAgICAgIHZhciBncm91cCA9IF9yZWYxMC5ncm91cDtcbiAgICAgIHZhciBfcmVmcmVzaGVkID0gX3JlZjEwLl9yZWZyZXNoZWQ7XG5cbiAgICAgIC8vIFJlY29tcHV0ZSBvcHRpb25zIGFuZCByZWJpbmQgY29uc3RyYWludHMgdG8gaGF2ZSBsYXRlc3QgY2hhbmdlc1xuICAgICAgaWYgKCFfcmVmcmVzaGVkKSB0aGlzLnJlZnJlc2goKTtcbiAgICAgIC8vIGRvIG5vdCB2YWxpZGF0ZSBhIGZpZWxkIGlmIG5vdCB0aGUgc2FtZSBhcyBnaXZlbiB2YWxpZGF0aW9uIGdyb3VwXG4gICAgICBpZiAoZ3JvdXAgJiYgIXRoaXMuX2lzSW5Hcm91cChncm91cCkpIHJldHVybjtcblxuICAgICAgdGhpcy52YWxpZGF0aW9uUmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgLy8gQSBmaWVsZCB3aXRob3V0IGNvbnN0cmFpbnQgaXMgdmFsaWRcbiAgICAgIGlmICghdGhpcy5oYXNDb25zdHJhaW50cygpKSByZXR1cm4gJC53aGVuKCk7XG5cbiAgICAgIC8vIFZhbHVlIGNvdWxkIGJlIHBhc3NlZCBhcyBhcmd1bWVudCwgbmVlZGVkIHRvIGFkZCBtb3JlIHBvd2VyIHRvICdmaWVsZDp2YWxpZGF0ZSdcbiAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHZhbHVlIHx8IG51bGwgPT09IHZhbHVlKSB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKCF0aGlzLm5lZWRzVmFsaWRhdGlvbih2YWx1ZSkgJiYgdHJ1ZSAhPT0gZm9yY2UpIHJldHVybiAkLndoZW4oKTtcblxuICAgICAgdmFyIGdyb3VwZWRDb25zdHJhaW50cyA9IHRoaXMuX2dldEdyb3VwZWRDb25zdHJhaW50cygpO1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAkLmVhY2goZ3JvdXBlZENvbnN0cmFpbnRzLCBmdW5jdGlvbiAoXywgY29uc3RyYWludHMpIHtcbiAgICAgICAgLy8gUHJvY2VzcyBvbmUgZ3JvdXAgb2YgY29uc3RyYWludHMgYXQgYSB0aW1lLCB3ZSB2YWxpZGF0ZSB0aGUgY29uc3RyYWludHNcbiAgICAgICAgLy8gYW5kIGNvbWJpbmUgdGhlIHByb21pc2VzIHRvZ2V0aGVyLlxuICAgICAgICB2YXIgcHJvbWlzZSA9IFV0aWxzLmFsbCgkLm1hcChjb25zdHJhaW50cywgZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMS5fdmFsaWRhdGVDb25zdHJhaW50KHZhbHVlLCBjb25zdHJhaW50KTtcbiAgICAgICAgfSkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSgpID09PSAncmVqZWN0ZWQnKSByZXR1cm4gZmFsc2U7IC8vIEludGVycnVwdCBwcm9jZXNzaW5nIGlmIGEgZ3JvdXAgaGFzIGFscmVhZHkgZmFpbGVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBVdGlscy5hbGwocHJvbWlzZXMpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJucyBhIHByb21pc2VcbiAgICBfdmFsaWRhdGVDb25zdHJhaW50OiBmdW5jdGlvbiBfdmFsaWRhdGVDb25zdHJhaW50KHZhbHVlLCBjb25zdHJhaW50KSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSBjb25zdHJhaW50LnZhbGlkYXRlKHZhbHVlLCB0aGlzKTtcbiAgICAgIC8vIE1hcCBmYWxzZSB0byBhIGZhaWxlZCBwcm9taXNlXG4gICAgICBpZiAoZmFsc2UgPT09IHJlc3VsdCkgcmVzdWx0ID0gJC5EZWZlcnJlZCgpLnJlamVjdCgpO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIHJldHVybiBhIHByb21pc2UgYW5kIHRoYXQgd2UgcmVjb3JkIGZhaWx1cmVzXG4gICAgICByZXR1cm4gVXRpbHMuYWxsKFtyZXN1bHRdKS5mYWlsKGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCEoX3RoaXMxMi52YWxpZGF0aW9uUmVzdWx0IGluc3RhbmNlb2YgQXJyYXkpKSBfdGhpczEyLnZhbGlkYXRpb25SZXN1bHQgPSBbXTtcbiAgICAgICAgX3RoaXMxMi52YWxpZGF0aW9uUmVzdWx0LnB1c2goe1xuICAgICAgICAgIGFzc2VydDogY29uc3RyYWludCxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6ICdzdHJpbmcnID09PSB0eXBlb2YgZXJyb3JNZXNzYWdlICYmIGVycm9yTWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJucyBQYXJzbGV5IGZpZWxkIGNvbXB1dGVkIHZhbHVlIHRoYXQgY291bGQgYmUgb3ZlcnJpZGVkIG9yIGNvbmZpZ3VyZWQgaW4gRE9NXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAvLyBWYWx1ZSBjb3VsZCBiZSBvdmVycmlkZW4gaW4gRE9NIG9yIHdpdGggZXhwbGljaXQgb3B0aW9uc1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLm9wdGlvbnMudmFsdWUpIHZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlKHRoaXMpO2Vsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbHVlKSB2YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtlbHNlIHZhbHVlID0gdGhpcy4kZWxlbWVudC52YWwoKTtcblxuICAgICAgLy8gSGFuZGxlIHdyb25nIERPTSBvciBjb25maWd1cmF0aW9uc1xuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdmFsdWUgfHwgbnVsbCA9PT0gdmFsdWUpIHJldHVybiAnJztcblxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVdoaXRlc3BhY2UodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyBSZXNldCBVSVxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuX3Jlc2V0VUkoKTtcbiAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKCdyZXNldCcpO1xuICAgIH0sXG5cbiAgICAvLyBEZXN0cm95IFBhcnNsZXkgaW5zdGFuY2UgKCsgVUkpXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIC8vIEZpZWxkIGNhc2U6IGVtaXQgZGVzdHJveSBldmVudCB0byBjbGVhbiBVSSBhbmQgdGhlbiBkZXN0cm95IHN0b3JlZCBpbnN0YW5jZVxuICAgICAgdGhpcy5fZGVzdHJveVVJKCk7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ1BhcnNsZXknKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnRmllbGRNdWx0aXBsZScpO1xuICAgICAgdGhpcy5fdHJpZ2dlcignZGVzdHJveScpO1xuICAgIH0sXG5cbiAgICAvLyBBY3R1YWxpemUgb3B0aW9ucyBhbmQgcmViaW5kIGNvbnN0cmFpbnRzXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2hDb25zdHJhaW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yZWZyZXNoQ29uc3RyYWludHM6IGZ1bmN0aW9uIF9yZWZyZXNoQ29uc3RyYWludHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3R1YWxpemVPcHRpb25zKCkuX2JpbmRDb25zdHJhaW50cygpO1xuICAgIH0sXG5cbiAgICByZWZyZXNoQ29uc3RyYWludHM6IGZ1bmN0aW9uIHJlZnJlc2hDb25zdHJhaW50cygpIHtcbiAgICAgIFV0aWxzLndhcm5PbmNlKFwiUGFyc2xleSdzIHJlZnJlc2hDb25zdHJhaW50cyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHJlZnJlc2hcIik7XG4gICAgICByZXR1cm4gdGhpcy5yZWZyZXNoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQWRkIGEgbmV3IGNvbnN0cmFpbnQgdG8gYSBmaWVsZFxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG5hbWVcbiAgICAqIEBwYXJhbSB7TWl4ZWR9ICAgIHJlcXVpcmVtZW50cyAgICAgIG9wdGlvbmFsXG4gICAgKiBAcGFyYW0ge051bWJlcn0gICBwcmlvcml0eSAgICAgICAgICBvcHRpb25hbFxuICAgICogQHBhcmFtIHtCb29sZWFufSAgaXNEb21Db25zdHJhaW50ICAgb3B0aW9uYWxcbiAgICAqL1xuICAgIGFkZENvbnN0cmFpbnQ6IGZ1bmN0aW9uIGFkZENvbnN0cmFpbnQobmFtZSwgcmVxdWlyZW1lbnRzLCBwcmlvcml0eSwgaXNEb21Db25zdHJhaW50KSB7XG5cbiAgICAgIGlmICh3aW5kb3cuUGFyc2xleS5fdmFsaWRhdG9yUmVnaXN0cnkudmFsaWRhdG9yc1tuYW1lXSkge1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBDb25zdHJhaW50KHRoaXMsIG5hbWUsIHJlcXVpcmVtZW50cywgcHJpb3JpdHksIGlzRG9tQ29uc3RyYWludCk7XG5cbiAgICAgICAgLy8gaWYgY29uc3RyYWludCBhbHJlYWR5IGV4aXN0LCBkZWxldGUgaXQgYW5kIHB1c2ggbmV3IHZlcnNpb25cbiAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lW2NvbnN0cmFpbnQubmFtZV0pIHRoaXMucmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50Lm5hbWUpO1xuXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50c0J5TmFtZVtjb25zdHJhaW50Lm5hbWVdID0gY29uc3RyYWludDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIGNvbnN0cmFpbnRcbiAgICByZW1vdmVDb25zdHJhaW50OiBmdW5jdGlvbiByZW1vdmVDb25zdHJhaW50KG5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykgaWYgKG5hbWUgPT09IHRoaXMuY29uc3RyYWludHNbaV0ubmFtZSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5jb25zdHJhaW50c0J5TmFtZVtuYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb25zdHJhaW50IChSZW1vdmUgKyByZS1hZGQpXG4gICAgdXBkYXRlQ29uc3RyYWludDogZnVuY3Rpb24gdXBkYXRlQ29uc3RyYWludChuYW1lLCBwYXJhbWV0ZXJzLCBwcmlvcml0eSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ29uc3RyYWludChuYW1lKS5hZGRDb25zdHJhaW50KG5hbWUsIHBhcmFtZXRlcnMsIHByaW9yaXR5KTtcbiAgICB9LFxuXG4gICAgLy8gIyBJbnRlcm5hbHNcblxuICAgIC8vIEludGVybmFsIG9ubHkuXG4gICAgLy8gQmluZCBjb25zdHJhaW50cyBmcm9tIGNvbmZpZyArIG9wdGlvbnMgKyBET01cbiAgICBfYmluZENvbnN0cmFpbnRzOiBmdW5jdGlvbiBfYmluZENvbnN0cmFpbnRzKCkge1xuICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW107XG4gICAgICB2YXIgY29uc3RyYWludHNCeU5hbWUgPSB7fTtcblxuICAgICAgLy8gY2xlYW4gYWxsIGV4aXN0aW5nIERPTSBjb25zdHJhaW50cyB0byBvbmx5IGtlZXAgamF2YXNjcmlwdCB1c2VyIGNvbnN0cmFpbnRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uc3RyYWludHMubGVuZ3RoOyBpKyspIGlmIChmYWxzZSA9PT0gdGhpcy5jb25zdHJhaW50c1tpXS5pc0RvbUNvbnN0cmFpbnQpIHtcbiAgICAgICAgY29uc3RyYWludHMucHVzaCh0aGlzLmNvbnN0cmFpbnRzW2ldKTtcbiAgICAgICAgY29uc3RyYWludHNCeU5hbWVbdGhpcy5jb25zdHJhaW50c1tpXS5uYW1lXSA9IHRoaXMuY29uc3RyYWludHNbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICAgIHRoaXMuY29uc3RyYWludHNCeU5hbWUgPSBjb25zdHJhaW50c0J5TmFtZTtcblxuICAgICAgLy8gdGhlbiByZS1hZGQgUGFyc2xleSBET00tQVBJIGNvbnN0cmFpbnRzXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMub3B0aW9ucykgdGhpcy5hZGRDb25zdHJhaW50KG5hbWUsIHRoaXMub3B0aW9uc1tuYW1lXSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgLy8gZmluYWxseSwgYmluZCBzcGVjaWFsIEhUTUw1IGNvbnN0cmFpbnRzXG4gICAgICByZXR1cm4gdGhpcy5fYmluZEh0bWw1Q29uc3RyYWludHMoKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgb25seS5cbiAgICAvLyBCaW5kIHNwZWNpZmljIEhUTUw1IGNvbnN0cmFpbnRzIHRvIGJlIEhUTUw1IGNvbXBsaWFudFxuICAgIF9iaW5kSHRtbDVDb25zdHJhaW50czogZnVuY3Rpb24gX2JpbmRIdG1sNUNvbnN0cmFpbnRzKCkge1xuICAgICAgLy8gaHRtbDUgcmVxdWlyZWRcbiAgICAgIGlmIChudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpKSB0aGlzLmFkZENvbnN0cmFpbnQoJ3JlcXVpcmVkJywgdHJ1ZSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgLy8gaHRtbDUgcGF0dGVyblxuICAgICAgaWYgKG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm4nKSkgdGhpcy5hZGRDb25zdHJhaW50KCdwYXR0ZXJuJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgncGF0dGVybicpLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAvLyByYW5nZVxuICAgICAgdmFyIG1pbiA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbicpO1xuICAgICAgdmFyIG1heCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heCcpO1xuICAgICAgaWYgKG51bGwgIT09IG1pbiAmJiBudWxsICE9PSBtYXgpIHRoaXMuYWRkQ29uc3RyYWludCgncmFuZ2UnLCBbbWluLCBtYXhdLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAvLyBIVE1MNSBtaW5cbiAgICAgIGVsc2UgaWYgKG51bGwgIT09IG1pbikgdGhpcy5hZGRDb25zdHJhaW50KCdtaW4nLCBtaW4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gSFRNTDUgbWF4XG4gICAgICAgIGVsc2UgaWYgKG51bGwgIT09IG1heCkgdGhpcy5hZGRDb25zdHJhaW50KCdtYXgnLCBtYXgsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIC8vIGxlbmd0aFxuICAgICAgaWYgKG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbmxlbmd0aCcpICYmIG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGxlbmd0aCcpKSB0aGlzLmFkZENvbnN0cmFpbnQoJ2xlbmd0aCcsIFt0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5sZW5ndGgnKSwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4bGVuZ3RoJyldLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAvLyBIVE1MNSBtaW5sZW5ndGhcbiAgICAgIGVsc2UgaWYgKG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbmxlbmd0aCcpKSB0aGlzLmFkZENvbnN0cmFpbnQoJ21pbmxlbmd0aCcsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbmxlbmd0aCcpLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAgIC8vIEhUTUw1IG1heGxlbmd0aFxuICAgICAgICBlbHNlIGlmIChudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnKSkgdGhpcy5hZGRDb25zdHJhaW50KCdtYXhsZW5ndGgnLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnKSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgLy8gaHRtbDUgdHlwZXNcbiAgICAgIHZhciB0eXBlID0gVXRpbHMuZ2V0VHlwZSh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAvLyBTbWFsbCBzcGVjaWFsIGNhc2UgaGVyZSBmb3IgSFRNTDUgbnVtYmVyOiBpbnRlZ2VyIHZhbGlkYXRvciBpZiBzdGVwIGF0dHJpYnV0ZSBpcyB1bmRlZmluZWQgb3IgYW4gaW50ZWdlciB2YWx1ZSwgbnVtYmVyIG90aGVyd2lzZVxuICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENvbnN0cmFpbnQoJ3R5cGUnLCBbJ251bWJlcicsIHtcbiAgICAgICAgICBzdGVwOiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdGVwJykgfHwgJzEnLFxuICAgICAgICAgIGJhc2U6IG1pbiB8fCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICAgIH1dLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAvLyBSZWd1bGFyIG90aGVyIEhUTUw1IHN1cHBvcnRlZCB0eXBlc1xuICAgICAgfSBlbHNlIGlmICgvXihlbWFpbHx1cmx8cmFuZ2V8ZGF0ZSkkL2kudGVzdCh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFkZENvbnN0cmFpbnQoJ3R5cGUnLCB0eXBlLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgb25seS5cbiAgICAvLyBGaWVsZCBpcyByZXF1aXJlZCBpZiBoYXZlIHJlcXVpcmVkIGNvbnN0cmFpbnQgd2l0aG91dCBgZmFsc2VgIHZhbHVlXG4gICAgX2lzUmVxdWlyZWQ6IGZ1bmN0aW9uIF9pc1JlcXVpcmVkKCkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy5jb25zdHJhaW50c0J5TmFtZS5yZXF1aXJlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gZmFsc2UgIT09IHRoaXMuY29uc3RyYWludHNCeU5hbWUucmVxdWlyZWQucmVxdWlyZW1lbnRzO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBvbmx5LlxuICAgIC8vIFNob3J0Y3V0IHRvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICBfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIoZXZlbnROYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdmaWVsZDonICsgZXZlbnROYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgb25seVxuICAgIC8vIEhhbmRsZXMgd2hpdGVzcGFjZSBpbiBhIHZhbHVlXG4gICAgLy8gVXNlIGBkYXRhLXBhcnNsZXktd2hpdGVzcGFjZT1cInNxdWlzaFwiYCB0byBhdXRvIHNxdWlzaCBpbnB1dCB2YWx1ZVxuICAgIC8vIFVzZSBgZGF0YS1wYXJzbGV5LXdoaXRlc3BhY2U9XCJ0cmltXCJgIHRvIGF1dG8gdHJpbSBpbnB1dCB2YWx1ZVxuICAgIF9oYW5kbGVXaGl0ZXNwYWNlOiBmdW5jdGlvbiBfaGFuZGxlV2hpdGVzcGFjZSh2YWx1ZSkge1xuICAgICAgaWYgKHRydWUgPT09IHRoaXMub3B0aW9ucy50cmltVmFsdWUpIFV0aWxzLndhcm5PbmNlKCdkYXRhLXBhcnNsZXktdHJpbS12YWx1ZT1cInRydWVcIiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGRhdGEtcGFyc2xleS13aGl0ZXNwYWNlPVwidHJpbVwiJyk7XG5cbiAgICAgIGlmICgnc3F1aXNoJyA9PT0gdGhpcy5vcHRpb25zLndoaXRlc3BhY2UpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpO1xuXG4gICAgICBpZiAoJ3RyaW0nID09PSB0aGlzLm9wdGlvbnMud2hpdGVzcGFjZSB8fCAnc3F1aXNoJyA9PT0gdGhpcy5vcHRpb25zLndoaXRlc3BhY2UgfHwgdHJ1ZSA9PT0gdGhpcy5vcHRpb25zLnRyaW1WYWx1ZSkgdmFsdWUgPSBVdGlscy50cmltU3RyaW5nKHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBfaXNEYXRlSW5wdXQ6IGZ1bmN0aW9uIF9pc0RhdGVJbnB1dCgpIHtcbiAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c0J5TmFtZS50eXBlO1xuICAgICAgcmV0dXJuIGMgJiYgYy5yZXF1aXJlbWVudHMgPT09ICdkYXRlJztcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgb25seS5cbiAgICAvLyBSZXR1cm5zIHRoZSBjb25zdHJhaW50cywgZ3JvdXBlZCBieSBkZXNjZW5kaW5nIHByaW9yaXR5LlxuICAgIC8vIFRoZSByZXN1bHQgaXMgdGh1cyBhbiBhcnJheSBvZiBhcnJheXMgb2YgY29uc3RyYWludHMuXG4gICAgX2dldEdyb3VwZWRDb25zdHJhaW50czogZnVuY3Rpb24gX2dldEdyb3VwZWRDb25zdHJhaW50cygpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gdGhpcy5vcHRpb25zLnByaW9yaXR5RW5hYmxlZCkgcmV0dXJuIFt0aGlzLmNvbnN0cmFpbnRzXTtcblxuICAgICAgdmFyIGdyb3VwZWRDb25zdHJhaW50cyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0ge307XG5cbiAgICAgIC8vIENyZWF0ZSBhcnJheSB1bmlxdWUgb2YgcHJpb3JpdGllc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5jb25zdHJhaW50c1tpXS5wcmlvcml0eTtcbiAgICAgICAgaWYgKCFpbmRleFtwXSkgZ3JvdXBlZENvbnN0cmFpbnRzLnB1c2goaW5kZXhbcF0gPSBbXSk7XG4gICAgICAgIGluZGV4W3BdLnB1c2godGhpcy5jb25zdHJhaW50c1tpXSk7XG4gICAgICB9XG4gICAgICAvLyBTb3J0IHRoZW0gYnkgcHJpb3JpdHkgREVTQ1xuICAgICAgZ3JvdXBlZENvbnN0cmFpbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGJbMF0ucHJpb3JpdHkgLSBhWzBdLnByaW9yaXR5O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBncm91cGVkQ29uc3RyYWludHM7XG4gICAgfVxuXG4gIH07XG5cbiAgdmFyIHBhcnNsZXlfZmllbGQgPSBGaWVsZDtcblxuICB2YXIgTXVsdGlwbGUgPSBmdW5jdGlvbiBNdWx0aXBsZSgpIHtcbiAgICB0aGlzLl9fY2xhc3NfXyA9ICdGaWVsZE11bHRpcGxlJztcbiAgfTtcblxuICBNdWx0aXBsZS5wcm90b3R5cGUgPSB7XG4gICAgLy8gQWRkIG5ldyBgJGVsZW1lbnRgIHNpYmxpbmcgZm9yIG11bHRpcGxlIGZpZWxkXG4gICAgYWRkRWxlbWVudDogZnVuY3Rpb24gYWRkRWxlbWVudCgkZWxlbWVudCkge1xuICAgICAgdGhpcy4kZWxlbWVudHMucHVzaCgkZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZWUgYEZpZWxkLl9yZWZyZXNoQ29uc3RyYWludHMoKWBcbiAgICBfcmVmcmVzaENvbnN0cmFpbnRzOiBmdW5jdGlvbiBfcmVmcmVzaENvbnN0cmFpbnRzKCkge1xuICAgICAgdmFyIGZpZWxkQ29uc3RyYWludHM7XG5cbiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgICAgLy8gU2VsZWN0IG11bHRpcGxlIHNwZWNpYWwgdHJlYXRtZW50XG4gICAgICBpZiAodGhpcy5lbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMoKS5fYmluZENvbnN0cmFpbnRzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEdhdGhlciBhbGwgY29uc3RyYWludHMgZm9yIGVhY2ggaW5wdXQgaW4gdGhlIG11bHRpcGxlIGdyb3VwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBoYXZlIG5vdCBiZWVuIGR5bmFtaWNhbGx5IHJlbW92ZWQgc2luY2UgbGFzdCBiaW5kaW5nXG4gICAgICAgIGlmICghJCgnaHRtbCcpLmhhcyh0aGlzLiRlbGVtZW50c1tpXSkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRDb25zdHJhaW50cyA9IHRoaXMuJGVsZW1lbnRzW2ldLmRhdGEoJ0ZpZWxkTXVsdGlwbGUnKS5fcmVmcmVzaENvbnN0cmFpbnRzKCkuY29uc3RyYWludHM7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZENvbnN0cmFpbnRzLmxlbmd0aDsgaisrKSB0aGlzLmFkZENvbnN0cmFpbnQoZmllbGRDb25zdHJhaW50c1tqXS5uYW1lLCBmaWVsZENvbnN0cmFpbnRzW2pdLnJlcXVpcmVtZW50cywgZmllbGRDb25zdHJhaW50c1tqXS5wcmlvcml0eSwgZmllbGRDb25zdHJhaW50c1tqXS5pc0RvbUNvbnN0cmFpbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2VlIGBGaWVsZC5nZXRWYWx1ZSgpYFxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIC8vIFZhbHVlIGNvdWxkIGJlIG92ZXJyaWRlbiBpbiBET01cbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbHVlKSByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlKHRoaXMpO2Vsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbHVlKSByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuXG4gICAgICAvLyBSYWRpbyBpbnB1dCBjYXNlXG4gICAgICBpZiAodGhpcy5lbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgIHZhciB0eXBlID0gVXRpbHMuZ2V0VHlwZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJykgcmV0dXJuIHRoaXMuX2ZpbmRSZWxhdGVkKCkuZmlsdGVyKCc6Y2hlY2tlZCcpLnZhbCgpIHx8ICcnO1xuXG4gICAgICAgIC8vIGNoZWNrYm94IGlucHV0IGNhc2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgICAgICB0aGlzLl9maW5kUmVsYXRlZCgpLmZpbHRlcignOmNoZWNrZWQnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKCQodGhpcykudmFsKCkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZWxlY3QgbXVsdGlwbGUgY2FzZVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcgJiYgbnVsbCA9PT0gdGhpcy4kZWxlbWVudC52YWwoKSkgcmV0dXJuIFtdO1xuXG4gICAgICAvLyBEZWZhdWx0IGNhc2UgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC52YWwoKTtcbiAgICB9LFxuXG4gICAgX2luaXQ6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdGhpcy4kZWxlbWVudHMgPSBbdGhpcy4kZWxlbWVudF07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICB2YXIgRmFjdG9yeSA9IGZ1bmN0aW9uIEZhY3RvcnkoZWxlbWVudCwgb3B0aW9ucywgcGFyc2xleUZvcm1JbnN0YW5jZSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cbiAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLCByZXR1cm5zIGl0cyBzYXZlZCBQYXJzbGV5IGluc3RhbmNlXG4gICAgdmFyIHNhdmVkcGFyc2xleUZvcm1JbnN0YW5jZSA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnUGFyc2xleScpO1xuICAgIGlmIChzYXZlZHBhcnNsZXlGb3JtSW5zdGFuY2UpIHtcblxuICAgICAgLy8gSWYgdGhlIHNhdmVkIGluc3RhbmNlIGhhcyBiZWVuIGJvdW5kIHdpdGhvdXQgYSBGb3JtIHBhcmVudCBhbmQgdGhlcmUgaXMgb25lIGdpdmVuIGluIHRoaXMgY2FsbCwgYWRkIGl0XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJzbGV5Rm9ybUluc3RhbmNlICYmIHNhdmVkcGFyc2xleUZvcm1JbnN0YW5jZS5wYXJlbnQgPT09IHdpbmRvdy5QYXJzbGV5KSB7XG4gICAgICAgIHNhdmVkcGFyc2xleUZvcm1JbnN0YW5jZS5wYXJlbnQgPSBwYXJzbGV5Rm9ybUluc3RhbmNlO1xuICAgICAgICBzYXZlZHBhcnNsZXlGb3JtSW5zdGFuY2UuX3Jlc2V0T3B0aW9ucyhzYXZlZHBhcnNsZXlGb3JtSW5zdGFuY2Uub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgX2V4dGVuZHMoc2F2ZWRwYXJzbGV5Rm9ybUluc3RhbmNlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2F2ZWRwYXJzbGV5Rm9ybUluc3RhbmNlO1xuICAgIH1cblxuICAgIC8vIFBhcnNsZXkgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIERPTSBlbGVtZW50IG9yIGpRdWVyeSAkZWxlbWVudFxuICAgIGlmICghdGhpcy4kZWxlbWVudC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmluZCBQYXJzbGV5IG9uIGFuIGV4aXN0aW5nIGVsZW1lbnQuJyk7XG5cbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJzbGV5Rm9ybUluc3RhbmNlICYmICdGb3JtJyAhPT0gcGFyc2xleUZvcm1JbnN0YW5jZS5fX2NsYXNzX18pIHRocm93IG5ldyBFcnJvcignUGFyZW50IGluc3RhbmNlIG11c3QgYmUgYSBGb3JtIGluc3RhbmNlJyk7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcnNsZXlGb3JtSW5zdGFuY2UgfHwgd2luZG93LlBhcnNsZXk7XG4gICAgcmV0dXJuIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX19jbGFzc19fID0gJ1BhcnNsZXknO1xuICAgICAgdGhpcy5fX3ZlcnNpb25fXyA9ICcyLjguMSc7XG4gICAgICB0aGlzLl9faWRfXyA9IFV0aWxzLmdlbmVyYXRlSUQoKTtcblxuICAgICAgLy8gUHJlLWNvbXB1dGUgb3B0aW9uc1xuICAgICAgdGhpcy5fcmVzZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAvLyBBIEZvcm0gaW5zdGFuY2UgaXMgb2J2aW91c2x5IGEgYDxmb3JtPmAgZWxlbWVudCBidXQgYWxzbyBldmVyeSBub2RlIHRoYXQgaXMgbm90IGFuIGlucHV0IGFuZCBoYXMgdGhlIGBkYXRhLXBhcnNsZXktdmFsaWRhdGVgIGF0dHJpYnV0ZVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0ZPUk0nIHx8IFV0aWxzLmNoZWNrQXR0cih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsICd2YWxpZGF0ZScpICYmICF0aGlzLiRlbGVtZW50LmlzKHRoaXMub3B0aW9ucy5pbnB1dHMpKSByZXR1cm4gdGhpcy5iaW5kKCdwYXJzbGV5Rm9ybScpO1xuXG4gICAgICAvLyBFdmVyeSBvdGhlciBlbGVtZW50IGlzIGJvdW5kIGFzIGEgYEZpZWxkYCBvciBgRmllbGRNdWx0aXBsZWBcbiAgICAgIHJldHVybiB0aGlzLmlzTXVsdGlwbGUoKSA/IHRoaXMuaGFuZGxlTXVsdGlwbGUoKSA6IHRoaXMuYmluZCgncGFyc2xleUZpZWxkJyk7XG4gICAgfSxcblxuICAgIGlzTXVsdGlwbGU6IGZ1bmN0aW9uIGlzTXVsdGlwbGUoKSB7XG4gICAgICB2YXIgdHlwZSA9IFV0aWxzLmdldFR5cGUodGhpcy5lbGVtZW50KTtcbiAgICAgIHJldHVybiB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcgfHwgdGhpcy5lbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJyAmJiBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtdWx0aXBsZScpO1xuICAgIH0sXG5cbiAgICAvLyBNdWx0aXBsZXMgZmllbGRzIGFyZSBhIHJlYWwgbmlnaHRtYXJlIDooXG4gICAgLy8gTWF5YmUgc29tZSByZWZhY3RvcmluZyB3b3VsZCBiZSBhcHByZWNpYXRlZCBoZXJlLi4uXG4gICAgaGFuZGxlTXVsdGlwbGU6IGZ1bmN0aW9uIGhhbmRsZU11bHRpcGxlKCkge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICB2YXIgbmFtZTtcbiAgICAgIHZhciBtdWx0aXBsZTtcbiAgICAgIHZhciBwYXJzbGV5TXVsdGlwbGVJbnN0YW5jZTtcblxuICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIG5hbWVcbiAgICAgIHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5tdWx0aXBsZSB8fCAobmFtZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSkgfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgICAgLy8gU3BlY2lhbCBzZWxlY3QgbXVsdGlwbGUgaW5wdXRcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQubm9kZU5hbWUgPT09ICdTRUxFQ1QnICYmIG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm11bHRpcGxlID0gdGhpcy5vcHRpb25zLm11bHRpcGxlIHx8IHRoaXMuX19pZF9fO1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kKCdwYXJzbGV5RmllbGRNdWx0aXBsZScpO1xuXG4gICAgICAgIC8vIEVsc2UgZm9yIHJhZGlvIC8gY2hlY2tib3hlcywgd2UgbmVlZCBhIGBuYW1lYCBvciBgZGF0YS1wYXJzbGV5LW11bHRpcGxlYCB0byBwcm9wZXJseSBiaW5kIGl0XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlwbGUpIHtcbiAgICAgICAgICBVdGlscy53YXJuKCdUbyBiZSBib3VuZCBieSBQYXJzbGV5LCBhIHJhZGlvLCBhIGNoZWNrYm94IGFuZCBhIG11bHRpcGxlIHNlbGVjdCBpbnB1dCBtdXN0IGhhdmUgZWl0aGVyIGEgbmFtZSBvciBhIG11bHRpcGxlIG9wdGlvbi4nLCB0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyc1xuICAgICAgdGhpcy5vcHRpb25zLm11bHRpcGxlID0gdGhpcy5vcHRpb25zLm11bHRpcGxlLnJlcGxhY2UoLyg6fFxcLnxcXFt8XFxdfFxce3xcXH18XFwkKS9nLCAnJyk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXIgYGRhdGEtcGFyc2xleS1tdWx0aXBsZWAgdG8gc2libGluZ3MgaWYgd2UgaGF2ZSBhIHZhbGlkIG11bHRpcGxlIG5hbWVcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICQoJ2lucHV0W25hbWU9XCInICsgbmFtZSArICdcIl0nKS5lYWNoKGZ1bmN0aW9uIChpLCBpbnB1dCkge1xuICAgICAgICAgIHZhciB0eXBlID0gVXRpbHMuZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JykgaW5wdXQuc2V0QXR0cmlidXRlKF90aGlzMTMub3B0aW9ucy5uYW1lc3BhY2UgKyAnbXVsdGlwbGUnLCBfdGhpczEzLm9wdGlvbnMubXVsdGlwbGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaGVyZSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZWxhdGVkIG11bHRpcGxlIGluc3RhbmNlIHNhdmVkXG4gICAgICB2YXIgJHByZXZpb3VzbHlSZWxhdGVkID0gdGhpcy5fZmluZFJlbGF0ZWQoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHByZXZpb3VzbHlSZWxhdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnNsZXlNdWx0aXBsZUluc3RhbmNlID0gJCgkcHJldmlvdXNseVJlbGF0ZWQuZ2V0KGkpKS5kYXRhKCdQYXJzbGV5Jyk7XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcnNsZXlNdWx0aXBsZUluc3RhbmNlKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuZGF0YSgnRmllbGRNdWx0aXBsZScpKSB7XG4gICAgICAgICAgICBwYXJzbGV5TXVsdGlwbGVJbnN0YW5jZS5hZGRFbGVtZW50KHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIHNlY3JldCBGaWVsZCBpbnN0YW5jZSBmb3IgZXZlcnkgbXVsdGlwbGUgZmllbGQuIEl0IHdpbGwgYmUgc3RvcmVkIGluIGBkYXRhKCdGaWVsZE11bHRpcGxlJylgXG4gICAgICAvLyBBbmQgd2lsbCBiZSB1c2VmdWwgbGF0ZXIgdG8gYWNjZXNzIGNsYXNzaWMgYEZpZWxkYCBzdHVmZiB3aGlsZSBiZWluZyBpbiBhIGBGaWVsZE11bHRpcGxlYCBpbnN0YW5jZVxuICAgICAgdGhpcy5iaW5kKCdwYXJzbGV5RmllbGQnLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIHBhcnNsZXlNdWx0aXBsZUluc3RhbmNlIHx8IHRoaXMuYmluZCgncGFyc2xleUZpZWxkTXVsdGlwbGUnKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHByb3BlciBgRm9ybWAsIGBGaWVsZGAgb3IgYEZpZWxkTXVsdGlwbGVgXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0eXBlLCBkb05vdFN0b3JlKSB7XG4gICAgICB2YXIgcGFyc2xleUluc3RhbmNlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncGFyc2xleUZvcm0nOlxuICAgICAgICAgIHBhcnNsZXlJbnN0YW5jZSA9ICQuZXh0ZW5kKG5ldyBGb3JtKHRoaXMuZWxlbWVudCwgdGhpcy5kb21PcHRpb25zLCB0aGlzLm9wdGlvbnMpLCBuZXcgQmFzZSgpLCB3aW5kb3cuUGFyc2xleUV4dGVuZCkuX2JpbmRGaWVsZHMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncGFyc2xleUZpZWxkJzpcbiAgICAgICAgICBwYXJzbGV5SW5zdGFuY2UgPSAkLmV4dGVuZChuZXcgcGFyc2xleV9maWVsZCh0aGlzLmVsZW1lbnQsIHRoaXMuZG9tT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLnBhcmVudCksIG5ldyBCYXNlKCksIHdpbmRvdy5QYXJzbGV5RXh0ZW5kKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncGFyc2xleUZpZWxkTXVsdGlwbGUnOlxuICAgICAgICAgIHBhcnNsZXlJbnN0YW5jZSA9ICQuZXh0ZW5kKG5ldyBwYXJzbGV5X2ZpZWxkKHRoaXMuZWxlbWVudCwgdGhpcy5kb21PcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMucGFyZW50KSwgbmV3IE11bHRpcGxlKCksIG5ldyBCYXNlKCksIHdpbmRvdy5QYXJzbGV5RXh0ZW5kKS5faW5pdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgJ2lzIG5vdCBhIHN1cHBvcnRlZCBQYXJzbGV5IHR5cGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tdWx0aXBsZSkgVXRpbHMuc2V0QXR0cih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsICdtdWx0aXBsZScsIHRoaXMub3B0aW9ucy5tdWx0aXBsZSk7XG5cbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvTm90U3RvcmUpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCdGaWVsZE11bHRpcGxlJywgcGFyc2xleUluc3RhbmNlKTtcblxuICAgICAgICByZXR1cm4gcGFyc2xleUluc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgZnJlc2hseSBib3VuZCBpbnN0YW5jZSBpbiBhIERPTSBlbGVtZW50IGZvciBsYXRlciBhY2Nlc3MgdXNpbmcgalF1ZXJ5IGBkYXRhKClgXG4gICAgICB0aGlzLiRlbGVtZW50LmRhdGEoJ1BhcnNsZXknLCBwYXJzbGV5SW5zdGFuY2UpO1xuXG4gICAgICAvLyBUZWxsIHRoZSB3b3JsZCB3ZSBoYXZlIGEgbmV3IEZvcm0gb3IgRmllbGQgaW5zdGFuY2UhXG4gICAgICBwYXJzbGV5SW5zdGFuY2UuX2FjdHVhbGl6ZVRyaWdnZXJzKCk7XG4gICAgICBwYXJzbGV5SW5zdGFuY2UuX3RyaWdnZXIoJ2luaXQnKTtcblxuICAgICAgcmV0dXJuIHBhcnNsZXlJbnN0YW5jZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHZlcm51bXMgPSAkLmZuLmpxdWVyeS5zcGxpdCgnLicpO1xuICBpZiAocGFyc2VJbnQodmVybnVtc1swXSkgPD0gMSAmJiBwYXJzZUludCh2ZXJudW1zWzFdKSA8IDgpIHtcbiAgICB0aHJvdyBcIlRoZSBsb2FkZWQgdmVyc2lvbiBvZiBqUXVlcnkgaXMgdG9vIG9sZC4gUGxlYXNlIHVwZ3JhZGUgdG8gMS44Lnggb3IgYmV0dGVyLlwiO1xuICB9XG4gIGlmICghdmVybnVtcy5mb3JFYWNoKSB7XG4gICAgVXRpbHMud2FybignUGFyc2xleSByZXF1aXJlcyBFUzUgdG8gcnVuIHByb3Blcmx5LiBQbGVhc2UgaW5jbHVkZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0nKTtcbiAgfVxuICAvLyBJbmhlcml0IGBvbmAsIGBvZmZgICYgYHRyaWdnZXJgIHRvIFBhcnNsZXk6XG4gIHZhciBQYXJzbGV5ID0gX2V4dGVuZHMobmV3IEJhc2UoKSwge1xuICAgIGVsZW1lbnQ6IGRvY3VtZW50LFxuICAgICRlbGVtZW50OiAkKGRvY3VtZW50KSxcbiAgICBhY3R1YWxpemVPcHRpb25zOiBudWxsLFxuICAgIF9yZXNldE9wdGlvbnM6IG51bGwsXG4gICAgRmFjdG9yeTogRmFjdG9yeSxcbiAgICB2ZXJzaW9uOiAnMi44LjEnXG4gIH0pO1xuXG4gIC8vIFN1cHBsZW1lbnQgRmllbGQgYW5kIEZvcm0gd2l0aCBCYXNlXG4gIC8vIFRoaXMgd2F5LCB0aGUgY29uc3RydWN0b3JzIHdpbGwgaGF2ZSBhY2Nlc3MgdG8gdGhvc2UgbWV0aG9kc1xuICBfZXh0ZW5kcyhwYXJzbGV5X2ZpZWxkLnByb3RvdHlwZSwgVUkuRmllbGQsIEJhc2UucHJvdG90eXBlKTtcbiAgX2V4dGVuZHMoRm9ybS5wcm90b3R5cGUsIFVJLkZvcm0sIEJhc2UucHJvdG90eXBlKTtcbiAgLy8gSW5oZXJpdCBhY3R1YWxpemVPcHRpb25zIGFuZCBfcmVzZXRPcHRpb25zOlxuICBfZXh0ZW5kcyhGYWN0b3J5LnByb3RvdHlwZSwgQmFzZS5wcm90b3R5cGUpO1xuXG4gIC8vICMjIyBqUXVlcnkgQVBJXG4gIC8vIGAkKCcuZWxlbScpLnBhcnNsZXkob3B0aW9ucylgIG9yIGAkKCcuZWxlbScpLnBzbHkob3B0aW9ucylgXG4gICQuZm4ucGFyc2xleSA9ICQuZm4ucHNseSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZXMucHVzaCgkKHRoaXMpLnBhcnNsZXkob3B0aW9ucykpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiBhcHBsaWVkIHRvIG5vbiBleGlzdGluZyBET00gZWxlbWVudFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGYWN0b3J5KHRoaXNbMF0sIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vICMjIyBGaWVsZCBhbmQgRm9ybSBleHRlbnNpb25cbiAgLy8gRW5zdXJlIHRoZSBleHRlbnNpb24gaXMgbm93IGRlZmluZWQgaWYgaXQgd2Fzbid0IHByZXZpb3VzbHlcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2Ygd2luZG93LlBhcnNsZXlFeHRlbmQpIHdpbmRvdy5QYXJzbGV5RXh0ZW5kID0ge307XG5cbiAgLy8gIyMjIFBhcnNsZXkgY29uZmlnXG4gIC8vIEluaGVyaXQgZnJvbSBQYXJzbGV5RGVmYXVsdCwgYW5kIGNvcHkgb3ZlciBhbnkgZXhpc3RpbmcgdmFsdWVzXG4gIFBhcnNsZXkub3B0aW9ucyA9IF9leHRlbmRzKFV0aWxzLm9iamVjdENyZWF0ZShEZWZhdWx0cyksIHdpbmRvdy5QYXJzbGV5Q29uZmlnKTtcbiAgd2luZG93LlBhcnNsZXlDb25maWcgPSBQYXJzbGV5Lm9wdGlvbnM7IC8vIE9sZCB3YXkgb2YgYWNjZXNzaW5nIGdsb2JhbCBvcHRpb25zXG5cbiAgLy8gIyMjIEdsb2JhbHNcbiAgd2luZG93LlBhcnNsZXkgPSB3aW5kb3cucHNseSA9IFBhcnNsZXk7XG4gIFBhcnNsZXkuVXRpbHMgPSBVdGlscztcbiAgd2luZG93LlBhcnNsZXlVdGlscyA9IHt9O1xuICAkLmVhY2goVXRpbHMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgd2luZG93LlBhcnNsZXlVdGlsc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBVdGlscy53YXJuT25jZSgnQWNjZXNzaW5nIGB3aW5kb3cuUGFyc2xleVV0aWxzYCBpcyBkZXByZWNhdGVkLiBVc2UgYHdpbmRvdy5QYXJzbGV5LlV0aWxzYCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gVXRpbHNba2V5XS5hcHBseShVdGlscywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyAjIyMgRGVmaW5lIG1ldGhvZHMgdGhhdCBmb3J3YXJkIHRvIHRoZSByZWdpc3RyeSwgYW5kIGRlcHJlY2F0ZSBhbGwgYWNjZXNzIGV4Y2VwdCB0aHJvdWdoIHdpbmRvdy5QYXJzbGV5XG4gIHZhciByZWdpc3RyeSA9IHdpbmRvdy5QYXJzbGV5Ll92YWxpZGF0b3JSZWdpc3RyeSA9IG5ldyBWYWxpZGF0b3JSZWdpc3RyeSh3aW5kb3cuUGFyc2xleUNvbmZpZy52YWxpZGF0b3JzLCB3aW5kb3cuUGFyc2xleUNvbmZpZy5pMThuKTtcbiAgd2luZG93LlBhcnNsZXlWYWxpZGF0b3IgPSB7fTtcbiAgJC5lYWNoKCdzZXRMb2NhbGUgYWRkQ2F0YWxvZyBhZGRNZXNzYWdlIGFkZE1lc3NhZ2VzIGdldEVycm9yTWVzc2FnZSBmb3JtYXRNZXNzYWdlIGFkZFZhbGlkYXRvciB1cGRhdGVWYWxpZGF0b3IgcmVtb3ZlVmFsaWRhdG9yIGhhc1ZhbGlkYXRvcicuc3BsaXQoJyAnKSwgZnVuY3Rpb24gKGksIG1ldGhvZCkge1xuICAgIHdpbmRvdy5QYXJzbGV5W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVnaXN0cnlbbWV0aG9kXS5hcHBseShyZWdpc3RyeSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHdpbmRvdy5QYXJzbGV5VmFsaWRhdG9yW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3dpbmRvdyRQYXJzbGV5O1xuXG4gICAgICBVdGlscy53YXJuT25jZSgnQWNjZXNzaW5nIHRoZSBtZXRob2QgXFwnJyArIG1ldGhvZCArICdcXCcgdGhyb3VnaCBWYWxpZGF0b3IgaXMgZGVwcmVjYXRlZC4gU2ltcGx5IGNhbGwgXFwnd2luZG93LlBhcnNsZXkuJyArIG1ldGhvZCArICcoLi4uKVxcJycpO1xuICAgICAgcmV0dXJuIChfd2luZG93JFBhcnNsZXkgPSB3aW5kb3cuUGFyc2xleSlbbWV0aG9kXS5hcHBseShfd2luZG93JFBhcnNsZXksIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gIyMjIFVJXG4gIC8vIERlcHJlY2F0ZWQgZ2xvYmFsIG9iamVjdFxuICB3aW5kb3cuUGFyc2xleS5VSSA9IFVJO1xuICB3aW5kb3cuUGFyc2xleVVJID0ge1xuICAgIHJlbW92ZUVycm9yOiBmdW5jdGlvbiByZW1vdmVFcnJvcihpbnN0YW5jZSwgbmFtZSwgZG9Ob3RVcGRhdGVDbGFzcykge1xuICAgICAgdmFyIHVwZGF0ZUNsYXNzID0gdHJ1ZSAhPT0gZG9Ob3RVcGRhdGVDbGFzcztcbiAgICAgIFV0aWxzLndhcm5PbmNlKCdBY2Nlc3NpbmcgVUkgaXMgZGVwcmVjYXRlZC4gQ2FsbCBcXCdyZW1vdmVFcnJvclxcJyBvbiB0aGUgaW5zdGFuY2UgZGlyZWN0bHkuIFBsZWFzZSBjb21tZW50IGluIGlzc3VlIDEwNzMgYXMgdG8geW91ciBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QuJyk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucmVtb3ZlRXJyb3IobmFtZSwgeyB1cGRhdGVDbGFzczogdXBkYXRlQ2xhc3MgfSk7XG4gICAgfSxcbiAgICBnZXRFcnJvcnNNZXNzYWdlczogZnVuY3Rpb24gZ2V0RXJyb3JzTWVzc2FnZXMoaW5zdGFuY2UpIHtcbiAgICAgIFV0aWxzLndhcm5PbmNlKCdBY2Nlc3NpbmcgVUkgaXMgZGVwcmVjYXRlZC4gQ2FsbCBcXCdnZXRFcnJvcnNNZXNzYWdlc1xcJyBvbiB0aGUgaW5zdGFuY2UgZGlyZWN0bHkuJyk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0RXJyb3JzTWVzc2FnZXMoKTtcbiAgICB9XG4gIH07XG4gICQuZWFjaCgnYWRkRXJyb3IgdXBkYXRlRXJyb3InLnNwbGl0KCcgJyksIGZ1bmN0aW9uIChpLCBtZXRob2QpIHtcbiAgICB3aW5kb3cuUGFyc2xleVVJW21ldGhvZF0gPSBmdW5jdGlvbiAoaW5zdGFuY2UsIG5hbWUsIG1lc3NhZ2UsIGFzc2VydCwgZG9Ob3RVcGRhdGVDbGFzcykge1xuICAgICAgdmFyIHVwZGF0ZUNsYXNzID0gdHJ1ZSAhPT0gZG9Ob3RVcGRhdGVDbGFzcztcbiAgICAgIFV0aWxzLndhcm5PbmNlKCdBY2Nlc3NpbmcgVUkgaXMgZGVwcmVjYXRlZC4gQ2FsbCBcXCcnICsgbWV0aG9kICsgJ1xcJyBvbiB0aGUgaW5zdGFuY2UgZGlyZWN0bHkuIFBsZWFzZSBjb21tZW50IGluIGlzc3VlIDEwNzMgYXMgdG8geW91ciBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QuJyk7XG4gICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXShuYW1lLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGFzc2VydDogYXNzZXJ0LCB1cGRhdGVDbGFzczogdXBkYXRlQ2xhc3MgfSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gIyMjIFBBUlNMRVkgYXV0by1iaW5kaW5nXG4gIC8vIFByZXZlbnQgaXQgYnkgc2V0dGluZyBgUGFyc2xleUNvbmZpZy5hdXRvQmluZGAgdG8gYGZhbHNlYFxuICBpZiAoZmFsc2UgIT09IHdpbmRvdy5QYXJzbGV5Q29uZmlnLmF1dG9CaW5kKSB7XG4gICAgJChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBXb3JrcyBvbmx5IG9uIGBkYXRhLXBhcnNsZXktdmFsaWRhdGVgLlxuICAgICAgaWYgKCQoJ1tkYXRhLXBhcnNsZXktdmFsaWRhdGVdJykubGVuZ3RoKSAkKCdbZGF0YS1wYXJzbGV5LXZhbGlkYXRlXScpLnBhcnNsZXkoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBvID0gJCh7fSk7XG4gIHZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBVdGlscy53YXJuT25jZShcIlBhcnNsZXkncyBwdWJzdWIgbW9kdWxlIGlzIGRlcHJlY2F0ZWQ7IHVzZSB0aGUgJ29uJyBhbmQgJ29mZicgbWV0aG9kcyBvbiBwYXJzbGV5IGluc3RhbmNlcyBvciB3aW5kb3cuUGFyc2xleVwiKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCBjYWxscyBgZm5gIHdpdGggdGhlIGFyZ3VtZW50cyBpdCBleHBlY3RzXG4gIGZ1bmN0aW9uIGFkYXB0KGZuLCBjb250ZXh0KSB7XG4gICAgLy8gU3RvcmUgdG8gYWxsb3cgdW5iaW5kaW5nXG4gICAgaWYgKCFmbi5wYXJzbGV5QWRhcHRlZENhbGxiYWNrKSB7XG4gICAgICBmbi5wYXJzbGV5QWRhcHRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgZm4uYXBwbHkoY29udGV4dCB8fCBvLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmbi5wYXJzbGV5QWRhcHRlZENhbGxiYWNrO1xuICB9XG5cbiAgdmFyIGV2ZW50UHJlZml4ID0gJ3BhcnNsZXk6JztcbiAgLy8gQ29udmVydHMgJ3BhcnNsZXk6Zm9ybTp2YWxpZGF0ZScgaW50byAnZm9ybTp2YWxpZGF0ZSdcbiAgZnVuY3Rpb24gZXZlbnROYW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZS5sYXN0SW5kZXhPZihldmVudFByZWZpeCwgMCkgPT09IDApIHJldHVybiBuYW1lLnN1YnN0cihldmVudFByZWZpeC5sZW5ndGgpO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgLy8gJC5saXN0ZW4gaXMgZGVwcmVjYXRlZC4gVXNlIFBhcnNsZXkub24gaW5zdGVhZC5cbiAgJC5saXN0ZW4gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgY29udGV4dDtcbiAgICBkZXByZWNhdGVkKCk7XG4gICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgYXJndW1lbnRzWzFdICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmd1bWVudHNbMl0pIHtcbiAgICAgIGNvbnRleHQgPSBhcmd1bWVudHNbMV07XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNhbGxiYWNrKSB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHBhcmFtZXRlcnMnKTtcblxuICAgIHdpbmRvdy5QYXJzbGV5Lm9uKGV2ZW50TmFtZShuYW1lKSwgYWRhcHQoY2FsbGJhY2ssIGNvbnRleHQpKTtcbiAgfTtcblxuICAkLmxpc3RlblRvID0gZnVuY3Rpb24gKGluc3RhbmNlLCBuYW1lLCBmbikge1xuICAgIGRlcHJlY2F0ZWQoKTtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIHBhcnNsZXlfZmllbGQpICYmICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBGb3JtKSkgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGdpdmUgUGFyc2xleSBpbnN0YW5jZScpO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignV3JvbmcgcGFyYW1ldGVycycpO1xuXG4gICAgaW5zdGFuY2Uub24oZXZlbnROYW1lKG5hbWUpLCBhZGFwdChmbikpO1xuICB9O1xuXG4gICQudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICBkZXByZWNhdGVkKCk7XG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignV3JvbmcgYXJndW1lbnRzJyk7XG4gICAgd2luZG93LlBhcnNsZXkub2ZmKGV2ZW50TmFtZShuYW1lKSwgZm4ucGFyc2xleUFkYXB0ZWRDYWxsYmFjayk7XG4gIH07XG5cbiAgJC51bnN1YnNjcmliZVRvID0gZnVuY3Rpb24gKGluc3RhbmNlLCBuYW1lKSB7XG4gICAgZGVwcmVjYXRlZCgpO1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgcGFyc2xleV9maWVsZCkgJiYgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEZvcm0pKSB0aHJvdyBuZXcgRXJyb3IoJ011c3QgZ2l2ZSBQYXJzbGV5IGluc3RhbmNlJyk7XG4gICAgaW5zdGFuY2Uub2ZmKGV2ZW50TmFtZShuYW1lKSk7XG4gIH07XG5cbiAgJC51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVwcmVjYXRlZCgpO1xuICAgIHdpbmRvdy5QYXJzbGV5Lm9mZihldmVudE5hbWUobmFtZSkpO1xuICAgICQoJ2Zvcm0saW5wdXQsdGV4dGFyZWEsc2VsZWN0JykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSAkKHRoaXMpLmRhdGEoJ1BhcnNsZXknKTtcbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS5vZmYoZXZlbnROYW1lKG5hbWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyAkLmVtaXQgaXMgZGVwcmVjYXRlZC4gVXNlIGpRdWVyeSBldmVudHMgaW5zdGVhZC5cbiAgJC5lbWl0ID0gZnVuY3Rpb24gKG5hbWUsIGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZTtcblxuICAgIGRlcHJlY2F0ZWQoKTtcbiAgICB2YXIgaW5zdGFuY2VHaXZlbiA9IGluc3RhbmNlIGluc3RhbmNlb2YgcGFyc2xleV9maWVsZCB8fCBpbnN0YW5jZSBpbnN0YW5jZW9mIEZvcm07XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIGluc3RhbmNlR2l2ZW4gPyAyIDogMSk7XG4gICAgYXJncy51bnNoaWZ0KGV2ZW50TmFtZShuYW1lKSk7XG4gICAgaWYgKCFpbnN0YW5jZUdpdmVuKSB7XG4gICAgICBpbnN0YW5jZSA9IHdpbmRvdy5QYXJzbGV5O1xuICAgIH1cbiAgICAoX2luc3RhbmNlID0gaW5zdGFuY2UpLnRyaWdnZXIuYXBwbHkoX2luc3RhbmNlLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICB9O1xuXG4gIHZhciBwdWJzdWIgPSB7fTtcblxuICAkLmV4dGVuZCh0cnVlLCBQYXJzbGV5LCB7XG4gICAgYXN5bmNWYWxpZGF0b3JzOiB7XG4gICAgICAnZGVmYXVsdCc6IHtcbiAgICAgICAgZm46IGZ1bmN0aW9uIGZuKHhocikge1xuICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIG9ubHkgc3RhdHVzIDJ4eCBhcmUgZGVlbWVkIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAgLy8gTm90ZTogd2UgdXNlIHN0YXR1cyBpbnN0ZWFkIG9mIHN0YXRlKCkgYmVjYXVzZSByZXNwb25zZXMgd2l0aCBzdGF0dXMgMjAwXG4gICAgICAgICAgLy8gYnV0IGludmFsaWQgbWVzc2FnZXMgKGUuZy4gYW4gZW1wdHkgYm9keSBmb3IgY29udGVudCB0eXBlIHNldCB0byBKU09OKSB3aWxsXG4gICAgICAgICAgLy8gcmVzdWx0IGluIHN0YXRlKCkgPT09ICdyZWplY3RlZCcuXG4gICAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDA7XG4gICAgICAgIH0sXG4gICAgICAgIHVybDogZmFsc2VcbiAgICAgIH0sXG4gICAgICByZXZlcnNlOiB7XG4gICAgICAgIGZuOiBmdW5jdGlvbiBmbih4aHIpIHtcbiAgICAgICAgICAvLyBJZiByZXZlcnNlIG9wdGlvbiBpcyBzZXQsIGEgZmFpbGluZyBhamF4IHJlcXVlc3QgaXMgY29uc2lkZXJlZCBzdWNjZXNzZnVsXG4gICAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+PSAzMDA7XG4gICAgICAgIH0sXG4gICAgICAgIHVybDogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkQXN5bmNWYWxpZGF0b3I6IGZ1bmN0aW9uIGFkZEFzeW5jVmFsaWRhdG9yKG5hbWUsIGZuLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgIFBhcnNsZXkuYXN5bmNWYWxpZGF0b3JzW25hbWVdID0ge1xuICAgICAgICBmbjogZm4sXG4gICAgICAgIHVybDogdXJsIHx8IGZhbHNlLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfSk7XG5cbiAgUGFyc2xleS5hZGRWYWxpZGF0b3IoJ3JlbW90ZScsIHtcbiAgICByZXF1aXJlbWVudFR5cGU6IHtcbiAgICAgICcnOiAnc3RyaW5nJyxcbiAgICAgICd2YWxpZGF0b3InOiAnc3RyaW5nJyxcbiAgICAgICdyZXZlcnNlJzogJ2Jvb2xlYW4nLFxuICAgICAgJ29wdGlvbnMnOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIHVybCwgb3B0aW9ucywgaW5zdGFuY2UpIHtcbiAgICAgIHZhciBkYXRhID0ge307XG4gICAgICB2YXIgYWpheE9wdGlvbnM7XG4gICAgICB2YXIgY3NyO1xuICAgICAgdmFyIHZhbGlkYXRvciA9IG9wdGlvbnMudmFsaWRhdG9yIHx8ICh0cnVlID09PSBvcHRpb25zLnJldmVyc2UgPyAncmV2ZXJzZScgOiAnZGVmYXVsdCcpO1xuXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBQYXJzbGV5LmFzeW5jVmFsaWRhdG9yc1t2YWxpZGF0b3JdKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgYW4gdW5kZWZpbmVkIGFzeW5jIHZhbGlkYXRvcjogYCcgKyB2YWxpZGF0b3IgKyAnYCcpO1xuXG4gICAgICB1cmwgPSBQYXJzbGV5LmFzeW5jVmFsaWRhdG9yc1t2YWxpZGF0b3JdLnVybCB8fCB1cmw7XG5cbiAgICAgIC8vIEZpbGwgY3VycmVudCB2YWx1ZVxuICAgICAgaWYgKHVybC5pbmRleE9mKCd7dmFsdWV9JykgPiAtMSkge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgne3ZhbHVlfScsIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbnN0YW5jZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8IGluc3RhbmNlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBNZXJnZSBvcHRpb25zIHBhc3NlZCBpbiBmcm9tIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBvbmVzIGluIHRoZSBhdHRyaWJ1dGVcbiAgICAgIHZhciByZW1vdGVPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwgb3B0aW9ucy5vcHRpb25zIHx8IHt9LCBQYXJzbGV5LmFzeW5jVmFsaWRhdG9yc1t2YWxpZGF0b3JdLm9wdGlvbnMpO1xuXG4gICAgICAvLyBBbGwgYCQuYWpheChvcHRpb25zKWAgY291bGQgYmUgb3ZlcnJpZGRlbiBvciBleHRlbmRlZCBkaXJlY3RseSBmcm9tIERPTSBpbiBgZGF0YS1wYXJzbGV5LXJlbW90ZS1vcHRpb25zYFxuICAgICAgYWpheE9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdHlwZTogJ0dFVCdcbiAgICAgIH0sIHJlbW90ZU9wdGlvbnMpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBzdG9yZSBrZXkgYmFzZWQgb24gYWpheCBvcHRpb25zXG4gICAgICBpbnN0YW5jZS50cmlnZ2VyKCdmaWVsZDphamF4b3B0aW9ucycsIGluc3RhbmNlLCBhamF4T3B0aW9ucyk7XG5cbiAgICAgIGNzciA9ICQucGFyYW0oYWpheE9wdGlvbnMpO1xuXG4gICAgICAvLyBJbml0aWFsaXNlIHF1ZXJyeSBjYWNoZVxuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgUGFyc2xleS5fcmVtb3RlQ2FjaGUpIFBhcnNsZXkuX3JlbW90ZUNhY2hlID0ge307XG5cbiAgICAgIC8vIFRyeSB0byByZXRyaWV2ZSBzdG9yZWQgeGhyXG4gICAgICB2YXIgeGhyID0gUGFyc2xleS5fcmVtb3RlQ2FjaGVbY3NyXSA9IFBhcnNsZXkuX3JlbW90ZUNhY2hlW2Nzcl0gfHwgJC5hamF4KGFqYXhPcHRpb25zKTtcblxuICAgICAgdmFyIGhhbmRsZVhociA9IGZ1bmN0aW9uIGhhbmRsZVhocigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFBhcnNsZXkuYXN5bmNWYWxpZGF0b3JzW3ZhbGlkYXRvcl0uZm4uY2FsbChpbnN0YW5jZSwgeGhyLCB1cmwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3VsdCkgLy8gTWFwIGZhbHN5IHJlc3VsdHMgdG8gcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgICAgIHJlc3VsdCA9ICQuRGVmZXJyZWQoKS5yZWplY3QoKTtcbiAgICAgICAgcmV0dXJuICQud2hlbihyZXN1bHQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHhoci50aGVuKGhhbmRsZVhociwgaGFuZGxlWGhyKTtcbiAgICB9LFxuXG4gICAgcHJpb3JpdHk6IC0xXG4gIH0pO1xuXG4gIFBhcnNsZXkub24oJ2Zvcm06c3VibWl0JywgZnVuY3Rpb24gKCkge1xuICAgIFBhcnNsZXkuX3JlbW90ZUNhY2hlID0ge307XG4gIH0pO1xuXG4gIEJhc2UucHJvdG90eXBlLmFkZEFzeW5jVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIFV0aWxzLndhcm5PbmNlKCdBY2Nlc3NpbmcgdGhlIG1ldGhvZCBgYWRkQXN5bmNWYWxpZGF0b3JgIHRocm91Z2ggYW4gaW5zdGFuY2UgaXMgZGVwcmVjYXRlZC4gU2ltcGx5IGNhbGwgYFBhcnNsZXkuYWRkQXN5bmNWYWxpZGF0b3IoLi4uKWAnKTtcbiAgICByZXR1cm4gUGFyc2xleS5hZGRBc3luY1ZhbGlkYXRvci5hcHBseShQYXJzbGV5LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgaW5jbHVkZWQgd2l0aCB0aGUgUGFyc2xleSBsaWJyYXJ5IGl0c2VsZixcbiAgLy8gdGh1cyB0aGVyZSBpcyBubyB1c2UgaW4gYWRkaW5nIGl0IHRvIHlvdXIgcHJvamVjdC5cbiAgUGFyc2xleS5hZGRNZXNzYWdlcygnZW4nLCB7XG4gICAgZGVmYXVsdE1lc3NhZ2U6IFwiVGhpcyB2YWx1ZSBzZWVtcyB0byBiZSBpbnZhbGlkLlwiLFxuICAgIHR5cGU6IHtcbiAgICAgIGVtYWlsOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgZW1haWwuXCIsXG4gICAgICB1cmw6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCB1cmwuXCIsXG4gICAgICBudW1iZXI6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCBudW1iZXIuXCIsXG4gICAgICBpbnRlZ2VyOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgaW50ZWdlci5cIixcbiAgICAgIGRpZ2l0czogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBkaWdpdHMuXCIsXG4gICAgICBhbHBoYW51bTogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhbHBoYW51bWVyaWMuXCJcbiAgICB9LFxuICAgIG5vdGJsYW5rOiBcIlRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSBibGFuay5cIixcbiAgICByZXF1aXJlZDogXCJUaGlzIHZhbHVlIGlzIHJlcXVpcmVkLlwiLFxuICAgIHBhdHRlcm46IFwiVGhpcyB2YWx1ZSBzZWVtcyB0byBiZSBpbnZhbGlkLlwiLFxuICAgIG1pbjogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJXMuXCIsXG4gICAgbWF4OiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gJXMuXCIsXG4gICAgcmFuZ2U6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYmV0d2VlbiAlcyBhbmQgJXMuXCIsXG4gICAgbWlubGVuZ3RoOiBcIlRoaXMgdmFsdWUgaXMgdG9vIHNob3J0LiBJdCBzaG91bGQgaGF2ZSAlcyBjaGFyYWN0ZXJzIG9yIG1vcmUuXCIsXG4gICAgbWF4bGVuZ3RoOiBcIlRoaXMgdmFsdWUgaXMgdG9vIGxvbmcuIEl0IHNob3VsZCBoYXZlICVzIGNoYXJhY3RlcnMgb3IgZmV3ZXIuXCIsXG4gICAgbGVuZ3RoOiBcIlRoaXMgdmFsdWUgbGVuZ3RoIGlzIGludmFsaWQuIEl0IHNob3VsZCBiZSBiZXR3ZWVuICVzIGFuZCAlcyBjaGFyYWN0ZXJzIGxvbmcuXCIsXG4gICAgbWluY2hlY2s6IFwiWW91IG11c3Qgc2VsZWN0IGF0IGxlYXN0ICVzIGNob2ljZXMuXCIsXG4gICAgbWF4Y2hlY2s6IFwiWW91IG11c3Qgc2VsZWN0ICVzIGNob2ljZXMgb3IgZmV3ZXIuXCIsXG4gICAgY2hlY2s6IFwiWW91IG11c3Qgc2VsZWN0IGJldHdlZW4gJXMgYW5kICVzIGNob2ljZXMuXCIsXG4gICAgZXF1YWx0bzogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSB0aGUgc2FtZS5cIlxuICB9KTtcblxuICBQYXJzbGV5LnNldExvY2FsZSgnZW4nKTtcblxuICAvKipcbiAgICogaW5wdXRldmVudCAtIEFsbGV2aWF0ZSBicm93c2VyIGJ1Z3MgZm9yIGlucHV0IGV2ZW50c1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2FuZHJlL2lucHV0ZXZlbnRcbiAgICogQHZlcnNpb24gdjAuMC4zIC0gKGJ1aWx0IFRodSwgQXByIDE0dGggMjAxNiwgNTo1OCBwbSlcbiAgICogQGF1dGhvciBNYXJjLUFuZHJlIExhZm9ydHVuZSA8Z2l0aHViQG1hcmMtYW5kcmUuY2E+XG4gICAqIEBsaWNlbnNlIE1JVFxuICAgKi9cblxuICBmdW5jdGlvbiBJbnB1dEV2ZW50KCkge1xuICAgIHZhciBfdGhpczE0ID0gdGhpcztcblxuICAgIHZhciBnbG9iYWxzID0gd2luZG93IHx8IGdsb2JhbDtcblxuICAgIC8vIFNsaWdodGx5IG9kZCB3YXkgY29uc3RydWN0IG91ciBvYmplY3QuIFRoaXMgd2F5IG1ldGhvZHMgYXJlIGZvcmNlIGJvdW5kLlxuICAgIC8vIFVzZWQgdG8gdGVzdCBmb3IgZHVwbGljYXRlIGxpYnJhcnkuXG4gICAgX2V4dGVuZHModGhpcywge1xuXG4gICAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpc1RydXN0ZWQsIGFzc3VtZXMgZXZlbnQgaXMgbmF0aXZlLlxuICAgICAgaXNOYXRpdmVFdmVudDogZnVuY3Rpb24gaXNOYXRpdmVFdmVudChldnQpIHtcbiAgICAgICAgcmV0dXJuIGV2dC5vcmlnaW5hbEV2ZW50ICYmIGV2dC5vcmlnaW5hbEV2ZW50LmlzVHJ1c3RlZCAhPT0gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBmYWtlSW5wdXRFdmVudDogZnVuY3Rpb24gZmFrZUlucHV0RXZlbnQoZXZ0KSB7XG4gICAgICAgIGlmIChfdGhpczE0LmlzTmF0aXZlRXZlbnQoZXZ0KSkge1xuICAgICAgICAgICQoZXZ0LnRhcmdldCkudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbWlzYmVoYXZlczogZnVuY3Rpb24gbWlzYmVoYXZlcyhldnQpIHtcbiAgICAgICAgaWYgKF90aGlzMTQuaXNOYXRpdmVFdmVudChldnQpKSB7XG4gICAgICAgICAgX3RoaXMxNC5iZWhhdmVzT2soZXZ0KTtcbiAgICAgICAgICAkKGRvY3VtZW50KS5vbignY2hhbmdlLmlucHV0ZXZlbnQnLCBldnQuZGF0YS5zZWxlY3RvciwgX3RoaXMxNC5mYWtlSW5wdXRFdmVudCk7XG4gICAgICAgICAgX3RoaXMxNC5mYWtlSW5wdXRFdmVudChldnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBiZWhhdmVzT2s6IGZ1bmN0aW9uIGJlaGF2ZXNPayhldnQpIHtcbiAgICAgICAgaWYgKF90aGlzMTQuaXNOYXRpdmVFdmVudChldnQpKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkgLy8gU2ltcGx5IHVuYmluZHMgdGhlIHRlc3RpbmcgaGFuZGxlclxuICAgICAgICAgIC5vZmYoJ2lucHV0LmlucHV0ZXZlbnQnLCBldnQuZGF0YS5zZWxlY3RvciwgX3RoaXMxNC5iZWhhdmVzT2spLm9mZignY2hhbmdlLmlucHV0ZXZlbnQnLCBldnQuZGF0YS5zZWxlY3RvciwgX3RoaXMxNC5taXNiZWhhdmVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gQmluZCB0aGUgdGVzdGluZyBoYW5kbGVyc1xuICAgICAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgaWYgKGdsb2JhbHMuaW5wdXRFdmVudFBhdGNoZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFscy5pbnB1dEV2ZW50UGF0Y2hlZCA9ICcwLjAuMyc7XG4gICAgICAgIHZhciBfYXJyID0gWydzZWxlY3QnLCAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScsICdpbnB1dFt0eXBlPVwiZmlsZVwiXSddO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBfYXJyW19pXTtcbiAgICAgICAgICAkKGRvY3VtZW50KS5vbignaW5wdXQuaW5wdXRldmVudCcsIHNlbGVjdG9yLCB7IHNlbGVjdG9yOiBzZWxlY3RvciB9LCBfdGhpczE0LmJlaGF2ZXNPaykub24oJ2NoYW5nZS5pbnB1dGV2ZW50Jywgc2VsZWN0b3IsIHsgc2VsZWN0b3I6IHNlbGVjdG9yIH0sIF90aGlzMTQubWlzYmVoYXZlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gdW5pbnN0YWxsKCkge1xuICAgICAgICBkZWxldGUgZ2xvYmFscy5pbnB1dEV2ZW50UGF0Y2hlZDtcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKCcuaW5wdXRldmVudCcpO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGlucHV0ZXZlbnQgPSBuZXcgSW5wdXRFdmVudCgpO1xuXG4gIGlucHV0ZXZlbnQuaW5zdGFsbCgpO1xuXG4gIHZhciBwYXJzbGV5ID0gUGFyc2xleTtcblxuICByZXR1cm4gcGFyc2xleTtcbn0pO1xuXG5cbihmdW5jdGlvbih3aW5kb3csIGZhY3RvcnkpIHtcbiAgdmFyIGxhenlTaXplcyA9IGZhY3Rvcnkod2luZG93LCB3aW5kb3cuZG9jdW1lbnQpO1xuICB3aW5kb3cubGF6eVNpemVzID0gbGF6eVNpemVzO1xuICBpZih0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxhenlTaXplcztcbiAgfVxufSh3aW5kb3csIGZ1bmN0aW9uIGwod2luZG93LCBkb2N1bWVudCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gIGlmKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXtyZXR1cm47fVxuXG4gIHZhciBsYXp5c2l6ZXMsIGxhenlTaXplc0NvbmZpZztcblxuICB2YXIgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICB2YXIgRGF0ZSA9IHdpbmRvdy5EYXRlO1xuXG4gIHZhciBzdXBwb3J0UGljdHVyZSA9IHdpbmRvdy5IVE1MUGljdHVyZUVsZW1lbnQ7XG5cbiAgdmFyIF9hZGRFdmVudExpc3RlbmVyID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xuXG4gIHZhciBfZ2V0QXR0cmlidXRlID0gJ2dldEF0dHJpYnV0ZSc7XG5cbiAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3dbX2FkZEV2ZW50TGlzdGVuZXJdO1xuXG4gIHZhciBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG5cbiAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgc2V0VGltZW91dDtcblxuICB2YXIgcmVxdWVzdElkbGVDYWxsYmFjayA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuXG4gIHZhciByZWdQaWN0dXJlID0gL15waWN0dXJlJC9pO1xuXG4gIHZhciBsb2FkRXZlbnRzID0gWydsb2FkJywgJ2Vycm9yJywgJ2xhenlpbmNsdWRlZCcsICdfbGF6eWxvYWRlZCddO1xuXG4gIHZhciByZWdDbGFzc0NhY2hlID0ge307XG5cbiAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcblxuICB2YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbihlbGUsIGNscykge1xuICAgIGlmKCFyZWdDbGFzc0NhY2hlW2Nsc10pe1xuICAgICAgcmVnQ2xhc3NDYWNoZVtjbHNdID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJytjbHMrJyhcXFxcc3wkKScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnQ2xhc3NDYWNoZVtjbHNdLnRlc3QoZWxlW19nZXRBdHRyaWJ1dGVdKCdjbGFzcycpIHx8ICcnKSAmJiByZWdDbGFzc0NhY2hlW2Nsc107XG4gIH07XG5cbiAgdmFyIGFkZENsYXNzID0gZnVuY3Rpb24oZWxlLCBjbHMpIHtcbiAgICBpZiAoIWhhc0NsYXNzKGVsZSwgY2xzKSl7XG4gICAgICBlbGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIChlbGVbX2dldEF0dHJpYnV0ZV0oJ2NsYXNzJykgfHwgJycpLnRyaW0oKSArICcgJyArIGNscyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsZSwgY2xzKSB7XG4gICAgdmFyIHJlZztcbiAgICBpZiAoKHJlZyA9IGhhc0NsYXNzKGVsZSxjbHMpKSkge1xuICAgICAgZWxlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlW19nZXRBdHRyaWJ1dGVdKCdjbGFzcycpIHx8ICcnKS5yZXBsYWNlKHJlZywgJyAnKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhZGRSZW1vdmVMb2FkRXZlbnRzID0gZnVuY3Rpb24oZG9tLCBmbiwgYWRkKXtcbiAgICB2YXIgYWN0aW9uID0gYWRkID8gX2FkZEV2ZW50TGlzdGVuZXIgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgaWYoYWRkKXtcbiAgICAgIGFkZFJlbW92ZUxvYWRFdmVudHMoZG9tLCBmbik7XG4gICAgfVxuICAgIGxvYWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldnQpe1xuICAgICAgZG9tW2FjdGlvbl0oZXZ0LCBmbik7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGRldGFpbCwgbm9CdWJibGVzLCBub0NhbmNlbGFibGUpe1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXG4gICAgaWYoIWRldGFpbCl7XG4gICAgICBkZXRhaWwgPSB7fTtcbiAgICB9XG5cbiAgICBkZXRhaWwuaW5zdGFuY2UgPSBsYXp5c2l6ZXM7XG5cbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgIW5vQnViYmxlcywgIW5vQ2FuY2VsYWJsZSk7XG5cbiAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG5cbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfTtcblxuICB2YXIgdXBkYXRlUG9seWZpbGwgPSBmdW5jdGlvbiAoZWwsIGZ1bGwpe1xuICAgIHZhciBwb2x5ZmlsbDtcbiAgICBpZiggIXN1cHBvcnRQaWN0dXJlICYmICggcG9seWZpbGwgPSAod2luZG93LnBpY3R1cmVmaWxsIHx8IGxhenlTaXplc0NvbmZpZy5wZikgKSApe1xuICAgICAgaWYoZnVsbCAmJiBmdWxsLnNyYyAmJiAhZWxbX2dldEF0dHJpYnV0ZV0oJ3NyY3NldCcpKXtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzcmNzZXQnLCBmdWxsLnNyYyk7XG4gICAgICB9XG4gICAgICBwb2x5ZmlsbCh7cmVldmFsdWF0ZTogdHJ1ZSwgZWxlbWVudHM6IFtlbF19KTtcbiAgICB9IGVsc2UgaWYoZnVsbCAmJiBmdWxsLnNyYyl7XG4gICAgICBlbC5zcmMgPSBmdWxsLnNyYztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldENTUyA9IGZ1bmN0aW9uIChlbGVtLCBzdHlsZSl7XG4gICAgcmV0dXJuIChnZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpIHx8IHt9KVtzdHlsZV07XG4gIH07XG5cbiAgdmFyIGdldFdpZHRoID0gZnVuY3Rpb24oZWxlbSwgcGFyZW50LCB3aWR0aCl7XG4gICAgd2lkdGggPSB3aWR0aCB8fCBlbGVtLm9mZnNldFdpZHRoO1xuXG4gICAgd2hpbGUod2lkdGggPCBsYXp5U2l6ZXNDb25maWcubWluU2l6ZSAmJiBwYXJlbnQgJiYgIWVsZW0uX2xhenlzaXplc1dpZHRoKXtcbiAgICAgIHdpZHRoID0gIHBhcmVudC5vZmZzZXRXaWR0aDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbiAgfTtcblxuICB2YXIgckFGID0gKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHJ1bm5pbmcsIHdhaXRpbmc7XG4gICAgdmFyIGZpcnN0Rm5zID0gW107XG4gICAgdmFyIHNlY29uZEZucyA9IFtdO1xuICAgIHZhciBmbnMgPSBmaXJzdEZucztcblxuICAgIHZhciBydW4gPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIHJ1bkZucyA9IGZucztcblxuICAgICAgZm5zID0gZmlyc3RGbnMubGVuZ3RoID8gc2Vjb25kRm5zIDogZmlyc3RGbnM7XG5cbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgICB3aGlsZShydW5GbnMubGVuZ3RoKXtcbiAgICAgICAgcnVuRm5zLnNoaWZ0KCkoKTtcbiAgICAgIH1cblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgcmFmQmF0Y2ggPSBmdW5jdGlvbihmbiwgcXVldWUpe1xuICAgICAgaWYocnVubmluZyAmJiAhcXVldWUpe1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm5zLnB1c2goZm4pO1xuXG4gICAgICAgIGlmKCF3YWl0aW5nKXtcbiAgICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAoZG9jdW1lbnQuaGlkZGVuID8gc2V0VGltZW91dCA6IHJlcXVlc3RBbmltYXRpb25GcmFtZSkocnVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByYWZCYXRjaC5fbHNGbHVzaCA9IHJ1bjtcblxuICAgIHJldHVybiByYWZCYXRjaDtcbiAgfSkoKTtcblxuICB2YXIgckFGSXQgPSBmdW5jdGlvbihmbiwgc2ltcGxlKXtcbiAgICByZXR1cm4gc2ltcGxlID9cbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByQUYoZm4pO1xuICAgICAgfSA6XG4gICAgICBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByQUYoZnVuY3Rpb24oKXtcbiAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgO1xuICB9O1xuXG4gIHZhciB0aHJvdHRsZSA9IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgcnVubmluZztcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciBnRGVsYXkgPSBsYXp5U2l6ZXNDb25maWcudGhyb3R0bGVEZWxheTtcbiAgICB2YXIgcklDVGltZW91dCA9IGxhenlTaXplc0NvbmZpZy5yaWNUaW1lb3V0O1xuICAgIHZhciBydW4gPSBmdW5jdGlvbigpe1xuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgZm4oKTtcbiAgICB9O1xuICAgIHZhciBpZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrICYmIHJJQ1RpbWVvdXQgPiA0OSA/XG4gICAgICBmdW5jdGlvbigpe1xuICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKHJ1biwge3RpbWVvdXQ6IHJJQ1RpbWVvdXR9KTtcblxuICAgICAgICBpZihySUNUaW1lb3V0ICE9PSBsYXp5U2l6ZXNDb25maWcucmljVGltZW91dCl7XG4gICAgICAgICAgcklDVGltZW91dCA9IGxhenlTaXplc0NvbmZpZy5yaWNUaW1lb3V0O1xuICAgICAgICB9XG4gICAgICB9IDpcbiAgICAgIHJBRkl0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHNldFRpbWVvdXQocnVuKTtcbiAgICAgIH0sIHRydWUpXG4gICAgO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGlzUHJpb3JpdHkpe1xuICAgICAgdmFyIGRlbGF5O1xuXG4gICAgICBpZigoaXNQcmlvcml0eSA9IGlzUHJpb3JpdHkgPT09IHRydWUpKXtcbiAgICAgICAgcklDVGltZW91dCA9IDMzO1xuICAgICAgfVxuXG4gICAgICBpZihydW5uaW5nKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nID0gIHRydWU7XG5cbiAgICAgIGRlbGF5ID0gZ0RlbGF5IC0gKERhdGUubm93KCkgLSBsYXN0VGltZSk7XG5cbiAgICAgIGlmKGRlbGF5IDwgMCl7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYoaXNQcmlvcml0eSB8fCBkZWxheSA8IDkpe1xuICAgICAgICBpZGxlQ2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoaWRsZUNhbGxiYWNrLCBkZWxheSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvL2Jhc2VkIG9uIGh0dHA6Ly9tb2Rlcm5qYXZhc2NyaXB0LmJsb2dzcG90LmRlLzIwMTMvMDgvYnVpbGRpbmctYmV0dGVyLWRlYm91bmNlLmh0bWxcbiAgdmFyIGRlYm91bmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciB0aW1lb3V0LCB0aW1lc3RhbXA7XG4gICAgdmFyIHdhaXQgPSA5OTtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgZnVuYygpO1xuICAgIH07XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xuICAgICAgICBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAocmVxdWVzdElkbGVDYWxsYmFjayB8fCBydW4pKHJ1bik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvcDtcblxuICAgIHZhciBsYXp5U2l6ZXNEZWZhdWx0cyA9IHtcbiAgICAgIGxhenlDbGFzczogJ2xhenlsb2FkJyxcbiAgICAgIGxvYWRlZENsYXNzOiAnbGF6eWxvYWRlZCcsXG4gICAgICBsb2FkaW5nQ2xhc3M6ICdsYXp5bG9hZGluZycsXG4gICAgICBwcmVsb2FkQ2xhc3M6ICdsYXp5cHJlbG9hZCcsXG4gICAgICBlcnJvckNsYXNzOiAnbGF6eWVycm9yJyxcbiAgICAgIC8vc3RyaWN0Q2xhc3M6ICdsYXp5c3RyaWN0JyxcbiAgICAgIGF1dG9zaXplc0NsYXNzOiAnbGF6eWF1dG9zaXplcycsXG4gICAgICBzcmNBdHRyOiAnZGF0YS1zcmMnLFxuICAgICAgc3Jjc2V0QXR0cjogJ2RhdGEtc3Jjc2V0JyxcbiAgICAgIHNpemVzQXR0cjogJ2RhdGEtc2l6ZXMnLFxuICAgICAgLy9wcmVsb2FkQWZ0ZXJMb2FkOiBmYWxzZSxcbiAgICAgIG1pblNpemU6IDQwLFxuICAgICAgY3VzdG9tTWVkaWE6IHt9LFxuICAgICAgaW5pdDogdHJ1ZSxcbiAgICAgIGV4cEZhY3RvcjogMS41LFxuICAgICAgaEZhYzogMC44LFxuICAgICAgbG9hZE1vZGU6IDIsXG4gICAgICBsb2FkSGlkZGVuOiB0cnVlLFxuICAgICAgcmljVGltZW91dDogMCxcbiAgICAgIHRocm90dGxlRGVsYXk6IDEyNSxcbiAgICB9O1xuXG4gICAgbGF6eVNpemVzQ29uZmlnID0gd2luZG93LmxhenlTaXplc0NvbmZpZyB8fCB3aW5kb3cubGF6eXNpemVzQ29uZmlnIHx8IHt9O1xuXG4gICAgZm9yKHByb3AgaW4gbGF6eVNpemVzRGVmYXVsdHMpe1xuICAgICAgaWYoIShwcm9wIGluIGxhenlTaXplc0NvbmZpZykpe1xuICAgICAgICBsYXp5U2l6ZXNDb25maWdbcHJvcF0gPSBsYXp5U2l6ZXNEZWZhdWx0c1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cubGF6eVNpemVzQ29uZmlnID0gbGF6eVNpemVzQ29uZmlnO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYobGF6eVNpemVzQ29uZmlnLmluaXQpe1xuICAgICAgICBpbml0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG5cbiAgdmFyIGxvYWRlciA9IChmdW5jdGlvbigpe1xuICAgIHZhciBwcmVsb2FkRWxlbXMsIGlzQ29tcGxldGVkLCByZXNldFByZWxvYWRpbmdUaW1lciwgbG9hZE1vZGUsIHN0YXJ0ZWQ7XG5cbiAgICB2YXIgZUx2VywgZWx2SCwgZUx0b3AsIGVMbGVmdCwgZUxyaWdodCwgZUxib3R0b207XG5cbiAgICB2YXIgZGVmYXVsdEV4cGFuZCwgcHJlbG9hZEV4cGFuZCwgaEZhYztcblxuICAgIHZhciByZWdJbWcgPSAvXmltZyQvaTtcbiAgICB2YXIgcmVnSWZyYW1lID0gL15pZnJhbWUkL2k7XG5cbiAgICB2YXIgc3VwcG9ydFNjcm9sbCA9ICgnb25zY3JvbGwnIGluIHdpbmRvdykgJiYgISgvKGdsZXxpbmcpYm90Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcblxuICAgIHZhciBzaHJpbmtFeHBhbmQgPSAwO1xuICAgIHZhciBjdXJyZW50RXhwYW5kID0gMDtcblxuICAgIHZhciBpc0xvYWRpbmcgPSAwO1xuICAgIHZhciBsb3dSdW5zID0gLTE7XG5cbiAgICB2YXIgcmVzZXRQcmVsb2FkaW5nID0gZnVuY3Rpb24oZSl7XG4gICAgICBpc0xvYWRpbmctLTtcbiAgICAgIGlmKGUgJiYgZS50YXJnZXQpe1xuICAgICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGUudGFyZ2V0LCByZXNldFByZWxvYWRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZighZSB8fCBpc0xvYWRpbmcgPCAwIHx8ICFlLnRhcmdldCl7XG4gICAgICAgIGlzTG9hZGluZyA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpc05lc3RlZFZpc2libGUgPSBmdW5jdGlvbihlbGVtLCBlbGVtRXhwYW5kKXtcbiAgICAgIHZhciBvdXRlclJlY3Q7XG4gICAgICB2YXIgcGFyZW50ID0gZWxlbTtcbiAgICAgIHZhciB2aXNpYmxlID0gZ2V0Q1NTKGRvY3VtZW50LmJvZHksICd2aXNpYmlsaXR5JykgPT0gJ2hpZGRlbicgfHwgKGdldENTUyhlbGVtLnBhcmVudE5vZGUsICd2aXNpYmlsaXR5JykgIT0gJ2hpZGRlbicgJiYgZ2V0Q1NTKGVsZW0sICd2aXNpYmlsaXR5JykgIT0gJ2hpZGRlbicpO1xuXG4gICAgICBlTHRvcCAtPSBlbGVtRXhwYW5kO1xuICAgICAgZUxib3R0b20gKz0gZWxlbUV4cGFuZDtcbiAgICAgIGVMbGVmdCAtPSBlbGVtRXhwYW5kO1xuICAgICAgZUxyaWdodCArPSBlbGVtRXhwYW5kO1xuXG4gICAgICB3aGlsZSh2aXNpYmxlICYmIChwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50KSAmJiBwYXJlbnQgIT0gZG9jdW1lbnQuYm9keSAmJiBwYXJlbnQgIT0gZG9jRWxlbSl7XG4gICAgICAgIHZpc2libGUgPSAoKGdldENTUyhwYXJlbnQsICdvcGFjaXR5JykgfHwgMSkgPiAwKTtcblxuICAgICAgICBpZih2aXNpYmxlICYmIGdldENTUyhwYXJlbnQsICdvdmVyZmxvdycpICE9ICd2aXNpYmxlJyl7XG4gICAgICAgICAgb3V0ZXJSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHZpc2libGUgPSBlTHJpZ2h0ID4gb3V0ZXJSZWN0LmxlZnQgJiZcbiAgICAgICAgICAgIGVMbGVmdCA8IG91dGVyUmVjdC5yaWdodCAmJlxuICAgICAgICAgICAgZUxib3R0b20gPiBvdXRlclJlY3QudG9wIC0gMSAmJlxuICAgICAgICAgICAgZUx0b3AgPCBvdXRlclJlY3QuYm90dG9tICsgMVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlTGxlbiwgaSwgcmVjdCwgYXV0b0xvYWRFbGVtLCBsb2FkZWRTb21ldGhpbmcsIGVsZW1FeHBhbmQsIGVsZW1OZWdhdGl2ZUV4cGFuZCwgZWxlbUV4cGFuZFZhbCwgYmVmb3JlRXhwYW5kVmFsO1xuXG4gICAgICB2YXIgbGF6eWxvYWRFbGVtcyA9IGxhenlzaXplcy5lbGVtZW50cztcblxuICAgICAgaWYoKGxvYWRNb2RlID0gbGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlKSAmJiBpc0xvYWRpbmcgPCA4ICYmIChlTGxlbiA9IGxhenlsb2FkRWxlbXMubGVuZ3RoKSl7XG5cbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgbG93UnVucysrO1xuXG4gICAgICAgIGlmKHByZWxvYWRFeHBhbmQgPT0gbnVsbCl7XG4gICAgICAgICAgaWYoISgnZXhwYW5kJyBpbiBsYXp5U2l6ZXNDb25maWcpKXtcbiAgICAgICAgICAgIGxhenlTaXplc0NvbmZpZy5leHBhbmQgPSBkb2NFbGVtLmNsaWVudEhlaWdodCA+IDUwMCAmJiBkb2NFbGVtLmNsaWVudFdpZHRoID4gNTAwID8gNTAwIDogMzcwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHRFeHBhbmQgPSBsYXp5U2l6ZXNDb25maWcuZXhwYW5kO1xuICAgICAgICAgIHByZWxvYWRFeHBhbmQgPSBkZWZhdWx0RXhwYW5kICogbGF6eVNpemVzQ29uZmlnLmV4cEZhY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnRFeHBhbmQgPCBwcmVsb2FkRXhwYW5kICYmIGlzTG9hZGluZyA8IDEgJiYgbG93UnVucyA+IDIgJiYgbG9hZE1vZGUgPiAyICYmICFkb2N1bWVudC5oaWRkZW4pe1xuICAgICAgICAgIGN1cnJlbnRFeHBhbmQgPSBwcmVsb2FkRXhwYW5kO1xuICAgICAgICAgIGxvd1J1bnMgPSAwO1xuICAgICAgICB9IGVsc2UgaWYobG9hZE1vZGUgPiAxICYmIGxvd1J1bnMgPiAxICYmIGlzTG9hZGluZyA8IDYpe1xuICAgICAgICAgIGN1cnJlbnRFeHBhbmQgPSBkZWZhdWx0RXhwYW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRFeHBhbmQgPSBzaHJpbmtFeHBhbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoOyBpIDwgZUxsZW47IGkrKyl7XG5cbiAgICAgICAgICBpZighbGF6eWxvYWRFbGVtc1tpXSB8fCBsYXp5bG9hZEVsZW1zW2ldLl9sYXp5UmFjZSl7Y29udGludWU7fVxuXG4gICAgICAgICAgaWYoIXN1cHBvcnRTY3JvbGwpe3VudmVpbEVsZW1lbnQobGF6eWxvYWRFbGVtc1tpXSk7Y29udGludWU7fVxuXG4gICAgICAgICAgaWYoIShlbGVtRXhwYW5kVmFsID0gbGF6eWxvYWRFbGVtc1tpXVtfZ2V0QXR0cmlidXRlXSgnZGF0YS1leHBhbmQnKSkgfHwgIShlbGVtRXhwYW5kID0gZWxlbUV4cGFuZFZhbCAqIDEpKXtcbiAgICAgICAgICAgIGVsZW1FeHBhbmQgPSBjdXJyZW50RXhwYW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKGJlZm9yZUV4cGFuZFZhbCAhPT0gZWxlbUV4cGFuZCl7XG4gICAgICAgICAgICBlTHZXID0gaW5uZXJXaWR0aCArIChlbGVtRXhwYW5kICogaEZhYyk7XG4gICAgICAgICAgICBlbHZIID0gaW5uZXJIZWlnaHQgKyBlbGVtRXhwYW5kO1xuICAgICAgICAgICAgZWxlbU5lZ2F0aXZlRXhwYW5kID0gZWxlbUV4cGFuZCAqIC0xO1xuICAgICAgICAgICAgYmVmb3JlRXhwYW5kVmFsID0gZWxlbUV4cGFuZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWN0ID0gbGF6eWxvYWRFbGVtc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgIGlmICgoZUxib3R0b20gPSByZWN0LmJvdHRvbSkgPj0gZWxlbU5lZ2F0aXZlRXhwYW5kICYmXG4gICAgICAgICAgICAoZUx0b3AgPSByZWN0LnRvcCkgPD0gZWx2SCAmJlxuICAgICAgICAgICAgKGVMcmlnaHQgPSByZWN0LnJpZ2h0KSA+PSBlbGVtTmVnYXRpdmVFeHBhbmQgKiBoRmFjICYmXG4gICAgICAgICAgICAoZUxsZWZ0ID0gcmVjdC5sZWZ0KSA8PSBlTHZXICYmXG4gICAgICAgICAgICAoZUxib3R0b20gfHwgZUxyaWdodCB8fCBlTGxlZnQgfHwgZUx0b3ApICYmXG4gICAgICAgICAgICAobGF6eVNpemVzQ29uZmlnLmxvYWRIaWRkZW4gfHwgZ2V0Q1NTKGxhenlsb2FkRWxlbXNbaV0sICd2aXNpYmlsaXR5JykgIT0gJ2hpZGRlbicpICYmXG4gICAgICAgICAgICAoKGlzQ29tcGxldGVkICYmIGlzTG9hZGluZyA8IDMgJiYgIWVsZW1FeHBhbmRWYWwgJiYgKGxvYWRNb2RlIDwgMyB8fCBsb3dSdW5zIDwgNCkpIHx8IGlzTmVzdGVkVmlzaWJsZShsYXp5bG9hZEVsZW1zW2ldLCBlbGVtRXhwYW5kKSkpe1xuICAgICAgICAgICAgdW52ZWlsRWxlbWVudChsYXp5bG9hZEVsZW1zW2ldKTtcbiAgICAgICAgICAgIGxvYWRlZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZihpc0xvYWRpbmcgPiA5KXticmVhazt9XG4gICAgICAgICAgfSBlbHNlIGlmKCFsb2FkZWRTb21ldGhpbmcgJiYgaXNDb21wbGV0ZWQgJiYgIWF1dG9Mb2FkRWxlbSAmJlxuICAgICAgICAgICAgaXNMb2FkaW5nIDwgNCAmJiBsb3dSdW5zIDwgNCAmJiBsb2FkTW9kZSA+IDIgJiZcbiAgICAgICAgICAgIChwcmVsb2FkRWxlbXNbMF0gfHwgbGF6eVNpemVzQ29uZmlnLnByZWxvYWRBZnRlckxvYWQpICYmXG4gICAgICAgICAgICAocHJlbG9hZEVsZW1zWzBdIHx8ICghZWxlbUV4cGFuZFZhbCAmJiAoKGVMYm90dG9tIHx8IGVMcmlnaHQgfHwgZUxsZWZ0IHx8IGVMdG9wKSB8fCBsYXp5bG9hZEVsZW1zW2ldW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NvbmZpZy5zaXplc0F0dHIpICE9ICdhdXRvJykpKSl7XG4gICAgICAgICAgICBhdXRvTG9hZEVsZW0gPSBwcmVsb2FkRWxlbXNbMF0gfHwgbGF6eWxvYWRFbGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihhdXRvTG9hZEVsZW0gJiYgIWxvYWRlZFNvbWV0aGluZyl7XG4gICAgICAgICAgdW52ZWlsRWxlbWVudChhdXRvTG9hZEVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0aHJvdHRsZWRDaGVja0VsZW1lbnRzID0gdGhyb3R0bGUoY2hlY2tFbGVtZW50cyk7XG5cbiAgICB2YXIgc3dpdGNoTG9hZGluZ0NsYXNzID0gZnVuY3Rpb24oZSl7XG4gICAgICBhZGRDbGFzcyhlLnRhcmdldCwgbGF6eVNpemVzQ29uZmlnLmxvYWRlZENsYXNzKTtcbiAgICAgIHJlbW92ZUNsYXNzKGUudGFyZ2V0LCBsYXp5U2l6ZXNDb25maWcubG9hZGluZ0NsYXNzKTtcbiAgICAgIGFkZFJlbW92ZUxvYWRFdmVudHMoZS50YXJnZXQsIHJhZlN3aXRjaExvYWRpbmdDbGFzcyk7XG4gICAgICB0cmlnZ2VyRXZlbnQoZS50YXJnZXQsICdsYXp5bG9hZGVkJyk7XG4gICAgfTtcbiAgICB2YXIgcmFmZWRTd2l0Y2hMb2FkaW5nQ2xhc3MgPSByQUZJdChzd2l0Y2hMb2FkaW5nQ2xhc3MpO1xuICAgIHZhciByYWZTd2l0Y2hMb2FkaW5nQ2xhc3MgPSBmdW5jdGlvbihlKXtcbiAgICAgIHJhZmVkU3dpdGNoTG9hZGluZ0NsYXNzKHt0YXJnZXQ6IGUudGFyZ2V0fSk7XG4gICAgfTtcblxuICAgIHZhciBjaGFuZ2VJZnJhbWVTcmMgPSBmdW5jdGlvbihlbGVtLCBzcmMpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWxlbS5jb250ZW50V2luZG93LmxvY2F0aW9uLnJlcGxhY2Uoc3JjKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGVsZW0uc3JjID0gc3JjO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlU291cmNlcyA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgICB2YXIgY3VzdG9tTWVkaWE7XG5cbiAgICAgIHZhciBzb3VyY2VTcmNzZXQgPSBzb3VyY2VbX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNyY3NldEF0dHIpO1xuXG4gICAgICBpZiggKGN1c3RvbU1lZGlhID0gbGF6eVNpemVzQ29uZmlnLmN1c3RvbU1lZGlhW3NvdXJjZVtfZ2V0QXR0cmlidXRlXSgnZGF0YS1tZWRpYScpIHx8IHNvdXJjZVtfZ2V0QXR0cmlidXRlXSgnbWVkaWEnKV0pICl7XG4gICAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgY3VzdG9tTWVkaWEpO1xuICAgICAgfVxuXG4gICAgICBpZihzb3VyY2VTcmNzZXQpe1xuICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKCdzcmNzZXQnLCBzb3VyY2VTcmNzZXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGF6eVVudmVpbCA9IHJBRkl0KGZ1bmN0aW9uIChlbGVtLCBkZXRhaWwsIGlzQXV0bywgc2l6ZXMsIGlzSW1nKXtcbiAgICAgIHZhciBzcmMsIHNyY3NldCwgcGFyZW50LCBpc1BpY3R1cmUsIGV2ZW50LCBmaXJlc0xvYWQ7XG5cbiAgICAgIGlmKCEoZXZlbnQgPSB0cmlnZ2VyRXZlbnQoZWxlbSwgJ2xhenliZWZvcmV1bnZlaWwnLCBkZXRhaWwpKS5kZWZhdWx0UHJldmVudGVkKXtcblxuICAgICAgICBpZihzaXplcyl7XG4gICAgICAgICAgaWYoaXNBdXRvKXtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW0sIGxhenlTaXplc0NvbmZpZy5hdXRvc2l6ZXNDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdzaXplcycsIHNpemVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzcmNzZXQgPSBlbGVtW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NvbmZpZy5zcmNzZXRBdHRyKTtcbiAgICAgICAgc3JjID0gZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc3JjQXR0cik7XG5cbiAgICAgICAgaWYoaXNJbWcpIHtcbiAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgaXNQaWN0dXJlID0gcGFyZW50ICYmIHJlZ1BpY3R1cmUudGVzdChwYXJlbnQubm9kZU5hbWUgfHwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlyZXNMb2FkID0gZGV0YWlsLmZpcmVzTG9hZCB8fCAoKCdzcmMnIGluIGVsZW0pICYmIChzcmNzZXQgfHwgc3JjIHx8IGlzUGljdHVyZSkpO1xuXG4gICAgICAgIGV2ZW50ID0ge3RhcmdldDogZWxlbX07XG5cbiAgICAgICAgaWYoZmlyZXNMb2FkKXtcbiAgICAgICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGVsZW0sIHJlc2V0UHJlbG9hZGluZywgdHJ1ZSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2V0UHJlbG9hZGluZ1RpbWVyKTtcbiAgICAgICAgICByZXNldFByZWxvYWRpbmdUaW1lciA9IHNldFRpbWVvdXQocmVzZXRQcmVsb2FkaW5nLCAyNTAwKTtcblxuICAgICAgICAgIGFkZENsYXNzKGVsZW0sIGxhenlTaXplc0NvbmZpZy5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICAgIGFkZFJlbW92ZUxvYWRFdmVudHMoZWxlbSwgcmFmU3dpdGNoTG9hZGluZ0NsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzUGljdHVyZSl7XG4gICAgICAgICAgZm9yRWFjaC5jYWxsKHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyksIGhhbmRsZVNvdXJjZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc3Jjc2V0KXtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnc3Jjc2V0Jywgc3Jjc2V0KTtcbiAgICAgICAgfSBlbHNlIGlmKHNyYyAmJiAhaXNQaWN0dXJlKXtcbiAgICAgICAgICBpZihyZWdJZnJhbWUudGVzdChlbGVtLm5vZGVOYW1lKSl7XG4gICAgICAgICAgICBjaGFuZ2VJZnJhbWVTcmMoZWxlbSwgc3JjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5zcmMgPSBzcmM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoaXNJbWcgJiYgKHNyY3NldCB8fCBpc1BpY3R1cmUpKXtcbiAgICAgICAgICB1cGRhdGVQb2x5ZmlsbChlbGVtLCB7c3JjOiBzcmN9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihlbGVtLl9sYXp5UmFjZSl7XG4gICAgICAgIGRlbGV0ZSBlbGVtLl9sYXp5UmFjZTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUNsYXNzKGVsZW0sIGxhenlTaXplc0NvbmZpZy5sYXp5Q2xhc3MpO1xuXG4gICAgICByQUYoZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFmaXJlc0xvYWQgfHwgKGVsZW0uY29tcGxldGUgJiYgZWxlbS5uYXR1cmFsV2lkdGggPiAxKSl7XG4gICAgICAgICAgaWYoZmlyZXNMb2FkKXtcbiAgICAgICAgICAgIHJlc2V0UHJlbG9hZGluZyhldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzTG9hZGluZy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2hMb2FkaW5nQ2xhc3MoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICB9KTtcblxuICAgIHZhciB1bnZlaWxFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW0pe1xuICAgICAgdmFyIGRldGFpbDtcblxuICAgICAgdmFyIGlzSW1nID0gcmVnSW1nLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG5cbiAgICAgIC8vYWxsb3cgdXNpbmcgc2l6ZXM9XCJhdXRvXCIsIGJ1dCBkb24ndCB1c2UuIGl0J3MgaW52YWxpZC4gVXNlIGRhdGEtc2l6ZXM9XCJhdXRvXCIgb3IgYSB2YWxpZCB2YWx1ZSBmb3Igc2l6ZXMgaW5zdGVhZCAoaS5lLjogc2l6ZXM9XCI4MHZ3XCIpXG4gICAgICB2YXIgc2l6ZXMgPSBpc0ltZyAmJiAoZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc2l6ZXNBdHRyKSB8fCBlbGVtW19nZXRBdHRyaWJ1dGVdKCdzaXplcycpKTtcbiAgICAgIHZhciBpc0F1dG8gPSBzaXplcyA9PSAnYXV0byc7XG5cbiAgICAgIGlmKCAoaXNBdXRvIHx8ICFpc0NvbXBsZXRlZCkgJiYgaXNJbWcgJiYgKGVsZW1bX2dldEF0dHJpYnV0ZV0oJ3NyYycpIHx8IGVsZW0uc3Jjc2V0KSAmJiAhZWxlbS5jb21wbGV0ZSAmJiAhaGFzQ2xhc3MoZWxlbSwgbGF6eVNpemVzQ29uZmlnLmVycm9yQ2xhc3MpICYmIGhhc0NsYXNzKGVsZW0sIGxhenlTaXplc0NvbmZpZy5sYXp5Q2xhc3MpKXtyZXR1cm47fVxuXG4gICAgICBkZXRhaWwgPSB0cmlnZ2VyRXZlbnQoZWxlbSwgJ2xhenl1bnZlaWxyZWFkJykuZGV0YWlsO1xuXG4gICAgICBpZihpc0F1dG8pe1xuICAgICAgICAgYXV0b1NpemVyLnVwZGF0ZUVsZW0oZWxlbSwgdHJ1ZSwgZWxlbS5vZmZzZXRXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0uX2xhenlSYWNlID0gdHJ1ZTtcbiAgICAgIGlzTG9hZGluZysrO1xuXG4gICAgICBsYXp5VW52ZWlsKGVsZW0sIGRldGFpbCwgaXNBdXRvLCBzaXplcywgaXNJbWcpO1xuICAgIH07XG5cbiAgICB2YXIgb25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmKGlzQ29tcGxldGVkKXtyZXR1cm47fVxuICAgICAgaWYoRGF0ZS5ub3coKSAtIHN0YXJ0ZWQgPCA5OTkpe1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZCwgOTk5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFmdGVyU2Nyb2xsID0gZGVib3VuY2UoZnVuY3Rpb24oKXtcbiAgICAgICAgbGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlID0gMztcbiAgICAgICAgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cygpO1xuICAgICAgfSk7XG5cbiAgICAgIGlzQ29tcGxldGVkID0gdHJ1ZTtcblxuICAgICAgbGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlID0gMztcblxuICAgICAgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cygpO1xuXG4gICAgICBhZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbigpe1xuICAgICAgICBpZihsYXp5U2l6ZXNDb25maWcubG9hZE1vZGUgPT0gMyl7XG4gICAgICAgICAgbGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBhZnRlclNjcm9sbCgpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBfOiBmdW5jdGlvbigpe1xuICAgICAgICBzdGFydGVkID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBsYXp5c2l6ZXMuZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGxhenlTaXplc0NvbmZpZy5sYXp5Q2xhc3MpO1xuICAgICAgICBwcmVsb2FkRWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGxhenlTaXplc0NvbmZpZy5sYXp5Q2xhc3MgKyAnICcgKyBsYXp5U2l6ZXNDb25maWcucHJlbG9hZENsYXNzKTtcbiAgICAgICAgaEZhYyA9IGxhenlTaXplc0NvbmZpZy5oRmFjO1xuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuXG4gICAgICAgIGlmKHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKXtcbiAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlciggdGhyb3R0bGVkQ2hlY2tFbGVtZW50cyApLm9ic2VydmUoIGRvY0VsZW0sIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWV9ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jRWxlbVtfYWRkRXZlbnRMaXN0ZW5lcl0oJ0RPTU5vZGVJbnNlcnRlZCcsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuICAgICAgICAgIGRvY0VsZW1bX2FkZEV2ZW50TGlzdGVuZXJdKCdET01BdHRyTW9kaWZpZWQnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgICBzZXRJbnRlcnZhbCh0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCA5OTkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuXG4gICAgICAgIC8vLCAnZnVsbHNjcmVlbmNoYW5nZSdcbiAgICAgICAgWydmb2N1cycsICdtb3VzZW92ZXInLCAnY2xpY2snLCAnbG9hZCcsICd0cmFuc2l0aW9uZW5kJywgJ2FuaW1hdGlvbmVuZCcsICd3ZWJraXRBbmltYXRpb25FbmQnXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgICAgIGRvY3VtZW50W19hZGRFdmVudExpc3RlbmVyXShuYW1lLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoKC9kJHxeYy8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSkpe1xuICAgICAgICAgIG9ubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgICAgIGRvY3VtZW50W19hZGRFdmVudExpc3RlbmVyXSgnRE9NQ29udGVudExvYWRlZCcsIHRocm90dGxlZENoZWNrRWxlbWVudHMpO1xuICAgICAgICAgIHNldFRpbWVvdXQob25sb2FkLCAyMDAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihsYXp5c2l6ZXMuZWxlbWVudHMubGVuZ3RoKXtcbiAgICAgICAgICBjaGVja0VsZW1lbnRzKCk7XG4gICAgICAgICAgckFGLl9sc0ZsdXNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tFbGVtczogdGhyb3R0bGVkQ2hlY2tFbGVtZW50cyxcbiAgICAgIHVudmVpbDogdW52ZWlsRWxlbWVudFxuICAgIH07XG4gIH0pKCk7XG5cblxuICB2YXIgYXV0b1NpemVyID0gKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGF1dG9zaXplc0VsZW1zO1xuXG4gICAgdmFyIHNpemVFbGVtZW50ID0gckFGSXQoZnVuY3Rpb24oZWxlbSwgcGFyZW50LCBldmVudCwgd2lkdGgpe1xuICAgICAgdmFyIHNvdXJjZXMsIGksIGxlbjtcbiAgICAgIGVsZW0uX2xhenlzaXplc1dpZHRoID0gd2lkdGg7XG4gICAgICB3aWR0aCArPSAncHgnO1xuXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnc2l6ZXMnLCB3aWR0aCk7XG5cbiAgICAgIGlmKHJlZ1BpY3R1cmUudGVzdChwYXJlbnQubm9kZU5hbWUgfHwgJycpKXtcbiAgICAgICAgc291cmNlcyA9IHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XG4gICAgICAgIGZvcihpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgc291cmNlc1tpXS5zZXRBdHRyaWJ1dGUoJ3NpemVzJywgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCFldmVudC5kZXRhaWwuZGF0YUF0dHIpe1xuICAgICAgICB1cGRhdGVQb2x5ZmlsbChlbGVtLCBldmVudC5kZXRhaWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBnZXRTaXplRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhQXR0ciwgd2lkdGgpe1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuICAgICAgaWYocGFyZW50KXtcbiAgICAgICAgd2lkdGggPSBnZXRXaWR0aChlbGVtLCBwYXJlbnQsIHdpZHRoKTtcbiAgICAgICAgZXZlbnQgPSB0cmlnZ2VyRXZlbnQoZWxlbSwgJ2xhenliZWZvcmVzaXplcycsIHt3aWR0aDogd2lkdGgsIGRhdGFBdHRyOiAhIWRhdGFBdHRyfSk7XG5cbiAgICAgICAgaWYoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpe1xuICAgICAgICAgIHdpZHRoID0gZXZlbnQuZGV0YWlsLndpZHRoO1xuXG4gICAgICAgICAgaWYod2lkdGggJiYgd2lkdGggIT09IGVsZW0uX2xhenlzaXplc1dpZHRoKXtcbiAgICAgICAgICAgIHNpemVFbGVtZW50KGVsZW0sIHBhcmVudCwgZXZlbnQsIHdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUVsZW1lbnRzU2l6ZXMgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYXV0b3NpemVzRWxlbXMubGVuZ3RoO1xuICAgICAgaWYobGVuKXtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZm9yKDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICBnZXRTaXplRWxlbWVudChhdXRvc2l6ZXNFbGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMgPSBkZWJvdW5jZSh1cGRhdGVFbGVtZW50c1NpemVzKTtcblxuICAgIHJldHVybiB7XG4gICAgICBfOiBmdW5jdGlvbigpe1xuICAgICAgICBhdXRvc2l6ZXNFbGVtcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobGF6eVNpemVzQ29uZmlnLmF1dG9zaXplc0NsYXNzKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2VkVXBkYXRlRWxlbWVudHNTaXplcyk7XG4gICAgICB9LFxuICAgICAgY2hlY2tFbGVtczogZGVib3VuY2VkVXBkYXRlRWxlbWVudHNTaXplcyxcbiAgICAgIHVwZGF0ZUVsZW06IGdldFNpemVFbGVtZW50XG4gICAgfTtcbiAgfSkoKTtcblxuICB2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIWluaXQuaSl7XG4gICAgICBpbml0LmkgPSB0cnVlO1xuICAgICAgYXV0b1NpemVyLl8oKTtcbiAgICAgIGxvYWRlci5fKCk7XG4gICAgfVxuICB9O1xuXG4gIGxhenlzaXplcyA9IHtcbiAgICBjZmc6IGxhenlTaXplc0NvbmZpZyxcbiAgICBhdXRvU2l6ZXI6IGF1dG9TaXplcixcbiAgICBsb2FkZXI6IGxvYWRlcixcbiAgICBpbml0OiBpbml0LFxuICAgIHVQOiB1cGRhdGVQb2x5ZmlsbCxcbiAgICBhQzogYWRkQ2xhc3MsXG4gICAgckM6IHJlbW92ZUNsYXNzLFxuICAgIGhDOiBoYXNDbGFzcyxcbiAgICBmaXJlOiB0cmlnZ2VyRXZlbnQsXG4gICAgZ1c6IGdldFdpZHRoLFxuICAgIHJBRjogckFGLFxuICB9O1xuXG4gIHJldHVybiBsYXp5c2l6ZXM7XG59XG4pKTtcblxuLy9cbi8vIFBhc3NpdmUgb3B0aW9uIGZvciBldmVudCBsaXN0ZW5lcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGZWF0dXJlIGRldGVjdGlvbiBmb3IgYWRkRXZlbnRMaXN0ZW5lcidzICdwYXNzaXZlJyBvcHRpb24uXG4vLyBBbGxvd3MgZm9yIGNvbmRpdGlvbmFsIHNldHRpbmcgb2YgdGhlIHRoaXJkIGFyZ3VtZW50IGluIGFuIGV2ZW50IGxpc3RlbmVyLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4YW1wbGUgdXNhZ2U6XG4vLyBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7Li4ufSwgcGFzc2l2ZUV2ZW50TGlzdGVuZXJPcHRpb25TdXBwb3J0ZWQgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgcGFzc2l2ZUV2ZW50TGlzdGVuZXJPcHRpb25TdXBwb3J0ZWQgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHBhc3NpdmVFdmVudExpc3RlbmVyT3B0aW9uU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RQYXNzaXZlT3B0aW9uXCIsIG51bGwsIG9wdHMpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RQYXNzaXZlT3B0aW9uXCIsIG51bGwsIG9wdHMpO1xufSBjYXRjaChlcnIpIHt9XG5cbi8vXG4vLyBSZW1vdmUgdGhlIHNjcm9sbGluZyBpbmNyZW1lbnQvZGVjcmVtZW50IGJlaGF2aW9yIGZyb20gbnVtYmVyIGlucHV0IGVsZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSA9PT0gXCJudW1iZXJcIil7XG4gICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gIH1cbn0sIHBhc3NpdmVFdmVudExpc3RlbmVyT3B0aW9uU3VwcG9ydGVkID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSk7XG5cbi8vXG4vLyBFeGNsdWRlIGhpZGRlbiBlbGVtZW50cyBmcm9tIFBhcnNsZXlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pZiAodHlwZW9mIFBhcnNsZXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBQYXJzbGV5Lm9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gIFBhcnNsZXkub3B0aW9ucy5leGNsdWRlZCA9ICdpbnB1dFt0eXBlPWJ1dHRvbl0sIGlucHV0W3R5cGU9c3VibWl0XSwgaW5wdXRbdHlwZT1yZXNldF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgW2Rpc2FibGVkXSwgOmhpZGRlbic7XG59XG5cbi8vXG4vLyBET00gbG9hZGVkIGJvZHkgY2xhc3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXaGVuIHRoZSBwYWdlIGlzIGxvYWRlZCwgYWRkICYgcmVtb3ZlIGNsYXNzZXMgZnJvbSB0aGUgYm9keSBlbGVtZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSC90IHRvIGh0dHBzOi8vd3d3LnNpdGVwb2ludC5jb20vanF1ZXJ5LWRvY3VtZW50LXJlYWR5LXBsYWluLWphdmFzY3JpcHQvXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGRvbUxvYWRlZENhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdkb20taGFzLWxvYWRlZCcpO1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2RvbS1ub3QteWV0LWxvYWRlZCcpO1xufTtcblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpICkge1xuICBkb21Mb2FkZWRDYWxsYmFjaygpO1xufSBlbHNlIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZG9tTG9hZGVkQ2FsbGJhY2spO1xufVxuXG4vL1xuLy8gRGlzcGF0Y2hlci5qc1xuLy8gdjAuNC40XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDcmVhdGUgYWN0aW9ucyAmIHJlYWN0aW9ucyBpbiBtYXJrdXBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE9cbi8vIC0gQ2hhbmdlIGRhdGEtZGlzcGF0Y2hlci1ub3RpZnkgdG8gYWNjZXB0IGFuIGFycmF5IG9mIElEcyB0byBub3RpZnlcbi8vIC0gQWxsb3cgY3VzdG9taXphdGlvbiBvZiAuaXMtZGlzcGF0Y2hlci1ub3RpZmllZCBjbGFzcyBuYW1lIChmb3IgbXVsdGlwbGUgdXNlcyBvZiBkaXNwYXRjaGVyKVxuLy8gLSBTZXBhcmF0ZSB0cmlnZ2VyLCB0YXJnZXQsIGFuZCBub3RpZmllZCBkaXNwYXRjaCBpbnRvIDMgZnVuY3Rpb25zP1xuLy8gLSBBZGQgYSBjYWxsYmFjayB3aGVuIGRpc3BhdGNoIGlzIGNvbXBsZXRlZD9cbi8vIC0gUmV3cml0ZSBpbiBWYW5pbGxhIEpTIChmb3IgZXZlbnQgZGVsZWdhdGlvbiwgc2VlIGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbS9jaGVja2luZy1ldmVudC10YXJnZXQtc2VsZWN0b3JzLXdpdGgtZXZlbnQtYnViYmxpbmctaW4tdmFuaWxsYS1qYXZhc2NyaXB0Lylcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjbGlja0Rpc3BhdGNoICh0cmlnZ2VyKSB7XG4gIC8vIEZlZWRiYWNrIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIGlmIGFuIGF0dHJpYnV0ZSBkYXRhLWRpc3BhdGNoZXItdHJpZ2dlci1hY3RpdmUtY2xhc3MgX19leGlzdHMgYW5kIGhhcyBhIHZhbHVlX19cbiAgaWYgKCB0cmlnZ2VyLmF0dHIoXCJkYXRhLWRpc3BhdGNoZXItdHJpZ2dlci1hY3RpdmUtY2xhc3NcIikgKSB7XG4gICAgdmFyICRjdXN0b21fdHJpZ2dlcl9jbGFzcyA9IHRyaWdnZXIuZGF0YShcImRpc3BhdGNoZXItdHJpZ2dlci1hY3RpdmUtY2xhc3NcIik7XG4gICAgdHJpZ2dlci50b2dnbGVDbGFzcygkY3VzdG9tX3RyaWdnZXJfY2xhc3MpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFRvZ2dsZSBhY3RpdmUgY2xhc3NcbiAgICB0cmlnZ2VyLnRvZ2dsZUNsYXNzKFwiaXMtYWN0aXZlXCIpO1xuICB9XG5cbiAgLy8gVG9nZ2xlIHNlbGVjdGVkIEFSSUEgYXR0cmlidXRlcyBpZiB0aGV5IGV4aXN0XG4gIGlmICggdHJpZ2dlci5hdHRyKFwiYXJpYS1wcmVzc2VkXCIpICkgIHsgdmFyIGhhc0FyaWFQcmVzc2VkQXR0ciAgPSB0cnVlOyB9XG4gIGlmICggdHJpZ2dlci5hdHRyKFwiYXJpYS1leHBhbmRlZFwiKSApIHsgdmFyIGhhc0FyaWFFeHBhbmRlZEF0dHIgPSB0cnVlOyB9XG5cbiAgaWYgKGhhc0FyaWFQcmVzc2VkQXR0cikge1xuICAgIHRyaWdnZXIuYXR0cihcImFyaWEtcHJlc3NlZFwiLCAgKHRyaWdnZXIuYXR0cihcImFyaWEtcHJlc3NlZFwiKSAgPT0gXCJmYWxzZVwiID8gdHJ1ZSA6IGZhbHNlKSk7XG4gIH1cbiAgaWYgKGhhc0FyaWFFeHBhbmRlZEF0dHIpIHtcbiAgICB0cmlnZ2VyLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsICh0cmlnZ2VyLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIpID09IFwiZmFsc2VcIiA/IHRydWUgOiBmYWxzZSkpO1xuICB9XG5cblxuICAvLyBOb3RpZmllZCBlbGVtZW50IGRpc3BhdGNoXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgYW4gZWxlbWVudCBpcyB0byBiZSBub3RpZmllZCAoYSB2YWx1ZSBpcyBnaXZlbiBpbiB0aGUgYXR0cmlidXRlKSxcbiAgLy8gbm90aWZ5IGl0L3RoZW0gd2l0aCB0b2dnbGVkIGNsYXNzIFwiaXMtZGlzcGF0Y2hpbmdcIlxuICBpZiAoIHRyaWdnZXIuYXR0cihcImRhdGEtZGlzcGF0Y2hlci1ub3RpZnlcIikgKSB7XG4gICAgdmFyICRub3RpZnlfY2xhc3MgPSBcIi5cIiArIHRyaWdnZXIuZGF0YShcImRpc3BhdGNoZXItbm90aWZ5XCIpO1xuICAgICQoJG5vdGlmeV9jbGFzcykudG9nZ2xlQ2xhc3MoXCJpcy1kaXNwYXRjaGVyLW5vdGlmaWVkXCIpO1xuICB9XG5cblxuICAvLyBUYXJnZXQgZWxlbWVudCBkaXNwYXRjaFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgdGFyZ2V0ZWQgZWxlbWVudCB2aWEgZGF0YS1hdHRyaWJ1dGVcbiAgdmFyIHRhcmdldCA9IFwiI1wiICsgdHJpZ2dlci5kYXRhKFwiZGlzcGF0Y2hlci10YXJnZXRcIik7XG4gIHRhcmdldCA9ICQodGFyZ2V0KTtcblxuICAvLyBpZiBhbiBhdHRyaWJ1dGUgZGF0YS1kaXNwYXRjaGVyLXRhcmdldC1hY3RpdmUtY2xhc3MgX19leGlzdHMgYW5kIGhhcyBhIHZhbHVlX19cbiAgaWYgKCB0cmlnZ2VyLmF0dHIoXCJkYXRhLWRpc3BhdGNoZXItdGFyZ2V0LWFjdGl2ZS1jbGFzc1wiKSApIHtcbiAgICB2YXIgJGN1c3RvbV90YXJnZXRfY2xhc3MgPSB0cmlnZ2VyLmRhdGEoXCJkaXNwYXRjaGVyLXRhcmdldC1hY3RpdmUtY2xhc3NcIik7XG4gICAgdGFyZ2V0LnRvZ2dsZUNsYXNzKCRjdXN0b21fdGFyZ2V0X2NsYXNzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0YXJnZXQudG9nZ2xlQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG4gIH1cblxuICAvLyBBUklBIGF0dHJpYnV0ZXMgdG8gZmxpcFxuICB0YXJnZXQuYXR0cihcImFyaWEtaGlkZGVuXCIsICh0YXJnZXQuYXR0cihcImFyaWEtaGlkZGVuXCIpID09IFwiZmFsc2VcIiA/IHRydWUgOiBmYWxzZSkpO1xuXG5cbiAgLy8gXCJPbmUgYXQgYSB0aW1lLCBzaWJsaW5nc1wiIGRpc3BhdGNoXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEZvciB3aGVuIG9ubHkgb25lIGNoaWxkIG1heSBiZSBhY3RpdmUgYXQgYSB0aW1lLiAoTGlrZSBhbiBhY2NvcmRpb24hKVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpZiAoIHRyaWdnZXIuYXR0cihcImRhdGEtZGlzcGF0Y2hlci1wYXJlbnRcIikgKSB7XG4gICAgLy8gR2V0IHRoZSB0YXJnZXRlZCBlbGVtZW50IHZpYSBkYXRhLWF0dHJpYnV0ZVxuICAgIHZhciAkcGFyZW50ID0gXCIjXCIgKyB0cmlnZ2VyLmRhdGEoXCJkaXNwYXRjaGVyLXBhcmVudFwiKTtcblxuICAgIC8vIFRoZXNlIG1heSBfc2VlbV8gcmV2ZXJzZWQsIGJ1dCBub3RlIHRoYXQgYXQgdGhlIHRvcCBvZiB0aGlzIGZ1bmN0aW9uLCB0aGUgaXMtYWN0aXZlIGNsYXNzIGlzIHRvZ2dsZWQuIFNvIGF0IHRoaXMgcG9pbnQsIHdlJ3JlIG5vdCBjaGVja2luZyBcImlmIHRoZSB0cmlnZ2VyIGhhZCBpcy1hY3RpdmUgYmVmb3JlIGNsaWNrXCIsIGJ1dCBcImlmIHRoZSB0cmlnZ2VyIGhhcyBpcy1hY3RpdmUgbm93IHRoYXQgaXQgaGFzIGJlZW4gY2xpY2tlZFwiLlxuICAgIGlmICggdHJpZ2dlci5oYXNDbGFzcyhcImlzLWFjdGl2ZVwiKSApIHtcbiAgICAgICQoJHBhcmVudCkuYWRkQ2xhc3MoXCJoYXMtZGlzcGF0Y2hlZC1hY3RpdmUtY2hpbGRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJCgkcGFyZW50KS5yZW1vdmVDbGFzcyhcImhhcy1kaXNwYXRjaGVkLWFjdGl2ZS1jaGlsZFwiKTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyLnNpYmxpbmdzKFwiLmRpc3BhdGNoZXItdHJpZ2dlclwiKS5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgfVxufVxuXG5cbi8vIExvZ2ljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gIC8vIGxpc3RlbiBmb3IgYSBjbGljayBvciBrZXlkb3duIGV2ZW50IG9uIGVsZW1lbnRzIHdpdGggLmRpc3BhdGNoLXRyaWdnZXIuIGtleWRvd24gaXMgbmVlZGVkIGJlY2F1c2Ugc29tZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgbmF0aXZlIDxidXR0b24+IG9yIDxhPiBlbGVtZW50cyDigJQgeWV0IGhhdmUgdGFiaW5kZXg9XCIwXCIgYWRkZWQgYWxsb3dpbmcgZm9yIGtleWJvYXJkIGFjY2VzcyDigJQgbmVlZCB0byByZWNlaXZlIGEgc3BhY2ViYXIga2V5IHByZXNzIG9yIHJldHVybiBrZXkgcHJlc3NcbiAgJChcImJvZHlcIikub24oXCJjbGljayBrZXlkb3duXCIsIFwiLmRpc3BhdGNoZXItdHJpZ2dlclwiLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGlzIGVpdGhlciBhIGNsaWNrLCBhIHNwYWNlYmFyIHByZXNzLCBvciBhIHJldHVybiBwcmVzc1xuICAgIGlmICggKGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikgfHwgKGV2ZW50LndoaWNoID09IDEzIHx8IGV2ZW50LndoaWNoID09IDMyKSkge1xuXG4gICAgICAvLyByZXN0cmljdHMgdGhlIFwib3ZlcnBvd2VyZWRcIiBwcmV2ZW50RGVmYXVsdCBhY3Rpb24gT05MWSB0byBhIGRpcmVjdCBjbGljay9rZXlkb3duIG9uIC5kaXNwYXRjaC10cmlnZXIgZWxlbWVudFxuICAgICAgLy8gICAtIHRoaXMgcmV0YWlucyBibG9ja2luZyBvZiBkZWZhdWx0IGFjdGlvbnMgd2hlbiB0aGUgdHJpZ2dlciBpcyBhbiBhbmNob3IgaXRzZWxmXG4gICAgICAvLyAgIC0gYnV0IGFsbG93cyBjaGlsZCBhLCBpbnB1dCwgYnV0dG9uLCBsYWJlbCwgZXRjLiB0byByZXRhaW4gdGhlaXIgZnVuY3Rpb25hbGl0eVxuICAgICAgaWYoZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBjbGljayBhY3Rpb25zXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpcmUgdGhlIG1haW4gZnVuY3Rpb25cbiAgICAgIGNsaWNrRGlzcGF0Y2goICQodGhpcykgKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8vXG4vLyBQZXJjaCBOYXZpZ2F0aW9uIC8gTWVudSBTeXN0ZW1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBWYXJpYWJsZXMgZGVmaW5lZCBpbiBwZXJjaC1jb3JlLXNjcmlwdHMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gVmFyaWFibGVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciAkZ2xvYmFsX2hlYWRlciAgICAgID0gJCgnI2dsb2JhbC1oZWFkZXInKSxcblxuICAkbmF2X291dGVyX3dyYXBwZXIgICAgPSAkKCcjZ2xvYmFsLW91dGVyLW5hdmlnYXRpb24td3JhcHBlcicpLFxuXG4gIC8vICRuYXZfcGFyZW50ICAgICAgPSAkKCcuZ2xvYmFsLW5hdi1pdGVtLS1oYXMtY2hpbGRyZW4nKSxcbiAgJG5hdl9hY3RpdmVfcGFyZW50ICAgID0gJCgnLmdsb2JhbC1uYXYtaXRlbS0taGFzLWNoaWxkcmVuLmFjdGl2ZS1wYXJlbnQnKSxcbiAgLy8gJG5hdl9wYXJlbnRfbGluayAgICAgPSAkKCcuZ2xvYmFsLW5hdi1pdGVtLS1oYXMtY2hpbGRyZW4gPiAuZ2xvYmFsLW5hdi1saW5rJyksXG4gICRuYXZfY2hpbGQgICAgICAgID0gJCgnLmdsb2JhbC1uYXYtY2hpbGQtbGlzdCcpLFxuXG4gICRuYXZfcmV2ZWFsX2J1dHRvbiAgICA9ICQoJy5oYW1idXJnZXItbWVudS1idXR0b24nKTtcblxuXG4vLyBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8vIE1vYmlsZSBuYXYgb3BlbmluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIG9wZW5Nb2JpbGVOYXYgKCkge1xuICAkKCdodG1sJykuYWRkQ2xhc3MoJ21vYmlsZS1uYXYtaXMtb3BlbiBpcy1tb2JpbGUtc2Nyb2xsLWxvY2tlZCcpO1xuICAkbmF2X3JldmVhbF9idXR0b24uYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpLmF0dHIoJ2FyaWEtcHJlc3NlZCcsICd0cnVlJyk7XG4gICRuYXZfb3V0ZXJfd3JhcHBlci5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICRnbG9iYWxfaGVhZGVyLmFkZENsYXNzKCdtb2JpbGUtbmF2LWlzLW9wZW4nKTtcbn1cblxuXG4vLyBOYXZpZ2F0aW9uIG9wZW5pbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcGVucyB0aGUgbWVudSBmb3IgYm90aCBtb2JpbGUgYW5kIGRlc2t0b3AuXG4vLyBBbHNvIGNhbiBhY2NlcHQgYW4gYXJndW1lbnQgdG8gb3BlbiBhIHNwZWNpZmljIGNoaWxkIG1lbnUuXG4vLyAgPiBDb3VsZCBiZSB1c2VkIHRvIG9wZW4gdGhlIG5hdmlnYXRpb24gYnkgY2xpY2tpbmcgYSBsaW5rIG9yIGJ1dHRvbiBvbiB0aGUgcGFnZS5cbi8vICA+IFdhcyBvbmNlIHVzZWQgb24gV01VL1dvcmRsQ3JhZnRzIHNpZGViYXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBvcGVuTmF2ICh0aGVfbWVudSkge1xuXG4gIC8vIFVzZSBpbnRlcnBvbGF0aW9uIHRvIHRha2UgdGhlIHBhc3NlZCBjaGlsZCBtZW51IG5hbWUgYW5kIHRoZW4gc2VsZWN0IGl0IGJlbG93XG4gIHZhciBpbnRlcnBvbGF0ZWRfc2VsZWN0b3IgPSBcIi5tZW51LVwiICsgdGhlX21lbnU7XG4gICQoaW50ZXJwb2xhdGVkX3NlbGVjdG9yKVxuICAgIC5mb2N1cygpXG4gICAgLmFkZENsYXNzKCdpcy1vcGVuIHN1Ym1lbnUtaXMtb3BlbicpO1xuICAkKGludGVycG9sYXRlZF9zZWxlY3RvcikuY2hpbGRyZW4oJG5hdl9jaGlsZCkuYWRkQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgJChpbnRlcnBvbGF0ZWRfc2VsZWN0b3IpLmNoaWxkcmVuKCcuY2hpbGQtbmF2LW9wZW5lcicpLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAvLyBGZWVkYmFjayB0byB0aGUgYm9keTogYSBjaGlsZCBtZW51IGlzIG9wZW4uIEFsbG93cyBmb3IgbWFraW5nIGEgYmFja2Ryb3Agc2hvdyB1cCBvdmVyIHRoZSBjb250ZW50L2JlbmVhdGggdGhlIG1lbnUuXG4gIC8vICQoJ2JvZHknKS5hZGRDbGFzcygnY2hpbGQtbWVudS1pcy1vcGVuJyk7XG5cbiAgb3Blbk1vYmlsZU5hdigpO1xuXG4gIGlmKCRuYXZfb3V0ZXJfd3JhcHBlci5oYXNDbGFzcygnbmF2aWdhdGlvbi1kcmF3ZXItd3JhcHBlcicpKSB7XG4gICAgZHJhd2VyTGlzdGVuRm9yQ2xvc2luZ1N3aXBlKCk7XG4gIH1cbn1cblxuXG4vLyBOYXZpZ2F0aW9uIGNsb3Npbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjbG9zZU5hdiAoY2xvc2VOYXZNaWxsaXNlY29uZHMpIHtcbiAgJCgnaHRtbCcpLnJlbW92ZUNsYXNzKCdtb2JpbGUtbmF2LWlzLW9wZW4gaXMtbW9iaWxlLXNjcm9sbC1sb2NrZWQnKTtcbiAgJG5hdl9vdXRlcl93cmFwcGVyLmFkZENsYXNzKCdhbmltYXRpbmctb3V0Jyk7XG4gICRuYXZfcmV2ZWFsX2J1dHRvbi5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtcHJlc3NlZCcsICdmYWxzZScpO1xuICAkZ2xvYmFsX2hlYWRlci5yZW1vdmVDbGFzcygnbW9iaWxlLW5hdi1pcy1vcGVuJyk7XG5cbiAgLy8gQ2xvc2UgbWVnYW1lbnVzIGZvciBtb2JpbGUuLi5iZWZvcmUgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICQoJy5nbG9iYWwtbmF2LWl0ZW0nKS5yZW1vdmVDbGFzcygnaXMtb3BlbiBzdWJtZW51LWlzLW9wZW4gc3VibWVudS1pcy1tb2JpbGUtb3BlbicpO1xuICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2NoaWxkLW1lbnUtaXMtb3BlbicpO1xuXG4gIC8vIGlmIGEgY3VzdG9tIHRpbWVvdXQgaXMgcGFzc2VkLCBcbiAgbWlsbGlzZWNvbmRzID0gKGNsb3NlTmF2TWlsbGlzZWNvbmRzID49IDApID8gY2xvc2VOYXZNaWxsaXNlY29uZHMgOiAyNTA7XG5cbiAgdmFyIG5hdl9jbG9zZV90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvc2UgbWVnYW1lbnVzIGZvciBtb2JpbGUuLi5hZnRlciBhbmltYXRpb24gaXMgZmluaXNoZWRcbiAgICAkKCcuY2hpbGQtbmF2LW9wZW5lcicpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAkbmF2X2NoaWxkLnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG5cbiAgICAkbmF2X291dGVyX3dyYXBwZXIucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICRuYXZfb3V0ZXJfd3JhcHBlci5yZW1vdmVDbGFzcygnYW5pbWF0aW5nLW91dCcpO1xuICB9LCBtaWxsaXNlY29uZHMpO1xuXG4gIC8vIGFsc28gY2xvc2UgdGhlIHNlYXJjaFxuICBpZiAodHlwZW9mIGNsb3NlU2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2xvc2VTZWFyY2goKTtcbiAgfVxuXG4gIC8vIGlmIGEgZHJhd2VyLCBwYXNzIHRoZSBmYWxzZSB2YWx1ZSB0byByZW1vdmUgdGhlIHN3aXBlIGV2ZW50IGxpc3RlbmVyc1xuICBpZigkbmF2X291dGVyX3dyYXBwZXIuaGFzQ2xhc3MoJ25hdmlnYXRpb24tZHJhd2VyLXdyYXBwZXInKSkge1xuICAgIGRyYXdlckxpc3RlbkZvckNsb3NpbmdTd2lwZShmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gTG9naWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBOYXZpZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDbG9zZSB0aGUgbWVudSBpZiBpdCdzIGN1cnJlbnRseSBhY3RpdmUuIE90aGVyd2lzZTogcnVuIG9wZW5OYXYgZnVuY3Rpb24uXG4kbmF2X3JldmVhbF9idXR0b24ub24oJ2NsaWNrIGtleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gIGlmICgoZS50eXBlID09ICdjbGljaycpIHx8IChlLmtleUNvZGUgPT0gMzIpKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgICBjbG9zZU5hdigpO1xuICAgICAgdGhpcy5ibHVyKCk7IC8vIFJlbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGUgYnV0dG9uIHNvIDpmb2N1cyBzdHlsZXMgZG9uJ3Qgc2hvdyBvbiB0b3VjaCBzY3JlZW5zXG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3Blbk5hdigpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vXG4vLyBDaGlsZCBOYXYgT3BlbiBXaXRoIFBhcmVudCBDbGlja1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIElmIGEgbmF2IGxpbmsgc2V0IHRvIG9wZW4gaXRzIGNoaWxkIGlzIGNsaWNrZWQsXG4vLyBvcGVuIHRoZSBjaGlsZCBtZW51LlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFzc3VtZXMgYW4gaW50ZWdyYXRpb24gd2l0aDpcbi8vIC0gbmF2aWdhdGlvbi1zeXN0ZW0uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEbyBub3QgdXNlIGFsb25nc2lkZSBjaGlsZC1uYXYtb3Blbi13aXRoLWdlbmVyYXRlZC1idXR0b24uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gVmFyaWFibGVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciAkbmF2X2xpbmtfb3BlbnNfY2hpbGQgICAgID0gJCgnLmdsb2JhbC1uYXYtaXRlbS0tb3BlbnMtY2hpbGQgPiAuZ2xvYmFsLW5hdi1saW5rJyk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBMb2dpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4kbmF2X2xpbmtfb3BlbnNfY2hpbGQuY2xpY2soZnVuY3Rpb24oZSkge1xuICAvLyBQcmV2ZW50IGxpbmsgZnJvbSBiZWluZyBmb2xsb3dlZFxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgLy8gc2V0IHRoZSBwYXJlbnRcbiAgdmFyICR0aGVfcGFyZW50ID0gJCh0aGlzKS5wYXJlbnQoKTtcblxuICAvLyByZW1vdmUgaXMtb3BlbiBjbGFzcyBpZiBpdCdzIGFscmVhZHkgdGhlcmVcbiAgaWYgKCAkdGhlX3BhcmVudC5oYXNDbGFzcygnc3VibWVudS1pcy1vcGVuJykgfHwgJHRoZV9wYXJlbnQuaGFzQ2xhc3MoJ3N1Ym1lbnUtaXMtbW9iaWxlLW9wZW4nKSApIHtcbiAgICAkdGhlX3BhcmVudC5yZW1vdmVDbGFzcygnc3VibWVudS1pcy1vcGVuIHN1Ym1lbnUtaXMtbW9iaWxlLW9wZW4nKVxuICAgICAgLmNoaWxkcmVuKCcuZ2xvYmFsLW5hdi1jaGlsZC1saXN0JykucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgICAkKHRoaXMpLmJsdXIoKTtcbiAgfVxuICAvLyBvdGhlcndpc2UsIGFkZCBpdFxuICBlbHNlIHtcbiAgICAkdGhlX3BhcmVudC5hZGRDbGFzcygnc3VibWVudS1pcy1vcGVuJylcbiAgICAgIC5jaGlsZHJlbignLmdsb2JhbC1uYXYtY2hpbGQtbGlzdCcpLmFkZENsYXNzKCdpcy1vcGVuJyk7XG4gIH1cbn0pO1xuXG4vL1xuLy8gTW9kYWwgU2VhcmNoIFN5c3RlbVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFZhcmlhYmxlcyBkZWZpbmVkIGluIHBlcmNoLWNvcmUtc2NyaXB0cy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBWYXJpYWJsZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyICRzZWFyY2hfcmV2ZWFsX2J1dHRvbiA9ICQoJy5nbG9iYWwtc2VhcmNoLXJldmVhbC1idXR0b24nKSxcbiAgJHNlYXJjaF9tZW51ICAgICAgPSAkKCcjZ2xvYmFsLXNlYXJjaC1vdmVybGF5JyksXG4gICRzZWFyY2hfaW5wdXQgICAgICAgPSAkKCcjZ2xvYmFsLXNlYXJjaC1vdmVybGF5X19pbnB1dCcpLFxuICAkc2VhcmNoX3N1Ym1pdCAgICAgID0gJCgnI2dsb2JhbC1zZWFyY2gtb3ZlcmxheV9fc3VibWl0JyksXG4gICRzZWFyY2hfY2xvc2VfYnRuICAgICA9ICQoJyNnbG9iYWwtc2VhcmNoLW92ZXJsYXlfX2Nsb3NlLWJ1dHRvbicpLFxuXG4gIC8vIEdsb2JhbCBzdGFuZGFyZCBmb3IgdHJpZ2dlcmluZyBzZWFyY2guXG4gIC8vIEV4YW1wbGUgdXNhZ2U6IHJhdGhlciB0aGFuIGVtYmVkIGFuIGFkZGl0aW9uYWwgc2VhcmNoIGZvcm0gaW5wdXQgYW5kIHN1Ym1pdCBvbiBhIDQwNCBwYWdlLCBhZGQgYSBsaW5rIG9yIGJ1dHRvbiB3aXRoIHRoaXMgY2xhc3MgdGhhdCBzdW1tb25zIHRoZSBzaXRlIHNlYXJjaC5cbiAgLy8gSWYgbm90IHVzaW5nIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIG1vZGFsIHNlYXJjaCBzeXN0ZW0sIHdyaXRlIHNvbWV0aGluZyBzaW1pbGFyIHVzaW5nIHRoaXMgY2xhc3MgbmFtZSBhbmQgdmFyaWFibGUuXG4gICRzZWFyY2hfdHJpZ2dlciAgICAgPSAkKCcuZ2xvYmFsLXNlYXJjaC10cmlnZ2VyJyk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBTZWFyY2ggb3BlbmluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIG9wZW5TZWFyY2ggKCkge1xuICAvLyBGaXJzdCwgbWFrZSB0aGUgbGluayBoaWdobGlnaHRlZCAmIHNob3cgdGhlIG1lbnVcbiAgJHNlYXJjaF9yZXZlYWxfYnV0dG9uLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKS5hdHRyKCdhcmlhLXByZXNzZWQnLCAndHJ1ZScpO1xuICAkc2VhcmNoX21lbnUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAvLyBUaGVuLCBzZWxlY3QgdGhlIGlucHV0IGZpZWxkXG4gICRzZWFyY2hfaW5wdXQuc2VsZWN0KCk7XG59XG5cblxuLy8gU2VhcmNoIGNsb3Npbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjbG9zZVNlYXJjaCAoKSB7XG4gIC8vIFJlbW92ZSBjbGFzc2VzIHRvIHRoZSBtZW51IGFuZCB0aGUgbGlua1xuICAvLyAkKHRoaXMpLm9mZnNldFdpZHRoID0gJCh0aGlzKS5vZmZzZXRXaWR0aDtcbiAgJHNlYXJjaF9tZW51LmFkZENsYXNzKCdhbmltYXRpbmctb3V0Jyk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgJHNlYXJjaF9yZXZlYWxfYnV0dG9uLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJykuYXR0cignYXJpYS1wcmVzc2VkJywgJ2ZhbHNlJyk7XG4gICAgJHNlYXJjaF9tZW51LnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAkc2VhcmNoX21lbnUucmVtb3ZlQ2xhc3MoJ2FuaW1hdGluZy1vdXQnKTtcbiAgfSwgMjUwKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vLyBMb2dpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIENsb3NlIHRoZSBtZW51IGlmIGl0J3MgY3VycmVudGx5IGFjdGl2ZS4gT3RoZXJ3aXNlOiBydW4gb3BlblNlYXJjaCBmdW5jdGlvbi5cbiRzZWFyY2hfcmV2ZWFsX2J1dHRvbi5jbGljayhmdW5jdGlvbigpIHtcbiAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgY2xvc2VTZWFyY2goKTtcbiAgfVxuXG4gIGVsc2Uge1xuICAgIG9wZW5TZWFyY2goKTtcbiAgfVxufSk7XG5cblxuLy8gT3BlbiB0aGUgc2VhcmNoIG1lbnUgaWYgYW55IGFuY2hvciB3aXRoIGEgY2VydGFpbiBjbGFzcyBpcyBjbGlja2VkXG4kc2VhcmNoX3RyaWdnZXIuY2xpY2soZnVuY3Rpb24oKSB7XG4gIC8vIGlmIHRoZSBzZWxlY3RlZCBzZWFyY2ggdHJpZ2dlciBpcyBhbHNvIGEgc2VhcmNoIHJldmVhbCBidXR0b24sIGFib3J0IHRoaXMgZnVuY3Rpb25cbiAgaWYoJCh0aGlzKS5pcygkc2VhcmNoX3JldmVhbF9idXR0b24pKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIEFkZCBjbGFzc2VzIHRvIHRoZSBtZW51IGFuZCB0aGUgbGlua1xuICAkc2VhcmNoX3JldmVhbF9idXR0b24uYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAkc2VhcmNoX21lbnUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gIC8vIEZvY3VzIHRoZSBzZWFyY2ggaW5wdXRcbiAgJCh0aGlzKS5ibHVyKCk7XG4gICRzZWFyY2hfaW5wdXQuc2VsZWN0KCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG5cblxuLy8gQ2xpY2tpbmcgYW55d2hlcmUgaW4gdGhlIHNlYXJjaCdzIGJhY2tncm91bmQgb3ZlcmxheSDigJQgZXhjZXB0IHdpdGhpbiB0aGUgYWN0dWFsIGZvcm0g4oCUIGNsb3NlcyB0aGUgb3ZlcmxheVxuJHNlYXJjaF9tZW51LmNsaWNrKGNsb3NlU2VhcmNoKTtcbiAgLy8gLi4uRG8gbm90IGNsb3NlIGlmIHRoZSBjbGljayBpcyBpbnNpZGUgdGhlIGlubmVyIGNvbnRhaW5lci5cbiAgJCgnLmdsb2JhbC1zZWFyY2gtb3ZlcmxheV9faW5uZXInKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbiRzZWFyY2hfY2xvc2VfYnRuLmNsaWNrKGNsb3NlU2VhcmNoKTtcblxuXG4vLyBTZWFyY2gga2V5Ym9hcmQgYXNzaXN0OiB3aGVuIHNlYXJjaCBtZW51IGlzIG9wZW4sIGtlZXAgZm9jdXMgd2l0aGluIHRoZSBzZWFyY2ggbWVudVxuLy8gYnkgZm9jdXNpbmcgXCJiYWNrIHRvXCIgdGhlIGNvcm5lciBjbG9zZXIgYnV0dG9uLCB3aGljaCBhbGxvd3MgdGhlIHVzZXIgdG8gY2xvc2UgaWYgZGVzaXJlZCxcbi8vIG9yIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGZvY3VzYWJsZSBmaWVsZCwgdGhlIGlucHV0IGl0c2VsZlxuJHNlYXJjaF9jbG9zZV9idG4ub24oJ2ZvY3Vzb3V0JywgZnVuY3Rpb24oKSB7XG4gICRzZWFyY2hfaW5wdXQuZm9jdXMoKTtcbn0pO1xuXG4vL1xuLy8gS2V5Ym9hcmQgc2hvcnRjdXRzIHdpdGggTW91c2VUcmFwLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQXNzdW1lcyBhbiBpbnRlZ3JhdGlvbiB3aXRoOlxuLy8gLSBuYXZpZ2F0aW9uLXN5c3RlbS5qc1xuLy8gLSBtb2RhbC1zZWFyY2gtc3lzdGVtLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBvcGVuIHNlYXJjaFxuTW91c2V0cmFwLmJpbmQoJy8nLCBmdW5jdGlvbihlKSB7XG5cbiAgaWYgKHR5cGVvZiBvcGVuU2VhcmNoID09ICdmdW5jdGlvbicgJiYgJHNlYXJjaF9tZW51Lmxlbmd0aCkge1xuICAgIC8vIElmIHRoZSBzZWFyY2ggbWVudSBpcyBhbHJlYWR5IG9wZW4sIG5ldmVybWluZCwgbGV0IHRoZSBgL2AgdGhyb3VnaC4uLlxuICAgIGlmICgkc2VhcmNoX21lbnUuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBCdXQgaWYgaXQncyBub3QgYWxyZWFkeSBvcGVuLCBjYXB0dXJlIHRoZSBgL2AgYW5kIG9wZW4gdGhlIG1lbnVcbiAgICBlbHNlIHtcbiAgICAgIC8vIFByZXZlbnQgJy8nIGNoYXIgZnJvbSBiZWluZyB0eXBlZCBpbnRvIHRoZSBuZXdseS1mb2N1c2VkIHNlYXJjaCBmaWVsZFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBvcGVuU2VhcmNoKCk7XG4gICAgfVxuICB9XG4gIC8vIGVsc2Uge1xuICAvLyAgY29uc29sZS5sb2coXCJFaXRoZXIgb3BlblNlYXJjaCBpcyBub3QgYSBmdW5jdGlvbiBvciAkc2VhcmNoX21lbnUgaGFzIG5vdCBiZWVuIGFzc2lnbmVkLlwiKTtcbiAgLy8gfVxuXG59KTtcblxuLy8gcHJlc3MgZXNjYXBlIChFU0MpIHRvIGNsb3NlIG1lbnVzXG5Nb3VzZXRyYXAuYmluZCgnZXNjJywgZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2YgY2xvc2VOYXYgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNsb3NlTmF2KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjbG9zZVNlYXJjaCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2xvc2VTZWFyY2goKTtcbiAgfVxufSk7XG5cbi8vIG9wZW4gdGhlIG1lbnUvbmF2XG5Nb3VzZXRyYXAuYmluZCgndScsIGZ1bmN0aW9uKCkge1xuICAvLyBTaW5jZSBzZWFyY2ggaW5wdXQgaXMgYWxsb3dlZCB0byBsaXN0ZW4gdG8gTW91c2V0cmFwIChub3JtYWxseSBpdCdzIGRpc2FibGVkIOKAlCBidXQgd2Ugd2FudCBpdCBlbmFibGVkIGZvciBFU0Mga2V5IGNsb3NlKSwgaWdub3JlIHRoZSBcInVcIiBjaGFyYWN0ZXIgaWYgaXQgaXMgb3BlblxuICBpZiggKCF0eXBlb2YoJHNlYXJjaF9tZW51KSA9PT0gJ3VuZGVmaW5lZCcpICYmICgkc2VhcmNoX21lbnUuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgaWYgdGhlIG1vYmlsZSBuYXZpZ2F0aW9uIGlzIG9wZW4sIGNsb3NlIGl0XG4gIGVsc2UgaWYgKCRnbG9iYWxfaGVhZGVyLmhhc0NsYXNzKCdtb2JpbGUtbmF2LWlzLW9wZW4nKSkge1xuICAgIGlmICh0eXBlb2YgY2xvc2VOYXYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2xvc2VOYXYoKTtcbiAgICB9XG4gIH1cblxuICAvLyAuLi5hbmQgaWYgaXQncyBub3Qgb3Blbiwgb3BlbiBpdFxuICBlbHNlIHtcbiAgICBpZiAodHlwZW9mIG9wZW5OYXYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3Blbk5hdigpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIC8vIGtvbmFtaSBjb2RlIVxuLy8gTW91c2V0cmFwLmJpbmQoJ3VwIHVwIGRvd24gZG93biBsZWZ0IHJpZ2h0IGxlZnQgcmlnaHQgYiBhJywgZnVuY3Rpb24oKSB7IC8vZW50ZXJcbi8vICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2tvbmFtaS1jb2RlLWlzLWFjdGl2ZScpO1xuLy8gfSk7XG5cbi8qIVxuXG5Ib2xkZXIgLSBjbGllbnQgc2lkZSBpbWFnZSBwbGFjZWhvbGRlcnNcblZlcnNpb24gMi45LjYrZmJseXlcbsKpIDIwMTggSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvXG5cblNpdGU6ICAgICBodHRwOi8vaG9sZGVyanMuY29tXG5Jc3N1ZXM6ICAgaHR0cHM6Ly9naXRodWIuY29tL2ltc2t5L2hvbGRlci9pc3N1ZXNcbkxpY2Vuc2U6ICBNSVRcblxuKi9cbihmdW5jdGlvbiAod2luZG93KSB7XG4gIGlmICghd2luZG93LmRvY3VtZW50KSByZXR1cm47XG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbC9ibG9iL21hc3Rlci93ZWIuanNcbiAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksIGVsZW1lbnRzID0gW10sIGVsZW1lbnQ7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgZG9jdW1lbnQuX3FzYSA9IFtdO1xuXG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHNlbGVjdG9ycyArICd7eC1xc2E6ZXhwcmVzc2lvbihkb2N1bWVudC5fcXNhICYmIGRvY3VtZW50Ll9xc2EucHVzaCh0aGlzKSl9JztcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIDApO1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuICAgICAgICB3aGlsZSAoZG9jdW1lbnQuX3FzYS5sZW5ndGgpIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuX3FzYS5zaGlmdCgpO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCd4LXFzYScpO1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuX3FzYSA9IG51bGw7XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycyk7XG4gICAgICAgIHJldHVybiAoZWxlbWVudHMubGVuZ3RoKSA/IGVsZW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgY2xhc3NOYW1lcyA9IFN0cmluZyhjbGFzc05hbWVzKS5yZXBsYWNlKC9efFxccysvZywgJy4nKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2xhc3NOYW1lcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbFxuICAvLyBFUzUgMTUuMi4zLjE0IE9iamVjdC5rZXlzICggTyApXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTsgfVxuICAgICAgdmFyIHJldCA9IFtdLCBwO1xuICAgICAgZm9yIChwIGluIG8pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkge1xuICAgICAgICAgIHJldC5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cblxuICAvLyBFUzUgMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcbiAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cblxuICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XG5cbiAgICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0KSB7XG4gICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHRbaV0sIGksIHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vaHR0cHM6Ly9naXRodWIuY29tL2luZXhvcmFibGV0YXNoL3BvbHlmaWxsL2Jsb2IvbWFzdGVyL3dlYi5qc1xuICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIHZhciBCNjRfQUxQSEFCRVQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIGdsb2JhbC5hdG9iID0gZ2xvYmFsLmF0b2IgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgICAgIGJ1ZmZlciA9IDAsIGJpdHMgPSAwLCBuO1xuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBpZiAoKGlucHV0Lmxlbmd0aCAlIDQpID09PSAwKSB7IGlucHV0ID0gaW5wdXQucmVwbGFjZSgvPSskLywgJycpOyB9XG4gICAgICBpZiAoKGlucHV0Lmxlbmd0aCAlIDQpID09PSAxKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuICAgICAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChpbnB1dCkpIHsgdGhyb3cgRXJyb3IoJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcicpOyB9XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBuID0gQjY0X0FMUEhBQkVULmluZGV4T2YoaW5wdXQuY2hhckF0KHBvc2l0aW9uKSk7XG4gICAgICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgNikgfCBuO1xuICAgICAgICBiaXRzICs9IDY7XG5cbiAgICAgICAgaWYgKGJpdHMgPT09IDI0KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoYnVmZmVyID4+IDE2KSAmIDB4RkYpKTtcbiAgICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChidWZmZXIgPj4gIDgpICYgMHhGRikpO1xuICAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyICYgMHhGRikpO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIGJ1ZmZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdHMgPT09IDEyKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciA+PiA0O1xuICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlciAmIDB4RkYpKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0cyA9PT0gMTgpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyID4+IDI7XG4gICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKGJ1ZmZlciA+PiA4KSAmIDB4RkYpKTtcbiAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIgJiAweEZGKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIGdsb2JhbC5idG9hID0gZ2xvYmFsLmJ0b2EgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgIG8xLCBvMiwgbzMsXG4gICAgICAgICAgZTEsIGUyLCBlMywgZTQ7XG5cbiAgICAgIGlmICgvW15cXHgwMC1cXHhGRl0vLnRlc3QoaW5wdXQpKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbzEgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKyspO1xuICAgICAgICBvMiA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24rKyk7XG4gICAgICAgIG8zID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbisrKTtcblxuICAgICAgICAvLyAxMTExMTEgMTEyMjIyIDIyMjIzMyAzMzMzMzNcbiAgICAgICAgZTEgPSBvMSA+PiAyO1xuICAgICAgICBlMiA9ICgobzEgJiAweDMpIDw8IDQpIHwgKG8yID4+IDQpO1xuICAgICAgICBlMyA9ICgobzIgJiAweGYpIDw8IDIpIHwgKG8zID4+IDYpO1xuICAgICAgICBlNCA9IG8zICYgMHgzZjtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCArIDIpIHtcbiAgICAgICAgICBlMyA9IDY0OyBlNCA9IDY0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgZTQgPSA2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5wdXNoKEI2NF9BTFBIQUJFVC5jaGFyQXQoZTEpLFxuICAgICAgICAgICAgICAgICBCNjRfQUxQSEFCRVQuY2hhckF0KGUyKSxcbiAgICAgICAgICAgICAgICAgQjY0X0FMUEhBQkVULmNoYXJBdChlMyksXG4gICAgICAgICAgICAgICAgIEI2NF9BTFBIQUJFVC5jaGFyQXQoZTQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgICB9O1xuICB9KHdpbmRvdykpO1xuXG4gIC8vaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamltZWgvMzMyMzU3XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl7XG4gICAgICAvKmpzaGludCAtVzAwMSwgLVcxMDMgKi9cbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgICB2YXIgcHJvdG8gPSB0aGlzLl9fcHJvdG9fXyB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAocHJvcCBpbiB0aGlzKSAmJiAoIShwcm9wIGluIHByb3RvKSB8fCBwcm90b1twcm9wXSAhPT0gdGhpc1twcm9wXSk7XG4gICAgfTtcbiAgICAgIC8qanNoaW50ICtXMDAxLCArVzEwMyAqL1xuICB9XG5cbiAgLy8gQGxpY2Vuc2UgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICAvLyBjb3B5cmlnaHQgUGF1bCBJcmlzaCAyMDE1XG5cblxuICAvLyBEYXRlLm5vdygpIGlzIHN1cHBvcnRlZCBldmVyeXdoZXJlIGV4Y2VwdCBJRTguIEZvciBJRTggd2UgdXNlIHRoZSBEYXRlLm5vdyBwb2x5ZmlsbFxuICAvLyAgIGdpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvYmxvYi9tYXN0ZXIvcG9seWZpbGxzL0RhdGUubm93L3BvbHlmaWxsLmpzXG4gIC8vIGFzIFNhZmFyaSA2IGRvZXNuJ3QgaGF2ZSBzdXBwb3J0IGZvciBOYXZpZ2F0aW9uVGltaW5nLCB3ZSB1c2UgYSBEYXRlLm5vdygpIHRpbWVzdGFtcCBmb3IgcmVsYXRpdmUgdmFsdWVzXG5cbiAgLy8gaWYgeW91IHdhbnQgdmFsdWVzIHNpbWlsYXIgdG8gd2hhdCB5b3UnZCBnZXQgd2l0aCByZWFsIHBlcmYubm93LCBwbGFjZSB0aGlzIHRvd2FyZHMgdGhlIGhlYWQgb2YgdGhlIHBhZ2VcbiAgLy8gYnV0IGluIHJlYWxpdHksIHlvdSdyZSBqdXN0IGdldHRpbmcgdGhlIGRlbHRhIGJldHdlZW4gbm93KCkgY2FsbHMsIHNvIGl0J3Mgbm90IHRlcnJpYmx5IGltcG9ydGFudCB3aGVyZSBpdCdzIHBsYWNlZFxuXG5cbiAgKGZ1bmN0aW9uKCl7XG5cbiAgICBpZiAoJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgPT09IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBEYXRlLm5vdyA9IChEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7ICAvLyB0aGFua3MgSUU4XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09PSBmYWxzZSl7XG4gICAgICBcbiAgICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgfSkoKTtcblxuICAvL3JlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBmb3Igb2xkZXIgRmlyZWZveC9DaHJvbWUgdmVyc2lvbnNcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgaWYgKHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvYmxvYi9tYXN0ZXIvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS9wb2x5ZmlsbC13ZWJraXQuanNcbiAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gd2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayhnbG9iYWwucGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB9KHdpbmRvdykpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL2Jsb2IvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUvcG9seWZpbGwtbW96LmpzXG4gICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG1velJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfSh3aW5kb3cpKTtcbiAgICB9IGVsc2Uge1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG4gICAgfSkod2luZG93KTtcbiAgICB9XG4gIH1cbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICAgIGV4cG9ydHNbXCJIb2xkZXJcIl0gPSBmYWN0b3J5KCk7XG4gIGVsc2VcbiAgICByb290W1wiSG9sZGVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovICAgIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gICAgaWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gICAgICBleHBvcnRzOiB7fSxcbi8qKioqKiovICAgICAgaWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gICAgICBsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyAgICB9O1xuXG4vKioqKioqLyAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyAgICBtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovICB9XG5cblxuLyoqKioqKi8gIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gIC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIC8qXG4gIEhvbGRlci5qcyAtIGNsaWVudCBzaWRlIGltYWdlIHBsYWNlaG9sZGVyc1xuICAoYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jb1xuICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LypcbiAgSG9sZGVyLmpzIC0gY2xpZW50IHNpZGUgaW1hZ2UgcGxhY2Vob2xkZXJzXG4gIChjKSAyMDEyLTIwMTYgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvXG4gICovXG5cbiAgLy9MaWJyYXJpZXMgYW5kIGZ1bmN0aW9uc1xuICB2YXIgb25Eb21SZWFkeSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4gIHZhciBxdWVyeXN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbiAgdmFyIFNjZW5lR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuICB2YXIgU1ZHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIERPTSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciBDb2xvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuICB2YXIgY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgdmFyIHN2Z1JlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4gIHZhciBzZ0NhbnZhc1JlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbiAgdmFyIGV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcbiAgdmFyIGRpbWVuc2lvbkNoZWNrID0gdXRpbHMuZGltZW5zaW9uQ2hlY2s7XG5cbiAgLy9Db25zdGFudHMgYW5kIGRlZmluaXRpb25zXG4gIHZhciBTVkdfTlMgPSBjb25zdGFudHMuc3ZnX25zO1xuXG4gIHZhciBIb2xkZXIgPSB7XG4gICAgICB2ZXJzaW9uOiBjb25zdGFudHMudmVyc2lvbixcblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGEgdGhlbWUgdG8gZGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZW1lIG5hbWVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGVtZSBUaGVtZSBvYmplY3QsIHdpdGggZm9yZWdyb3VuZCwgYmFja2dyb3VuZCwgc2l6ZSwgZm9udCwgYW5kIGZvbnR3ZWlnaHQgcHJvcGVydGllcy5cbiAgICAgICAqL1xuICAgICAgYWRkVGhlbWU6IGZ1bmN0aW9uKG5hbWUsIHRoZW1lKSB7XG4gICAgICAgICAgbmFtZSAhPSBudWxsICYmIHRoZW1lICE9IG51bGwgJiYgKEFwcC5zZXR0aW5ncy50aGVtZXNbbmFtZV0gPSB0aGVtZSk7XG4gICAgICAgICAgZGVsZXRlIEFwcC52YXJzLmNhY2hlLnRoZW1lS2V5cztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQXBwZW5kcyBhIHBsYWNlaG9sZGVyIHRvIGFuIGVsZW1lbnRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFBsYWNlaG9sZGVyIFVSTCBzdHJpbmdcbiAgICAgICAqIEBwYXJhbSBlbCBBIHNlbGVjdG9yIG9yIGEgcmVmZXJlbmNlIHRvIGEgRE9NIG5vZGVcbiAgICAgICAqL1xuICAgICAgYWRkSW1hZ2U6IGZ1bmN0aW9uKHNyYywgZWwpIHtcbiAgICAgICAgICAvL3RvZG86IHVzZSBqcXVlcnkgZmFsbGJhY2sgaWYgYXZhaWxhYmxlIGZvciBhbGwgUVNBIHJlZmVyZW5jZXNcbiAgICAgICAgICB2YXIgbm9kZXMgPSBET00uZ2V0Tm9kZUFycmF5KGVsKTtcbiAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHZhciBpbWcgPSBET00ubmV3RWwoJ2ltZycpO1xuICAgICAgICAgICAgICB2YXIgZG9tUHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgZG9tUHJvcHNbQXBwLnNldHVwLmRhdGFBdHRyXSA9IHNyYztcbiAgICAgICAgICAgICAgRE9NLnNldEF0dHIoaW1nLCBkb21Qcm9wcyk7XG4gICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbiBpbWFnZSBpcyB1cGRhdGVkIG9uIHJlc2l6ZS5cbiAgICAgICAqIElmIGFuIGltYWdlIGlzIHNldCB0byBiZSB1cGRhdGVkLCBpdCBpcyBpbW1lZGlhdGVseSByZW5kZXJlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWwgSW1hZ2UgRE9NIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgUmVzaXphYmxlIHVwZGF0ZSBmbGFnIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIHNldFJlc2l6ZVVwZGF0ZTogZnVuY3Rpb24oZWwsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGVsLmhvbGRlckRhdGEpIHtcbiAgICAgICAgICAgICAgZWwuaG9sZGVyRGF0YS5yZXNpemVVcGRhdGUgPSAhIXZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZWwuaG9sZGVyRGF0YS5yZXNpemVVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUnVucyBIb2xkZXIgd2l0aCBvcHRpb25zLiBCeSBkZWZhdWx0IHJ1bnMgSG9sZGVyIG9uIGFsbCBpbWFnZXMgd2l0aCBcImhvbGRlci5qc1wiIGluIHRoZWlyIHNvdXJjZSBhdHRyaWJ1dGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9ucyBPcHRpb25zIG9iamVjdCwgY2FuIGNvbnRhaW4gZG9tYWluLCB0aGVtZXMsIGltYWdlcywgYW5kIGJnbm9kZXMgcHJvcGVydGllc1xuICAgICAgICovXG4gICAgICBydW46IGZ1bmN0aW9uKHVzZXJPcHRpb25zKSB7XG4gICAgICAgICAgLy90b2RvOiBzcGxpdCBwcm9jZXNzaW5nIGludG8gc2VwYXJhdGUgcXVldWVzXG4gICAgICAgICAgdXNlck9wdGlvbnMgPSB1c2VyT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICB2YXIgZW5naW5lU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZChBcHAuc2V0dGluZ3MsIHVzZXJPcHRpb25zKTtcblxuICAgICAgICAgIEFwcC52YXJzLnByZWVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgQXBwLnZhcnMuZGF0YUF0dHIgPSBvcHRpb25zLmRhdGFBdHRyIHx8IEFwcC5zZXR1cC5kYXRhQXR0cjtcblxuICAgICAgICAgIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlciA/IG9wdGlvbnMucmVuZGVyZXIgOiBBcHAuc2V0dXAucmVuZGVyZXI7XG4gICAgICAgICAgaWYgKEFwcC5zZXR1cC5yZW5kZXJlcnMuam9pbignLCcpLmluZGV4T2YoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIpID09PSAtMSkge1xuICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5yZW5kZXJlciA9IEFwcC5zZXR1cC5zdXBwb3J0c1NWRyA/ICdzdmcnIDogKEFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcyA/ICdjYW52YXMnIDogJ2h0bWwnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW1hZ2VzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLmltYWdlcyk7XG4gICAgICAgICAgdmFyIGJnbm9kZXMgPSBET00uZ2V0Tm9kZUFycmF5KG9wdGlvbnMuYmdub2Rlcyk7XG4gICAgICAgICAgdmFyIHN0eWxlbm9kZXMgPSBET00uZ2V0Tm9kZUFycmF5KG9wdGlvbnMuc3R5bGVub2Rlcyk7XG4gICAgICAgICAgdmFyIG9iamVjdHMgPSBET00uZ2V0Tm9kZUFycmF5KG9wdGlvbnMub2JqZWN0cyk7XG5cbiAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5zdHlsZXNoZWV0cyA9IFtdO1xuICAgICAgICAgIGVuZ2luZVNldHRpbmdzLnN2Z1hNTFN0eWxlc2hlZXQgPSB0cnVlO1xuICAgICAgICAgIGVuZ2luZVNldHRpbmdzLm5vRm9udEZhbGxiYWNrID0gISFvcHRpb25zLm5vRm9udEZhbGxiYWNrO1xuICAgICAgICAgIGVuZ2luZVNldHRpbmdzLm5vQmFja2dyb3VuZFNpemUgPSAhIW9wdGlvbnMubm9CYWNrZ3JvdW5kU2l6ZTtcblxuICAgICAgICAgIHN0eWxlbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChzdHlsZU5vZGUuYXR0cmlidXRlcy5yZWwgJiYgc3R5bGVOb2RlLmF0dHJpYnV0ZXMuaHJlZiAmJiBzdHlsZU5vZGUuYXR0cmlidXRlcy5yZWwudmFsdWUgPT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IHN0eWxlTm9kZS5hdHRyaWJ1dGVzLmhyZWYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAvL3RvZG86IHdyaXRlIGlzb21vcnBoaWMgcmVsYXRpdmUtdG8tYWJzb2x1dGUgVVJMIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICB2YXIgcHJveHlMaW5rID0gRE9NLm5ld0VsKCdhJyk7XG4gICAgICAgICAgICAgICAgICBwcm94eUxpbmsuaHJlZiA9IGhyZWY7XG4gICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzaGVldFVSTCA9IHByb3h5TGluay5wcm90b2NvbCArICcvLycgKyBwcm94eUxpbmsuaG9zdCArIHByb3h5TGluay5wYXRobmFtZSArIHByb3h5TGluay5zZWFyY2g7XG4gICAgICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5zdHlsZXNoZWV0cy5wdXNoKHN0eWxlc2hlZXRVUkwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBiZ25vZGVzLmZvckVhY2goZnVuY3Rpb24gKGJnTm9kZSkge1xuICAgICAgICAgICAgICAvL1NraXAgcHJvY2Vzc2luZyBiYWNrZ3JvdW5kIG5vZGVzIGlmIGdldENvbXB1dGVkU3R5bGUgaXMgdW5hdmFpbGFibGUsIHNpbmNlIG9ubHkgbW9kZXJuIGJyb3dzZXJzIHdvdWxkIGJlIGFibGUgdG8gdXNlIGNhbnZhcyBvciBTVkcgdG8gcmVuZGVyIHRvIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgaWYgKCFnbG9iYWwuZ2V0Q29tcHV0ZWRTdHlsZSkgcmV0dXJuO1xuICAgICAgICAgICAgICB2YXIgYmFja2dyb3VuZEltYWdlID0gZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoYmdOb2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gICAgICAgICAgICAgIHZhciBkYXRhQmFja2dyb3VuZEltYWdlID0gYmdOb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrZ3JvdW5kLXNyYycpO1xuICAgICAgICAgICAgICB2YXIgcmF3VVJMID0gZGF0YUJhY2tncm91bmRJbWFnZSB8fCBiYWNrZ3JvdW5kSW1hZ2U7XG5cbiAgICAgICAgICAgICAgdmFyIGhvbGRlclVSTCA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciBob2xkZXJTdHJpbmcgPSBvcHRpb25zLmRvbWFpbiArICcvJztcbiAgICAgICAgICAgICAgdmFyIGhvbGRlclN0cmluZ0luZGV4ID0gcmF3VVJMLmluZGV4T2YoaG9sZGVyU3RyaW5nKTtcblxuICAgICAgICAgICAgICBpZiAoaG9sZGVyU3RyaW5nSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGhvbGRlclVSTCA9IHJhd1VSTDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChob2xkZXJTdHJpbmdJbmRleCA9PT0gMSAmJiByYXdVUkxbMF0gPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgaG9sZGVyVVJMID0gcmF3VVJMLnNsaWNlKDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gcmF3VVJMLnN1YnN0cihob2xkZXJTdHJpbmdJbmRleCkubWF0Y2goLyhbXlxcXCJdKilcIj9cXCkvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGhvbGRlclVSTCA9IGZyYWdtZW50WzFdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYXdVUkwuaW5kZXhPZigndXJsKCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0hvbGRlcjogdW5hYmxlIHRvIHBhcnNlIGJhY2tncm91bmQgVVJMOiAnICsgcmF3VVJMO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGhvbGRlclVSTCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGhvbGRlckZsYWdzID0gcGFyc2VVUkwoaG9sZGVyVVJMLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChob2xkZXJGbGFncykge1xuICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVET01FbGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2JhY2tncm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogYmdOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogaG9sZGVyRmxhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbmdpbmVTZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgICB2YXIgb2JqZWN0QXR0ciA9IHt9O1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBvYmplY3RBdHRyLmRhdGEgPSBvYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhJyk7XG4gICAgICAgICAgICAgICAgICBvYmplY3RBdHRyLmRhdGFTcmMgPSBvYmplY3QuZ2V0QXR0cmlidXRlKEFwcC52YXJzLmRhdGFBdHRyKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICAgICAgICB2YXIgb2JqZWN0SGFzU3JjVVJMID0gb2JqZWN0QXR0ci5kYXRhICE9IG51bGwgJiYgb2JqZWN0QXR0ci5kYXRhLmluZGV4T2Yob3B0aW9ucy5kb21haW4pID09PSAwO1xuICAgICAgICAgICAgICB2YXIgb2JqZWN0SGFzRGF0YVNyY1VSTCA9IG9iamVjdEF0dHIuZGF0YVNyYyAhPSBudWxsICYmIG9iamVjdEF0dHIuZGF0YVNyYy5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcblxuICAgICAgICAgICAgICBpZiAob2JqZWN0SGFzU3JjVVJMKSB7XG4gICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBvYmplY3RBdHRyLmRhdGEsIG9iamVjdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0SGFzRGF0YVNyY1VSTCkge1xuICAgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgb2JqZWN0QXR0ci5kYXRhU3JjLCBvYmplY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGltYWdlQXR0ciA9IHt9O1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpbWFnZUF0dHIuc3JjID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgICAgICAgIGltYWdlQXR0ci5kYXRhU3JjID0gaW1hZ2UuZ2V0QXR0cmlidXRlKEFwcC52YXJzLmRhdGFBdHRyKTtcbiAgICAgICAgICAgICAgICAgIGltYWdlQXR0ci5yZW5kZXJlZCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnZGF0YS1ob2xkZXItcmVuZGVyZWQnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICAgICAgICB2YXIgaW1hZ2VIYXNTcmMgPSBpbWFnZUF0dHIuc3JjICE9IG51bGw7XG4gICAgICAgICAgICAgIHZhciBpbWFnZUhhc0RhdGFTcmNVUkwgPSBpbWFnZUF0dHIuZGF0YVNyYyAhPSBudWxsICYmIGltYWdlQXR0ci5kYXRhU3JjLmluZGV4T2Yob3B0aW9ucy5kb21haW4pID09PSAwO1xuICAgICAgICAgICAgICB2YXIgaW1hZ2VSZW5kZXJlZCA9IGltYWdlQXR0ci5yZW5kZXJlZCAhPSBudWxsICYmIGltYWdlQXR0ci5yZW5kZXJlZCA9PSAndHJ1ZSc7XG5cbiAgICAgICAgICAgICAgaWYgKGltYWdlSGFzU3JjKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VBdHRyLnNyYy5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIGltYWdlQXR0ci5zcmMsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VIYXNEYXRhU3JjVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy9JbWFnZSBoYXMgYSB2YWxpZCBkYXRhLXNyYyBhbmQgYW4gaW52YWxpZCBzcmNcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZSBwbGFjZWhvbGRlciBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlciwgcmUtcmVuZGVyIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIGltYWdlQXR0ci5kYXRhU3JjLCBpbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgcGxhY2Vob2xkZXIgaGFzIG5vdCBiZWVuIHJlbmRlcmVkLCBjaGVjayBpZiB0aGUgaW1hZ2UgZXhpc3RzIGFuZCByZW5kZXIgYSBmYWxsYmFjayBpZiBpdCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihzcmMsIG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBkYXRhU3JjLCBpbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuaW1hZ2VFeGlzdHMoc3JjLCBmdW5jdGlvbihleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBkYXRhU3JjLCBpbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKGltYWdlQXR0ci5zcmMsIG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbWFnZUhhc0RhdGFTcmNVUkwpIHtcbiAgICAgICAgICAgICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIGltYWdlQXR0ci5kYXRhU3JjLCBpbWFnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICB9O1xuXG4gIHZhciBBcHAgPSB7XG4gICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGRvbWFpbjogJ2hvbGRlci5qcycsXG4gICAgICAgICAgaW1hZ2VzOiAnaW1nJyxcbiAgICAgICAgICBvYmplY3RzOiAnb2JqZWN0JyxcbiAgICAgICAgICBiZ25vZGVzOiAnYm9keSAuaG9sZGVyanMnLFxuICAgICAgICAgIHN0eWxlbm9kZXM6ICdoZWFkIGxpbmsuaG9sZGVyanMnLFxuICAgICAgICAgIHRoZW1lczoge1xuICAgICAgICAgICAgICAnZ3JheSc6IHtcbiAgICAgICAgICAgICAgICAgIGJnOiAnI0VFRUVFRScsXG4gICAgICAgICAgICAgICAgICBmZzogJyNBQUFBQUEnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdzb2NpYWwnOiB7XG4gICAgICAgICAgICAgICAgICBiZzogJyMzYTVhOTcnLFxuICAgICAgICAgICAgICAgICAgZmc6ICcjRkZGRkZGJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnaW5kdXN0cmlhbCc6IHtcbiAgICAgICAgICAgICAgICAgIGJnOiAnIzQzNEE1MicsXG4gICAgICAgICAgICAgICAgICBmZzogJyNDMkYyMDAnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdza3knOiB7XG4gICAgICAgICAgICAgICAgICBiZzogJyMwRDhGREInLFxuICAgICAgICAgICAgICAgICAgZmc6ICcjRkZGRkZGJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAndmluZSc6IHtcbiAgICAgICAgICAgICAgICAgIGJnOiAnIzM5REJBQycsXG4gICAgICAgICAgICAgICAgICBmZzogJyMxRTI5MkMnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdsYXZhJzoge1xuICAgICAgICAgICAgICAgICAgYmc6ICcjRjg1OTFBJyxcbiAgICAgICAgICAgICAgICAgIGZnOiAnIzFDMjg0NidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgIHVuaXRzOiAncHQnLFxuICAgICAgICAgIHNjYWxlOiAxIC8gMTZcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvY2Vzc2VzIHByb3ZpZGVkIHNvdXJjZSBhdHRyaWJ1dGUgYW5kIHNldHMgdXAgdGhlIGFwcHJvcHJpYXRlIHJlbmRlcmluZyB3b3JrZmxvd1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBJbnN0YW5jZSBvcHRpb25zIGZyb20gSG9sZGVyLnJ1blxuICAgKiBAcGFyYW0gcmVuZGVyU2V0dGluZ3MgSW5zdGFuY2UgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gc3JjIEltYWdlIFVSTFxuICAgKiBAcGFyYW0gZWwgSW1hZ2UgRE9NIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIHNyYywgZWwpIHtcbiAgICAgIHZhciBob2xkZXJGbGFncyA9IHBhcnNlVVJMKHNyYy5zdWJzdHIoc3JjLmxhc3RJbmRleE9mKG9wdGlvbnMuZG9tYWluKSksIG9wdGlvbnMpO1xuICAgICAgaWYgKGhvbGRlckZsYWdzKSB7XG4gICAgICAgICAgcHJlcGFyZURPTUVsZW1lbnQoe1xuICAgICAgICAgICAgICBtb2RlOiBudWxsLFxuICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgIGZsYWdzOiBob2xkZXJGbGFncyxcbiAgICAgICAgICAgICAgZW5naW5lU2V0dGluZ3M6IGVuZ2luZVNldHRpbmdzXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgSG9sZGVyIFVSTCBhbmQgZXh0cmFjdHMgY29uZmlndXJhdGlvbiBmcm9tIHF1ZXJ5IHN0cmluZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gdXJsIFVSTFxuICAgKiBAcGFyYW0gaW5zdGFuY2VPcHRpb25zIEluc3RhbmNlIG9wdGlvbnMgZnJvbSBIb2xkZXIucnVuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVVSTCh1cmwsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgdmFyIGhvbGRlciA9IHtcbiAgICAgICAgICB0aGVtZTogZXh0ZW5kKEFwcC5zZXR0aW5ncy50aGVtZXMuZ3JheSwgbnVsbCksXG4gICAgICAgICAgc3R5bGVzaGVldHM6IGluc3RhbmNlT3B0aW9ucy5zdHlsZXNoZWV0cyxcbiAgICAgICAgICBpbnN0YW5jZU9wdGlvbnM6IGluc3RhbmNlT3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdmFyIGZpcnN0UXVlc3Rpb25NYXJrID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICAgIHZhciBwYXJ0cyA9IFt1cmxdO1xuXG4gICAgICBpZiAoZmlyc3RRdWVzdGlvbk1hcmsgIT09IC0xKSB7XG4gICAgICAgICAgcGFydHMgPSBbdXJsLnNsaWNlKDAsIGZpcnN0UXVlc3Rpb25NYXJrKSwgdXJsLnNsaWNlKGZpcnN0UXVlc3Rpb25NYXJrICsgMSldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFzaWNzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICAgICAgaG9sZGVyLmhvbGRlclVSTCA9IHVybDtcblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBiYXNpY3NbMV07XG4gICAgICB2YXIgZGltZW5zaW9uRGF0YSA9IGRpbWVuc2lvbnMubWF0Y2goLyhbXFxkXStwPyl4KFtcXGRdK3A/KS8pO1xuXG4gICAgICBpZiAoIWRpbWVuc2lvbkRhdGEpIHJldHVybiBmYWxzZTtcblxuICAgICAgaG9sZGVyLmZsdWlkID0gZGltZW5zaW9ucy5pbmRleE9mKCdwJykgIT09IC0xO1xuXG4gICAgICBob2xkZXIuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB3aWR0aDogZGltZW5zaW9uRGF0YVsxXS5yZXBsYWNlKCdwJywgJyUnKSxcbiAgICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbkRhdGFbMl0ucmVwbGFjZSgncCcsICclJylcbiAgICAgIH07XG5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHBhcnRzWzFdKTtcblxuICAgICAgICAgIC8vIERpbWVuc2lvbnNcblxuICAgICAgICAgIGlmICh1dGlscy50cnV0aHkob3B0aW9ucy5yYXRpbykpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLmZsdWlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHJhdGlvV2lkdGggPSBwYXJzZUZsb2F0KGhvbGRlci5kaW1lbnNpb25zLndpZHRoLnJlcGxhY2UoJyUnLCAnJykpO1xuICAgICAgICAgICAgICB2YXIgcmF0aW9IZWlnaHQgPSBwYXJzZUZsb2F0KGhvbGRlci5kaW1lbnNpb25zLmhlaWdodC5yZXBsYWNlKCclJywgJycpKTtcblxuICAgICAgICAgICAgICByYXRpb0hlaWdodCA9IE1hdGguZmxvb3IoMTAwICogKHJhdGlvSGVpZ2h0IC8gcmF0aW9XaWR0aCkpO1xuICAgICAgICAgICAgICByYXRpb1dpZHRoID0gMTAwO1xuXG4gICAgICAgICAgICAgIGhvbGRlci5kaW1lbnNpb25zLndpZHRoID0gcmF0aW9XaWR0aCArICclJztcbiAgICAgICAgICAgICAgaG9sZGVyLmRpbWVuc2lvbnMuaGVpZ2h0ID0gcmF0aW9IZWlnaHQgKyAnJSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaG9sZGVyLmF1dG8gPSB1dGlscy50cnV0aHkob3B0aW9ucy5hdXRvKTtcblxuICAgICAgICAgIC8vIENvbG9yc1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYmcpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLnRoZW1lLmJnID0gdXRpbHMucGFyc2VDb2xvcihvcHRpb25zLmJnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5mZykge1xuICAgICAgICAgICAgICBob2xkZXIudGhlbWUuZmcgPSB1dGlscy5wYXJzZUNvbG9yKG9wdGlvbnMuZmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vdG9kbzogYWRkIGF1dG9tYXRpYyBmb3JlZ3JvdW5kIHRvIHRoZW1lcyB3aXRob3V0IGZvcmVncm91bmRcbiAgICAgICAgICBpZiAob3B0aW9ucy5iZyAmJiAhb3B0aW9ucy5mZykge1xuICAgICAgICAgICAgICBob2xkZXIuYXV0b0ZnID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50aGVtZSAmJiBob2xkZXIuaW5zdGFuY2VPcHRpb25zLnRoZW1lcy5oYXNPd25Qcm9wZXJ0eShvcHRpb25zLnRoZW1lKSkge1xuICAgICAgICAgICAgICBob2xkZXIudGhlbWUgPSBleHRlbmQoaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXNbb3B0aW9ucy50aGVtZV0sIG51bGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRleHRcblxuICAgICAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudGV4dG1vZGUpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLnRleHRtb2RlID0gb3B0aW9ucy50ZXh0bW9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zaXplICYmIHBhcnNlRmxvYXQob3B0aW9ucy5zaXplKSkge1xuICAgICAgICAgICAgICBob2xkZXIuc2l6ZSA9IHBhcnNlRmxvYXQob3B0aW9ucy5zaXplKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5mb250KSB7XG4gICAgICAgICAgICAgIGhvbGRlci5mb250ID0gb3B0aW9ucy5mb250O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICAgIGhvbGRlci5hbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubGluZVdyYXApIHtcbiAgICAgICAgICAgICAgaG9sZGVyLmxpbmVXcmFwID0gb3B0aW9ucy5saW5lV3JhcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBob2xkZXIubm93cmFwID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMubm93cmFwKTtcblxuICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcblxuICAgICAgICAgIGhvbGRlci5vdXRsaW5lID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMub3V0bGluZSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMudHJ1dGh5KG9wdGlvbnMucmFuZG9tKSkge1xuICAgICAgICAgICAgICBBcHAudmFycy5jYWNoZS50aGVtZUtleXMgPSBBcHAudmFycy5jYWNoZS50aGVtZUtleXMgfHwgT2JqZWN0LmtleXMoaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXMpO1xuICAgICAgICAgICAgICB2YXIgX3RoZW1lID0gQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzWzAgfCBNYXRoLnJhbmRvbSgpICogQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzLmxlbmd0aF07XG4gICAgICAgICAgICAgIGhvbGRlci50aGVtZSA9IGV4dGVuZChob2xkZXIuaW5zdGFuY2VPcHRpb25zLnRoZW1lc1tfdGhlbWVdLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBob2xkZXI7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgdGhlIERPTSB0byBmaXQgcGxhY2Vob2xkZXJzIGFuZCBzZXRzIHVwIHJlc2l6YWJsZSBpbWFnZSBjYWxsYmFja3MgKGZvciBmbHVpZCBhbmQgYXV0b21hdGljYWxseSBzaXplZCBwbGFjZWhvbGRlcnMpXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBzZXR0aW5ncyBET00gcHJlcCBzZXR0aW5nc1xuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZURPTUVsZW1lbnQocHJlcFNldHRpbmdzKSB7XG4gICAgICB2YXIgbW9kZSA9IHByZXBTZXR0aW5ncy5tb2RlO1xuICAgICAgdmFyIGVsID0gcHJlcFNldHRpbmdzLmVsO1xuICAgICAgdmFyIGZsYWdzID0gcHJlcFNldHRpbmdzLmZsYWdzO1xuICAgICAgdmFyIF9lbmdpbmVTZXR0aW5ncyA9IHByZXBTZXR0aW5ncy5lbmdpbmVTZXR0aW5ncztcbiAgICAgIHZhciBkaW1lbnNpb25zID0gZmxhZ3MuZGltZW5zaW9ucyxcbiAgICAgICAgICB0aGVtZSA9IGZsYWdzLnRoZW1lO1xuICAgICAgdmFyIGRpbWVuc2lvbnNDYXB0aW9uID0gZGltZW5zaW9ucy53aWR0aCArICd4JyArIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgbW9kZSA9IG1vZGUgPT0gbnVsbCA/IChmbGFncy5mbHVpZCA/ICdmbHVpZCcgOiAnaW1hZ2UnKSA6IG1vZGU7XG4gICAgICB2YXIgaG9sZGVyVGVtcGxhdGVSZSA9IC9ob2xkZXJfKFthLXpdKykvZztcbiAgICAgIHZhciBkaW1lbnNpb25zSW5UZXh0ID0gZmFsc2U7XG5cbiAgICAgIGlmIChmbGFncy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGVtZS50ZXh0ID0gZmxhZ3MudGV4dDtcblxuICAgICAgICAgIC8vPG9iamVjdD4gU1ZHIGVtYmVkZGluZyBkb2Vzbid0IHBhcnNlIFVuaWNvZGUgcHJvcGVybHlcbiAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHRMaW5lcyA9IHRoZW1lLnRleHQuc3BsaXQoJ1xcXFxuJyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGV4dExpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0TGluZXNba10gPSB1dGlscy5lbmNvZGVIdG1sRW50aXR5KHRleHRMaW5lc1trXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhlbWUudGV4dCA9IHRleHRMaW5lcy5qb2luKCdcXFxcbicpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoZW1lLnRleHQpIHtcbiAgICAgICAgICB2YXIgaG9sZGVyVGVtcGxhdGVNYXRjaGVzID0gdGhlbWUudGV4dC5tYXRjaChob2xkZXJUZW1wbGF0ZVJlKTtcblxuICAgICAgICAgIGlmIChob2xkZXJUZW1wbGF0ZU1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy90b2RvOiBvcHRpbWl6ZSB0ZW1wbGF0ZSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICBob2xkZXJUZW1wbGF0ZU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJ2hvbGRlcl9kaW1lbnNpb25zJykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLnRleHQgPSB0aGVtZS50ZXh0LnJlcGxhY2UobWF0Y2gsIGRpbWVuc2lvbnNDYXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaG9sZGVyVVJMID0gZmxhZ3MuaG9sZGVyVVJMO1xuICAgICAgdmFyIGVuZ2luZVNldHRpbmdzID0gZXh0ZW5kKF9lbmdpbmVTZXR0aW5ncywgbnVsbCk7XG5cbiAgICAgIGlmIChmbGFncy5mb250KSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICBJZiBleHRlcm5hbCBmb250cyBhcmUgdXNlZCBpbiBhIDxpbWc+IHBsYWNlaG9sZGVyIHJlbmRlcmVkIHdpdGggU1ZHLCBIb2xkZXIgZmFsbHMgYmFjayB0byBjYW52YXMuXG5cbiAgICAgICAgICBUaGlzIGlzIGRvbmUgYmVjYXVzZSBGaXJlZm94IGFuZCBDaHJvbWUgZGlzYWxsb3cgZW1iZWRkZWQgU1ZHcyBmcm9tIHJlZmVyZW5jaW5nIGV4dGVybmFsIGFzc2V0cy5cbiAgICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyBlaXRoZXIgdG8gY2hhbmdlIHRoZSBwbGFjZWhvbGRlciB0YWcgZnJvbSA8aW1nPiB0byA8b2JqZWN0PiBvciB0byB1c2UgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgICAgICAqL1xuICAgICAgICAgIHRoZW1lLmZvbnQgPSBmbGFncy5mb250O1xuICAgICAgICAgIGlmICghZW5naW5lU2V0dGluZ3Mubm9Gb250RmFsbGJhY2sgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycgJiYgQXBwLnNldHVwLnN1cHBvcnRzQ2FudmFzICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5ncyA9IGV4dGVuZChlbmdpbmVTZXR0aW5ncywge1xuICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6ICdjYW52YXMnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9DaHJvbWUgYW5kIE9wZXJhIHJlcXVpcmUgYSBxdWljayAxMG1zIHJlLXJlbmRlciBpZiB3ZWIgZm9udHMgYXJlIHVzZWQgd2l0aCBjYW52YXNcbiAgICAgIGlmIChmbGFncy5mb250ICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09ICdjYW52YXMnKSB7XG4gICAgICAgICAgZW5naW5lU2V0dGluZ3MucmVSZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tncm91bmQtc3JjJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuICAgICAgICAgICAgICAgICAgJ2RhdGEtYmFja2dyb3VuZC1zcmMnOiBob2xkZXJVUkxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZG9tUHJvcHMgPSB7fTtcbiAgICAgICAgICBkb21Qcm9wc1tBcHAudmFycy5kYXRhQXR0cl0gPSBob2xkZXJVUkw7XG4gICAgICAgICAgRE9NLnNldEF0dHIoZWwsIGRvbVByb3BzKTtcbiAgICAgIH1cblxuICAgICAgZmxhZ3MudGhlbWUgPSB0aGVtZTtcblxuICAgICAgLy90b2RvIGNvbnNpZGVyIHVzaW5nIGFsbCByZW5kZXJTZXR0aW5ncyBpbiBob2xkZXJEYXRhXG4gICAgICBlbC5ob2xkZXJEYXRhID0ge1xuICAgICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgICBlbmdpbmVTZXR0aW5nczogZW5naW5lU2V0dGluZ3NcbiAgICAgIH07XG5cbiAgICAgIGlmIChtb2RlID09ICdpbWFnZScgfHwgbW9kZSA9PSAnZmx1aWQnKSB7XG4gICAgICAgICAgRE9NLnNldEF0dHIoZWwsIHtcbiAgICAgICAgICAgICAgJ2FsdCc6IHRoZW1lLnRleHQgPyAoZGltZW5zaW9uc0luVGV4dCA/IHRoZW1lLnRleHQgOiB0aGVtZS50ZXh0ICsgJyBbJyArIGRpbWVuc2lvbnNDYXB0aW9uICsgJ10nKSA6IGRpbWVuc2lvbnNDYXB0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJTZXR0aW5ncyA9IHtcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICBob2xkZXJTZXR0aW5nczoge1xuICAgICAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICAgIGZsYWdzOiBmbGFnc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5naW5lU2V0dGluZ3M6IGVuZ2luZVNldHRpbmdzXG4gICAgICB9O1xuXG4gICAgICBpZiAobW9kZSA9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgaWYgKCFmbGFncy5hdXRvKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoZW1lLmJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbmRlcihyZW5kZXJTZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgaWYgKGZsYWdzLnRleHRtb2RlID09ICdleGFjdCcpIHtcbiAgICAgICAgICAgICAgICAgIGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcgJiYgZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgIT0gJ2h0bWwnKSB7XG4gICAgICAgICAgcmVuZGVyKHJlbmRlclNldHRpbmdzKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnZmx1aWQnKSB7XG4gICAgICAgICAgZWwuaG9sZGVyRGF0YS5yZXNpemVVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0LnNsaWNlKC0xKSA9PSAnJScpIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmbGFncy5hdXRvID09IG51bGwgfHwgIWZsYWdzLmF1dG8pIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aC5zbGljZSgtMSkgPT0gJyUnKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmF1dG8gPT0gbnVsbCB8fCAhZmxhZ3MuYXV0bykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PSAnaW5saW5lJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09ICdub25lJykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRJbml0aWFsRGltZW5zaW9ucyhlbCk7XG5cbiAgICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoZW1lLmJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgdXBkYXRlUmVzaXphYmxlRWxlbWVudHMoZWwpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgb3V0cHV0IGZyb20gcmVuZGVyZXJzIGFuZCBzZXRzIGl0IGFzIHRoZSBzb3VyY2Ugb3IgYmFja2dyb3VuZC1pbWFnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHJlbmRlclNldHRpbmdzIFJlbmRlcmVyIHNldHRpbmdzXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXIocmVuZGVyU2V0dGluZ3MpIHtcbiAgICAgIHZhciBpbWFnZSA9IG51bGw7XG4gICAgICB2YXIgbW9kZSA9IHJlbmRlclNldHRpbmdzLm1vZGU7XG4gICAgICB2YXIgZWwgPSByZW5kZXJTZXR0aW5ncy5lbDtcbiAgICAgIHZhciBob2xkZXJTZXR0aW5ncyA9IHJlbmRlclNldHRpbmdzLmhvbGRlclNldHRpbmdzO1xuICAgICAgdmFyIGVuZ2luZVNldHRpbmdzID0gcmVuZGVyU2V0dGluZ3MuZW5naW5lU2V0dGluZ3M7XG5cbiAgICAgIHN3aXRjaCAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIpIHtcbiAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICBpZiAoIUFwcC5zZXR1cC5zdXBwb3J0c1NWRykgcmV0dXJuO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgICBpZiAoIUFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcykgcmV0dXJuO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vdG9kbzogbW92ZSBnZW5lcmF0aW9uIG9mIHNjZW5lIHVwIHRvIGZsYWcgZ2VuZXJhdGlvbiB0byByZWR1Y2UgZXh0cmEgb2JqZWN0IGNyZWF0aW9uXG4gICAgICB2YXIgc2NlbmUgPSB7XG4gICAgICAgICAgd2lkdGg6IGhvbGRlclNldHRpbmdzLmRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBob2xkZXJTZXR0aW5ncy5kaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICB0aGVtZTogaG9sZGVyU2V0dGluZ3MudGhlbWUsXG4gICAgICAgICAgZmxhZ3M6IGhvbGRlclNldHRpbmdzLmZsYWdzXG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NlbmVHcmFwaCA9IGJ1aWxkU2NlbmVHcmFwaChzY2VuZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVkSW1hZ2UoKSB7XG4gICAgICAgICAgdmFyIGltYWdlID0gbnVsbDtcbiAgICAgICAgICBzd2l0Y2ggKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICAgICAgICBpbWFnZSA9IHNnQ2FudmFzUmVuZGVyZXIoc2NlbmVHcmFwaCwgcmVuZGVyU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3N2Zyc6XG4gICAgICAgICAgICAgICAgICBpbWFnZSA9IHN2Z1JlbmRlcmVyKHNjZW5lR3JhcGgsIHJlbmRlclNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgJ0hvbGRlcjogaW52YWxpZCByZW5kZXJlcjogJyArIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbWFnZTtcbiAgICAgIH1cblxuICAgICAgaW1hZ2UgPSBnZXRSZW5kZXJlZEltYWdlKCk7XG5cbiAgICAgIGlmIChpbWFnZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgJ0hvbGRlcjogY291bGRuXFwndCByZW5kZXIgcGxhY2Vob2xkZXInO1xuICAgICAgfVxuXG4gICAgICAvL3RvZG86IGFkZCA8b2JqZWN0PiBjYW52YXMgcmVuZGVyaW5nXG4gICAgICBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpbWFnZSArICcpJztcblxuICAgICAgICAgIGlmICghZW5naW5lU2V0dGluZ3Mubm9CYWNrZ3JvdW5kU2l6ZSkge1xuICAgICAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHNjZW5lLndpZHRoICsgJ3B4ICcgKyBzY2VuZS5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG4gICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG4gICAgICAgICAgICAgICAgICAnc3JjJzogaW1hZ2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuICAgICAgICAgICAgICAgICAgJ2RhdGEnOiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3N2Zyt4bWwnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVSZW5kZXIpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gZ2V0UmVuZGVyZWRJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGltYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnSG9sZGVyOiBjb3VsZG5cXCd0IHJlbmRlciBwbGFjZWhvbGRlcic7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvL3RvZG86IHJlZmFjdG9yIHRoaXMgY29kZSBpbnRvIGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuICAgICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICdzcmMnOiBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3N2Zyt4bWwnXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy90b2RvOiBhY2NvdW50IGZvciByZS1yZW5kZXJpbmdcbiAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG4gICAgICAgICAgJ2RhdGEtaG9sZGVyLXJlbmRlcmVkJzogdHJ1ZVxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgSG9sZGVyIHNjZW5lIGRlc2NyaXB0aW9uIGFuZCBidWlsZHMgYSBzY2VuZSBncmFwaFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gc2NlbmUgSG9sZGVyIHNjZW5lIG9iamVjdFxuICAgKi9cbiAgLy90b2RvOiBtYWtlIHRoaXMgZnVuY3Rpb24gcmV1c2FibGVcbiAgLy90b2RvOiBtZXJnZSBhcHAgZGVmYXVsdHMgYW5kIHNldHVwIHByb3BlcnRpZXMgaW50byB0aGUgc2NlbmUgYXJndW1lbnRcbiAgZnVuY3Rpb24gYnVpbGRTY2VuZUdyYXBoKHNjZW5lKSB7XG4gICAgICB2YXIgZm9udFNpemUgPSBBcHAuZGVmYXVsdHMuc2l6ZTtcbiAgICAgIGlmIChwYXJzZUZsb2F0KHNjZW5lLnRoZW1lLnNpemUpKSB7XG4gICAgICAgICAgZm9udFNpemUgPSBzY2VuZS50aGVtZS5zaXplO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHNjZW5lLmZsYWdzLnNpemUpKSB7XG4gICAgICAgICAgZm9udFNpemUgPSBzY2VuZS5mbGFncy5zaXplO1xuICAgICAgfVxuXG4gICAgICBzY2VuZS5mb250ID0ge1xuICAgICAgICAgIGZhbWlseTogc2NlbmUudGhlbWUuZm9udCA/IHNjZW5lLnRoZW1lLmZvbnQgOiAnQXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgICBzaXplOiB0ZXh0U2l6ZShzY2VuZS53aWR0aCwgc2NlbmUuaGVpZ2h0LCBmb250U2l6ZSwgQXBwLmRlZmF1bHRzLnNjYWxlKSxcbiAgICAgICAgICB1bml0czogc2NlbmUudGhlbWUudW5pdHMgPyBzY2VuZS50aGVtZS51bml0cyA6IEFwcC5kZWZhdWx0cy51bml0cyxcbiAgICAgICAgICB3ZWlnaHQ6IHNjZW5lLnRoZW1lLmZvbnR3ZWlnaHQgPyBzY2VuZS50aGVtZS5mb250d2VpZ2h0IDogJ2JvbGQnXG4gICAgICB9O1xuXG4gICAgICBzY2VuZS50ZXh0ID0gc2NlbmUudGhlbWUudGV4dCB8fCBNYXRoLmZsb29yKHNjZW5lLndpZHRoKSArICd4JyArIE1hdGguZmxvb3Ioc2NlbmUuaGVpZ2h0KTtcblxuICAgICAgc2NlbmUubm9XcmFwID0gc2NlbmUudGhlbWUubm93cmFwIHx8IHNjZW5lLmZsYWdzLm5vd3JhcDtcblxuICAgICAgc2NlbmUuYWxpZ24gPSBzY2VuZS50aGVtZS5hbGlnbiB8fCBzY2VuZS5mbGFncy5hbGlnbiB8fCAnY2VudGVyJztcblxuICAgICAgc3dpdGNoIChzY2VuZS5mbGFncy50ZXh0bW9kZSkge1xuICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgICBzY2VuZS50ZXh0ID0gc2NlbmUuZmxhZ3MuZGltZW5zaW9ucy53aWR0aCArICd4JyArIHNjZW5lLmZsYWdzLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdleGFjdCc6XG4gICAgICAgICAgICAgIGlmICghc2NlbmUuZmxhZ3MuZXhhY3REaW1lbnNpb25zKSBicmVhaztcbiAgICAgICAgICAgICAgc2NlbmUudGV4dCA9IE1hdGguZmxvb3Ioc2NlbmUuZmxhZ3MuZXhhY3REaW1lbnNpb25zLndpZHRoKSArICd4JyArIE1hdGguZmxvb3Ioc2NlbmUuZmxhZ3MuZXhhY3REaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVdyYXAgPSBzY2VuZS5mbGFncy5saW5lV3JhcCB8fCBBcHAuc2V0dXAubGluZVdyYXBSYXRpbztcbiAgICAgIHZhciBzY2VuZU1hcmdpbiA9IHNjZW5lLndpZHRoICogbGluZVdyYXA7XG4gICAgICB2YXIgbWF4TGluZVdpZHRoID0gc2NlbmVNYXJnaW47XG5cbiAgICAgIHZhciBzY2VuZUdyYXBoID0gbmV3IFNjZW5lR3JhcGgoe1xuICAgICAgICAgIHdpZHRoOiBzY2VuZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNjZW5lLmhlaWdodFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBTaGFwZSA9IHNjZW5lR3JhcGguU2hhcGU7XG5cbiAgICAgIHZhciBob2xkZXJCZyA9IG5ldyBTaGFwZS5SZWN0KCdob2xkZXJCZycsIHtcbiAgICAgICAgICBmaWxsOiBzY2VuZS50aGVtZS5iZ1xuICAgICAgfSk7XG5cbiAgICAgIGhvbGRlckJnLnJlc2l6ZShzY2VuZS53aWR0aCwgc2NlbmUuaGVpZ2h0KTtcbiAgICAgIHNjZW5lR3JhcGgucm9vdC5hZGQoaG9sZGVyQmcpO1xuXG4gICAgICBpZiAoc2NlbmUuZmxhZ3Mub3V0bGluZSkge1xuICAgICAgICAgIHZhciBvdXRsaW5lQ29sb3IgPSBuZXcgQ29sb3IoaG9sZGVyQmcucHJvcGVydGllcy5maWxsKTtcbiAgICAgICAgICBvdXRsaW5lQ29sb3IgPSBvdXRsaW5lQ29sb3IubGlnaHRlbihvdXRsaW5lQ29sb3IubGlnaHRlclRoYW4oJzdmN2Y3ZicpID8gLTAuMSA6IDAuMSk7XG4gICAgICAgICAgaG9sZGVyQmcucHJvcGVydGllcy5vdXRsaW5lID0ge1xuICAgICAgICAgICAgICBmaWxsOiBvdXRsaW5lQ29sb3IudG9IZXgodHJ1ZSksXG4gICAgICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvbGRlclRleHRDb2xvciA9IHNjZW5lLnRoZW1lLmZnO1xuXG4gICAgICBpZiAoc2NlbmUuZmxhZ3MuYXV0b0ZnKSB7XG4gICAgICAgICAgdmFyIGhvbGRlckJnQ29sb3IgPSBuZXcgQ29sb3IoaG9sZGVyQmcucHJvcGVydGllcy5maWxsKTtcbiAgICAgICAgICB2YXIgbGlnaHRDb2xvciA9IG5ldyBDb2xvcignZmZmJyk7XG4gICAgICAgICAgdmFyIGRhcmtDb2xvciA9IG5ldyBDb2xvcignMDAwJywge1xuICAgICAgICAgICAgICAnYWxwaGEnOiAwLjI4NTcxNFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaG9sZGVyVGV4dENvbG9yID0gaG9sZGVyQmdDb2xvci5ibGVuZEFscGhhKGhvbGRlckJnQ29sb3IubGlnaHRlclRoYW4oJzdmN2Y3ZicpID8gZGFya0NvbG9yIDogbGlnaHRDb2xvcikudG9IZXgodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBob2xkZXJUZXh0R3JvdXAgPSBuZXcgU2hhcGUuR3JvdXAoJ2hvbGRlclRleHRHcm91cCcsIHtcbiAgICAgICAgICB0ZXh0OiBzY2VuZS50ZXh0LFxuICAgICAgICAgIGFsaWduOiBzY2VuZS5hbGlnbixcbiAgICAgICAgICBmb250OiBzY2VuZS5mb250LFxuICAgICAgICAgIGZpbGw6IGhvbGRlclRleHRDb2xvclxuICAgICAgfSk7XG5cbiAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgbnVsbCwgMSk7XG4gICAgICBzY2VuZUdyYXBoLnJvb3QuYWRkKGhvbGRlclRleHRHcm91cCk7XG5cbiAgICAgIHZhciB0cGRhdGEgPSBob2xkZXJUZXh0R3JvdXAudGV4dFBvc2l0aW9uRGF0YSA9IHN0YWdpbmdSZW5kZXJlcihzY2VuZUdyYXBoKTtcbiAgICAgIGlmICghdHBkYXRhKSB7XG4gICAgICAgICAgdGhyb3cgJ0hvbGRlcjogc3RhZ2luZyBmYWxsYmFjayBub3Qgc3VwcG9ydGVkIHlldC4nO1xuICAgICAgfVxuICAgICAgaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXMubGVhZGluZyA9IHRwZGF0YS5ib3VuZGluZ0JveC5oZWlnaHQ7XG5cbiAgICAgIHZhciB0ZXh0Tm9kZSA9IG51bGw7XG4gICAgICB2YXIgbGluZSA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGZpbmFsaXplTGluZShwYXJlbnQsIGxpbmUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICBsaW5lLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgcGFyZW50LndpZHRoID0gTWF0aC5tYXgocGFyZW50LndpZHRoLCBsaW5lLndpZHRoKTtcbiAgICAgICAgICBwYXJlbnQuaGVpZ2h0ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAodHBkYXRhLmxpbmVDb3VudCA+IDEpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0WCA9IDA7XG4gICAgICAgICAgdmFyIG9mZnNldFkgPSAwO1xuICAgICAgICAgIHZhciBsaW5lSW5kZXggPSAwO1xuICAgICAgICAgIHZhciBsaW5lS2V5O1xuICAgICAgICAgIGxpbmUgPSBuZXcgU2hhcGUuR3JvdXAoJ2xpbmUnICsgbGluZUluZGV4KTtcblxuICAgICAgICAgIC8vRG91YmxlIG1hcmdpbiBzbyB0aGF0IGxlZnQvcmlnaHQtYWxpZ25lZCBuZXh0IGlzIG5vdCBmbHVzaCB3aXRoIGVkZ2Ugb2YgaW1hZ2VcbiAgICAgICAgICBpZiAoc2NlbmUuYWxpZ24gPT09ICdsZWZ0JyB8fCBzY2VuZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBzY2VuZS53aWR0aCAqICgxIC0gKDEgLSBsaW5lV3JhcCkgKiAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRwZGF0YS53b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgd29yZCA9IHRwZGF0YS53b3Jkc1tpXTtcbiAgICAgICAgICAgICAgdGV4dE5vZGUgPSBuZXcgU2hhcGUuVGV4dCh3b3JkLnRleHQpO1xuICAgICAgICAgICAgICB2YXIgbmV3bGluZSA9IHdvcmQudGV4dCA9PSAnXFxcXG4nO1xuICAgICAgICAgICAgICBpZiAoIXNjZW5lLm5vV3JhcCAmJiAob2Zmc2V0WCArIHdvcmQud2lkdGggPj0gbWF4TGluZVdpZHRoIHx8IG5ld2xpbmUgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbGl6ZUxpbmUoaG9sZGVyVGV4dEdyb3VwLCBsaW5lLCBvZmZzZXRYLCBob2xkZXJUZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nKTtcbiAgICAgICAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5hZGQobGluZSk7XG4gICAgICAgICAgICAgICAgICBvZmZzZXRYID0gMDtcbiAgICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXMubGVhZGluZztcbiAgICAgICAgICAgICAgICAgIGxpbmVJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgbGluZSA9IG5ldyBTaGFwZS5Hcm91cCgnbGluZScgKyBsaW5lSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgbGluZS55ID0gb2Zmc2V0WTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV3bGluZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dE5vZGUubW92ZVRvKG9mZnNldFgsIDApO1xuICAgICAgICAgICAgICBvZmZzZXRYICs9IHRwZGF0YS5zcGFjZVdpZHRoICsgd29yZC53aWR0aDtcbiAgICAgICAgICAgICAgbGluZS5hZGQodGV4dE5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbmFsaXplTGluZShob2xkZXJUZXh0R3JvdXAsIGxpbmUsIG9mZnNldFgsIGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzLmxlYWRpbmcpO1xuICAgICAgICAgIGhvbGRlclRleHRHcm91cC5hZGQobGluZSk7XG5cbiAgICAgICAgICBpZiAoc2NlbmUuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4sIG51bGwsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2NlbmUuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgZm9yIChsaW5lS2V5IGluIGhvbGRlclRleHRHcm91cC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgbGluZSA9IGhvbGRlclRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcbiAgICAgICAgICAgICAgICAgIGxpbmUubW92ZVRvKHNjZW5lLndpZHRoIC0gbGluZS53aWR0aCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKDAgLSAoc2NlbmUud2lkdGggLSBzY2VuZU1hcmdpbiksIG51bGwsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAobGluZUtleSBpbiBob2xkZXJUZXh0R3JvdXAuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBob2xkZXJUZXh0R3JvdXAuY2hpbGRyZW5bbGluZUtleV07XG4gICAgICAgICAgICAgICAgICBsaW5lLm1vdmVUbygoaG9sZGVyVGV4dEdyb3VwLndpZHRoIC0gbGluZS53aWR0aCkgLyAyLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oKHNjZW5lLndpZHRoIC0gaG9sZGVyVGV4dEdyb3VwLndpZHRoKSAvIDIsIG51bGwsIG51bGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgKHNjZW5lLmhlaWdodCAtIGhvbGRlclRleHRHcm91cC5oZWlnaHQpIC8gMiwgbnVsbCk7XG5cbiAgICAgICAgICAvL0lmIHRoZSB0ZXh0IGV4Y2VlZHMgdmVydGljYWwgc3BhY2UsIG1vdmUgaXQgZG93biBzbyB0aGUgZmlyc3QgbGluZSBpcyB2aXNpYmxlXG4gICAgICAgICAgaWYgKChzY2VuZS5oZWlnaHQgLSBob2xkZXJUZXh0R3JvdXAuaGVpZ2h0KSAvIDIgPCAwKSB7XG4gICAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgMCwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IG5ldyBTaGFwZS5UZXh0KHNjZW5lLnRleHQpO1xuICAgICAgICAgIGxpbmUgPSBuZXcgU2hhcGUuR3JvdXAoJ2xpbmUwJyk7XG4gICAgICAgICAgbGluZS5hZGQodGV4dE5vZGUpO1xuICAgICAgICAgIGhvbGRlclRleHRHcm91cC5hZGQobGluZSk7XG5cbiAgICAgICAgICBpZiAoc2NlbmUuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4sIG51bGwsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2NlbmUuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbygwIC0gKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4pLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKChzY2VuZS53aWR0aCAtIHRwZGF0YS5ib3VuZGluZ0JveC53aWR0aCkgLyAyLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKG51bGwsIChzY2VuZS5oZWlnaHQgLSB0cGRhdGEuYm91bmRpbmdCb3guaGVpZ2h0KSAvIDIsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvL3RvZG86IHJlbmRlcmxpc3RcbiAgICAgIHJldHVybiBzY2VuZUdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkYXB0aXZlIHRleHQgc2l6aW5nIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB3aWR0aCBQYXJlbnQgd2lkdGhcbiAgICogQHBhcmFtIGhlaWdodCBQYXJlbnQgaGVpZ2h0XG4gICAqIEBwYXJhbSBmb250U2l6ZSBSZXF1ZXN0ZWQgdGV4dCBzaXplXG4gICAqIEBwYXJhbSBzY2FsZSBQcm9wb3J0aW9uYWwgc2NhbGUgb2YgdGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gdGV4dFNpemUod2lkdGgsIGhlaWdodCwgZm9udFNpemUsIHNjYWxlKSB7XG4gICAgICB2YXIgc3RhZ2VXaWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG4gICAgICB2YXIgc3RhZ2VIZWlnaHQgPSBwYXJzZUludChoZWlnaHQsIDEwKTtcblxuICAgICAgdmFyIGJpZ1NpZGUgPSBNYXRoLm1heChzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XG4gICAgICB2YXIgc21hbGxTaWRlID0gTWF0aC5taW4oc3RhZ2VXaWR0aCwgc3RhZ2VIZWlnaHQpO1xuXG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gMC44ICogTWF0aC5taW4oc21hbGxTaWRlLCBiaWdTaWRlICogc2NhbGUpO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5tYXgoZm9udFNpemUsIG5ld0hlaWdodCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgcmVzaXphYmxlIChmbHVpZCBvciBhdXRvKSBwbGFjZWhvbGRlcnMgYW5kIHJlbmRlcnMgdGhlbVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZWxlbWVudCBPcHRpb25hbCBlbGVtZW50IHNlbGVjdG9yLCBzcGVjaWZpZWQgb25seSBpZiBhIHNwZWNpZmljIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWRcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgICAgIHZhciBpbWFnZXM7XG4gICAgICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IGVsZW1lbnQubm9kZVR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgIGltYWdlcyA9IEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1hZ2VzID0gW2VsZW1lbnRdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbWFnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsID0gaW1hZ2VzW2ldO1xuICAgICAgICAgIGlmIChlbC5ob2xkZXJEYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBmbGFncyA9IGVsLmhvbGRlckRhdGEuZmxhZ3M7XG4gICAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gZGltZW5zaW9uQ2hlY2soZWwpO1xuICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlbC5ob2xkZXJEYXRhLnJlc2l6ZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MuZmx1aWQgJiYgZmxhZ3MuYXV0bykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBmbHVpZENvbmZpZyA9IGVsLmhvbGRlckRhdGEuZmx1aWRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmbHVpZENvbmZpZy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gZGltZW5zaW9ucy53aWR0aCAvIGZsdWlkQ29uZmlnLnJhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoID0gZGltZW5zaW9ucy5oZWlnaHQgKiBmbHVpZENvbmZpZy5yYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgaG9sZGVyU2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6IGZsYWdzLnRoZW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5nczogZWwuaG9sZGVyRGF0YS5lbmdpbmVTZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzLnRleHRtb2RlID09ICdleGFjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncy5leGFjdERpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhvbGRlclNldHRpbmdzLmRpbWVuc2lvbnMgPSBmbGFncy5kaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZW5kZXIoc2V0dGluZ3MpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2V0SW52aXNpYmxlKGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGFzcGVjdCByYXRpbyBtZXRhZGF0YSBmb3IgZmx1aWQgcGxhY2Vob2xkZXJzLCBpbiBvcmRlciB0byBwcmVzZXJ2ZSBwcm9wb3J0aW9ucyB3aGVuIHJlc2l6aW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBlbCBJbWFnZSBET00gZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0SW5pdGlhbERpbWVuc2lvbnMoZWwpIHtcbiAgICAgIGlmIChlbC5ob2xkZXJEYXRhKSB7XG4gICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25DaGVjayhlbCk7XG4gICAgICAgICAgaWYgKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgdmFyIGZsYWdzID0gZWwuaG9sZGVyRGF0YS5mbGFncztcblxuICAgICAgICAgICAgICB2YXIgZmx1aWRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICBmbHVpZEhlaWdodDogZmxhZ3MuZGltZW5zaW9ucy5oZWlnaHQuc2xpY2UoLTEpID09ICclJyxcbiAgICAgICAgICAgICAgICAgIGZsdWlkV2lkdGg6IGZsYWdzLmRpbWVuc2lvbnMud2lkdGguc2xpY2UoLTEpID09ICclJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICBpbml0aWFsRGltZW5zaW9uczogZGltZW5zaW9uc1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChmbHVpZENvbmZpZy5mbHVpZFdpZHRoICYmICFmbHVpZENvbmZpZy5mbHVpZEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgZmx1aWRDb25maWcubW9kZSA9ICd3aWR0aCc7XG4gICAgICAgICAgICAgICAgICBmbHVpZENvbmZpZy5yYXRpbyA9IGZsdWlkQ29uZmlnLmluaXRpYWxEaW1lbnNpb25zLndpZHRoIC8gcGFyc2VGbG9hdChmbGFncy5kaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZsdWlkQ29uZmlnLmZsdWlkV2lkdGggJiYgZmx1aWRDb25maWcuZmx1aWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGZsdWlkQ29uZmlnLm1vZGUgPSAnaGVpZ2h0JztcbiAgICAgICAgICAgICAgICAgIGZsdWlkQ29uZmlnLnJhdGlvID0gcGFyc2VGbG9hdChmbGFncy5kaW1lbnNpb25zLndpZHRoKSAvIGZsdWlkQ29uZmlnLmluaXRpYWxEaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsLmhvbGRlckRhdGEuZmx1aWRDb25maWcgPSBmbHVpZENvbmZpZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRJbnZpc2libGUoZWwpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBjdXJyZW50IGludmlzaWJsZSBpbWFnZXMsIGFuZCBpZiB0aGV5J3JlIHZpc2libGUsIHJlbmRlcnMgdGhlbSBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gZnVydGhlciBjaGVja3MuIFJ1bnMgZXZlcnkgYW5pbWF0aW9uIGZyYW1lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gdmlzaWJpbGl0eUNoZWNrKCkge1xuICAgICAgdmFyIHJlbmRlcmFibGVJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoQXBwLnZhcnMuaW52aXNpYmxlSW1hZ2VzKTtcbiAgICAgIHZhciBlbDtcblxuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBlbCA9IEFwcC52YXJzLmludmlzaWJsZUltYWdlc1trZXldO1xuICAgICAgICAgIGlmIChkaW1lbnNpb25DaGVjayhlbCkgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAnaW1nJykge1xuICAgICAgICAgICAgICByZW5kZXJhYmxlSW1hZ2VzLnB1c2goZWwpO1xuICAgICAgICAgICAgICBkZWxldGUgQXBwLnZhcnMuaW52aXNpYmxlSW1hZ2VzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZW5kZXJhYmxlSW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIEhvbGRlci5ydW4oe1xuICAgICAgICAgICAgICBpbWFnZXM6IHJlbmRlcmFibGVJbWFnZXNcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uZSB0byBwcmV2ZW50IDEwMCUgQ1BVIHVzYWdlIHZpYSBhZ2dyZXNzaXZlIGNhbGxpbmcgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHZpc2liaWxpdHlDaGVjayk7XG4gICAgICB9LCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGNoZWNraW5nIGZvciBpbnZpc2libGUgcGxhY2Vob2xkZXJzIGlmIG5vdCBkb2luZyBzbyB5ZXQuIERvZXMgbm90aGluZyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzdGFydFZpc2liaWxpdHlDaGVjaygpIHtcbiAgICAgIGlmICghQXBwLnZhcnMudmlzaWJpbGl0eUNoZWNrU3RhcnRlZCkge1xuICAgICAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodmlzaWJpbGl0eUNoZWNrKTtcbiAgICAgICAgICBBcHAudmFycy52aXNpYmlsaXR5Q2hlY2tTdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgdW5pcXVlIElEIGZvciBhbiBpbWFnZSBkZXRlY3RlZCB0byBiZSBpbnZpc2libGUgYW5kIGFkZHMgaXQgdG8gdGhlIG1hcCBvZiBpbnZpc2libGUgaW1hZ2VzIGNoZWNrZWQgYnkgdmlzaWJpbGl0eUNoZWNrXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBlbCBJbnZpc2libGUgRE9NIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHNldEludmlzaWJsZShlbCkge1xuICAgICAgaWYgKCFlbC5ob2xkZXJEYXRhLmludmlzaWJsZUlkKSB7XG4gICAgICAgICAgQXBwLnZhcnMuaW52aXNpYmxlSWQgKz0gMTtcbiAgICAgICAgICBBcHAudmFycy5pbnZpc2libGVJbWFnZXNbJ2knICsgQXBwLnZhcnMuaW52aXNpYmxlSWRdID0gZWw7XG4gICAgICAgICAgZWwuaG9sZGVyRGF0YS5pbnZpc2libGVJZCA9IEFwcC52YXJzLmludmlzaWJsZUlkO1xuICAgICAgfVxuICB9XG5cbiAgLy90b2RvOiBzZWUgaWYgcG9zc2libGUgdG8gY29udmVydCBzdGFnaW5nUmVuZGVyZXIgdG8gdXNlIEhUTUwgb25seVxuICB2YXIgc3RhZ2luZ1JlbmRlcmVyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN2ZyA9IG51bGwsXG4gICAgICAgICAgc3RhZ2luZ1RleHQgPSBudWxsLFxuICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgICAgICAgICB2YXIgcm9vdE5vZGUgPSBncmFwaC5yb290O1xuICAgICAgICAgIGlmIChBcHAuc2V0dXAuc3VwcG9ydHNTVkcpIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZVNldHVwID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciB0bm9kZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKHN2ZyA9PSBudWxsIHx8IHN2Zy5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdFRpbWVTZXR1cCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdmcgPSBTVkcuaW5pdFNWRyhzdmcsIHJvb3ROb2RlLnByb3BlcnRpZXMud2lkdGgsIHJvb3ROb2RlLnByb3BlcnRpZXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgLy9TaG93IHN0YWdpbmcgZWxlbWVudCBiZWZvcmUgc3RhZ2luZ1xuICAgICAgICAgICAgICBzdmcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZVNldHVwKSB7XG4gICAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dCA9IERPTS5uZXdFbCgndGV4dCcsIFNWR19OUyk7XG4gICAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUgPSB0bm9kZShudWxsKTtcbiAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKHN0YWdpbmdUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgeDogMFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dC5hcHBlbmRDaGlsZChzdGFnaW5nVGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHN0YWdpbmdUZXh0KTtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgICAgICAgICAgICAgIHN2Zy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICBzdmcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgICAgc3ZnLnN0eWxlLnRvcCA9ICctMTAwJSc7XG4gICAgICAgICAgICAgICAgICBzdmcuc3R5bGUubGVmdCA9ICctMTAwJSc7XG4gICAgICAgICAgICAgICAgICAvL3RvZG86IHdvcmthcm91bmQgZm9yIHplcm8tZGltZW5zaW9uIDxzdmc+IHRhZyBpbiBPcGVyYSAxMlxuICAgICAgICAgICAgICAgICAgLy9zdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDApO1xuICAgICAgICAgICAgICAgICAgLy9zdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBob2xkZXJUZXh0R3JvdXAgPSByb290Tm9kZS5jaGlsZHJlbi5ob2xkZXJUZXh0R3JvdXA7XG4gICAgICAgICAgICAgIHZhciBodGdQcm9wcyA9IGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICBET00uc2V0QXR0cihzdGFnaW5nVGV4dCwge1xuICAgICAgICAgICAgICAgICAgJ3knOiBodGdQcm9wcy5mb250LnNpemUsXG4gICAgICAgICAgICAgICAgICAnc3R5bGUnOiB1dGlscy5jc3NQcm9wcyh7XG4gICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogaHRnUHJvcHMuZm9udC53ZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IGh0Z1Byb3BzLmZvbnQuc2l6ZSArIGh0Z1Byb3BzLmZvbnQudW5pdHMsXG4gICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogaHRnUHJvcHMuZm9udC5mYW1pbHlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vVW5lc2NhcGUgSFRNTCBlbnRpdGllcyB0byBnZXQgYXBwcm94aW1hdGVseSB0aGUgcmlnaHQgd2lkdGhcbiAgICAgICAgICAgICAgdmFyIHR4dCA9IERPTS5uZXdFbCgndGV4dGFyZWEnKTtcbiAgICAgICAgICAgICAgdHh0LmlubmVySFRNTCA9IGh0Z1Byb3BzLnRleHQ7XG4gICAgICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZS5ub2RlVmFsdWUgPSB0eHQudmFsdWU7XG5cbiAgICAgICAgICAgICAgLy9HZXQgYm91bmRpbmcgYm94IGZvciB0aGUgd2hvbGUgc3RyaW5nICh0b3RhbCB3aWR0aCBhbmQgaGVpZ2h0KVxuICAgICAgICAgICAgICB2YXIgc3RhZ2luZ1RleHRCQm94ID0gc3RhZ2luZ1RleHQuZ2V0QkJveCgpO1xuXG4gICAgICAgICAgICAgIC8vR2V0IGxpbmUgY291bnQgYW5kIHNwbGl0IHRoZSBzdHJpbmcgaW50byB3b3Jkc1xuICAgICAgICAgICAgICB2YXIgbGluZUNvdW50ID0gTWF0aC5jZWlsKHN0YWdpbmdUZXh0QkJveC53aWR0aCAvIHJvb3ROb2RlLnByb3BlcnRpZXMud2lkdGgpO1xuICAgICAgICAgICAgICB2YXIgd29yZHMgPSBodGdQcm9wcy50ZXh0LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIHZhciBuZXdsaW5lcyA9IGh0Z1Byb3BzLnRleHQubWF0Y2goL1xcXFxuL2cpO1xuICAgICAgICAgICAgICBsaW5lQ291bnQgKz0gbmV3bGluZXMgPT0gbnVsbCA/IDAgOiBuZXdsaW5lcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgLy9HZXQgYm91bmRpbmcgYm94IGZvciB0aGUgc3RyaW5nIHdpdGggc3BhY2VzIHJlbW92ZWRcbiAgICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlLm5vZGVWYWx1ZSA9IGh0Z1Byb3BzLnRleHQucmVwbGFjZSgvWyBdKy9nLCAnJyk7XG4gICAgICAgICAgICAgIHZhciBjb21wdXRlZE5vU3BhY2VMZW5ndGggPSBzdGFnaW5nVGV4dC5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcblxuICAgICAgICAgICAgICAvL0NvbXB1dGUgYXZlcmFnZSBzcGFjZSB3aWR0aFxuICAgICAgICAgICAgICB2YXIgZGlmZkxlbmd0aCA9IHN0YWdpbmdUZXh0QkJveC53aWR0aCAtIGNvbXB1dGVkTm9TcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgdmFyIHNwYWNlV2lkdGggPSBNYXRoLnJvdW5kKGRpZmZMZW5ndGggLyBNYXRoLm1heCgxLCB3b3Jkcy5sZW5ndGggLSAxKSk7XG5cbiAgICAgICAgICAgICAgLy9HZXQgd2lkdGhzIGZvciBldmVyeSB3b3JkIHdpdGggc3BhY2Ugb25seSBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGxpbmVcbiAgICAgICAgICAgICAgdmFyIHdvcmRXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZS5ub2RlVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAod29yZHNbaV0ubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUubm9kZVZhbHVlID0gdXRpbHMuZGVjb2RlSHRtbEVudGl0eSh3b3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJib3ggPSBzdGFnaW5nVGV4dC5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgICAgd29yZFdpZHRocy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogd29yZHNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYm94LndpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL0hpZGUgc3RhZ2luZyBlbGVtZW50IGFmdGVyIHN0YWdpbmdcbiAgICAgICAgICAgICAgc3ZnLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHNwYWNlV2lkdGg6IHNwYWNlV2lkdGgsXG4gICAgICAgICAgICAgICAgICBsaW5lQ291bnQ6IGxpbmVDb3VudCxcbiAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94OiBzdGFnaW5nVGV4dEJCb3gsXG4gICAgICAgICAgICAgICAgICB3b3Jkczogd29yZFdpZHRoc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vdG9kbzogY2FudmFzIGZhbGxiYWNrIGZvciBtZWFzdXJpbmcgdGV4dCBvbiBhbmRyb2lkIDIuM1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfSkoKTtcblxuICAvL0hlbHBlcnNcblxuICAvKipcbiAgICogUHJldmVudHMgYSBmdW5jdGlvbiBmcm9tIGJlaW5nIGNhbGxlZCB0b28gb2Z0ZW4sIHdhaXRzIHVudGlsIGEgdGltZXIgZWxhcHNlcyB0byBjYWxsIGl0IGFnYWluXG4gICAqXG4gICAqIEBwYXJhbSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gICAqL1xuICBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICAgICAgaWYgKCFBcHAudmFycy5kZWJvdW5jZVRpbWVyKSBmbi5jYWxsKHRoaXMpO1xuICAgICAgaWYgKEFwcC52YXJzLmRlYm91bmNlVGltZXIpIGdsb2JhbC5jbGVhclRpbWVvdXQoQXBwLnZhcnMuZGVib3VuY2VUaW1lcik7XG4gICAgICBBcHAudmFycy5kZWJvdW5jZVRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgQXBwLnZhcnMuZGVib3VuY2VUaW1lciA9IG51bGw7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgIH0sIEFwcC5zZXR1cC5kZWJvdW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogSG9sZGVyLXNwZWNpZmljIHJlc2l6ZS9vcmllbnRhdGlvbiBjaGFuZ2UgY2FsbGJhY2ssIGRlYm91bmNlZCB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSBleGVjdXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlc2l6ZUV2ZW50KCkge1xuICAgICAgZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdXBkYXRlUmVzaXphYmxlRWxlbWVudHMobnVsbCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8vU2V0IHVwIGZsYWdzXG5cbiAgZm9yICh2YXIgZmxhZyBpbiBBcHAuZmxhZ3MpIHtcbiAgICAgIGlmICghQXBwLmZsYWdzLmhhc093blByb3BlcnR5KGZsYWcpKSBjb250aW51ZTtcbiAgICAgIEFwcC5mbGFnc1tmbGFnXS5tYXRjaCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwubWF0Y2godGhpcy5yZWdleCk7XG4gICAgICB9O1xuICB9XG5cbiAgLy9Qcm9wZXJ0aWVzIHNldCBvbmNlIG9uIHNldHVwXG5cbiAgQXBwLnNldHVwID0ge1xuICAgICAgcmVuZGVyZXI6ICdodG1sJyxcbiAgICAgIGRlYm91bmNlOiAxMDAsXG4gICAgICByYXRpbzogMSxcbiAgICAgIHN1cHBvcnRzQ2FudmFzOiBmYWxzZSxcbiAgICAgIHN1cHBvcnRzU1ZHOiBmYWxzZSxcbiAgICAgIGxpbmVXcmFwUmF0aW86IDAuOSxcbiAgICAgIGRhdGFBdHRyOiAnZGF0YS1zcmMnLFxuICAgICAgcmVuZGVyZXJzOiBbJ2h0bWwnLCAnY2FudmFzJywgJ3N2ZyddXG4gIH07XG5cbiAgLy9Qcm9wZXJ0aWVzIG1vZGlmaWVkIGR1cmluZyBydW50aW1lXG5cbiAgQXBwLnZhcnMgPSB7XG4gICAgICBwcmVlbXB0ZWQ6IGZhbHNlLFxuICAgICAgcmVzaXphYmxlSW1hZ2VzOiBbXSxcbiAgICAgIGludmlzaWJsZUltYWdlczoge30sXG4gICAgICBpbnZpc2libGVJZDogMCxcbiAgICAgIHZpc2liaWxpdHlDaGVja1N0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgZGVib3VuY2VUaW1lcjogbnVsbCxcbiAgICAgIGNhY2hlOiB7fVxuICB9O1xuXG4gIC8vUHJlLWZsaWdodFxuXG4gIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYW52YXMgPSBET00ubmV3RWwoJ2NhbnZhcycpO1xuXG4gICAgICBpZiAoY2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykuaW5kZXhPZignZGF0YTppbWFnZS9wbmcnKSAhPSAtMSkge1xuICAgICAgICAgICAgICBBcHAuc2V0dXAucmVuZGVyZXIgPSAnY2FudmFzJztcbiAgICAgICAgICAgICAgQXBwLnNldHVwLnN1cHBvcnRzQ2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICdzdmcnKS5jcmVhdGVTVkdSZWN0KSB7XG4gICAgICAgICAgQXBwLnNldHVwLnJlbmRlcmVyID0gJ3N2Zyc7XG4gICAgICAgICAgQXBwLnNldHVwLnN1cHBvcnRzU1ZHID0gdHJ1ZTtcbiAgICAgIH1cbiAgfSkoKTtcblxuICAvL1N0YXJ0cyBjaGVja2luZyBmb3IgaW52aXNpYmxlIHBsYWNlaG9sZGVyc1xuICBzdGFydFZpc2liaWxpdHlDaGVjaygpO1xuXG4gIGlmIChvbkRvbVJlYWR5KSB7XG4gICAgICBvbkRvbVJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghQXBwLnZhcnMucHJlZW1wdGVkKSB7XG4gICAgICAgICAgICAgIEhvbGRlci5ydW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCByZXNpemVFdmVudCwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb25yZXNpemUnLCByZXNpemVFdmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwuVHVyYm9saW5rcyA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFnZTpjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIEhvbGRlci5ydW4oKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IEhvbGRlcjtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIC8qIVxuICAgKiBvbkRvbVJlYWR5LmpzIDEuNC4wIChjKSAyMDEzIFR1YmFsIE1hcnRpbiAtIE1JVCBsaWNlbnNlXG4gICAqXG4gICAqIFNwZWNpYWxseSBtb2RpZmllZCB0byB3b3JrIHdpdGggSG9sZGVyLmpzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIF9vbkRvbVJlYWR5KHdpbikge1xuICAgICAgLy9MYXp5IGxvYWRpbmcgZml4IGZvciBGaXJlZm94IDwgMy42XG4gICAgICAvL2h0dHA6Ly93ZWJyZWZsZWN0aW9uLmJsb2dzcG90LmNvbS8yMDA5LzExLzE5NS1jaGFycy10by1oZWxwLWxhenktbG9hZGluZy5odG1sXG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSBudWxsICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiBET01Db250ZW50TG9hZGVkKCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBET01Db250ZW50TG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPSBcImNvbXBsZXRlXCI7XG4gICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPSBcImxvYWRpbmdcIjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudCxcbiAgICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgIFxuICAgICAgICAgIExPQUQgPSBcImxvYWRcIixcbiAgICAgICAgICBGQUxTRSA9IGZhbHNlLFxuICAgICAgICAgIE9OTE9BRCA9IFwib25cIitMT0FELFxuICAgICAgICAgIENPTVBMRVRFID0gXCJjb21wbGV0ZVwiLFxuICAgICAgICAgIFJFQURZU1RBVEUgPSBcInJlYWR5U3RhdGVcIixcbiAgICAgICAgICBBVFRBQ0hFVkVOVCA9IFwiYXR0YWNoRXZlbnRcIixcbiAgICAgICAgICBERVRBQ0hFVkVOVCA9IFwiZGV0YWNoRXZlbnRcIixcbiAgICAgICAgICBBRERFVkVOVExJU1RFTkVSID0gXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgICAgRE9NQ09OVEVOVExPQURFRCA9IFwiRE9NQ29udGVudExvYWRlZFwiLFxuICAgICAgICAgIE9OUkVBRFlTVEFURUNIQU5HRSA9IFwib25yZWFkeXN0YXRlY2hhbmdlXCIsXG4gICAgICAgICAgUkVNT1ZFRVZFTlRMSVNURU5FUiA9IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgXG4gICAgICAgICAgLy8gVzNDIEV2ZW50IG1vZGVsXG4gICAgICAgICAgdzNjID0gQURERVZFTlRMSVNURU5FUiBpbiBkb2MsXG4gICAgICAgICAgX3RvcCA9IEZBTFNFLFxuICAgICAgXG4gICAgICAgICAgLy8gaXNSZWFkeTogSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cbiAgICAgICAgICBpc1JlYWR5ID0gRkFMU0UsXG4gICAgICBcbiAgICAgICAgICAvLyBDYWxsYmFja3MgcGVuZGluZyBleGVjdXRpb24gdW50aWwgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICAgIGZ1bmN0aW9uIHJlYWR5KCBmbiApIHtcbiAgICAgICAgICBpZiAoICFpc1JlYWR5ICkge1xuICAgICAgXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cbiAgICAgICAgICAgICAgaWYgKCAhZG9jLmJvZHkgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXIoIHJlYWR5ICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgICAgICAgaXNSZWFkeSA9IHRydWU7XG4gICAgICBcbiAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBhbGwgY2FsbGJhY2tzXG4gICAgICAgICAgICAgIHdoaWxlICggZm4gPSBjYWxsYmFja3Muc2hpZnQoKSApIHtcbiAgICAgICAgICAgICAgICAgIGRlZmVyKCBmbiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlclxuICAgICAgZnVuY3Rpb24gY29tcGxldGVkKCBldmVudCApIHtcbiAgICAgICAgICAvLyByZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgaXMgZ29vZCBlbm91Z2ggZm9yIHVzIHRvIGNhbGwgdGhlIGRvbSByZWFkeSBpbiBvbGRJRVxuICAgICAgICAgIGlmICggdzNjIHx8IGV2ZW50LnR5cGUgPT09IExPQUQgfHwgZG9jW1JFQURZU1RBVEVdID09PSBDT01QTEVURSApIHtcbiAgICAgICAgICAgICAgZGV0YWNoKCk7XG4gICAgICAgICAgICAgIHJlYWR5KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDbGVhbi11cCBtZXRob2QgZm9yIGRvbSByZWFkeSBldmVudHNcbiAgICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgICAgICBpZiAoIHczYyApIHtcbiAgICAgICAgICAgICAgZG9jW1JFTU9WRUVWRU5UTElTVEVORVJdKCBET01DT05URU5UTE9BREVELCBjb21wbGV0ZWQsIEZBTFNFICk7XG4gICAgICAgICAgICAgIHdpbltSRU1PVkVFVkVOVExJU1RFTkVSXSggTE9BRCwgY29tcGxldGVkLCBGQUxTRSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvY1tERVRBQ0hFVkVOVF0oIE9OUkVBRFlTVEFURUNIQU5HRSwgY29tcGxldGVkICk7XG4gICAgICAgICAgICAgIHdpbltERVRBQ0hFVkVOVF0oIE9OTE9BRCwgY29tcGxldGVkICk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cbiAgICAgIGZ1bmN0aW9uIGRlZmVyKCBmbiwgd2FpdCApIHtcbiAgICAgICAgICAvLyBBbGxvdyAwIHRvIGJlIHBhc3NlZFxuICAgICAgICAgIHNldFRpbWVvdXQoIGZuLCArd2FpdCA+PSAwID8gd2FpdCA6IDEgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXR0YWNoIHRoZSBsaXN0ZW5lcnM6XG4gICAgICBcbiAgICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlIG9uRG9tUmVhZHkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuICAgICAgLy8gd2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG4gICAgICAvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG4gICAgICBpZiAoIGRvY1tSRUFEWVNUQVRFXSA9PT0gQ09NUExFVEUgKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG4gICAgICAgICAgZGVmZXIoIHJlYWR5ICk7XG4gICAgICBcbiAgICAgIC8vIFN0YW5kYXJkcy1iYXNlZCBicm93c2VycyBzdXBwb3J0IERPTUNvbnRlbnRMb2FkZWRcbiAgICAgIH0gZWxzZSBpZiAoIHczYyApIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgICAgZG9jW0FEREVWRU5UTElTVEVORVJdKCBET01DT05URU5UTE9BREVELCBjb21wbGV0ZWQsIEZBTFNFICk7XG4gICAgICBcbiAgICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICAgIHdpbltBRERFVkVOVExJU1RFTkVSXSggTE9BRCwgY29tcGxldGVkLCBGQUxTRSApO1xuICAgICAgXG4gICAgICAvLyBJZiBJRSBldmVudCBtb2RlbCBpcyB1c2VkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCwgbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG4gICAgICAgICAgZG9jW0FUVEFDSEVWRU5UXSggT05SRUFEWVNUQVRFQ0hBTkdFLCBjb21wbGV0ZWQgKTtcbiAgICAgIFxuICAgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgICAgICAgd2luW0FUVEFDSEVWRU5UXSggT05MT0FELCBjb21wbGV0ZWQgKTtcbiAgICAgIFxuICAgICAgICAgIC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxuICAgICAgICAgIC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBfdG9wID0gd2luLmZyYW1lRWxlbWVudCA9PSBudWxsICYmIGRvY0VsZW07XG4gICAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgXG4gICAgICAgICAgaWYgKCBfdG9wICYmIF90b3AuZG9TY3JvbGwgKSB7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCAhaXNSZWFkeSApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdG9wLmRvU2Nyb2xsKFwibGVmdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyKCBkb1Njcm9sbENoZWNrLCA1MCApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRldGFjaCBhbGwgZG9tIHJlYWR5IGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgIGRldGFjaCgpO1xuICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgcmVhZHkoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIG9uRG9tUmVhZHkoIGZuICkge1xuICAgICAgICAgIC8vIElmIERPTSBpcyByZWFkeSwgZXhlY3V0ZSB0aGUgZnVuY3Rpb24gKGFzeW5jKSwgb3RoZXJ3aXNlIHdhaXRcbiAgICAgICAgICBpc1JlYWR5ID8gZGVmZXIoIGZuICkgOiBjYWxsYmFja3MucHVzaCggZm4gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIHZlcnNpb25cbiAgICAgIG9uRG9tUmVhZHkudmVyc2lvbiA9IFwiMS40LjBcIjtcbiAgICAgIC8vIEFkZCBtZXRob2QgdG8gY2hlY2sgaWYgRE9NIGlzIHJlYWR5XG4gICAgICBvbkRvbVJlYWR5LmlzUmVhZHkgPSBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBpc1JlYWR5O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9uRG9tUmVhZHk7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgX29uRG9tUmVhZHkod2luZG93KTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgLy9Nb2RpZmllZCB2ZXJzaW9uIG9mIGNvbXBvbmVudC9xdWVyeXN0cmluZ1xuICAvL0NoYW5nZXM6IHVwZGF0ZWQgZGVwZW5kZW5jaWVzLCBkb3Qgbm90YXRpb24gcGFyc2luZywgSlNIaW50IGZpeGVzXG4gIC8vRm9yayBhdCBodHRwczovL2dpdGh1Yi5jb20vaW1za3kvcXVlcnlzdHJpbmdcblxuICAvKipcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgdmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcbiAgdmFyIHRyaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuICB2YXIgdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbiAgdmFyIGFycmF5UmVnZXggPSAvKFxcdyspXFxbKFxcZCspXFxdLztcbiAgdmFyIG9iamVjdFJlZ2V4ID0gL1xcdytcXC5cXHcrLztcblxuICAvKipcbiAgICogUGFyc2UgdGhlIGdpdmVuIHF1ZXJ5IGBzdHJgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHN0cil7XG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3RyKSByZXR1cm4ge307XG5cbiAgICBzdHIgPSB0cmltKHN0cik7XG4gICAgaWYgKCcnID09PSBzdHIpIHJldHVybiB7fTtcbiAgICBpZiAoJz8nID09PSBzdHIuY2hhckF0KDApKSBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRzID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHNbMF0pO1xuICAgICAgdmFyIG0sIGN0eCwgcHJvcDtcblxuICAgICAgaWYgKG0gPSBhcnJheVJlZ2V4LmV4ZWMoa2V5KSkge1xuICAgICAgICBvYmpbbVsxXV0gPSBvYmpbbVsxXV0gfHwgW107XG4gICAgICAgIG9ialttWzFdXVttWzJdXSA9IGRlY29kZShwYXJ0c1sxXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobSA9IG9iamVjdFJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgICBtID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgIGN0eCA9IG9iajtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlIChtLmxlbmd0aCkge1xuICAgICAgICAgIHByb3AgPSBtLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiAoIXByb3AubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmICghY3R4W3Byb3BdKSB7XG4gICAgICAgICAgICBjdHhbcHJvcF0gPSB7fTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN0eFtwcm9wXSAmJiB0eXBlb2YgY3R4W3Byb3BdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtLmxlbmd0aCkge1xuICAgICAgICAgICAgY3R4W3Byb3BdID0gZGVjb2RlKHBhcnRzWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHggPSBjdHhbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgb2JqW3BhcnRzWzBdXSA9IG51bGwgPT0gcGFydHNbMV0gPyAnJyA6IGRlY29kZShwYXJ0c1sxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvKipcbiAgICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgb2JqYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqKXtcbiAgICBpZiAoIW9iaikgcmV0dXJuICcnO1xuICAgIHZhciBwYWlycyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICgnYXJyYXknID09IHR5cGUodmFsdWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKGVuY29kZShrZXkgKyAnWycgKyBpICsgJ10nKSArICc9JyArIGVuY29kZSh2YWx1ZVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwYWlycy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKG9ialtrZXldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbiAgfTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBcbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuICBmdW5jdGlvbiB0cmltKHN0cil7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG4gIH1cblxuICBleHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG4gIH07XG5cbiAgZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbiAgfTtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAvKipcbiAgICogdG9TdHJpbmcgcmVmLlxuICAgKi9cblxuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHJldHVybiAnZGF0ZSc7XG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAnYXJyYXknO1xuICAgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOiByZXR1cm4gJ2Vycm9yJztcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIGlmICh2YWwgIT09IHZhbCkgcmV0dXJuICduYW4nO1xuICAgIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcblxuICAgIHZhbCA9IHZhbC52YWx1ZU9mXG4gICAgICA/IHZhbC52YWx1ZU9mKClcbiAgICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbCk7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgfTtcblxuICAvLyBjb2RlIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pcy1idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXG4gICAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgICApKVxuICB9XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgdmFyIFNjZW5lR3JhcGggPSBmdW5jdGlvbihzY2VuZVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlQ291bnQgPSAxO1xuXG4gICAgICAvL3RvZG86IG1vdmUgbWVyZ2UgdG8gaGVscGVycyBzZWN0aW9uXG4gICAgICBmdW5jdGlvbiBtZXJnZShwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICBwYXJlbnRbcHJvcF0gPSBjaGlsZFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIFNjZW5lTm9kZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBub2RlQ291bnQrKztcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICAgICAgICAgIHRoaXMuaWQgPSBub2RlQ291bnQ7XG4gICAgICAgICAgdGhpcy5uYW1lID0gJ24nICsgbm9kZUNvdW50O1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcbiAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgfTtcblxuICAgICAgU2NlbmVOb2RlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgU2NlbmVOb2RlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgICAgICAgdGhpcy54ID0geCAhPSBudWxsID8geCA6IHRoaXMueDtcbiAgICAgICAgICB0aGlzLnkgPSB5ICE9IG51bGwgPyB5IDogdGhpcy55O1xuICAgICAgICAgIHRoaXMueiA9IHogIT0gbnVsbCA/IHogOiB0aGlzLno7XG4gICAgICB9O1xuXG4gICAgICBTY2VuZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBjaGlsZC5uYW1lO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbltuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltuYW1lXSA9IGNoaWxkO1xuICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93ICdTY2VuZUdyYXBoOiBjaGlsZCBhbHJlYWR5IGV4aXN0czogJyArIG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIFJvb3ROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgU2NlbmVOb2RlLmNhbGwodGhpcywgJ3Jvb3QnKTtcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBzY2VuZVByb3BlcnRpZXM7XG4gICAgICB9O1xuXG4gICAgICBSb290Tm9kZS5wcm90b3R5cGUgPSBuZXcgU2NlbmVOb2RlKCk7XG5cbiAgICAgIHZhciBTaGFwZSA9IGZ1bmN0aW9uKG5hbWUsIHByb3BzKSB7XG4gICAgICAgICAgU2NlbmVOb2RlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAnZmlsbCc6ICcjMDAwMDAwJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgbWVyZ2UodGhpcy5wcm9wZXJ0aWVzLCBwcm9wcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRocm93ICdTY2VuZUdyYXBoOiBpbnZhbGlkIG5vZGUgbmFtZSc7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgU2hhcGUucHJvdG90eXBlID0gbmV3IFNjZW5lTm9kZSgpO1xuXG4gICAgICB2YXIgR3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHRoaXMudHlwZSA9ICdncm91cCc7XG4gICAgICB9O1xuXG4gICAgICBHcm91cC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblxuICAgICAgdmFyIFJlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHRoaXMudHlwZSA9ICdyZWN0JztcbiAgICAgIH07XG5cbiAgICAgIFJlY3QucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5cbiAgICAgIHZhciBUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgICAgICAgIHRoaXMucHJvcGVydGllcy50ZXh0ID0gdGV4dDtcbiAgICAgIH07XG5cbiAgICAgIFRleHQucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5cbiAgICAgIHZhciByb290ID0gbmV3IFJvb3ROb2RlKCk7XG5cbiAgICAgIHRoaXMuU2hhcGUgPSB7XG4gICAgICAgICAgJ1JlY3QnOiBSZWN0LFxuICAgICAgICAgICdUZXh0JzogVGV4dCxcbiAgICAgICAgICAnR3JvdXAnOiBHcm91cFxuICAgICAgfTtcblxuICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gU2NlbmVHcmFwaDtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG4gICAqIFNoYWxsb3cgb2JqZWN0IGNsb25lIGFuZCBtZXJnZVxuICAgKlxuICAgKiBAcGFyYW0gYSBPYmplY3QgQVxuICAgKiBAcGFyYW0gYiBPYmplY3QgQlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHdpdGggYWxsIG9mIEEncyBwcm9wZXJ0aWVzLCBhbmQgYWxsIG9mIEIncyBwcm9wZXJ0aWVzLCBvdmVyd3JpdGluZyBBJ3MgcHJvcGVydGllc1xuICAgKi9cbiAgZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgYyA9IHt9O1xuICAgICAgZm9yICh2YXIgeCBpbiBhKSB7XG4gICAgICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoeCkpIHtcbiAgICAgICAgICAgICAgY1t4XSA9IGFbeF07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAodmFyIHkgaW4gYikge1xuICAgICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eSh5KSkge1xuICAgICAgICAgICAgICAgICAgY1t5XSA9IGJbeV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgfTtcblxuICAvKipcbiAgICogVGFrZXMgYSBrL3YgbGlzdCBvZiBDU1MgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIHJ1bGVcbiAgICpcbiAgICogQHBhcmFtIHByb3BzIENTUyBwcm9wZXJ0aWVzIG9iamVjdFxuICAgKi9cbiAgZXhwb3J0cy5jc3NQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBmb3IgKHZhciBwIGluIHByb3BzKSB7XG4gICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgIHJldC5wdXNoKHAgKyAnOicgKyBwcm9wc1twXSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldC5qb2luKCc7Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgSFRNTCBlbnRpdGllcyBpbiBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZ1xuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGVIdG1sRW50aXR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYnVmID0gW107XG4gICAgICB2YXIgY2hhckNvZGUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgaWYgKGNoYXJDb2RlID4gMTI4KSB7XG4gICAgICAgICAgICAgIGJ1Zi51bnNoaWZ0KFsnJiMnLCBjaGFyQ29kZSwgJzsnXS5qb2luKCcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnVmLnVuc2hpZnQoc3RyW2ldKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gaW1hZ2UgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSBzcmMgVVJMIG9mIGltYWdlXG4gICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIG9uY2UgaW1hZ2Ugc3RhdHVzIGhhcyBiZWVuIGZvdW5kXG4gICAqL1xuICBleHBvcnRzLmltYWdlRXhpc3RzID0gZnVuY3Rpb24oc3JjLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICB9O1xuICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZXMgSFRNTCBlbnRpdGllcyBpbiBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZ1xuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGVIdG1sRW50aXR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbihtYXRjaCwgZGVjKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjKTtcbiAgICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZWxlbWVudCdzIGRpbWVuc2lvbnMgaWYgaXQncyB2aXNpYmxlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIGVsIERPTSBlbGVtZW50XG4gICAqL1xuICBleHBvcnRzLmRpbWVuc2lvbkNoZWNrID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBkaW1lbnNpb25zID0ge1xuICAgICAgICAgIGhlaWdodDogZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBlbC5jbGllbnRXaWR0aFxuICAgICAgfTtcblxuICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0ICYmIGRpbWVuc2lvbnMud2lkdGgpIHtcbiAgICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyB0cnV0aHkgb3IgaWYgaXQgaXMgXCJzZW1hbnRpY2FsbHkgdHJ1dGh5XCJcbiAgICogQHBhcmFtIHZhbFxuICAgKi9cbiAgZXhwb3J0cy50cnV0aHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICd5ZXMnIHx8IHZhbCA9PT0gJzEnIHx8IHZhbCA9PT0gJ29uJyB8fCB2YWwgPT09ICfinJMnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgaW5wdXQgaW50byBhIHdlbGwtZm9ybWVkIENTUyBjb2xvclxuICAgKiBAcGFyYW0gdmFsXG4gICAqL1xuICBleHBvcnRzLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBoZXhyZSA9IC8oXig/OiM/KVswLTlhLWZdezZ9JCl8KF4oPzojPylbMC05YS1mXXszfSQpL2k7XG4gICAgICB2YXIgcmdicmUgPSAvXnJnYlxcKChcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccypcXCkkLztcbiAgICAgIHZhciByZ2JhcmUgPSAvXnJnYmFcXCgoXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooMFxcLlxcZHsxLH18MSlcXCkkLztcblxuICAgICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKGhleHJlKTtcbiAgICAgIHZhciByZXR2YWw7XG5cbiAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHZhbCA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdO1xuICAgICAgICAgIGlmIChyZXR2YWxbMF0gIT09ICcjJykge1xuICAgICAgICAgICAgICByZXR1cm4gJyMnICsgcmV0dmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHZhbC5tYXRjaChyZ2JyZSk7XG5cbiAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHZhbCA9ICdyZ2IoJyArIG1hdGNoLnNsaWNlKDEpLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHZhbC5tYXRjaChyZ2JhcmUpO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSAncmdiYSgnICsgbWF0Y2guc2xpY2UoMSkuam9pbignLCcpICsgJyknO1xuICAgICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyB0aGUgY29ycmVjdCBzY2FsaW5nIHJhdGlvIGZvciBjYW52YXMgZHJhd2luZyBvcGVyYXRpb25zIG9uIEhpRFBJIHNjcmVlbnMgKGUuZy4gUmV0aW5hIGRpc3BsYXlzKVxuICAgKi9cbiAgZXhwb3J0cy5jYW52YXNSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gMTtcbiAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IDE7XG5cbiAgICAgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgICAgICB2YXIgY2FudmFzID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW8gPSBnbG9iYWwuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICB9O1xuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgRE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuICB2YXIgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIE5PREVfVFlQRV9DT01NRU5UID0gODtcblxuICAvKipcbiAgICogR2VuZXJpYyBTVkcgZWxlbWVudCBjcmVhdGlvbiBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0gc3ZnIFNWRyBjb250ZXh0LCBzZXQgdG8gbnVsbCBpZiBuZXdcbiAgICogQHBhcmFtIHdpZHRoIERvY3VtZW50IHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHQgRG9jdW1lbnQgaGVpZ2h0XG4gICAqL1xuICBleHBvcnRzLmluaXRTVkcgPSBmdW5jdGlvbihzdmcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBkZWZzLCBzdHlsZSwgaW5pdGlhbGl6ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3ZnICYmIHN2Zy5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgICAgc3R5bGUgPSBzdmcucXVlcnlTZWxlY3Rvcignc3R5bGUnKTtcbiAgICAgICAgICBpZiAoc3R5bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdmcgPSBET00ubmV3RWwoJ3N2ZycsIFNWR19OUyk7XG4gICAgICAgICAgaW5pdGlhbGl6ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbml0aWFsaXplKSB7XG4gICAgICAgICAgZGVmcyA9IERPTS5uZXdFbCgnZGVmcycsIFNWR19OUyk7XG4gICAgICAgICAgc3R5bGUgPSBET00ubmV3RWwoJ3N0eWxlJywgU1ZHX05TKTtcbiAgICAgICAgICBET00uc2V0QXR0cihzdHlsZSwge1xuICAgICAgICAgICAgICAndHlwZSc6ICd0ZXh0L2NzcydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgICB9XG5cbiAgICAgIC8vSUUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGlzIGlzIHNldCBhbmQgQ2hyb21lIHJlcXVpcmVzIGl0IHRvIGJlIHNldFxuICAgICAgaWYgKHN2Zy53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd4bWxucycsIFNWR19OUyk7XG4gICAgICB9XG5cbiAgICAgIC8vUmVtb3ZlIGNvbW1lbnQgbm9kZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ZnLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc3ZnLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgPT09IE5PREVfVFlQRV9DT01NRU5UKSB7XG4gICAgICAgICAgICAgIHN2Zy5yZW1vdmVDaGlsZChzdmcuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1JlbW92ZSBDU1NcbiAgICAgIHdoaWxlIChzdHlsZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICBET00uc2V0QXR0cihzdmcsIHtcbiAgICAgICAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuICAgICAgICAgICd2aWV3Qm94JzogJzAgMCAnICsgd2lkdGggKyAnICcgKyBoZWlnaHQsXG4gICAgICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZSdcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3ZnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIFNWRyB0byBhIHN0cmluZyBzdWl0YWJsZSBmb3IgZGF0YSBVUkkgdXNlXG4gICAqIEBwYXJhbSBzdmdTdHJpbmcgU2VyaWFsaXplZCBTVkcgc3RyaW5nXG4gICAqIEBwYXJhbSBbYmFzZTY0XSBVc2UgYmFzZTY0IGVuY29kaW5nIGZvciBkYXRhIFVSSVxuICAgKi9cbiAgZXhwb3J0cy5zdmdTdHJpbmdUb0RhdGFVUkkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYXdQcmVmaXggPSAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsJztcbiAgICAgIHZhciBiYXNlNjRQcmVmaXggPSAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTg7YmFzZTY0LCc7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihzdmdTdHJpbmcsIGJhc2U2NCkge1xuICAgICAgICAgIGlmIChiYXNlNjQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFByZWZpeCArIGJ0b2EoZ2xvYmFsLnVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdmdTdHJpbmcpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhd1ByZWZpeCArIGVuY29kZVVSSUNvbXBvbmVudChzdmdTdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gIH0oKTtcblxuICAvKipcbiAgICogUmV0dXJucyBzZXJpYWxpemVkIFNWRyB3aXRoIFhNTCBwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gc3ZnIFNWRyBjb250ZXh0XG4gICAqIEBwYXJhbSBzdHlsZXNoZWV0cyBDU1Mgc3R5bGVzaGVldHMgdG8gaW5jbHVkZVxuICAgKi9cbiAgZXhwb3J0cy5zZXJpYWxpemVTVkcgPSBmdW5jdGlvbihzdmcsIGVuZ2luZVNldHRpbmdzKSB7XG4gICAgICBpZiAoIWdsb2JhbC5YTUxTZXJpYWxpemVyKSByZXR1cm47XG4gICAgICB2YXIgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG4gICAgICB2YXIgc3ZnQ1NTID0gJyc7XG4gICAgICB2YXIgc3R5bGVzaGVldHMgPSBlbmdpbmVTZXR0aW5ncy5zdHlsZXNoZWV0cztcblxuICAgICAgLy9FeHRlcm5hbCBzdHlsZXNoZWV0czogUHJvY2Vzc2luZyBJbnN0cnVjdGlvbiBtZXRob2RcbiAgICAgIGlmIChlbmdpbmVTZXR0aW5ncy5zdmdYTUxTdHlsZXNoZWV0KSB7XG4gICAgICAgICAgdmFyIHhtbCA9IERPTS5jcmVhdGVYTUwoKTtcbiAgICAgICAgICAvL0FkZCA8P3htbC1zdHlsZXNoZWV0ID8+IGRpcmVjdGl2ZXNcbiAgICAgICAgICBmb3IgKHZhciBpID0gc3R5bGVzaGVldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGNzc3BpID0geG1sLmNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbigneG1sLXN0eWxlc2hlZXQnLCAnaHJlZj1cIicgKyBzdHlsZXNoZWV0c1tpXSArICdcIiByZWw9XCJzdHlsZXNoZWV0XCInKTtcbiAgICAgICAgICAgICAgeG1sLmluc2VydEJlZm9yZShjc3NwaSwgeG1sLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHhtbC5yZW1vdmVDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICBzdmdDU1MgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdmdUZXh0ID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmcpO1xuICAgICAgc3ZnVGV4dCA9IHN2Z1RleHQucmVwbGFjZSgvXFwmYW1wOyhcXCNbMC05XXsyLH1cXDspL2csICcmJDEnKTtcbiAgICAgIHJldHVybiBzdmdDU1MgKyBzdmdUZXh0O1xuICB9O1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuICAgKiBHZW5lcmljIG5ldyBET00gZWxlbWVudCBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0gdGFnIFRhZyB0byBjcmVhdGVcbiAgICogQHBhcmFtIG5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgdmFsdWVcbiAgICovXG4gIGV4cG9ydHMubmV3RWwgPSBmdW5jdGlvbih0YWcsIG5hbWVzcGFjZSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHJldHVybjtcblxuICAgICAgaWYgKG5hbWVzcGFjZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJpYyBzZXRBdHRyaWJ1dGUgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGVsIFJlZmVyZW5jZSB0byBET00gZWxlbWVudFxuICAgKiBAcGFyYW0gYXR0cnMgT2JqZWN0IHdpdGggYXR0cmlidXRlIGtleXMgYW5kIHZhbHVlc1xuICAgKi9cbiAgZXhwb3J0cy5zZXRBdHRyID0gZnVuY3Rpb24gKGVsLCBhdHRycykge1xuICAgICAgZm9yICh2YXIgYSBpbiBhdHRycykge1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhLCBhdHRyc1thXSk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBYTUwgZG9jdW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4cG9ydHMuY3JlYXRlWE1MID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWdsb2JhbC5ET01QYXJzZXIpIHJldHVybjtcbiAgICAgIHJldHVybiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCc8eG1sIC8+JywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAqXG4gICAqIEBwYXJhbSB2YWwgQSBzdHJpbmcsIGEgTm9kZUxpc3QsIGEgTm9kZSwgb3IgYW4gSFRNTENvbGxlY3Rpb25cbiAgICovXG4gIGV4cG9ydHMuZ2V0Tm9kZUFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgcmV0dmFsID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YodmFsKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHZhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk5vZGVMaXN0ICYmIHZhbCBpbnN0YW5jZW9mIGdsb2JhbC5Ob2RlTGlzdCkge1xuICAgICAgICAgIHJldHZhbCA9IHZhbDtcbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk5vZGUgJiYgdmFsIGluc3RhbmNlb2YgZ2xvYmFsLk5vZGUpIHtcbiAgICAgICAgICByZXR2YWwgPSBbdmFsXTtcbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsLkhUTUxDb2xsZWN0aW9uICYmIHZhbCBpbnN0YW5jZW9mIGdsb2JhbC5IVE1MQ29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHZhbCA9IHZhbDtcbiAgICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICByZXR2YWwgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHZhbCA9IFtdO1xuICAgICAgfVxuXG4gICAgICByZXR2YWwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyZXR2YWwpO1xuXG4gICAgICByZXR1cm4gcmV0dmFsO1xuICB9O1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgICAvL3RvZG86IHN1cHBvcnQgcmdiYSwgaHNsYSwgYW5kIHJyZ2diYmFhIG5vdGF0aW9uXG4gICAgICAvL3RvZG86IHVzZSBDSUVMQUIgaW50ZXJuYWxseVxuICAgICAgLy90b2RvOiBhZGQgY2xhbXAgZnVuY3Rpb24gKHdpdGggc2lnbilcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnKSByZXR1cm47XG5cbiAgICAgIHRoaXMub3JpZ2luYWwgPSBjb2xvcjtcblxuICAgICAgaWYgKGNvbG9yLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgY29sb3IgPSBjb2xvci5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKC9bXmEtZjAtOV0rL2kudGVzdChjb2xvcikpIHJldHVybjtcblxuICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgvLi9nLCAnJCYkJicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3IubGVuZ3RoICE9PSA2KSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWxwaGEgPSAxO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFscGhhKSB7XG4gICAgICAgICAgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KHBhcnNlSW50KGNvbG9yLCAxNikpO1xuICB9O1xuXG4gIC8vdG9kbzoganNkb2NzXG4gIENvbG9yLnJnYjJoZXggPSBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQgKGRlY2ltYWwpIHtcbiAgICAgICAgICB2YXIgaGV4ID0gKGRlY2ltYWwgfCAwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgaWYgKGRlY2ltYWwgPCAxNikge1xuICAgICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbciwgZywgYl0ubWFwKGZvcm1hdCkuam9pbignJyk7XG4gIH07XG5cbiAgLy90b2RvOiBqc2RvY3NcbiAgQ29sb3IuaHNsMnJnYiA9IGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgICB2YXIgSCA9IGggLyA2MDtcbiAgICAgIHZhciBDID0gKDEgLSBNYXRoLmFicygyICogbCAtIDEpKSAqIHM7XG4gICAgICB2YXIgWCA9IEMgKiAoMSAtIE1hdGguYWJzKHBhcnNlSW50KEgpICUgMiAtIDEpKTtcbiAgICAgIHZhciBtID0gbCAtIChDIC8gMik7XG5cbiAgICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwO1xuXG4gICAgICBpZiAoSCA+PSAwICYmIEggPCAxKSB7XG4gICAgICAgICAgciA9IEM7XG4gICAgICAgICAgZyA9IFg7XG4gICAgICB9IGVsc2UgaWYgKEggPj0gMSAmJiBIIDwgMikge1xuICAgICAgICAgIHIgPSBYO1xuICAgICAgICAgIGcgPSBDO1xuICAgICAgfSBlbHNlIGlmIChIID49IDIgJiYgSCA8IDMpIHtcbiAgICAgICAgICBnID0gQztcbiAgICAgICAgICBiID0gWDtcbiAgICAgIH0gZWxzZSBpZiAoSCA+PSAzICYmIEggPCA0KSB7XG4gICAgICAgICAgZyA9IFg7XG4gICAgICAgICAgYiA9IEM7XG4gICAgICB9IGVsc2UgaWYgKEggPj0gNCAmJiBIIDwgNSkge1xuICAgICAgICAgIHIgPSBYO1xuICAgICAgICAgIGIgPSBDO1xuICAgICAgfSBlbHNlIGlmIChIID49IDUgJiYgSCA8IDYpIHtcbiAgICAgICAgICByID0gQztcbiAgICAgICAgICBiID0gWDtcbiAgICAgIH1cblxuICAgICAgciArPSBtO1xuICAgICAgZyArPSBtO1xuICAgICAgYiArPSBtO1xuXG4gICAgICByID0gcGFyc2VJbnQociAqIDI1NSk7XG4gICAgICBnID0gcGFyc2VJbnQoZyAqIDI1NSk7XG4gICAgICBiID0gcGFyc2VJbnQoYiAqIDI1NSk7XG5cbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIGZyb20gYSByYXcgUkdCODg4IGludGVnZXJcbiAgICogQHBhcmFtIHJhdyBSR0I4ODggcmVwcmVzZW50YXRpb24gb2YgY29sb3JcbiAgICovXG4gIC8vdG9kbzogcmVmYWN0b3IgaW50byBhIHN0YXRpYyBtZXRob2RcbiAgLy90b2RvOiBmYWN0b3Igb3V0IGluZGl2aWR1YWwgY29sb3Igc3BhY2VzXG4gIC8vdG9kbzogYWRkIEhTTCwgQ0lFTEFCLCBhbmQgQ0lFTFVWXG4gIENvbG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLnJhdyA9IHZhbDtcblxuICAgICAgdmFyIHIgPSAodGhpcy5yYXcgJiAweEZGMDAwMCkgPj4gMTY7XG4gICAgICB2YXIgZyA9ICh0aGlzLnJhdyAmIDB4MDBGRjAwKSA+PiA4O1xuICAgICAgdmFyIGIgPSAodGhpcy5yYXcgJiAweDAwMDBGRik7XG5cbiAgICAgIC8vIEJULjcwOVxuICAgICAgdmFyIHkgPSAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XG4gICAgICB2YXIgdSA9IC0wLjA5OTkxICogciAtIDAuMzM2MDkgKiBnICsgMC40MzYgKiBiO1xuICAgICAgdmFyIHYgPSAwLjYxNSAqIHIgLSAwLjU1ODYxICogZyAtIDAuMDU2MzkgKiBiO1xuXG4gICAgICB0aGlzLnJnYiA9IHtcbiAgICAgICAgICByOiByLFxuICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgYjogYlxuICAgICAgfTtcblxuICAgICAgdGhpcy55dXYgPSB7XG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB1OiB1LFxuICAgICAgICAgIHY6IHZcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaWdodGVuIG9yIGRhcmtlbiBhIGNvbG9yXG4gICAqIEBwYXJhbSBtdWx0aXBsaWVyIEFtb3VudCB0byBsaWdodGVuIG9yIGRhcmtlbiAoLTEgdG8gMSlcbiAgICovXG4gIENvbG9yLnByb3RvdHlwZS5saWdodGVuID0gZnVuY3Rpb24obXVsdGlwbGllcikge1xuICAgICAgdmFyIGNtID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgTWF0aC5hYnMobXVsdGlwbGllcikpKSAqIChtdWx0aXBsaWVyIDwgMCA/IC0xIDogMSk7XG4gICAgICB2YXIgYm0gPSAoMjU1ICogY20pIHwgMDtcbiAgICAgIHZhciBjciA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgdGhpcy5yZ2IuciArIGJtKSk7XG4gICAgICB2YXIgY2cgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIHRoaXMucmdiLmcgKyBibSkpO1xuICAgICAgdmFyIGNiID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCB0aGlzLnJnYi5iICsgYm0pKTtcbiAgICAgIHZhciBoZXggPSBDb2xvci5yZ2IyaGV4KGNyLCBjZywgY2IpO1xuICAgICAgcmV0dXJuIG5ldyBDb2xvcihoZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPdXRwdXQgY29sb3IgaW4gaGV4IGZvcm1hdFxuICAgKiBAcGFyYW0gYWRkSGFzaCBBZGQgYSBoYXNoIGNoYXJhY3RlciB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBvdXRwdXRcbiAgICovXG4gIENvbG9yLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKGFkZEhhc2gpIHtcbiAgICAgIHJldHVybiAoYWRkSGFzaCA/ICcjJyA6ICcnKSArIHRoaXMucmF3LnRvU3RyaW5nKDE2KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBjdXJyZW50IGNvbG9yIGlzIGxpZ2h0ZXIgdGhhbiBhbm90aGVyIGNvbG9yXG4gICAqIEBwYXJhbSBjb2xvciBDb2xvciB0byBjb21wYXJlIGFnYWluc3RcbiAgICovXG4gIENvbG9yLnByb3RvdHlwZS5saWdodGVyVGhhbiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMueXV2LnkgPiBjb2xvci55dXYueTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIG1peGluZyBjdXJyZW50IGNvbG9yIHdpdGggYW5vdGhlciBjb2xvclxuICAgKiBAcGFyYW0gY29sb3IgQ29sb3IgdG8gbWl4IHdpdGhcbiAgICogQHBhcmFtIG11bHRpcGxpZXIgSG93IG11Y2ggdG8gbWl4IHdpdGggdGhlIG90aGVyIGNvbG9yXG4gICAqL1xuICAvKlxuICBDb2xvci5wcm90b3R5cGUubWl4ID0gZnVuY3Rpb24gKGNvbG9yLCBtdWx0aXBsaWVyKSB7XG4gICAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSB0aGlzLnJnYi5yO1xuICAgICAgdmFyIGcgPSB0aGlzLnJnYi5nO1xuICAgICAgdmFyIGIgPSB0aGlzLnJnYi5iO1xuICAgICAgdmFyIGEgPSB0aGlzLmFscGhhO1xuXG4gICAgICB2YXIgbSA9IHR5cGVvZiBtdWx0aXBsaWVyICE9PSAndW5kZWZpbmVkJyA/IG11bHRpcGxpZXIgOiAwLjU7XG5cbiAgICAgIC8vdG9kbzogd3JpdGUgYSBsZXJwIGZ1bmN0aW9uXG4gICAgICByID0gciArIG0gKiAoY29sb3IucmdiLnIgLSByKTtcbiAgICAgIGcgPSBnICsgbSAqIChjb2xvci5yZ2IuZyAtIGcpO1xuICAgICAgYiA9IGIgKyBtICogKGNvbG9yLnJnYi5iIC0gYik7XG4gICAgICBhID0gYSArIG0gKiAoY29sb3IuYWxwaGEgLSBhKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihDb2xvci5yZ2JUb0hleChyLCBnLCBiKSwge1xuICAgICAgICAgICdhbHBoYSc6IGFcbiAgICAgIH0pO1xuICB9O1xuICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYmxlbmRpbmcgYW5vdGhlciBjb2xvciBvbiB0b3Agb2YgY3VycmVudCBjb2xvciB3aXRoIGFscGhhXG4gICAqIEBwYXJhbSBjb2xvciBDb2xvciB0byBibGVuZCBvbiB0b3Agb2YgY3VycmVudCBjb2xvciwgaS5lLiBcIkNhXCJcbiAgICovXG4gIC8vdG9kbzogc2VlIGlmIC5ibGVuZEFscGhhIGNhbiBiZSBtZXJnZWQgaW50byAubWl4XG4gIENvbG9yLnByb3RvdHlwZS5ibGVuZEFscGhhID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIGlmICghKGNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgICAgY29sb3IgPSBuZXcgQ29sb3IoY29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgQ2EgPSBjb2xvcjtcbiAgICAgIHZhciBDYiA9IHRoaXM7XG5cbiAgICAgIC8vdG9kbzogd3JpdGUgYWxwaGEgYmxlbmRpbmcgZnVuY3Rpb25cbiAgICAgIHZhciByID0gQ2EuYWxwaGEgKiBDYS5yZ2IuciArICgxIC0gQ2EuYWxwaGEpICogQ2IucmdiLnI7XG4gICAgICB2YXIgZyA9IENhLmFscGhhICogQ2EucmdiLmcgKyAoMSAtIENhLmFscGhhKSAqIENiLnJnYi5nO1xuICAgICAgdmFyIGIgPSBDYS5hbHBoYSAqIENhLnJnYi5iICsgKDEgLSBDYS5hbHBoYSkgKiBDYi5yZ2IuYjtcblxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihDb2xvci5yZ2IyaGV4KHIsIGcsIGIpKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAndmVyc2lvbic6ICcyLjkuNicsXG4gICAgJ3N2Z19ucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcbiAgfTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIHZhciBzaGF2ZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuICB2YXIgU1ZHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbiAgdmFyIGNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4gIHZhciBTVkdfTlMgPSBjb25zdGFudHMuc3ZnX25zO1xuXG4gIHZhciB0ZW1wbGF0ZXMgPSB7XG4gICAgJ2VsZW1lbnQnOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHRhZyA9IG9wdGlvbnMudGFnO1xuICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnQgfHwgJyc7XG4gICAgICBkZWxldGUgb3B0aW9ucy50YWc7XG4gICAgICBkZWxldGUgb3B0aW9ucy5jb250ZW50O1xuICAgICAgcmV0dXJuICBbdGFnLCBjb250ZW50LCBvcHRpb25zXTtcbiAgICB9XG4gIH07XG5cbiAgLy90b2RvOiBkZXByZWNhdGUgdGFnIGFyZywgaW5mZXIgdGFnIGZyb20gc2hhcGUgb2JqZWN0XG4gIGZ1bmN0aW9uIGNvbnZlcnRTaGFwZSAoc2hhcGUsIHRhZykge1xuICAgIHJldHVybiB0ZW1wbGF0ZXMuZWxlbWVudCh7XG4gICAgICAndGFnJzogdGFnLFxuICAgICAgJ3dpZHRoJzogc2hhcGUud2lkdGgsXG4gICAgICAnaGVpZ2h0Jzogc2hhcGUuaGVpZ2h0LFxuICAgICAgJ2ZpbGwnOiBzaGFwZS5wcm9wZXJ0aWVzLmZpbGxcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRDc3MgKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdXRpbHMuY3NzUHJvcHMoe1xuICAgICAgJ2ZpbGwnOiBwcm9wZXJ0aWVzLmZpbGwsXG4gICAgICAnZm9udC13ZWlnaHQnOiBwcm9wZXJ0aWVzLmZvbnQud2VpZ2h0LFxuICAgICAgJ2ZvbnQtZmFtaWx5JzogcHJvcGVydGllcy5mb250LmZhbWlseSArICcsIG1vbm9zcGFjZScsXG4gICAgICAnZm9udC1zaXplJzogcHJvcGVydGllcy5mb250LnNpemUgKyBwcm9wZXJ0aWVzLmZvbnQudW5pdHNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG91dGxpbmVQYXRoIChiZ1dpZHRoLCBiZ0hlaWdodCwgb3V0bGluZVdpZHRoKSB7XG4gICAgdmFyIG91dGxpbmVPZmZzZXRXaWR0aCA9IG91dGxpbmVXaWR0aCAvIDI7XG5cbiAgICByZXR1cm4gW1xuICAgICAgJ00nLCBvdXRsaW5lT2Zmc2V0V2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCxcbiAgICAgICdIJywgYmdXaWR0aCAtIG91dGxpbmVPZmZzZXRXaWR0aCxcbiAgICAgICdWJywgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG4gICAgICAnSCcsIG91dGxpbmVPZmZzZXRXaWR0aCxcbiAgICAgICdWJywgMCxcbiAgICAgICdNJywgMCwgb3V0bGluZU9mZnNldFdpZHRoLFxuICAgICAgJ0wnLCBiZ1dpZHRoLCBiZ0hlaWdodCAtIG91dGxpbmVPZmZzZXRXaWR0aCxcbiAgICAgICdNJywgMCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG4gICAgICAnTCcsIGJnV2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aFxuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NlbmVHcmFwaCwgcmVuZGVyU2V0dGluZ3MpIHtcbiAgICB2YXIgZW5naW5lU2V0dGluZ3MgPSByZW5kZXJTZXR0aW5ncy5lbmdpbmVTZXR0aW5ncztcbiAgICB2YXIgc3R5bGVzaGVldHMgPSBlbmdpbmVTZXR0aW5ncy5zdHlsZXNoZWV0cztcbiAgICB2YXIgc3R5bGVzaGVldFhtbCA9IHN0eWxlc2hlZXRzLm1hcChmdW5jdGlvbiAoc3R5bGVzaGVldCkge1xuICAgICAgcmV0dXJuICc8P3htbC1zdHlsZXNoZWV0IHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiJyArIHN0eWxlc2hlZXQgKyAnXCI/Pic7XG4gICAgfSkuam9pbignXFxuJyk7XG5cbiAgICB2YXIgaG9sZGVySWQgPSAnaG9sZGVyXycgKyBOdW1iZXIobmV3IERhdGUoKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHJvb3QgPSBzY2VuZUdyYXBoLnJvb3Q7XG4gICAgdmFyIHRleHRHcm91cCA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyVGV4dEdyb3VwO1xuXG4gICAgdmFyIGNzcyA9ICcjJyArIGhvbGRlcklkICsgJyB0ZXh0IHsgJyArIHRleHRDc3ModGV4dEdyb3VwLnByb3BlcnRpZXMpICsgJyB9ICc7XG5cbiAgICAvLyBwdXNoIHRleHQgZG93biB0byBiZSBlcXVhbGx5IHZlcnRpY2FsbHkgYWxpZ25lZCB3aXRoIGNhbnZhcyByZW5kZXJlclxuICAgIHRleHRHcm91cC55ICs9IHRleHRHcm91cC50ZXh0UG9zaXRpb25EYXRhLmJvdW5kaW5nQm94LmhlaWdodCAqIDAuODtcblxuICAgIHZhciB3b3JkVGFncyA9IFtdO1xuXG4gICAgT2JqZWN0LmtleXModGV4dEdyb3VwLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lS2V5KSB7XG4gICAgICB2YXIgbGluZSA9IHRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcblxuICAgICAgT2JqZWN0LmtleXMobGluZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAod29yZEtleSkge1xuICAgICAgICB2YXIgd29yZCA9IGxpbmUuY2hpbGRyZW5bd29yZEtleV07XG4gICAgICAgIHZhciB4ID0gdGV4dEdyb3VwLnggKyBsaW5lLnggKyB3b3JkLng7XG4gICAgICAgIHZhciB5ID0gdGV4dEdyb3VwLnkgKyBsaW5lLnkgKyB3b3JkLnk7XG4gICAgICAgIHZhciB3b3JkVGFnID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgICAgICd0YWcnOiAndGV4dCcsXG4gICAgICAgICAgJ2NvbnRlbnQnOiB3b3JkLnByb3BlcnRpZXMudGV4dCxcbiAgICAgICAgICAneCc6IHgsXG4gICAgICAgICAgJ3knOiB5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdvcmRUYWdzLnB1c2god29yZFRhZyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciB0ZXh0ID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgJ3RhZyc6ICdnJyxcbiAgICAgICdjb250ZW50Jzogd29yZFRhZ3NcbiAgICB9KTtcblxuICAgIHZhciBvdXRsaW5lID0gbnVsbDtcblxuICAgIGlmIChyb290LmNoaWxkcmVuLmhvbGRlckJnLnByb3BlcnRpZXMub3V0bGluZSkge1xuICAgICAgdmFyIG91dGxpbmVQcm9wZXJ0aWVzID0gcm9vdC5jaGlsZHJlbi5ob2xkZXJCZy5wcm9wZXJ0aWVzLm91dGxpbmU7XG4gICAgICBvdXRsaW5lID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgICAndGFnJzogJ3BhdGgnLFxuICAgICAgICAnZCc6IG91dGxpbmVQYXRoKHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcud2lkdGgsIHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcuaGVpZ2h0LCBvdXRsaW5lUHJvcGVydGllcy53aWR0aCksXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiBvdXRsaW5lUHJvcGVydGllcy53aWR0aCxcbiAgICAgICAgJ3N0cm9rZSc6IG91dGxpbmVQcm9wZXJ0aWVzLmZpbGwsXG4gICAgICAgICdmaWxsJzogJ25vbmUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYmcgPSBjb252ZXJ0U2hhcGUocm9vdC5jaGlsZHJlbi5ob2xkZXJCZywgJ3JlY3QnKTtcblxuICAgIHZhciBzY2VuZUNvbnRlbnQgPSBbXTtcblxuICAgIHNjZW5lQ29udGVudC5wdXNoKGJnKTtcbiAgICBpZiAob3V0bGluZVByb3BlcnRpZXMpIHtcbiAgICAgIHNjZW5lQ29udGVudC5wdXNoKG91dGxpbmUpO1xuICAgIH1cbiAgICBzY2VuZUNvbnRlbnQucHVzaCh0ZXh0KTtcblxuICAgIHZhciBzY2VuZSA9IHRlbXBsYXRlcy5lbGVtZW50KHtcbiAgICAgICd0YWcnOiAnZycsXG4gICAgICAnaWQnOiBob2xkZXJJZCxcbiAgICAgICdjb250ZW50Jzogc2NlbmVDb250ZW50XG4gICAgfSk7XG5cbiAgICB2YXIgc3R5bGUgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG4gICAgICAndGFnJzogJ3N0eWxlJyxcbiAgICAgIC8vdG9kbzogZmlndXJlIG91dCBob3cgdG8gYWRkIENEQVRBIGRpcmVjdGl2ZVxuICAgICAgJ2NvbnRlbnQnOiBjc3MsXG4gICAgICAndHlwZSc6ICd0ZXh0L2NzcydcbiAgICB9KTtcblxuICAgIHZhciBkZWZzID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgJ3RhZyc6ICdkZWZzJyxcbiAgICAgICdjb250ZW50Jzogc3R5bGVcbiAgICB9KTtcblxuICAgIHZhciBzdmcgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG4gICAgICAndGFnJzogJ3N2ZycsXG4gICAgICAnY29udGVudCc6IFtkZWZzLCBzY2VuZV0sXG4gICAgICAnd2lkdGgnOiByb290LnByb3BlcnRpZXMud2lkdGgsXG4gICAgICAnaGVpZ2h0Jzogcm9vdC5wcm9wZXJ0aWVzLmhlaWdodCxcbiAgICAgICd4bWxucyc6IFNWR19OUyxcbiAgICAgICd2aWV3Qm94JzogWzAsIDAsIHJvb3QucHJvcGVydGllcy53aWR0aCwgcm9vdC5wcm9wZXJ0aWVzLmhlaWdodF0uam9pbignICcpLFxuICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZSdcbiAgICB9KTtcblxuICAgIHZhciBvdXRwdXQgPSBzaGF2ZW4oc3ZnKTtcblxuICAgIGlmICgvXFwmYW1wOyh4KT8jWzAtOUEtRmEtZl0vLnRlc3Qob3V0cHV0WzBdKSkge1xuICAgICAgb3V0cHV0WzBdID0gb3V0cHV0WzBdLnJlcGxhY2UoLyZhbXA7Iy9nbSwgJyYjJyk7XG4gICAgfVxuICAgIFxuICAgIG91dHB1dCA9IHN0eWxlc2hlZXRYbWwgKyBvdXRwdXRbMF07XG5cbiAgICB2YXIgc3ZnU3RyaW5nID0gU1ZHLnN2Z1N0cmluZ1RvRGF0YVVSSShvdXRwdXQsIHJlbmRlclNldHRpbmdzLm1vZGUgPT09ICdiYWNrZ3JvdW5kJyk7XG4gICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgfTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIHZhciBlc2NhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxuXG4gIC8vIFRPRE86IHJlbW92ZSBuYW1lc3BhY2VcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYXZlbiAoYXJyYXksIG5hbWVzcGFjZSwgcmV0dXJuT2JqZWN0KSB7XG5cbiAgICAndXNlIHN0cmljdCdcblxuICAgIHZhciBpID0gMVxuICAgIHZhciBkb2VzRXNjYXBlID0gdHJ1ZVxuICAgIHZhciBIVE1MU3RyaW5nXG4gICAgdmFyIGF0dHJpYnV0ZUtleVxuICAgIHZhciBjYWxsYmFja1xuICAgIHZhciBrZXlcblxuXG4gICAgcmV0dXJuT2JqZWN0ID0gcmV0dXJuT2JqZWN0IHx8IHt9XG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKHN1Z2FyU3RyaW5nKSB7XG5cbiAgICAgIHZhciB0YWdzID0gc3VnYXJTdHJpbmcubWF0Y2goL15bXFx3LV0rLylcbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0YWc6IHRhZ3MgPyB0YWdzWzBdIDogJ2RpdicsXG4gICAgICAgIGF0dHI6IHt9LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH1cbiAgICAgIHZhciBpZCA9IHN1Z2FyU3RyaW5nLm1hdGNoKC8jKFtcXHctXSspLylcbiAgICAgIHZhciByZWZlcmVuY2UgPSBzdWdhclN0cmluZy5tYXRjaCgvXFwkKFtcXHctXSspLylcbiAgICAgIHZhciBjbGFzc05hbWVzID0gc3VnYXJTdHJpbmcubWF0Y2goL1xcLltcXHctXSsvZylcblxuXG4gICAgICAvLyBBc3NpZ24gaWQgaWYgaXMgc2V0XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgZWxlbWVudC5hdHRyLmlkID0gaWRbMV1cblxuICAgICAgICAvLyBBZGQgZWxlbWVudCB0byB0aGUgcmV0dXJuIG9iamVjdFxuICAgICAgICByZXR1cm5PYmplY3RbaWRbMV1dID0gZWxlbWVudFxuICAgICAgfVxuXG4gICAgICBpZiAocmVmZXJlbmNlKVxuICAgICAgICByZXR1cm5PYmplY3RbcmVmZXJlbmNlWzFdXSA9IGVsZW1lbnRcblxuICAgICAgaWYgKGNsYXNzTmFtZXMpXG4gICAgICAgIGVsZW1lbnQuYXR0ci5jbGFzcyA9IGNsYXNzTmFtZXMuam9pbignICcpLnJlcGxhY2UoL1xcLi9nLCAnJylcblxuICAgICAgaWYgKHN1Z2FyU3RyaW5nLm1hdGNoKC8mJC9nKSlcbiAgICAgICAgZG9lc0VzY2FwZSA9IGZhbHNlXG5cbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIgKGtleSwgdmFsdWUpIHtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm5cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcblxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlIChzdHJpbmcpIHtcbiAgICAgIHJldHVybiAoc3RyaW5nIHx8IHN0cmluZyA9PT0gMCkgP1xuICAgICAgICBTdHJpbmcoc3RyaW5nKVxuICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSA6XG4gICAgICAgICcnXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlSFRNTCAoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cmluZylcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCAnJmFwb3M7JylcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgfVxuXG5cbiAgICBpZiAodHlwZW9mIGFycmF5WzBdID09PSAnc3RyaW5nJylcbiAgICAgIGFycmF5WzBdID0gY3JlYXRlRWxlbWVudChhcnJheVswXSlcblxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pKVxuICAgICAgaSA9IDBcblxuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ZpcnN0IGVsZW1lbnQgb2YgYXJyYXkgbXVzdCBiZSBhIHN0cmluZywgJyArXG4gICAgICAgICdvciBhbiBhcnJheSBhbmQgbm90ICcgKyBKU09OLnN0cmluZ2lmeShhcnJheVswXSlcbiAgICAgIClcblxuXG4gICAgZm9yICg7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAvLyBEb24ndCByZW5kZXIgZWxlbWVudCBpZiB2YWx1ZSBpcyBmYWxzZSBvciBudWxsXG4gICAgICBpZiAoYXJyYXlbaV0gPT09IGZhbHNlIHx8IGFycmF5W2ldID09PSBudWxsKSB7XG4gICAgICAgIGFycmF5WzBdID0gZmFsc2VcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udGludWUgd2l0aCBuZXh0IGFycmF5IHZhbHVlIGlmIGN1cnJlbnQgdmFsdWUgaXMgdW5kZWZpbmVkIG9yIHRydWVcbiAgICAgIGVsc2UgaWYgKGFycmF5W2ldID09PSB1bmRlZmluZWQgfHwgYXJyYXlbaV0gPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFycmF5W2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9lc0VzY2FwZSlcbiAgICAgICAgICBhcnJheVtpXSA9IGVzY2FwZUhUTUwoYXJyYXlbaV0pXG5cbiAgICAgICAgYXJyYXlbMF0uY2hpbGRyZW4ucHVzaChhcnJheVtpXSlcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFycmF5W2ldID09PSAnbnVtYmVyJykge1xuXG4gICAgICAgIGFycmF5WzBdLmNoaWxkcmVuLnB1c2goYXJyYXlbaV0pXG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV1bMF0pKSB7XG4gICAgICAgICAgYXJyYXlbaV0ucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKHN1YkFycmF5KSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSArIDEsIDAsIHN1YkFycmF5KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoaSAhPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgaSsrXG4gICAgICAgIH1cblxuICAgICAgICBzaGF2ZW4oYXJyYXlbaV0sIG5hbWVzcGFjZSwgcmV0dXJuT2JqZWN0KVxuXG4gICAgICAgIGlmIChhcnJheVtpXVswXSlcbiAgICAgICAgICBhcnJheVswXS5jaGlsZHJlbi5wdXNoKGFycmF5W2ldWzBdKVxuICAgICAgfVxuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgYXJyYXlbaV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGNhbGxiYWNrID0gYXJyYXlbaV1cblxuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgYXJyYXlbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoYXR0cmlidXRlS2V5IGluIGFycmF5W2ldKVxuICAgICAgICAgIGlmIChhcnJheVtpXS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVLZXkpKVxuICAgICAgICAgICAgaWYgKGFycmF5W2ldW2F0dHJpYnV0ZUtleV0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgYXJyYXlbaV1bYXR0cmlidXRlS2V5XSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVLZXkgPT09ICdzdHlsZScgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJyYXlbaV1bYXR0cmlidXRlS2V5XSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgYXJyYXlbMF0uYXR0clthdHRyaWJ1dGVLZXldID0gSlNPTlxuICAgICAgICAgICAgICAgICAgLnN0cmluZ2lmeShhcnJheVtpXVthdHRyaWJ1dGVLZXldLCByZXBsYWNlcilcbiAgICAgICAgICAgICAgICAgIC5zbGljZSgyLCAtMilcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIixcIi9nLCAnOycpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCI6XCIvZywgJzonKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXFwnJylcblxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYXJyYXlbMF0uYXR0clthdHRyaWJ1dGVLZXldID0gYXJyYXlbaV1bYXR0cmlidXRlS2V5XVxuICAgICAgfVxuXG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiJyArIGFycmF5W2ldICsgJ1wiIGlzIG5vdCBhbGxvd2VkIGFzIGEgdmFsdWUuJylcbiAgICB9XG5cblxuICAgIGlmIChhcnJheVswXSAhPT0gZmFsc2UpIHtcblxuICAgICAgSFRNTFN0cmluZyA9ICc8JyArIGFycmF5WzBdLnRhZ1xuXG4gICAgICBmb3IgKGtleSBpbiBhcnJheVswXS5hdHRyKVxuICAgICAgICBpZiAoYXJyYXlbMF0uYXR0ci5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgIEhUTUxTdHJpbmcgKz0gJyAnICsga2V5ICsgJz1cIicgK1xuICAgICAgICAgICAgZXNjYXBlQXR0cmlidXRlKGFycmF5WzBdLmF0dHJba2V5XSkgKyAnXCInXG5cbiAgICAgIEhUTUxTdHJpbmcgKz0gJz4nXG5cbiAgICAgIGFycmF5WzBdLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIEhUTUxTdHJpbmcgKz0gY2hpbGRcbiAgICAgIH0pXG5cbiAgICAgIEhUTUxTdHJpbmcgKz0gJzwvJyArIGFycmF5WzBdLnRhZyArICc+J1xuXG4gICAgICBhcnJheVswXSA9IEhUTUxTdHJpbmdcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gcm9vdCBlbGVtZW50IG9uIGluZGV4IDBcbiAgICByZXR1cm5PYmplY3RbMF0gPSBhcnJheVswXVxuXG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgY2FsbGJhY2soYXJyYXlbMF0pXG5cbiAgICAvLyByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFsbCBlbGVtZW50cyB3aXRoIGFuIGlkIGFuZCB0aGUgcm9vdCBlbGVtZW50XG4gICAgcmV0dXJuIHJldHVybk9iamVjdFxuICB9XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIC8qIVxuICAgKiBlc2NhcGUtaHRtbFxuICAgKiBDb3B5cmlnaHQoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gICAqIENvcHlyaWdodChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAgICogQ29weXJpZ2h0KGMpIDIwMTUgVGlhbmNoZW5nIFwiVGltb3RoeVwiIEd1XG4gICAqIE1JVCBMaWNlbnNlZFxuICAgKi9cblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgZXhwb3J0cy5cbiAgICogQHB1YmxpY1xuICAgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IGVzY2FwZUh0bWw7XG5cbiAgLyoqXG4gICAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZSBmb3IgaW5zZXJ0aW5nIGludG8gSFRNTFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIGVzY2FwZTtcbiAgICB2YXIgaHRtbCA9ICcnO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgY2FzZSAzNDogLy8gXCJcbiAgICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODogLy8gJlxuICAgICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6IC8vICdcbiAgICAgICAgICBlc2NhcGUgPSAnJiMzOTsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDYyOiAvLyA+XG4gICAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgIGh0bWwgKz0gZXNjYXBlO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4XG4gICAgICA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpXG4gICAgICA6IGh0bWw7XG4gIH1cblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgdmFyIERPTSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gIHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FudmFzID0gRE9NLm5ld0VsKCdjYW52YXMnKTtcbiAgICAgIHZhciBjdHggPSBudWxsO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NlbmVHcmFwaCkge1xuICAgICAgICAgIGlmIChjdHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZHByID0gdXRpbHMuY2FudmFzUmF0aW8oKTtcbiAgICAgICAgICB2YXIgcm9vdCA9IHNjZW5lR3JhcGgucm9vdDtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBkcHIgKiByb290LnByb3BlcnRpZXMud2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGRwciAqIHJvb3QucHJvcGVydGllcy5oZWlnaHQgO1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgICAgIHZhciBiZyA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyQmc7XG4gICAgICAgICAgdmFyIGJnV2lkdGggPSBkcHIgKiBiZy53aWR0aDtcbiAgICAgICAgICB2YXIgYmdIZWlnaHQgPSBkcHIgKiBiZy5oZWlnaHQ7XG4gICAgICAgICAgLy90b2RvOiBwYXJhbWV0cml6ZSBvdXRsaW5lIHdpZHRoIChlLmcuIGluIHNjZW5lIG9iamVjdClcbiAgICAgICAgICB2YXIgb3V0bGluZVdpZHRoID0gMjtcbiAgICAgICAgICB2YXIgb3V0bGluZU9mZnNldFdpZHRoID0gb3V0bGluZVdpZHRoIC8gMjtcblxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZy5wcm9wZXJ0aWVzLmZpbGw7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGJnV2lkdGgsIGJnSGVpZ2h0KTtcblxuICAgICAgICAgIGlmIChiZy5wcm9wZXJ0aWVzLm91dGxpbmUpIHtcbiAgICAgICAgICAgICAgLy90b2RvOiBhYnN0cmFjdCB0aGlzIGludG8gYSBtZXRob2RcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYmcucHJvcGVydGllcy5vdXRsaW5lLmZpbGw7XG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBiZy5wcm9wZXJ0aWVzLm91dGxpbmUud2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8ob3V0bGluZU9mZnNldFdpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICAvLyBUTCwgVFIsIEJSLCBCTFxuICAgICAgICAgICAgICBjdHgubGluZVRvKGJnV2lkdGggLSBvdXRsaW5lT2Zmc2V0V2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmdXaWR0aCAtIG91dGxpbmVPZmZzZXRXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKG91dGxpbmVPZmZzZXRXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKG91dGxpbmVPZmZzZXRXaWR0aCwgb3V0bGluZU9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgLy8gRGlhZ29uYWxzXG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgb3V0bGluZU9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoLCBiZ0hlaWdodCAtIG91dGxpbmVPZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKGJnV2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dEdyb3VwID0gcm9vdC5jaGlsZHJlbi5ob2xkZXJUZXh0R3JvdXA7XG4gICAgICAgICAgY3R4LmZvbnQgPSB0ZXh0R3JvdXAucHJvcGVydGllcy5mb250LndlaWdodCArICcgJyArIChkcHIgKiB0ZXh0R3JvdXAucHJvcGVydGllcy5mb250LnNpemUpICsgdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC51bml0cyArICcgJyArIHRleHRHcm91cC5wcm9wZXJ0aWVzLmZvbnQuZmFtaWx5ICsgJywgbW9ub3NwYWNlJztcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dEdyb3VwLnByb3BlcnRpZXMuZmlsbDtcblxuICAgICAgICAgIGZvciAodmFyIGxpbmVLZXkgaW4gdGV4dEdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5lID0gdGV4dEdyb3VwLmNoaWxkcmVuW2xpbmVLZXldO1xuICAgICAgICAgICAgICBmb3IgKHZhciB3b3JkS2V5IGluIGxpbmUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgIHZhciB3b3JkID0gbGluZS5jaGlsZHJlblt3b3JkS2V5XTtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID0gZHByICogKHRleHRHcm91cC54ICsgbGluZS54ICsgd29yZC54KTtcbiAgICAgICAgICAgICAgICAgIHZhciB5ID0gZHByICogKHRleHRHcm91cC55ICsgbGluZS55ICsgd29yZC55ICsgKHRleHRHcm91cC5wcm9wZXJ0aWVzLmxlYWRpbmcgLyAyKSk7XG5cbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh3b3JkLnByb3BlcnRpZXMudGV4dCwgeCwgeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuKGZ1bmN0aW9uKGN0eCwgaXNNZXRlb3JQYWNrYWdlKSB7XG4gICAgaWYgKGlzTWV0ZW9yUGFja2FnZSkge1xuICAgICAgICBIb2xkZXIgPSBjdHguSG9sZGVyO1xuICAgIH1cbn0pKHRoaXMsIHR5cGVvZiBNZXRlb3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBQYWNrYWdlICE9PSAndW5kZWZpbmVkJyk7XG5cblxuIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=