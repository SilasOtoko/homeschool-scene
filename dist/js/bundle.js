/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@fortawesome/fontawesome-svg-core/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@fortawesome/fontawesome-svg-core/index.es.js ***!
  \********************************************************************/
/*! exports provided: icon, noAuto, config, toHtml, layer, text, counter, library, dom, parse, findIconDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "icon", function() { return icon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noAuto", function() { return noAuto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHtml", function() { return toHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layer", function() { return layer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "counter", function() { return counter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "library", function() { return library; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dom", function() { return dom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIconDefinition", function() { return findIconDefinition; });
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var noop = function noop() {};

var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};

try {
  if (typeof window !== 'undefined') _WINDOW = window;
  if (typeof document !== 'undefined') _DOCUMENT = document;
  if (typeof MutationObserver !== 'undefined') _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== 'undefined') _PERFORMANCE = performance;
} catch (e) {}

var _ref = _WINDOW.navigator || {},
    _ref$userAgent = _ref.userAgent,
    userAgent = _ref$userAgent === void 0 ? '' : _ref$userAgent;

var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';
var IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');

var NAMESPACE_IDENTIFIER = '___FONT_AWESOME___';
var UNITS_IN_GRID = 16;
var DEFAULT_FAMILY_PREFIX = 'fa';
var DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa';
var DATA_FA_I2SVG = 'data-fa-i2svg';
var DATA_FA_PSEUDO_ELEMENT = 'data-fa-pseudo-element';
var DATA_FA_PSEUDO_ELEMENT_PENDING = 'data-fa-pseudo-element-pending';
var DATA_PREFIX = 'data-prefix';
var DATA_ICON = 'data-icon';
var HTML_CLASS_I2SVG_BASE_CLASS = 'fontawesome-i2svg';
var MUTATION_APPROACH_ASYNC = 'async';
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ['HTML', 'HEAD', 'STYLE', 'SCRIPT'];
var PRODUCTION = function () {
  try {
    return "development" === 'production';
  } catch (e) {
    return false;
  }
}();
var PREFIX_TO_STYLE = {
  'fas': 'solid',
  'far': 'regular',
  'fal': 'light',
  'fab': 'brands',
  'fa': 'solid'
};
var STYLE_TO_PREFIX = {
  'solid': 'fas',
  'regular': 'far',
  'light': 'fal',
  'brands': 'fab'
};
var LAYERS_TEXT_CLASSNAME = 'fa-layers-text';
var FONT_FAMILY_PATTERN = /Font Awesome 5 (Solid|Regular|Light|Brands|Free|Pro)/;
var FONT_WEIGHT_TO_PREFIX = {
  '900': 'fas',
  '400': 'far',
  'normal': 'far',
  '300': 'fal'
};
var oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'];
var RESERVED_CLASSES = ['xs', 'sm', 'lg', 'fw', 'ul', 'li', 'border', 'pull-left', 'pull-right', 'spin', 'pulse', 'rotate-90', 'rotate-180', 'rotate-270', 'flip-horizontal', 'flip-vertical', 'flip-both', 'stack', 'stack-1x', 'stack-2x', 'inverse', 'layers', 'layers-text', 'layers-counter'].concat(oneToTen.map(function (n) {
  return "".concat(n, "x");
})).concat(oneToTwenty.map(function (n) {
  return "w-".concat(n);
}));

var initial = WINDOW.FontAwesomeConfig || {};

function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector('script[' + attr + ']');

  if (element) {
    return element.getAttribute(attr);
  }
}

function coerce(val) {
  // Getting an empty string will occur if the attribute is set on the HTML tag but without a value
  // We'll assume that this is an indication that it should be toggled to true
  // For example <script data-search-pseudo-elements src="..."></script>
  if (val === '') return true;
  if (val === 'false') return false;
  if (val === 'true') return true;
  return val;
}

if (DOCUMENT && typeof DOCUMENT.querySelector === 'function') {
  var attrs = [['data-family-prefix', 'familyPrefix'], ['data-replacement-class', 'replacementClass'], ['data-auto-replace-svg', 'autoReplaceSvg'], ['data-auto-add-css', 'autoAddCss'], ['data-auto-a11y', 'autoA11y'], ['data-search-pseudo-elements', 'searchPseudoElements'], ['data-observe-mutations', 'observeMutations'], ['data-mutate-approach', 'mutateApproach'], ['data-keep-original-source', 'keepOriginalSource'], ['data-measure-performance', 'measurePerformance'], ['data-show-missing-icons', 'showMissingIcons']];
  attrs.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        attr = _ref2[0],
        key = _ref2[1];

    var val = coerce(getAttrConfig(attr));

    if (val !== undefined && val !== null) {
      initial[key] = val;
    }
  });
}

var _default = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: 'async',
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};

var _config = _objectSpread({}, _default, initial);

if (!_config.autoReplaceSvg) _config.observeMutations = false;

var config = _objectSpread({}, _config);

WINDOW.FontAwesomeConfig = config;

var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];

var functions = [];

var listener = function listener() {
  DOCUMENT.removeEventListener('DOMContentLoaded', listener);
  loaded = 1;
  functions.map(function (fn) {
    return fn();
  });
};

var loaded = false;

if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);
}

function domready (fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';

var NOOP = function NOOP() {};

var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
  // run promise callbacks
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  } // reset async asyncQueue


  asyncQueue = [];
  asyncTimer = false;
}

function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);

  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}

function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }

  function rejectPromise(reason) {
    reject(promise, reason);
  }

  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e) {
    rejectPromise(e);
  }
}

function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;

  if (typeof callback === 'function') {
    settled = FULFILLED;

    try {
      value = callback(value);
    } catch (e) {
      reject(promise, e);
    }
  }

  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }

    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}

function handleThenable(promise, value) {
  var resolved;

  try {
    if (promise === value) {
      throw new TypeError('A promises callback cannot return that same promise.');
    }

    if (value && (typeof value === 'function' || _typeof(value) === 'object')) {
      // then should be retrieved only once
      var then = value.then;

      if (typeof then === 'function') {
        then.call(value, function (val) {
          if (!resolved) {
            resolved = true;

            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function (reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e) {
    if (!resolved) {
      reject(promise, e);
    }

    return true;
  }

  return false;
}

function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}

function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}

function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}

function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}

function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);

  if (!promise._handled && isNode) {
    global.process.emit('unhandledRejection', promise._data, promise);
  }
}

function notifyRejectionHandled(promise) {
  global.process.emit('rejectionHandled', promise);
}
/**
 * @class
 */


function P(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('Promise resolver ' + resolver + ' is not a function');
  }

  if (this instanceof P === false) {
    throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
  }

  this._then = [];
  invokeResolver(resolver, this);
}

P.prototype = {
  constructor: P,
  _state: PENDING,
  _then: null,
  _data: undefined,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };

    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;

      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }

    if (this._state === FULFILLED || this._state === REJECTED) {
      // already resolved, call callback async
      asyncCall(invokeCallback, subscriber);
    } else {
      // subscribe
      this._then.push(subscriber);
    }

    return subscriber.then;
  },
  catch: function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

P.all = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.all().');
  }

  return new P(function (resolve, reject) {
    var results = [];
    var remaining = 0;

    function resolver(index) {
      remaining++;
      return function (value) {
        results[index] = value;

        if (! --remaining) {
          resolve(results);
        }
      };
    }

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolver(i), reject);
      } else {
        results[i] = promise;
      }
    }

    if (!remaining) {
      resolve(results);
    }
  });
};

P.race = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.race().');
  }

  return new P(function (resolve, reject) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
  });
};

P.resolve = function (value) {
  if (value && _typeof(value) === 'object' && value.constructor === P) {
    return value;
  }

  return new P(function (resolve) {
    resolve(value);
  });
};

P.reject = function (reason) {
  return new P(function (resolve, reject) {
    reject(reason);
  });
};

var picked = typeof Promise === 'function' ? Promise : P;

var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};

function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function insertCss(css) {
  if (!css || !IS_DOM) {
    return;
  }

  var style = DOCUMENT.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;

  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || '').toUpperCase();

    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }

  DOCUMENT.head.insertBefore(style, beforeChild);
  return css;
}
var idPool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function nextUniqueId() {
  var size = 12;
  var id = '';

  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }

  return id;
}
function toArray(obj) {
  var array = [];

  for (var i = (obj || []).length >>> 0; i--;) {
    array[i] = obj[i];
  }

  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute('class') || '').split(' ').filter(function (i) {
      return i;
    });
  }
}
function getIconName(familyPrefix, cls) {
  var parts = cls.split('-');
  var prefix = parts[0];
  var iconName = parts.slice(1).join('-');

  if (prefix === familyPrefix && iconName !== '' && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function (acc, attributeName) {
    return acc + "".concat(attributeName, "=\"").concat(htmlEscape(attributes[attributeName]), "\" ");
  }, '').trim();
}
function joinStyles(styles) {
  return Object.keys(styles || {}).reduce(function (acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles[styleName], ";");
  }, '');
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  var transform = _ref.transform,
      containerWidth = _ref.containerWidth,
      iconWidth = _ref.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer: outer,
    inner: inner,
    path: path
  };
}
function transformForCss(_ref2) {
  var transform = _ref2.transform,
      _ref2$width = _ref2.width,
      width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width,
      _ref2$height = _ref2.height,
      height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height,
      _ref2$startCentered = _ref2.startCentered,
      startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = '';

  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d - width / 2, "em, ").concat(transform.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d, "em), calc(-50% + ").concat(transform.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d, "em, ").concat(transform.y / d, "em) ");
  }

  val += "scale(".concat(transform.size / d * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}

var ALL_SPACE = {
  x: 0,
  y: 0,
  width: '100%',
  height: '100%'
};
function makeIconMasking (_ref) {
  var children = _ref.children,
      attributes = _ref.attributes,
      main = _ref.main,
      mask = _ref.mask,
      transform = _ref.transform;
  var mainWidth = main.width,
      mainPath = main.icon;
  var maskWidth = mask.width,
      maskPath = mask.icon;
  var trans = transformForSvg({
    transform: transform,
    containerWidth: maskWidth,
    iconWidth: mainWidth
  });
  var maskRect = {
    tag: 'rect',
    attributes: _objectSpread({}, ALL_SPACE, {
      fill: 'white'
    })
  };
  var maskInnerGroup = {
    tag: 'g',
    attributes: _objectSpread({}, trans.inner),
    children: [{
      tag: 'path',
      attributes: _objectSpread({}, mainPath.attributes, trans.path, {
        fill: 'black'
      })
    }]
  };
  var maskOuterGroup = {
    tag: 'g',
    attributes: _objectSpread({}, trans.outer),
    children: [maskInnerGroup]
  };
  var maskId = "mask-".concat(nextUniqueId());
  var clipId = "clip-".concat(nextUniqueId());
  var maskTag = {
    tag: 'mask',
    attributes: _objectSpread({}, ALL_SPACE, {
      id: maskId,
      maskUnits: 'userSpaceOnUse',
      maskContentUnits: 'userSpaceOnUse'
    }),
    children: [maskRect, maskOuterGroup]
  };
  var defs = {
    tag: 'defs',
    children: [{
      tag: 'clipPath',
      attributes: {
        id: clipId
      },
      children: [maskPath]
    }, maskTag]
  };
  children.push(defs, {
    tag: 'rect',
    attributes: _objectSpread({
      fill: 'currentColor',
      'clip-path': "url(#".concat(clipId, ")"),
      mask: "url(#".concat(maskId, ")")
    }, ALL_SPACE)
  });
  return {
    children: children,
    attributes: attributes
  };
}

function makeIconStandard (_ref) {
  var children = _ref.children,
      attributes = _ref.attributes,
      main = _ref.main,
      transform = _ref.transform,
      styles = _ref.styles;
  var styleString = joinStyles(styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  if (transformIsMeaningful(transform)) {
    var trans = transformForSvg({
      transform: transform,
      containerWidth: main.width,
      iconWidth: main.width
    });
    children.push({
      tag: 'g',
      attributes: _objectSpread({}, trans.outer),
      children: [{
        tag: 'g',
        attributes: _objectSpread({}, trans.inner),
        children: [{
          tag: main.icon.tag,
          children: main.icon.children,
          attributes: _objectSpread({}, main.icon.attributes, trans.path)
        }]
      }]
    });
  } else {
    children.push(main.icon);
  }

  return {
    children: children,
    attributes: attributes
  };
}

function asIcon (_ref) {
  var children = _ref.children,
      main = _ref.main,
      mask = _ref.mask,
      attributes = _ref.attributes,
      styles = _ref.styles,
      transform = _ref.transform;

  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    var width = main.width,
        height = main.height;
    var offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes['style'] = joinStyles(_objectSpread({}, styles, {
      'transform-origin': "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    }));
  }

  return [{
    tag: 'svg',
    attributes: attributes,
    children: children
  }];
}

function asSymbol (_ref) {
  var prefix = _ref.prefix,
      iconName = _ref.iconName,
      children = _ref.children,
      attributes = _ref.attributes,
      symbol = _ref.symbol;
  var id = symbol === true ? "".concat(prefix, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: 'svg',
    attributes: {
      style: 'display: none;'
    },
    children: [{
      tag: 'symbol',
      attributes: _objectSpread({}, attributes, {
        id: id
      }),
      children: children
    }]
  }];
}

function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons,
      main = _params$icons.main,
      mask = _params$icons.mask,
      prefix = params.prefix,
      iconName = params.iconName,
      transform = params.transform,
      symbol = params.symbol,
      title = params.title,
      extra = params.extra,
      _params$watchable = params.watchable,
      watchable = _params$watchable === void 0 ? false : _params$watchable;

  var _ref = mask.found ? mask : main,
      width = _ref.width,
      height = _ref.height;

  var widthClass = "fa-w-".concat(Math.ceil(width / height * 16));
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : '', widthClass].filter(function (c) {
    return extra.classes.indexOf(c) === -1;
  }).concat(extra.classes).join(' ');
  var content = {
    children: [],
    attributes: _objectSpread({}, extra.attributes, {
      'data-prefix': prefix,
      'data-icon': iconName,
      'class': attrClass,
      'role': extra.attributes.role || 'img',
      'xmlns': 'http://www.w3.org/2000/svg',
      'viewBox': "0 0 ".concat(width, " ").concat(height)
    })
  };

  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = '';
  }

  if (title) content.children.push({
    tag: 'title',
    attributes: {
      id: content.attributes['aria-labelledby'] || "title-".concat(nextUniqueId())
    },
    children: [title]
  });

  var args = _objectSpread({}, content, {
    prefix: prefix,
    iconName: iconName,
    main: main,
    mask: mask,
    transform: transform,
    symbol: symbol,
    styles: extra.styles
  });

  var _ref2 = mask.found && main.found ? makeIconMasking(args) : makeIconStandard(args),
      children = _ref2.children,
      attributes = _ref2.attributes;

  args.children = children;
  args.attributes = attributes;

  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content,
      width = params.width,
      height = params.height,
      transform = params.transform,
      title = params.title,
      extra = params.extra,
      _params$watchable2 = params.watchable,
      watchable = _params$watchable2 === void 0 ? false : _params$watchable2;

  var attributes = _objectSpread({}, extra.attributes, title ? {
    'title': title
  } : {}, {
    'class': extra.classes.join(' ')
  });

  if (watchable) {
    attributes[DATA_FA_I2SVG] = '';
  }

  var styles = _objectSpread({}, extra.styles);

  if (transformIsMeaningful(transform)) {
    styles['transform'] = transformForCss({
      transform: transform,
      startCentered: true,
      width: width,
      height: height
    });
    styles['-webkit-transform'] = styles['transform'];
  }

  var styleString = joinStyles(styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}
function makeLayersCounterAbstract(params) {
  var content = params.content,
      title = params.title,
      extra = params.extra;

  var attributes = _objectSpread({}, extra.attributes, title ? {
    'title': title
  } : {}, {
    'class': extra.classes.join(' ')
  });

  var styleString = joinStyles(extra.styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}

var noop$1 = function noop() {};

var p = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = "FA \"5.9.0\"";

var begin = function begin(name) {
  p.mark("".concat(preamble, " ").concat(name, " begins"));
  return function () {
    return end(name);
  };
};

var end = function end(name) {
  p.mark("".concat(preamble, " ").concat(name, " ends"));
  p.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};

var perf = {
  begin: begin,
  end: end
};

/**
 * Internal helper to bind a function known to have 4 arguments
 * to a given context.
 */

var bindInternal4 = function bindInternal4(func, thisContext) {
  return function (a, b, c, d) {
    return func.call(thisContext, a, b, c, d);
  };
};

/**
 * # Reduce
 *
 * A fast object `.reduce()` implementation.
 *
 * @param  {Object}   subject      The object to reduce over.
 * @param  {Function} fn           The reducer function.
 * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].
 * @param  {Object}   thisContext  The context for the reducer.
 * @return {mixed}                 The final result.
 */


var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject),
      length = keys.length,
      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,
      i,
      key,
      result;

  if (initialValue === undefined) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }

  for (; i < length; i++) {
    key = keys[i];
    result = iterator(result, subject[key], key, subject);
  }

  return result;
};

function toHex(unicode) {
  var result = '';

  for (var i = 0; i < unicode.length; i++) {
    var hex = unicode.charCodeAt(i).toString(16);
    result += ('000' + hex).slice(-4);
  }

  return result;
}

function defineIcons(prefix, icons) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks,
      skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = Object.keys(icons).reduce(function (acc, iconName) {
    var icon = icons[iconName];
    var expanded = !!icon.icon;

    if (expanded) {
      acc[icon.iconName] = icon.icon;
    } else {
      acc[iconName] = icon;
    }

    return acc;
  }, {});

  if (typeof namespace.hooks.addPack === 'function' && !skipHooks) {
    namespace.hooks.addPack(prefix, normalized);
  } else {
    namespace.styles[prefix] = _objectSpread({}, namespace.styles[prefix] || {}, normalized);
  }
  /**
   * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction
   * of new styles we needed to differentiate between them. Prefix `fa` is now an alias
   * for `fas` so we'll easy the upgrade process for our users by automatically defining
   * this as well.
   */


  if (prefix === 'fas') {
    defineIcons('fa', icons);
  }
}

var styles = namespace.styles,
    shims = namespace.shims;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var build = function build() {
  var lookup = function lookup(reducer) {
    return reduce(styles, function (o, style, prefix) {
      o[prefix] = reduce(style, reducer, {});
      return o;
    }, {});
  };

  _byUnicode = lookup(function (acc, icon, iconName) {
    if (icon[3]) {
      acc[icon[3]] = iconName;
    }

    return acc;
  });
  _byLigature = lookup(function (acc, icon, iconName) {
    var ligatures = icon[2];
    acc[iconName] = iconName;
    ligatures.forEach(function (ligature) {
      acc[ligature] = iconName;
    });
    return acc;
  });
  var hasRegular = 'far' in styles;
  _byOldName = reduce(shims, function (acc, shim) {
    var oldName = shim[0];
    var prefix = shim[1];
    var iconName = shim[2];

    if (prefix === 'far' && !hasRegular) {
      prefix = 'fas';
    }

    acc[oldName] = {
      prefix: prefix,
      iconName: iconName
    };
    return acc;
  }, {});
};
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}

var styles$1 = namespace.styles;
var emptyCanonicalIcon = function emptyCanonicalIcon() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalIcon(values) {
  return values.reduce(function (acc, cls) {
    var iconName = getIconName(config.familyPrefix, cls);

    if (styles$1[cls]) {
      acc.prefix = cls;
    } else if (config.autoFetchSvg && ['fas', 'far', 'fal', 'fab', 'fa'].indexOf(cls) > -1) {
      acc.prefix = cls;
    } else if (iconName) {
      var shim = acc.prefix === 'fa' ? byOldName(iconName) : {};
      acc.iconName = shim.iconName || iconName;
      acc.prefix = shim.prefix || acc.prefix;
    } else if (cls !== config.replacementClass && cls.indexOf('fa-w-') !== 0) {
      acc.rest.push(cls);
    }

    return acc;
  }, emptyCanonicalIcon());
}
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix: prefix,
      iconName: iconName,
      icon: mapping[prefix][iconName]
    };
  }
}

function toHtml(abstractNodes) {
  var tag = abstractNodes.tag,
      _abstractNodes$attrib = abstractNodes.attributes,
      attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib,
      _abstractNodes$childr = abstractNodes.children,
      children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;

  if (typeof abstractNodes === 'string') {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(''), "</").concat(tag, ">");
  }
}

var noop$2 = function noop() {};

function isWatched(node) {
  var i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === 'string';
}

function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }

  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}

var mutators = {
  replace: function replace(mutation) {
    var node = mutation[0];
    var abstract = mutation[1];
    var newOuterHTML = abstract.map(function (a) {
      return toHtml(a);
    }).join('\n');

    if (node.parentNode && node.outerHTML) {
      node.outerHTML = newOuterHTML + (config.keepOriginalSource && node.tagName.toLowerCase() !== 'svg' ? "<!-- ".concat(node.outerHTML, " -->") : '');
    } else if (node.parentNode) {
      var newNode = document.createElement('span');
      node.parentNode.replaceChild(newNode, node);
      newNode.outerHTML = newOuterHTML;
    }
  },
  nest: function nest(mutation) {
    var node = mutation[0];
    var abstract = mutation[1]; // If we already have a replaced node we do not want to continue nesting within it.
    // Short-circuit to the standard replacement

    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }

    var forSvg = new RegExp("".concat(config.familyPrefix, "-.*"));
    delete abstract[0].attributes.style;
    var splitClasses = abstract[0].attributes.class.split(' ').reduce(function (acc, cls) {
      if (cls === config.replacementClass || cls.match(forSvg)) {
        acc.toSvg.push(cls);
      } else {
        acc.toNode.push(cls);
      }

      return acc;
    }, {
      toNode: [],
      toSvg: []
    });
    abstract[0].attributes.class = splitClasses.toSvg.join(' ');
    var newInnerHTML = abstract.map(function (a) {
      return toHtml(a);
    }).join('\n');
    node.setAttribute('class', splitClasses.toNode.join(' '));
    node.setAttribute(DATA_FA_I2SVG, '');
    node.innerHTML = newInnerHTML;
  }
};

function performOperationSync(op) {
  op();
}

function perform(mutations, callback) {
  var callbackFunction = typeof callback === 'function' ? callback : noop$2;

  if (mutations.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;

    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }

    frame(function () {
      var mutator = getMutator();
      var mark = perf.begin('mutate');
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }

  if (!config.observeMutations) {
    return;
  }

  var treeCallback = options.treeCallback,
      nodeCallback = options.nodeCallback,
      pseudoElementsCallback = options.pseudoElementsCallback,
      _options$observeMutat = options.observeMutationsRoot,
      observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function (objects) {
    if (disabled) return;
    toArray(objects).forEach(function (mutationRecord) {
      if (mutationRecord.type === 'childList' && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }

        treeCallback(mutationRecord.target);
      }

      if (mutationRecord.type === 'attributes' && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }

      if (mutationRecord.type === 'attributes' && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === 'class') {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)),
              prefix = _getCanonicalIcon.prefix,
              iconName = _getCanonicalIcon.iconName;

          if (prefix) mutationRecord.target.setAttribute('data-prefix', prefix);
          if (iconName) mutationRecord.target.setAttribute('data-icon', iconName);
        } else {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo) return;
  mo.disconnect();
}

function styleParser (node) {
  var style = node.getAttribute('style');
  var val = [];

  if (style) {
    val = style.split(';').reduce(function (acc, style) {
      var styles = style.split(':');
      var prop = styles[0];
      var value = styles.slice(1);

      if (prop && value.length > 0) {
        acc[prop] = value.join(':').trim();
      }

      return acc;
    }, {});
  }

  return val;
}

function classParser (node) {
  var existingPrefix = node.getAttribute('data-prefix');
  var existingIconName = node.getAttribute('data-icon');
  var innerText = node.innerText !== undefined ? node.innerText.trim() : '';
  var val = getCanonicalIcon(classArray(node));

  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }

  if (val.prefix && innerText.length > 1) {
    val.iconName = byLigature(val.prefix, node.innerText);
  } else if (val.prefix && innerText.length === 1) {
    val.iconName = byUnicode(val.prefix, toHex(node.innerText));
  }

  return val;
}

var parseTransformString = function parseTransformString(transformString) {
  var transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };

  if (!transformString) {
    return transform;
  } else {
    return transformString.toLowerCase().split(' ').reduce(function (acc, n) {
      var parts = n.toLowerCase().split('-');
      var first = parts[0];
      var rest = parts.slice(1).join('-');

      if (first && rest === 'h') {
        acc.flipX = true;
        return acc;
      }

      if (first && rest === 'v') {
        acc.flipY = true;
        return acc;
      }

      rest = parseFloat(rest);

      if (isNaN(rest)) {
        return acc;
      }

      switch (first) {
        case 'grow':
          acc.size = acc.size + rest;
          break;

        case 'shrink':
          acc.size = acc.size - rest;
          break;

        case 'left':
          acc.x = acc.x - rest;
          break;

        case 'right':
          acc.x = acc.x + rest;
          break;

        case 'up':
          acc.y = acc.y - rest;
          break;

        case 'down':
          acc.y = acc.y + rest;
          break;

        case 'rotate':
          acc.rotate = acc.rotate + rest;
          break;
      }

      return acc;
    }, transform);
  }
};
function transformParser (node) {
  return parseTransformString(node.getAttribute('data-fa-transform'));
}

function symbolParser (node) {
  var symbol = node.getAttribute('data-fa-symbol');
  return symbol === null ? false : symbol === '' ? true : symbol;
}

function attributesParser (node) {
  var extraAttributes = toArray(node.attributes).reduce(function (acc, attr) {
    if (acc.name !== 'class' && acc.name !== 'style') {
      acc[attr.name] = attr.value;
    }

    return acc;
  }, {});
  var title = node.getAttribute('title');

  if (config.autoA11y) {
    if (title) {
      extraAttributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(nextUniqueId());
    } else {
      extraAttributes['aria-hidden'] = 'true';
      extraAttributes['focusable'] = 'false';
    }
  }

  return extraAttributes;
}

function maskParser (node) {
  var mask = node.getAttribute('data-fa-mask');

  if (!mask) {
    return emptyCanonicalIcon();
  } else {
    return getCanonicalIcon(mask.split(' ').map(function (i) {
      return i.trim();
    }));
  }
}

function blankMeta() {
  return {
    iconName: null,
    title: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  var _classParser = classParser(node),
      iconName = _classParser.iconName,
      prefix = _classParser.prefix,
      extraClasses = _classParser.rest;

  var extraStyles = styleParser(node);
  var transform = transformParser(node);
  var symbol = symbolParser(node);
  var extraAttributes = attributesParser(node);
  var mask = maskParser(node);
  return {
    iconName: iconName,
    title: node.getAttribute('title'),
    prefix: prefix,
    transform: transform,
    symbol: symbol,
    mask: mask,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  };
}

function MissingIcon(error) {
  this.name = 'MissingIcon';
  this.message = error || 'Icon unavailable';
  this.stack = new Error().stack;
}
MissingIcon.prototype = Object.create(Error.prototype);
MissingIcon.prototype.constructor = MissingIcon;

var FILL = {
  fill: 'currentColor'
};
var ANIMATION_BASE = {
  attributeType: 'XML',
  repeatCount: 'indefinite',
  dur: '2s'
};
var RING = {
  tag: 'path',
  attributes: _objectSpread({}, FILL, {
    d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
  })
};

var OPACITY_ANIMATE = _objectSpread({}, ANIMATION_BASE, {
  attributeName: 'opacity'
});

var DOT = {
  tag: 'circle',
  attributes: _objectSpread({}, FILL, {
    cx: '256',
    cy: '364',
    r: '28'
  }),
  children: [{
    tag: 'animate',
    attributes: _objectSpread({}, ANIMATION_BASE, {
      attributeName: 'r',
      values: '28;14;28;28;14;28;'
    })
  }, {
    tag: 'animate',
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: '1;0;1;1;0;1;'
    })
  }]
};
var QUESTION = {
  tag: 'path',
  attributes: _objectSpread({}, FILL, {
    opacity: '1',
    d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
  }),
  children: [{
    tag: 'animate',
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: '1;0;0;0;0;1;'
    })
  }]
};
var EXCLAMATION = {
  tag: 'path',
  attributes: _objectSpread({}, FILL, {
    opacity: '0',
    d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
  }),
  children: [{
    tag: 'animate',
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: '0;0;1;1;0;0;'
    })
  }]
};
var missing = {
  tag: 'g',
  children: [RING, DOT, QUESTION, EXCLAMATION]
};

var styles$2 = namespace.styles;
function findIcon(iconName, prefix) {
  return new picked(function (resolve, reject) {
    var val = {
      found: false,
      width: 512,
      height: 512,
      icon: missing
    };

    if (iconName && prefix && styles$2[prefix] && styles$2[prefix][iconName]) {
      var icon = styles$2[prefix][iconName];
      var width = icon[0];
      var height = icon[1];
      var vectorData = icon.slice(4);
      val = {
        found: true,
        width: width,
        height: height,
        icon: {
          tag: 'path',
          attributes: {
            fill: 'currentColor',
            d: vectorData[0]
          }
        }
      };
      return resolve(val);
    }

    if (iconName && prefix && !config.showMissingIcons) {
      reject(new MissingIcon("Icon is missing for prefix ".concat(prefix, " with icon name ").concat(iconName)));
    } else {
      resolve(val);
    }
  });
}

var styles$3 = namespace.styles;

function generateSvgReplacementMutation(node, nodeMeta) {
  var iconName = nodeMeta.iconName,
      title = nodeMeta.title,
      prefix = nodeMeta.prefix,
      transform = nodeMeta.transform,
      symbol = nodeMeta.symbol,
      mask = nodeMeta.mask,
      extra = nodeMeta.extra;
  return new picked(function (resolve, reject) {
    picked.all([findIcon(iconName, prefix), findIcon(mask.iconName, mask.prefix)]).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          main = _ref2[0],
          mask = _ref2[1];

      resolve([node, makeInlineSvgAbstract({
        icons: {
          main: main,
          mask: mask
        },
        prefix: prefix,
        iconName: iconName,
        transform: transform,
        symbol: symbol,
        mask: mask,
        title: title,
        extra: extra,
        watchable: true
      })]);
    });
  });
}

function generateLayersText(node, nodeMeta) {
  var title = nodeMeta.title,
      transform = nodeMeta.transform,
      extra = nodeMeta.extra;
  var width = null;
  var height = null;

  if (IS_IE) {
    var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
    var boundingClientRect = node.getBoundingClientRect();
    width = boundingClientRect.width / computedFontSize;
    height = boundingClientRect.height / computedFontSize;
  }

  if (config.autoA11y && !title) {
    extra.attributes['aria-hidden'] = 'true';
  }

  return picked.resolve([node, makeLayersTextAbstract({
    content: node.innerHTML,
    width: width,
    height: height,
    transform: transform,
    title: title,
    extra: extra,
    watchable: true
  })]);
}

function generateMutation(node) {
  var nodeMeta = parseMeta(node);

  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return generateLayersText(node, nodeMeta);
  } else {
    return generateSvgReplacementMutation(node, nodeMeta);
  }
}

function onTree(root) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!IS_DOM) return;
  var htmlClassList = DOCUMENT.documentElement.classList;

  var hclAdd = function hclAdd(suffix) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var hclRemove = function hclRemove(suffix) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var prefixes = config.autoFetchSvg ? Object.keys(PREFIX_TO_STYLE) : Object.keys(styles$3);
  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map(function (p) {
    return ".".concat(p, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(', ');

  if (prefixesDomQuery.length === 0) {
    return;
  }

  var candidates = [];

  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e) {// noop
  }

  if (candidates.length > 0) {
    hclAdd('pending');
    hclRemove('complete');
  } else {
    return;
  }

  var mark = perf.begin('onTree');
  var mutations = candidates.reduce(function (acc, node) {
    try {
      var mutation = generateMutation(node);

      if (mutation) {
        acc.push(mutation);
      }
    } catch (e) {
      if (!PRODUCTION) {
        if (e instanceof MissingIcon) {
          console.error(e);
        }
      }
    }

    return acc;
  }, []);
  return new picked(function (resolve, reject) {
    picked.all(mutations).then(function (resolvedMutations) {
      perform(resolvedMutations, function () {
        hclAdd('active');
        hclAdd('complete');
        hclRemove('pending');
        if (typeof callback === 'function') callback();
        mark();
        resolve();
      });
    }).catch(function () {
      mark();
      reject();
    });
  });
}
function onNode(node) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  generateMutation(node).then(function (mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}

function replaceForPosition(node, position) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(':', '-'));
  return new picked(function (resolve, reject) {
    if (node.getAttribute(pendingAttribute) !== null) {
      // This node is already being processed
      return resolve();
    }

    var children = toArray(node.children);
    var alreadyProcessedPseudoElement = children.filter(function (c) {
      return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
    })[0];
    var styles = WINDOW.getComputedStyle(node, position);
    var fontFamily = styles.getPropertyValue('font-family').match(FONT_FAMILY_PATTERN);
    var fontWeight = styles.getPropertyValue('font-weight');

    if (alreadyProcessedPseudoElement && !fontFamily) {
      // If we've already processed it but the current computed style does not result in a font-family,
      // that probably means that a class name that was previously present to make the icon has been
      // removed. So we now should delete the icon.
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamily) {
      var content = styles.getPropertyValue('content');
      var prefix = ~['Light', 'Regular', 'Solid', 'Brands'].indexOf(fontFamily[1]) ? STYLE_TO_PREFIX[fontFamily[1].toLowerCase()] : FONT_WEIGHT_TO_PREFIX[fontWeight];
      var hexValue = toHex(content.length === 3 ? content.substr(1, 1) : content);
      var iconName = byUnicode(prefix, hexValue);
      var iconIdentifier = iconName; // Only convert the pseudo element in this :before/:after position into an icon if we haven't
      // already done so with the same prefix and iconName

      if (iconName && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);

        if (alreadyProcessedPseudoElement) {
          // Delete the old one, since we're replacing it with a new one
          node.removeChild(alreadyProcessedPseudoElement);
        }

        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then(function (main) {
          var abstract = makeInlineSvgAbstract(_objectSpread({}, meta, {
            icons: {
              main: main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix,
            iconName: iconIdentifier,
            extra: extra,
            watchable: true
          }));
          var element = DOCUMENT.createElement('svg');

          if (position === ':before') {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }

          element.outerHTML = abstract.map(function (a) {
            return toHtml(a);
          }).join('\n');
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}

function replace(node) {
  return picked.all([replaceForPosition(node, ':before'), replaceForPosition(node, ':after')]);
}

function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== 'svg');
}

function searchPseudoElements (root) {
  if (!IS_DOM) return;
  return new picked(function (resolve, reject) {
    var operations = toArray(root.querySelectorAll('*')).filter(processable).map(replace);
    var end = perf.begin('searchPseudoElements');
    disableObservation();
    picked.all(operations).then(function () {
      end();
      enableObservation();
      resolve();
    }).catch(function () {
      end();
      enableObservation();
      reject();
    });
  });
}

var baseStyles = "svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}";

function css () {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc = config.replacementClass;
  var s = baseStyles;

  if (fp !== dfp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), 'g');
    var rPatt = new RegExp("\\.".concat(drc), 'g');
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }

  return s;
}

var Library =
/*#__PURE__*/
function () {
  function Library() {
    _classCallCheck(this, Library);

    this.definitions = {};
  }

  _createClass(Library, [{
    key: "add",
    value: function add() {
      var _this = this;

      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }

      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function (key) {
        _this.definitions[key] = _objectSpread({}, _this.definitions[key] || {}, additions[key]);
        defineIcons(key, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function (key) {
        var _normalized$key = normalized[key],
            prefix = _normalized$key.prefix,
            iconName = _normalized$key.iconName,
            icon = _normalized$key.icon;
        if (!additions[prefix]) additions[prefix] = {};
        additions[prefix][iconName] = icon;
      });
      return additions;
    }
  }]);

  return Library;
}();

function prepIcon(icon) {
  var width = icon[0];
  var height = icon[1];
  var vectorData = icon.slice(4);
  return {
    found: true,
    width: width,
    height: height,
    icon: {
      tag: 'path',
      attributes: {
        fill: 'currentColor',
        d: vectorData[0]
      }
    }
  };
}

function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());

    _cssInserted = true;
  }
}

function apiObject(val, abstractCreator) {
  Object.defineProperty(val, 'abstract', {
    get: abstractCreator
  });
  Object.defineProperty(val, 'html', {
    get: function get() {
      return val.abstract.map(function (a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, 'node', {
    get: function get() {
      if (!IS_DOM) return;
      var container = DOCUMENT.createElement('div');
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}

function findIconDefinition(iconLookup) {
  var _iconLookup$prefix = iconLookup.prefix,
      prefix = _iconLookup$prefix === void 0 ? 'fa' : _iconLookup$prefix,
      iconName = iconLookup.iconName;
  if (!iconName) return;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}

function resolveIcons(next) {
  return function (maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;

    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }

    return next(iconDefinition, _objectSpread({}, params, {
      mask: mask
    }));
  };
}

var library = new Library();
var noAuto = function noAuto() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  disconnect();
};
var _cssInserted = false;
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (IS_DOM) {
      ensureCss();
      var _params$node = params.node,
          node = _params$node === void 0 ? DOCUMENT : _params$node,
          _params$callback = params.callback,
          callback = _params$callback === void 0 ? function () {} : _params$callback;

      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }

      return onTree(node, callback);
    } else {
      return picked.reject('Operation requires a DOM of some kind.');
    }
  },
  css: css,
  insertCss: function insertCss$$1() {
    if (!_cssInserted) {
      insertCss(css());

      _cssInserted = true;
    }
  },
  watch: function watch() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot,
        observeMutationsRoot = params.observeMutationsRoot;

    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }

    config.observeMutations = true;
    domready(function () {
      autoReplace({
        autoReplaceSvgRoot: autoReplaceSvgRoot
      });
      observe({
        treeCallback: onTree,
        nodeCallback: onNode,
        pseudoElementsCallback: searchPseudoElements,
        observeMutationsRoot: observeMutationsRoot
      });
    });
  }
};
var parse = {
  transform: function transform(transformString) {
    return parseTransformString(transformString);
  }
};
var icon = resolveIcons(function (iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$transform = params.transform,
      transform = _params$transform === void 0 ? meaninglessTransform : _params$transform,
      _params$symbol = params.symbol,
      symbol = _params$symbol === void 0 ? false : _params$symbol,
      _params$mask = params.mask,
      mask = _params$mask === void 0 ? null : _params$mask,
      _params$title = params.title,
      title = _params$title === void 0 ? null : _params$title,
      _params$classes = params.classes,
      classes = _params$classes === void 0 ? [] : _params$classes,
      _params$attributes = params.attributes,
      attributes = _params$attributes === void 0 ? {} : _params$attributes,
      _params$styles = params.styles,
      styles = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix = iconDefinition.prefix,
      iconName = iconDefinition.iconName,
      icon = iconDefinition.icon;
  return apiObject(_objectSpread({
    type: 'icon'
  }, iconDefinition), function () {
    ensureCss();

    if (config.autoA11y) {
      if (title) {
        attributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(nextUniqueId());
      } else {
        attributes['aria-hidden'] = 'true';
        attributes['focusable'] = 'false';
      }
    }

    return makeInlineSvgAbstract({
      icons: {
        main: prepIcon(icon),
        mask: mask ? prepIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix,
      iconName: iconName,
      transform: _objectSpread({}, meaninglessTransform, transform),
      symbol: symbol,
      title: title,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: classes
      }
    });
  });
});
var text = function text(content) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$transform2 = params.transform,
      transform = _params$transform2 === void 0 ? meaninglessTransform : _params$transform2,
      _params$title2 = params.title,
      title = _params$title2 === void 0 ? null : _params$title2,
      _params$classes2 = params.classes,
      classes = _params$classes2 === void 0 ? [] : _params$classes2,
      _params$attributes2 = params.attributes,
      attributes = _params$attributes2 === void 0 ? {} : _params$attributes2,
      _params$styles2 = params.styles,
      styles = _params$styles2 === void 0 ? {} : _params$styles2;
  return apiObject({
    type: 'text',
    content: content
  }, function () {
    ensureCss();
    return makeLayersTextAbstract({
      content: content,
      transform: _objectSpread({}, meaninglessTransform, transform),
      title: title,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: ["".concat(config.familyPrefix, "-layers-text")].concat(_toConsumableArray(classes))
      }
    });
  });
};
var counter = function counter(content) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$title3 = params.title,
      title = _params$title3 === void 0 ? null : _params$title3,
      _params$classes3 = params.classes,
      classes = _params$classes3 === void 0 ? [] : _params$classes3,
      _params$attributes3 = params.attributes,
      attributes = _params$attributes3 === void 0 ? {} : _params$attributes3,
      _params$styles3 = params.styles,
      styles = _params$styles3 === void 0 ? {} : _params$styles3;
  return apiObject({
    type: 'counter',
    content: content
  }, function () {
    ensureCss();
    return makeLayersCounterAbstract({
      content: content.toString(),
      title: title,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: ["".concat(config.familyPrefix, "-layers-counter")].concat(_toConsumableArray(classes))
      }
    });
  });
};
var layer = function layer(assembler) {
  return apiObject({
    type: 'layer'
  }, function () {
    ensureCss();
    var children = [];
    assembler(function (args) {
      Array.isArray(args) ? args.map(function (a) {
        children = children.concat(a.abstract);
      }) : children = children.concat(args.abstract);
    });
    return [{
      tag: 'span',
      attributes: {
        class: "".concat(config.familyPrefix, "-layers")
      },
      children: children
    }];
  });
};
var api = {
  noAuto: noAuto,
  config: config,
  dom: dom,
  library: library,
  parse: parse,
  findIconDefinition: findIconDefinition,
  icon: icon,
  text: text,
  counter: counter,
  layer: layer,
  toHtml: toHtml
};

var autoReplace = function autoReplace() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot,
      autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebook.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faFacebook.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'facebook';
var width = 512;
var height = 512;
var ligatures = [];
var unicode = 'f09a';
var svgPathData = 'M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faFacebook = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebookF.js":
/*!************************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faFacebookF.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'facebook-f';
var width = 320;
var height = 512;
var ligatures = [];
var unicode = 'f39e';
var svgPathData = 'M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faFacebookF = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faInstagram.js":
/*!************************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faInstagram.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'instagram';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f16d';
var svgPathData = 'M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faInstagram = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faLinkedin.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'linkedin';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f08c';
var svgPathData = 'M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faLinkedin = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedinIn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faLinkedinIn.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'linkedin-in';
var width = 448;
var height = 512;
var ligatures = [];
var unicode = 'f0e1';
var svgPathData = 'M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faLinkedinIn = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/@fortawesome/free-brands-svg-icons/faTwitter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fortawesome/free-brands-svg-icons/faTwitter.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, '__esModule', { value: true });
var prefix = 'fab';
var iconName = 'twitter';
var width = 512;
var height = 512;
var ligatures = [];
var unicode = 'f099';
var svgPathData = 'M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z';

exports.definition = {
  prefix: prefix,
  iconName: iconName,
  icon: [
    width,
    height,
    ligatures,
    unicode,
    svgPathData
  ]};

exports.faTwitter = exports.definition;
exports.prefix = prefix;
exports.iconName = iconName;
exports.width = width;
exports.height = height;
exports.ligatures = ligatures;
exports.unicode = unicode;
exports.svgPathData = svgPathData;

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/js/bundle.js":
/*!**************************!*\
  !*** ./src/js/bundle.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modernizr_custom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modernizr-custom */ "./src/js/modernizr-custom.js");
/* harmony import */ var _modernizr_custom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modernizr_custom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rarebird_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rarebird-includes */ "./src/js/rarebird-includes.js");
/* harmony import */ var _rarebird_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rarebird_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _navigation_dropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./navigation-dropdown */ "./src/js/navigation-dropdown.js");
/* harmony import */ var _navigation_dropdown__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_navigation_dropdown__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _icons_import__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icons-import */ "./src/js/icons-import.js");





/***/ }),

/***/ "./src/js/icons-import.js":
/*!********************************!*\
  !*** ./src/js/icons-import.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fortawesome/fontawesome-svg-core */ "./node_modules/@fortawesome/fontawesome-svg-core/index.es.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faFacebookF */ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebookF.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faFacebook */ "./node_modules/@fortawesome/free-brands-svg-icons/faFacebook.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faTwitter */ "./node_modules/@fortawesome/free-brands-svg-icons/faTwitter.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faInstagram */ "./node_modules/@fortawesome/free-brands-svg-icons/faInstagram.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faLinkedin */ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedin.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @fortawesome/free-brands-svg-icons/faLinkedinIn */ "./node_modules/@fortawesome/free-brands-svg-icons/faLinkedinIn.js");
/* harmony import */ var _fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6__);
//
// Icons import file
// --------------------------------------------------
// Uses Font Awesome 5 icons + API:
// https://fontawesome.com/how-to-use/on-the-web/advanced/svg-javascript-core
// https://fontawesome.com/how-to-use/with-the-api/setup/getting-started
// --------------------------------------------------
// 
// --------------------------------------------------
// Gulp is used to command Rollup to turn this import
// file in to a rendered, tree-shaken file, that only
// includes the icons desired.
// --------------------------------------------------
// [Step 1] Import desired icons...
// ---------------------------------------
// First, import the library and DOM manipulation utilities
 // Add the icons you want to use here, AND include them in the Library .add() function below
// Common Brands _________



 // import { faPinterest } from '@fortawesome/free-brands-svg-icons';



 // import { faYoutube } from '@fortawesome/free-brands-svg-icons';
// Demo: Light, Solid, and Regular versions of the same icon _________
// import { faEnvelope as falEnvelope } from '@fortawesome/pro-light-svg-icons';
// import { faEnvelope as fasEnvelope } from '@fortawesome/pro-solid-svg-icons';
// import { faEnvelope as farEnvelope } from '@fortawesome/pro-regular-svg-icons';
// Common Icons that RB uses on sites _________
// import { faEnvelope } from '@fortawesome/pro-regular-svg-icons';
// import { faFilter } from '@fortawesome/pro-regular-svg-icons';
// import { faFilePdf } from '@fortawesome/pro-regular-svg-icons';
// import { faExclamationTriangle } from '@fortawesome/pro-regular-svg-icons';
// import { faInfoCircle } from '@fortawesome/pro-regular-svg-icons';
// import { faLink } from '@fortawesome/pro-regular-svg-icons';
// import { faSearch } from '@fortawesome/pro-regular-svg-icons';
// import { faPrint } from '@fortawesome/pro-regular-svg-icons';
// import { faPlus } from '@fortawesome/pro-regular-svg-icons';
// import { faMinus } from '@fortawesome/pro-regular-svg-icons';
// import { faTimes } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronUp } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronRight } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronDown } from '@fortawesome/pro-regular-svg-icons';
// import { faChevronLeft } from '@fortawesome/pro-regular-svg-icons';
// [Step 2] Add desired icons to library
// ---------------------------------------

_fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__["library"].add( // faEnvelope,
_fortawesome_free_brands_svg_icons_faFacebookF__WEBPACK_IMPORTED_MODULE_1__["faFacebookF"], _fortawesome_free_brands_svg_icons_faFacebook__WEBPACK_IMPORTED_MODULE_2__["faFacebook"], _fortawesome_free_brands_svg_icons_faTwitter__WEBPACK_IMPORTED_MODULE_3__["faTwitter"], // faPinterest,
_fortawesome_free_brands_svg_icons_faInstagram__WEBPACK_IMPORTED_MODULE_4__["faInstagram"], _fortawesome_free_brands_svg_icons_faLinkedin__WEBPACK_IMPORTED_MODULE_5__["faLinkedin"], _fortawesome_free_brands_svg_icons_faLinkedinIn__WEBPACK_IMPORTED_MODULE_6__["faLinkedinIn"] // faYoutube,
// falEnvelope,
// fasEnvelope,
// farEnvelope,
// faFilter,
// faFilePdf,
// faExclamationTriangle,
// faInfoCircle,
// faLink,
// faSearch,
// faPrint,
// faPlus,
// faMinus,
// faTimes,
// faChevronUp,
// faChevronRight,
// faChevronDown,
// faChevronLeft,
); // Replace any existing <i> tags with <svg> and set up a MutationObserver to
// continue doing this as the DOM changes.
// ---------------------------------------

_fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__["dom"].watch();

/***/ }),

/***/ "./src/js/modernizr-custom.js":
/*!************************************!*\
  !*** ./src/js/modernizr-custom.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! modernizr 3.6.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-backdropfilter-backgroundcliptext-cssfilters-cssgrid_cssgridlegacy-csspositionsticky-picture-domprefixes-prefixed-prefixes-setclasses-testallprops-testprop-teststyles-cssclassprefix:mod- !*/
!function (e, t, n) {
  function r(e, t) {
    return _typeof(e) === t;
  }

  function s() {
    var e, t, n, s, o, i, l;

    for (var a in S) {
      if (S.hasOwnProperty(a)) {
        if (e = [], t = S[a], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) {
          e.push(t.options.aliases[n].toLowerCase());
        }

        for (s = r(t.fn, "function") ? t.fn() : t.fn, o = 0; o < e.length; o++) {
          i = e[o], l = i.split("."), 1 === l.length ? Modernizr[l[0]] = s : (!Modernizr[l[0]] || Modernizr[l[0]] instanceof Boolean || (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])), Modernizr[l[0]][l[1]] = s), C.push((s ? "" : "no-") + l.join("-"));
        }
      }
    }
  }

  function o(e) {
    var t = w.className,
        n = Modernizr._config.classPrefix || "";

    if (b && (t = t.baseVal), Modernizr._config.enableJSClass) {
      var r = new RegExp("(^|\\s)" + n + "no-js(\\s|$)");
      t = t.replace(r, "$1" + n + "js$2");
    }

    Modernizr._config.enableClasses && (t += " " + n + e.join(" " + n), b ? w.className.baseVal = t : w.className = t);
  }

  function i(e) {
    return e.replace(/([a-z])-([a-z])/g, function (e, t, n) {
      return t + n.toUpperCase();
    }).replace(/^-/, "");
  }

  function l() {
    return "function" != typeof t.createElement ? t.createElement(arguments[0]) : b ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments);
  }

  function a(e, t) {
    return !!~("" + e).indexOf(t);
  }

  function u() {
    var e = t.body;
    return e || (e = l(b ? "svg" : "body"), e.fake = !0), e;
  }

  function f(e, n, r, s) {
    var o,
        i,
        a,
        f,
        d = "modernizr",
        p = l("div"),
        c = u();
    if (parseInt(r, 10)) for (; r--;) {
      a = l("div"), a.id = s ? s[r] : d + (r + 1), p.appendChild(a);
    }
    return o = l("style"), o.type = "text/css", o.id = "s" + d, (c.fake ? c : p).appendChild(o), c.appendChild(p), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(t.createTextNode(e)), p.id = d, c.fake && (c.style.background = "", c.style.overflow = "hidden", f = w.style.overflow, w.style.overflow = "hidden", w.appendChild(c)), i = n(p, e), c.fake ? (c.parentNode.removeChild(c), w.style.overflow = f, w.offsetHeight) : p.parentNode.removeChild(p), !!i;
  }

  function d(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  }

  function p(e, t, n) {
    var s;

    for (var o in e) {
      if (e[o] in t) return n === !1 ? e[o] : (s = t[e[o]], r(s, "function") ? d(s, n || t) : s);
    }

    return !1;
  }

  function c(e) {
    return e.replace(/([A-Z])/g, function (e, t) {
      return "-" + t.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }

  function m(t, n, r) {
    var s;

    if ("getComputedStyle" in e) {
      s = getComputedStyle.call(e, t, n);
      var o = e.console;
      if (null !== s) r && (s = s.getPropertyValue(r));else if (o) {
        var i = o.error ? "error" : "log";
        o[i].call(o, "getComputedStyle returning null, its possible modernizr test results are inaccurate");
      }
    } else s = !n && t.currentStyle && t.currentStyle[r];

    return s;
  }

  function g(t, r) {
    var s = t.length;

    if ("CSS" in e && "supports" in e.CSS) {
      for (; s--;) {
        if (e.CSS.supports(c(t[s]), r)) return !0;
      }

      return !1;
    }

    if ("CSSSupportsRule" in e) {
      for (var o = []; s--;) {
        o.push("(" + c(t[s]) + ":" + r + ")");
      }

      return o = o.join(" or "), f("@supports (" + o + ") { #modernizr { position: absolute; } }", function (e) {
        return "absolute" == m(e, null, "position");
      });
    }

    return n;
  }

  function y(e, t, s, o) {
    function u() {
      d && (delete L.style, delete L.modElem);
    }

    if (o = r(o, "undefined") ? !1 : o, !r(s, "undefined")) {
      var f = g(e, s);
      if (!r(f, "undefined")) return f;
    }

    for (var d, p, c, m, y, v = ["modernizr", "tspan", "samp"]; !L.style && v.length;) {
      d = !0, L.modElem = l(v.shift()), L.style = L.modElem.style;
    }

    for (c = e.length, p = 0; c > p; p++) {
      if (m = e[p], y = L.style[m], a(m, "-") && (m = i(m)), L.style[m] !== n) {
        if (o || r(s, "undefined")) return u(), "pfx" == t ? m : !0;

        try {
          L.style[m] = s;
        } catch (h) {}

        if (L.style[m] != y) return u(), "pfx" == t ? m : !0;
      }
    }

    return u(), !1;
  }

  function v(e, t, n, s, o) {
    var i = e.charAt(0).toUpperCase() + e.slice(1),
        l = (e + " " + z.join(i + " ") + i).split(" ");
    return r(t, "string") || r(t, "undefined") ? y(l, t, s, o) : (l = (e + " " + P.join(i + " ") + i).split(" "), p(l, t, n));
  }

  function h(e, t, r) {
    return v(e, n, n, t, r);
  }

  var C = [],
      S = [],
      x = {
    _version: "3.6.0",
    _config: {
      classPrefix: "mod-",
      enableClasses: !0,
      enableJSClass: !0,
      usePrefixes: !0
    },
    _q: [],
    on: function on(e, t) {
      var n = this;
      setTimeout(function () {
        t(n[e]);
      }, 0);
    },
    addTest: function addTest(e, t, n) {
      S.push({
        name: e,
        fn: t,
        options: n
      });
    },
    addAsyncTest: function addAsyncTest(e) {
      S.push({
        name: null,
        fn: e
      });
    }
  },
      Modernizr = function Modernizr() {};

  Modernizr.prototype = x, Modernizr = new Modernizr(), Modernizr.addTest("picture", "HTMLPictureElement" in e);

  var _ = x._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];

  x._prefixes = _;
  var w = t.documentElement,
      b = "svg" === w.nodeName.toLowerCase(),
      T = "Moz O ms Webkit",
      P = x._config.usePrefixes ? T.toLowerCase().split(" ") : [];
  x._domPrefixes = P, Modernizr.addTest("csspositionsticky", function () {
    var e = "position:",
        t = "sticky",
        n = l("a"),
        r = n.style;
    return r.cssText = e + _.join(t + ";" + e).slice(0, -e.length), -1 !== r.position.indexOf(t);
  });
  var k = "CSS" in e && "supports" in e.CSS,
      E = "supportsCSS" in e;
  Modernizr.addTest("supports", k || E);
  var z = x._config.usePrefixes ? T.split(" ") : [];
  x._cssomPrefixes = z;

  var j = function j(t) {
    var r,
        s = _.length,
        o = e.CSSRule;
    if ("undefined" == typeof o) return n;
    if (!t) return !1;
    if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in o) return "@" + t;

    for (var i = 0; s > i; i++) {
      var l = _[i],
          a = l.toUpperCase() + "_" + r;
      if (a in o) return "@-" + l.toLowerCase() + "-" + t;
    }

    return !1;
  };

  x.atRule = j;
  var N = (x.testStyles = f, {
    elem: l("modernizr")
  });

  Modernizr._q.push(function () {
    delete N.elem;
  });

  var L = {
    style: N.elem.style
  };

  Modernizr._q.unshift(function () {
    delete L.style;
  });

  x.testProp = function (e, t, r) {
    return y([e], n, t, r);
  };

  x.testAllProps = v;

  x.prefixed = function (e, t, n) {
    return 0 === e.indexOf("@") ? j(e) : (-1 != e.indexOf("-") && (e = i(e)), t ? v(e, t, n) : v(e, "pfx"));
  };

  x.testAllProps = h, Modernizr.addTest("backdropfilter", h("backdropFilter")), Modernizr.addTest("backgroundcliptext", function () {
    return h("backgroundClip", "text");
  }), Modernizr.addTest("cssgridlegacy", h("grid-columns", "10px", !0)), Modernizr.addTest("cssgrid", h("grid-template-rows", "none", !0)), Modernizr.addTest("cssfilters", function () {
    if (Modernizr.supports) return h("filter", "blur(2px)");
    var e = l("a");
    return e.style.cssText = _.join("filter:blur(2px); "), !!e.style.length && (t.documentMode === n || t.documentMode > 9);
  }), s(), o(C), delete x.addTest, delete x.addAsyncTest;

  for (var O = 0; O < Modernizr._q.length; O++) {
    Modernizr._q[O]();
  }

  e.Modernizr = Modernizr;
}(window, document);

/***/ }),

/***/ "./src/js/navigation-dropdown.js":
/*!***************************************!*\
  !*** ./src/js/navigation-dropdown.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

jQuery(document).ready(function () {
  $(".main-navigation .menu-item-has-children").on('mouseenter mouseleave', function (e) {
    if ($('ul', this).length) {
      var elm = $('ul:first', this);
      var off = elm.offset();
      var l = off.left;
      var w = elm.width();
      var docH = $(".main-navigation").height();
      var docW = $(".main-navigation").width();
      var isEntirelyVisible = l + w <= docW;

      if (!isEntirelyVisible) {
        $(this).addClass('edge');
      } else {
        $(this).removeClass('edge');
      }
    }
  });
});

/***/ }),

/***/ "./src/js/rarebird-includes.js":
/*!*************************************!*\
  !*** ./src/js/rarebird-includes.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//
// Compiled Site Scripts
// ----------------------------------------------------------------------------
// Warning: Global.js is a COMPILED file! Edit a source file, or create a new
// one. See gulpfile.js!
//
//  #######
//     #    #    # #  ####      #  ####        ##
//     #    #    # # #          # #           #  #
//     #    ###### #  ####      #  ####      #    #
//     #    #    # #      #     #      #     ######
//     #    #    # # #    #     # #    #     #    #
//     #    #    # #  ####      #  ####      #    #
//  #####  ####### #     # ######  ### #       ####### ######
// #     # #     # ##   ## #     #  #  #       #       #     #
// #       #     # # # # # #     #  #  #       #       #     #
// #       #     # #  #  # ######   #  #       #####   #     #
// #       #     # #     # #        #  #       #       #     #
// #     # #     # #     # #        #  #       #       #     #
//  #####  ####### #     # #       ### ####### ####### ######
//
// ####### ### #       #######
// #        #  #       #
// #        #  #       #
// #####    #  #       #####
// #        #  #       #
// #        #  #       #
// #       ### ####### #######
//
// Warning: Global.js is a COMPILED file! Edit a source file, or create a new
// one. See gulpfile.babel.js!
// ----------------------------------------------------------------------------
//
// Polyfill for using forEach() on NodeLists
// --------------------------------------------------
// Adds support for IE 11 without calling in a 
// Babel dumptruck.
// --------------------------------------------------
// via https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#Polyfill
// --------------------------------------------------
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = function (callback, thisArg) {
    thisArg = thisArg || window;

    for (var i = 0; i < this.length; i++) {
      callback.call(thisArg, this[i], i, this);
    }
  };
}
/* ========================================================================
 * Bootstrap: transition.js v3.4.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict'; // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap');
    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    };

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return {
          end: transEndEventNames[name]
        };
      }
    }

    return false; // explicit for ie8 (  ._.)
  } // http://blog.alexmaccaw.com/css-transitions


  $.fn.emulateTransitionEnd = function (duration) {
    var called = false;
    var $el = this;
    $(this).one('bsTransitionEnd', function () {
      called = true;
    });

    var callback = function callback() {
      if (!called) $($el).trigger($.support.transition.end);
    };

    setTimeout(callback, duration);
    return this;
  };

  $(function () {
    $.support.transition = transitionEnd();
    if (!$.support.transition) return;
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function handle(e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
      }
    };
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: alert.js v3.4.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
  'use strict'; // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]';

  var Alert = function Alert(el) {
    $(el).on('click', dismiss, this.close);
  };

  Alert.VERSION = '3.4.0';
  Alert.TRANSITION_DURATION = 150;

  Alert.prototype.close = function (e) {
    var $this = $(this);
    var selector = $this.attr('data-target');

    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

    selector = selector === '#' ? [] : selector;
    var $parent = $(document).find(selector);
    if (e) e.preventDefault();

    if (!$parent.length) {
      $parent = $this.closest('.alert');
    }

    $parent.trigger(e = $.Event('close.bs.alert'));
    if (e.isDefaultPrevented()) return;
    $parent.removeClass('in');

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove();
    }

    $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
  }; // ALERT PLUGIN DEFINITION
  // =======================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.alert');
      if (!data) $this.data('bs.alert', data = new Alert(this));
      if (typeof option == 'string') data[option].call($this);
    });
  }

  var old = $.fn.alert;
  $.fn.alert = Plugin;
  $.fn.alert.Constructor = Alert; // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  }; // ALERT DATA-API
  // ==============


  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
}(jQuery);
/* ========================================================================
 * Bootstrap: modal.js v3.4.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
  'use strict'; // MODAL CLASS DEFINITION
  // ======================

  var Modal = function Modal(element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find('.modal-dialog');
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;

    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };

  Modal.VERSION = '3.4.0';
  Modal.TRANSITION_DURATION = 300;
  Modal.BACKDROP_TRANSITION_DURATION = 150;
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };

  Modal.prototype.show = function (_relatedTarget) {
    var that = this;
    var e = $.Event('show.bs.modal', {
      relatedTarget: _relatedTarget
    });
    this.$element.trigger(e);
    if (this.isShown || e.isDefaultPrevented()) return;
    this.isShown = true;
    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass('modal-open');
    this.escape();
    this.resize();
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
      });
    });
    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body); // don't move modals dom position
      }

      that.$element.show().scrollTop(0);
      that.adjustDialog();

      if (transition) {
        that.$element[0].offsetWidth; // force reflow
      }

      that.$element.addClass('in');
      that.enforceFocus();
      var e = $.Event('shown.bs.modal', {
        relatedTarget: _relatedTarget
      });
      transition ? that.$dialog // wait for modal to slide in
      .one('bsTransitionEnd', function () {
        that.$element.trigger('focus').trigger(e);
      }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
    });
  };

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault();
    e = $.Event('hide.bs.modal');
    this.$element.trigger(e);
    if (!this.isShown || e.isDefaultPrevented()) return;
    this.isShown = false;
    this.escape();
    this.resize();
    $(document).off('focusin.bs.modal');
    this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
    this.$dialog.off('mousedown.dismiss.bs.modal');
    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
  };

  Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal') // guard against infinite focus loop
    .on('focusin.bs.modal', $.proxy(function (e) {
      if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
        this.$element.trigger('focus');
      }
    }, this));
  };

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal');
    }
  };

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
    } else {
      $(window).off('resize.bs.modal');
    }
  };

  Modal.prototype.hideModal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass('modal-open');
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger('hidden.bs.modal');
    });
  };

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };

  Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass('fade') ? 'fade' : '';

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;
      this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }

        if (e.target !== e.currentTarget) return;
        this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
      }, this));
      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

      this.$backdrop.addClass('in');
      if (!callback) return;
      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in');

      var callbackRemove = function callbackRemove() {
        that.removeBackdrop();
        callback && callback();
      };

      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
    } else if (callback) {
      callback();
    }
  }; // these following methods are used to handle overflowing modals


  Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    });
  };

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    });
  };

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;

    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect();
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
    }

    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || '';
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
  };

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad);
  };

  Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement('div');
    scrollDiv.className = 'modal-scrollbar-measure';
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  }; // MODAL PLUGIN DEFINITION
  // =======================


  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);
      if (!data) $this.data('bs.modal', data = new Modal(this, options));
      if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
    });
  }

  var old = $.fn.modal;
  $.fn.modal = Plugin;
  $.fn.modal.Constructor = Modal; // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  }; // MODAL DATA-API
  // ==============


  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this);
    var href = $this.attr('href');
    var target = $this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

    var $target = $(document).find(target);
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({
      remote: !/#/.test(href) && href
    }, $target.data(), $this.data());
    if ($this.is('a')) e.preventDefault();
    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown

      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus');
      });
    });
    Plugin.call($target, option, this);
  });
}(jQuery);
/*global define:false */

/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.2
 * @url craig.is/killing/mice
 */

(function (window, document, undefined) {
  // Check if mousetrap is used inside browser, if not, return
  if (!window) {
    return;
  }
  /**
   * mapping of special keycodes to their corresponding keys
   *
   * everything in this dictionary cannot use keypress events
   * so it has to be here to map to the correct keycodes for
   * keyup/keydown events
   *
   * @type {Object}
   */


  var _MAP = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    16: 'shift',
    17: 'ctrl',
    18: 'alt',
    20: 'capslock',
    27: 'esc',
    32: 'space',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    45: 'ins',
    46: 'del',
    91: 'meta',
    93: 'meta',
    224: 'meta'
  };
  /**
   * mapping for special characters so they can support
   *
   * this dictionary is only used incase you want to bind a
   * keyup or keydown event to one of these keys
   *
   * @type {Object}
   */

  var _KEYCODE_MAP = {
    106: '*',
    107: '+',
    109: '-',
    110: '.',
    111: '/',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: '\''
  };
  /**
   * this is a mapping of keys that require shift on a US keypad
   * back to the non shift equivelents
   *
   * this is so you can use keyup events with these keys
   *
   * note that this will only work reliably on US keyboards
   *
   * @type {Object}
   */

  var _SHIFT_MAP = {
    '~': '`',
    '!': '1',
    '@': '2',
    '#': '3',
    '$': '4',
    '%': '5',
    '^': '6',
    '&': '7',
    '*': '8',
    '(': '9',
    ')': '0',
    '_': '-',
    '+': '=',
    ':': ';',
    '\"': '\'',
    '<': ',',
    '>': '.',
    '?': '/',
    '|': '\\'
  };
  /**
   * this is a list of special strings you can use to map
   * to modifier keys when you specify your keyboard shortcuts
   *
   * @type {Object}
   */

  var _SPECIAL_ALIASES = {
    'option': 'alt',
    'command': 'meta',
    'return': 'enter',
    'escape': 'esc',
    'plus': '+',
    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
  };
  /**
   * variable to store the flipped version of _MAP from above
   * needed to check if we should use keypress or not when no action
   * is specified
   *
   * @type {Object|undefined}
   */

  var _REVERSE_MAP;
  /**
   * loop through the f keys, f1 to f19 and add them to the map
   * programatically
   */


  for (var i = 1; i < 20; ++i) {
    _MAP[111 + i] = 'f' + i;
  }
  /**
   * loop through to map numbers on the numeric keypad
   */


  for (i = 0; i <= 9; ++i) {
    // This needs to use a string cause otherwise since 0 is falsey
    // mousetrap will never fire for numpad 0 pressed as part of a keydown
    // event.
    //
    // @see https://github.com/ccampbell/mousetrap/pull/258
    _MAP[i + 96] = i.toString();
  }
  /**
   * cross browser add event method
   *
   * @param {Element|HTMLDocument} object
   * @param {string} type
   * @param {Function} callback
   * @returns void
   */


  function _addEvent(object, type, callback) {
    if (object.addEventListener) {
      object.addEventListener(type, callback, false);
      return;
    }

    object.attachEvent('on' + type, callback);
  }
  /**
   * takes the event and returns the key character
   *
   * @param {Event} e
   * @return {string}
   */


  function _characterFromEvent(e) {
    // for keypress events we should return the character as is
    if (e.type == 'keypress') {
      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume
      // that we want the character to be lowercase.  this means if
      // you accidentally have caps lock on then your key bindings
      // will continue to work
      //
      // the only side effect that might not be desired is if you
      // bind something like 'A' cause you want to trigger an
      // event when capital A is pressed caps lock will no longer
      // trigger the event.  shift+a will though.

      if (!e.shiftKey) {
        character = character.toLowerCase();
      }

      return character;
    } // for non keypress events the special maps are needed


    if (_MAP[e.which]) {
      return _MAP[e.which];
    }

    if (_KEYCODE_MAP[e.which]) {
      return _KEYCODE_MAP[e.which];
    } // if it is not in the special map
    // with keydown and keyup events the character seems to always
    // come in as an uppercase character whether you are pressing shift
    // or not.  we should make sure it is always lowercase for comparisons


    return String.fromCharCode(e.which).toLowerCase();
  }
  /**
   * checks if two arrays are equal
   *
   * @param {Array} modifiers1
   * @param {Array} modifiers2
   * @returns {boolean}
   */


  function _modifiersMatch(modifiers1, modifiers2) {
    return modifiers1.sort().join(',') === modifiers2.sort().join(',');
  }
  /**
   * takes a key event and figures out what the modifiers are
   *
   * @param {Event} e
   * @returns {Array}
   */


  function _eventModifiers(e) {
    var modifiers = [];

    if (e.shiftKey) {
      modifiers.push('shift');
    }

    if (e.altKey) {
      modifiers.push('alt');
    }

    if (e.ctrlKey) {
      modifiers.push('ctrl');
    }

    if (e.metaKey) {
      modifiers.push('meta');
    }

    return modifiers;
  }
  /**
   * prevents default for this event
   *
   * @param {Event} e
   * @returns void
   */


  function _preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
      return;
    }

    e.returnValue = false;
  }
  /**
   * stops propogation for this event
   *
   * @param {Event} e
   * @returns void
   */


  function _stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
      return;
    }

    e.cancelBubble = true;
  }
  /**
   * determines if the keycode specified is a modifier key or not
   *
   * @param {string} key
   * @returns {boolean}
   */


  function _isModifier(key) {
    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
  }
  /**
   * reverses the map lookup so that we can look for specific keys
   * to see what can and can't use keypress
   *
   * @return {Object}
   */


  function _getReverseMap() {
    if (!_REVERSE_MAP) {
      _REVERSE_MAP = {};

      for (var key in _MAP) {
        // pull out the numeric keypad from here cause keypress should
        // be able to detect the keys from the character
        if (key > 95 && key < 112) {
          continue;
        }

        if (_MAP.hasOwnProperty(key)) {
          _REVERSE_MAP[_MAP[key]] = key;
        }
      }
    }

    return _REVERSE_MAP;
  }
  /**
   * picks the best action based on the key combination
   *
   * @param {string} key - character for key
   * @param {Array} modifiers
   * @param {string=} action passed in
   */


  function _pickBestAction(key, modifiers, action) {
    // if no action was picked in we should try to pick the one
    // that we think would work best for this key
    if (!action) {
      action = _getReverseMap()[key] ? 'keydown' : 'keypress';
    } // modifier keys don't work as expected with keypress,
    // switch to keydown


    if (action == 'keypress' && modifiers.length) {
      action = 'keydown';
    }

    return action;
  }
  /**
   * Converts from a string key combination to an array
   *
   * @param  {string} combination like "command+shift+l"
   * @return {Array}
   */


  function _keysFromString(combination) {
    if (combination === '+') {
      return ['+'];
    }

    combination = combination.replace(/\+{2}/g, '+plus');
    return combination.split('+');
  }
  /**
   * Gets info for a specific key combination
   *
   * @param  {string} combination key combination ("command+s" or "a" or "*")
   * @param  {string=} action
   * @returns {Object}
   */


  function _getKeyInfo(combination, action) {
    var keys;
    var key;
    var i;
    var modifiers = []; // take the keys from this pattern and figure out what the actual
    // pattern is all about

    keys = _keysFromString(combination);

    for (i = 0; i < keys.length; ++i) {
      key = keys[i]; // normalize key names

      if (_SPECIAL_ALIASES[key]) {
        key = _SPECIAL_ALIASES[key];
      } // if this is not a keypress event then we should
      // be smart about using shift keys
      // this will only work for US keyboards however


      if (action && action != 'keypress' && _SHIFT_MAP[key]) {
        key = _SHIFT_MAP[key];
        modifiers.push('shift');
      } // if this key is a modifier then add it to the list of modifiers


      if (_isModifier(key)) {
        modifiers.push(key);
      }
    } // depending on what the key combination is
    // we will try to pick the best event for it


    action = _pickBestAction(key, modifiers, action);
    return {
      key: key,
      modifiers: modifiers,
      action: action
    };
  }

  function _belongsTo(element, ancestor) {
    if (element === null || element === document) {
      return false;
    }

    if (element === ancestor) {
      return true;
    }

    return _belongsTo(element.parentNode, ancestor);
  }

  function Mousetrap(targetElement) {
    var self = this;
    targetElement = targetElement || document;

    if (!(self instanceof Mousetrap)) {
      return new Mousetrap(targetElement);
    }
    /**
     * element to attach key events to
     *
     * @type {Element}
     */


    self.target = targetElement;
    /**
     * a list of all the callbacks setup via Mousetrap.bind()
     *
     * @type {Object}
     */

    self._callbacks = {};
    /**
     * direct map of string combinations to callbacks used for trigger()
     *
     * @type {Object}
     */

    self._directMap = {};
    /**
     * keeps track of what level each sequence is at since multiple
     * sequences can start out with the same sequence
     *
     * @type {Object}
     */

    var _sequenceLevels = {};
    /**
     * variable to store the setTimeout call
     *
     * @type {null|number}
     */

    var _resetTimer;
    /**
     * temporary state where we will ignore the next keyup
     *
     * @type {boolean|string}
     */


    var _ignoreNextKeyup = false;
    /**
     * temporary state where we will ignore the next keypress
     *
     * @type {boolean}
     */

    var _ignoreNextKeypress = false;
    /**
     * are we currently inside of a sequence?
     * type of action ("keyup" or "keydown" or "keypress") or false
     *
     * @type {boolean|string}
     */

    var _nextExpectedAction = false;
    /**
     * resets all sequence counters except for the ones passed in
     *
     * @param {Object} doNotReset
     * @returns void
     */

    function _resetSequences(doNotReset) {
      doNotReset = doNotReset || {};
      var activeSequences = false,
          key;

      for (key in _sequenceLevels) {
        if (doNotReset[key]) {
          activeSequences = true;
          continue;
        }

        _sequenceLevels[key] = 0;
      }

      if (!activeSequences) {
        _nextExpectedAction = false;
      }
    }
    /**
     * finds all callbacks that match based on the keycode, modifiers,
     * and action
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event|Object} e
     * @param {string=} sequenceName - name of the sequence we are looking for
     * @param {string=} combination
     * @param {number=} level
     * @returns {Array}
     */


    function _getMatches(character, modifiers, e, sequenceName, combination, level) {
      var i;
      var callback;
      var matches = [];
      var action = e.type; // if there are no events related to this keycode

      if (!self._callbacks[character]) {
        return [];
      } // if a modifier key is coming up on its own we should allow it


      if (action == 'keyup' && _isModifier(character)) {
        modifiers = [character];
      } // loop through all callbacks for the key that was pressed
      // and see if any of them match


      for (i = 0; i < self._callbacks[character].length; ++i) {
        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at
        // the wrong level then move onto the next match

        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
          continue;
        } // if the action we are looking for doesn't match the action we got
        // then we should keep going


        if (action != callback.action) {
          continue;
        } // if this is a keypress event and the meta key and control key
        // are not pressed that means that we need to only look at the
        // character, otherwise check the modifiers as well
        //
        // chrome will not fire a keypress if meta or control is down
        // safari will fire a keypress if meta or meta+shift is down
        // firefox will fire a keypress if meta or control is down


        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
          // when you bind a combination or sequence a second time it
          // should overwrite the first one.  if a sequenceName or
          // combination is specified in this call it does just that
          //
          // @todo make deleting its own method?
          var deleteCombo = !sequenceName && callback.combo == combination;
          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;

          if (deleteCombo || deleteSequence) {
            self._callbacks[character].splice(i, 1);
          }

          matches.push(callback);
        }
      }

      return matches;
    }
    /**
     * actually calls the callback function
     *
     * if your callback function returns false this will use the jquery
     * convention - prevent default and stop propogation on the event
     *
     * @param {Function} callback
     * @param {Event} e
     * @returns void
     */


    function _fireCallback(callback, e, combo, sequence) {
      // if this event should not happen stop here
      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
        return;
      }

      if (callback(e, combo) === false) {
        _preventDefault(e);

        _stopPropagation(e);
      }
    }
    /**
     * handles a character key event
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event} e
     * @returns void
     */


    self._handleKey = function (character, modifiers, e) {
      var callbacks = _getMatches(character, modifiers, e);

      var i;
      var doNotReset = {};
      var maxLevel = 0;
      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence

      for (i = 0; i < callbacks.length; ++i) {
        if (callbacks[i].seq) {
          maxLevel = Math.max(maxLevel, callbacks[i].level);
        }
      } // loop through matching callbacks for this key event


      for (i = 0; i < callbacks.length; ++i) {
        // fire for all sequence callbacks
        // this is because if for example you have multiple sequences
        // bound such as "g i" and "g t" they both need to fire the
        // callback for matching g cause otherwise you can only ever
        // match the first one
        if (callbacks[i].seq) {
          // only fire callbacks for the maxLevel to prevent
          // subsequences from also firing
          //
          // for example 'a option b' should not cause 'option b' to fire
          // even though 'option b' is part of the other sequence
          //
          // any sequences that do not match here will be discarded
          // below by the _resetSequences call
          if (callbacks[i].level != maxLevel) {
            continue;
          }

          processedSequenceCallback = true; // keep a list of which sequences were matches for later

          doNotReset[callbacks[i].seq] = 1;

          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);

          continue;
        } // if there were no sequence matches but we are still here
        // that means this is a regular match so we should fire that


        if (!processedSequenceCallback) {
          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
        }
      } // if the key you pressed matches the type of sequence without
      // being a modifier (ie "keyup" or "keypress") then we should
      // reset all sequences that were not matched by this event
      //
      // this is so, for example, if you have the sequence "h a t" and you
      // type "h e a r t" it does not match.  in this case the "e" will
      // cause the sequence to reset
      //
      // modifier keys are ignored because you can have a sequence
      // that contains modifiers such as "enter ctrl+space" and in most
      // cases the modifier key will be pressed before the next key
      //
      // also if you have a sequence such as "ctrl+b a" then pressing the
      // "b" key will trigger a "keypress" and a "keydown"
      //
      // the "keydown" is expected when there is a modifier, but the
      // "keypress" ends up matching the _nextExpectedAction since it occurs
      // after and that causes the sequence to reset
      //
      // we ignore keypresses in a sequence that directly follow a keydown
      // for the same character


      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;

      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
        _resetSequences(doNotReset);
      }

      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
    };
    /**
     * handles a keydown event
     *
     * @param {Event} e
     * @returns void
     */


    function _handleKeyEvent(e) {
      // normalize e.which for key events
      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
      if (typeof e.which !== 'number') {
        e.which = e.keyCode;
      }

      var character = _characterFromEvent(e); // no character found then stop


      if (!character) {
        return;
      } // need to use === for the character check because the character can be 0


      if (e.type == 'keyup' && _ignoreNextKeyup === character) {
        _ignoreNextKeyup = false;
        return;
      }

      self.handleKey(character, _eventModifiers(e), e);
    }
    /**
     * called to set a 1 second timeout on the specified sequence
     *
     * this is so after each key press in the sequence you have 1 second
     * to press the next key before you have to start over
     *
     * @returns void
     */


    function _resetSequenceTimer() {
      clearTimeout(_resetTimer);
      _resetTimer = setTimeout(_resetSequences, 1000);
    }
    /**
     * binds a key sequence to an event
     *
     * @param {string} combo - combo specified in bind call
     * @param {Array} keys
     * @param {Function} callback
     * @param {string=} action
     * @returns void
     */


    function _bindSequence(combo, keys, callback, action) {
      // start off by adding a sequence level record for this combination
      // and setting the level to 0
      _sequenceLevels[combo] = 0;
      /**
       * callback to increase the sequence level for this sequence and reset
       * all other sequences that were active
       *
       * @param {string} nextAction
       * @returns {Function}
       */

      function _increaseSequence(nextAction) {
        return function () {
          _nextExpectedAction = nextAction;
          ++_sequenceLevels[combo];

          _resetSequenceTimer();
        };
      }
      /**
       * wraps the specified callback inside of another function in order
       * to reset all sequence counters as soon as this sequence is done
       *
       * @param {Event} e
       * @returns void
       */


      function _callbackAndReset(e) {
        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down
        // or keypress.  this is so if you finish a sequence and
        // release the key the final key will not trigger a keyup


        if (action !== 'keyup') {
          _ignoreNextKeyup = _characterFromEvent(e);
        } // weird race condition if a sequence ends with the key
        // another sequence begins with


        setTimeout(_resetSequences, 10);
      } // loop through keys one at a time and bind the appropriate callback
      // function.  for any key leading up to the final one it should
      // increase the sequence. after the final, it should reset all sequences
      //
      // if an action is specified in the original bind call then that will
      // be used throughout.  otherwise we will pass the action that the
      // next key in the sequence should match.  this allows a sequence
      // to mix and match keypress and keydown events depending on which
      // ones are better suited to the key provided


      for (var i = 0; i < keys.length; ++i) {
        var isFinal = i + 1 === keys.length;
        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);

        _bindSingle(keys[i], wrappedCallback, action, combo, i);
      }
    }
    /**
     * binds a single keyboard combination
     *
     * @param {string} combination
     * @param {Function} callback
     * @param {string=} action
     * @param {string=} sequenceName - name of sequence if part of sequence
     * @param {number=} level - what part of the sequence the command is
     * @returns void
     */


    function _bindSingle(combination, callback, action, sequenceName, level) {
      // store a direct mapped reference for use with Mousetrap.trigger
      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space

      combination = combination.replace(/\s+/g, ' ');
      var sequence = combination.split(' ');
      var info; // if this pattern is a sequence of keys then run through this method
      // to reprocess each pattern one key at a time

      if (sequence.length > 1) {
        _bindSequence(combination, sequence, callback, action);

        return;
      }

      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time
      // a callback is added for this key

      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one

      _getMatches(info.key, info.modifiers, {
        type: info.action
      }, sequenceName, combination, level); // add this call back to the array
      // if it is a sequence put it at the beginning
      // if not put it at the end
      //
      // this is important because the way these are processed expects
      // the sequence ones to come first


      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
        callback: callback,
        modifiers: info.modifiers,
        action: info.action,
        seq: sequenceName,
        level: level,
        combo: combination
      });
    }
    /**
     * binds multiple combinations to the same callback
     *
     * @param {Array} combinations
     * @param {Function} callback
     * @param {string|undefined} action
     * @returns void
     */


    self._bindMultiple = function (combinations, callback, action) {
      for (var i = 0; i < combinations.length; ++i) {
        _bindSingle(combinations[i], callback, action);
      }
    }; // start!


    _addEvent(targetElement, 'keypress', _handleKeyEvent);

    _addEvent(targetElement, 'keydown', _handleKeyEvent);

    _addEvent(targetElement, 'keyup', _handleKeyEvent);
  }
  /**
   * binds an event to mousetrap
   *
   * can be a single key, a combination of keys separated with +,
   * an array of keys, or a sequence of keys separated by spaces
   *
   * be sure to list the modifier keys first to make sure that the
   * correct key ends up getting bound (the last key in the pattern)
   *
   * @param {string|Array} keys
   * @param {Function} callback
   * @param {string=} action - 'keypress', 'keydown', or 'keyup'
   * @returns void
   */


  Mousetrap.prototype.bind = function (keys, callback, action) {
    var self = this;
    keys = keys instanceof Array ? keys : [keys];

    self._bindMultiple.call(self, keys, callback, action);

    return self;
  };
  /**
   * unbinds an event to mousetrap
   *
   * the unbinding sets the callback function of the specified key combo
   * to an empty function and deletes the corresponding key in the
   * _directMap dict.
   *
   * TODO: actually remove this from the _callbacks dictionary instead
   * of binding an empty function
   *
   * the keycombo+action has to be exactly the same as
   * it was defined in the bind method
   *
   * @param {string|Array} keys
   * @param {string} action
   * @returns void
   */


  Mousetrap.prototype.unbind = function (keys, action) {
    var self = this;
    return self.bind.call(self, keys, function () {}, action);
  };
  /**
   * triggers an event that has already been bound
   *
   * @param {string} keys
   * @param {string=} action
   * @returns void
   */


  Mousetrap.prototype.trigger = function (keys, action) {
    var self = this;

    if (self._directMap[keys + ':' + action]) {
      self._directMap[keys + ':' + action]({}, keys);
    }

    return self;
  };
  /**
   * resets the library back to its initial state.  this is useful
   * if you want to clear out the current keyboard shortcuts and bind
   * new ones - for example if you switch to another page
   *
   * @returns void
   */


  Mousetrap.prototype.reset = function () {
    var self = this;
    self._callbacks = {};
    self._directMap = {};
    return self;
  };
  /**
   * should we stop this event before firing off callbacks
   *
   * @param {Event} e
   * @param {Element} element
   * @return {boolean}
   */


  Mousetrap.prototype.stopCallback = function (e, element) {
    var self = this; // if the element has the class "mousetrap" then no need to stop

    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
      return false;
    }

    if (_belongsTo(element, self.target)) {
      return false;
    } // stop for input, select, and textarea


    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
  };
  /**
   * exposes _handleKey publicly so it can be overwritten by extensions
   */


  Mousetrap.prototype.handleKey = function () {
    var self = this;
    return self._handleKey.apply(self, arguments);
  };
  /**
   * allow custom key mappings
   */


  Mousetrap.addKeycodes = function (object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        _MAP[key] = object[key];
      }
    }

    _REVERSE_MAP = null;
  };
  /**
   * Init the global mousetrap functions
   *
   * This method is needed to allow the global mousetrap functions to work
   * now that mousetrap is a constructor function.
   */


  Mousetrap.init = function () {
    var documentMousetrap = Mousetrap(document);

    for (var method in documentMousetrap) {
      if (method.charAt(0) !== '_') {
        Mousetrap[method] = function (method) {
          return function () {
            return documentMousetrap[method].apply(documentMousetrap, arguments);
          };
        }(method);
      }
    }
  };

  Mousetrap.init(); // expose mousetrap to the global object

  window.Mousetrap = Mousetrap; // expose as a common js module

  if ( true && module.exports) {
    module.exports = Mousetrap;
  } // expose mousetrap as an AMD module


  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Mousetrap;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null); // luhn extra validators


window.ParsleyConfig = window.ParsleyConfig || {};
window.ParsleyConfig.validators = window.ParsleyConfig.validators || {};
window.ParsleyConfig.validators.luhn = {
  fn: function fn(value) {
    value = value.replace(/[ -]/g, '');
    var digit;
    var n;

    var _j;

    var _len1;

    var _ref2;

    var sum = 0;
    _ref2 = value.split('').reverse();

    for (n = _j = 0, _len1 = _ref2.length; _j < _len1; n = ++_j) {
      digit = _ref2[n];
      digit = +digit;

      if (n % 2) {
        digit *= 2;

        if (digit < 10) {
          sum += digit;
        } else {
          sum += digit - 9;
        }
      } else {
        sum += digit;
      }
    }

    return sum % 10 === 0;
  },
  priority: 32
};
/*!
* Parsley.js
* Version 2.8.1 - built Sat, Feb 3rd 2018, 2:27 pm
* http://parsleyjs.org
* Guillaume Potier - <guillaume@wisembly.com>
* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>
* MIT Licensed
*/
// The source code below is generated by babel as
// Parsley is written in ECMAScript 6
//

var _slice = Array.prototype.slice;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i['return']) _i['return']();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError('Invalid attempt to destructure non-iterable instance');
    }
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
}

(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function ($) {
  'use strict';

  var globalID = 1;
  var pastWarnings = {};
  var Utils = {
    // Parsley DOM-API
    // returns object from dom attributes and values
    attr: function attr(element, namespace, obj) {
      var i;
      var attribute;
      var attributes;
      var regex = new RegExp('^' + namespace, 'i');
      if ('undefined' === typeof obj) obj = {};else {
        // Clear all own properties. This won't affect prototype's values
        for (i in obj) {
          if (obj.hasOwnProperty(i)) delete obj[i];
        }
      }
      if (!element) return obj;
      attributes = element.attributes;

      for (i = attributes.length; i--;) {
        attribute = attributes[i];

        if (attribute && attribute.specified && regex.test(attribute.name)) {
          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);
        }
      }

      return obj;
    },
    checkAttr: function checkAttr(element, namespace, _checkAttr) {
      return element.hasAttribute(namespace + _checkAttr);
    },
    setAttr: function setAttr(element, namespace, attr, value) {
      element.setAttribute(this.dasherize(namespace + attr), String(value));
    },
    getType: function getType(element) {
      return element.getAttribute('type') || 'text';
    },
    generateID: function generateID() {
      return '' + globalID++;
    },

    /** Third party functions **/
    deserializeValue: function deserializeValue(value) {
      var num;

      try {
        return value ? value == "true" || (value == "false" ? false : value == "null" ? null : !isNaN(num = Number(value)) ? num : /^[\[\{]/.test(value) ? JSON.parse(value) : value) : value;
      } catch (e) {
        return value;
      }
    },
    // Zepto camelize function
    camelize: function camelize(str) {
      return str.replace(/-+(.)?/g, function (match, chr) {
        return chr ? chr.toUpperCase() : '';
      });
    },
    // Zepto dasherize function
    dasherize: function dasherize(str) {
      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
    },
    warn: function warn() {
      var _window$console;

      if (window.console && 'function' === typeof window.console.warn) (_window$console = window.console).warn.apply(_window$console, arguments);
    },
    warnOnce: function warnOnce(msg) {
      if (!pastWarnings[msg]) {
        pastWarnings[msg] = true;
        this.warn.apply(this, arguments);
      }
    },
    _resetWarnings: function _resetWarnings() {
      pastWarnings = {};
    },
    trimString: function trimString(string) {
      return string.replace(/^\s+|\s+$/g, '');
    },
    parse: {
      date: function date(string) {
        var parsed = string.match(/^(\d{4,})-(\d\d)-(\d\d)$/);
        if (!parsed) return null;

        var _parsed$map = parsed.map(function (x) {
          return parseInt(x, 10);
        });

        var _parsed$map2 = _slicedToArray(_parsed$map, 4);

        var _ = _parsed$map2[0];
        var year = _parsed$map2[1];
        var month = _parsed$map2[2];
        var day = _parsed$map2[3];
        var date = new Date(year, month - 1, day);
        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) return null;
        return date;
      },
      string: function string(_string) {
        return _string;
      },
      integer: function integer(string) {
        if (isNaN(string)) return null;
        return parseInt(string, 10);
      },
      number: function number(string) {
        if (isNaN(string)) throw null;
        return parseFloat(string);
      },
      'boolean': function _boolean(string) {
        return !/^\s*false\s*$/i.test(string);
      },
      object: function object(string) {
        return Utils.deserializeValue(string);
      },
      regexp: function regexp(_regexp) {
        var flags = ''; // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern

        if (/^\/.*\/(?:[gimy]*)$/.test(_regexp)) {
          // Replace the regexp literal string with the first match group: ([gimy]*)
          // If no flag is present, this will be a blank string
          flags = _regexp.replace(/.*\/([gimy]*)$/, '$1'); // Again, replace the regexp literal string with the first match group:
          // everything excluding the opening and closing slashes and the flags

          _regexp = _regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');
        } else {
          // Anchor regexp:
          _regexp = '^' + _regexp + '$';
        }

        return new RegExp(_regexp, flags);
      }
    },
    parseRequirement: function parseRequirement(requirementType, string) {
      var converter = this.parse[requirementType || 'string'];
      if (!converter) throw 'Unknown requirement specification: "' + requirementType + '"';
      var converted = converter(string);
      if (converted === null) throw 'Requirement is not a ' + requirementType + ': "' + string + '"';
      return converted;
    },
    namespaceEvents: function namespaceEvents(events, namespace) {
      events = this.trimString(events || '').split(/\s+/);
      if (!events[0]) return '';
      return $.map(events, function (evt) {
        return evt + '.' + namespace;
      }).join(' ');
    },
    difference: function difference(array, remove) {
      // This is O(N^2), should be optimized
      var result = [];
      $.each(array, function (_, elem) {
        if (remove.indexOf(elem) == -1) result.push(elem);
      });
      return result;
    },
    // Alter-ego to native Promise.all, but for jQuery
    all: function all(promises) {
      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements
      return $.when.apply($, _toConsumableArray(promises).concat([42, 42]));
    },
    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill
    objectCreate: Object.create || function () {
      var Object = function Object() {};

      return function (prototype) {
        if (arguments.length > 1) {
          throw Error('Second argument not supported');
        }

        if (_typeof(prototype) != 'object') {
          throw TypeError('Argument must be an object');
        }

        Object.prototype = prototype;
        var result = new Object();
        Object.prototype = null;
        return result;
      };
    }(),
    _SubmitSelector: 'input[type="submit"], button:submit'
  }; // All these options could be overriden and specified directly in DOM using
  // `data-parsley-` default DOM-API
  // eg: `inputs` can be set in DOM using `data-parsley-inputs="input, textarea"`
  // eg: `data-parsley-stop-on-first-failing-constraint="false"`

  var Defaults = {
    // ### General
    // Default data-namespace for DOM API
    namespace: 'data-parsley-',
    // Supported inputs by default
    inputs: 'input, textarea, select',
    // Excluded inputs by default
    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',
    // Stop validating field on highest priority failing constraint
    priorityEnabled: true,
    // ### Field only
    // identifier used to group together inputs (e.g. radio buttons...)
    multiple: null,
    // identifier (or array of identifiers) used to validate only a select group of inputs
    group: null,
    // ### UI
    // Enable\Disable error messages
    uiEnabled: true,
    // Key events threshold before validation
    validationThreshold: 3,
    // Focused field on form validation error. 'first'|'last'|'none'
    focus: 'first',
    // event(s) that will trigger validation before first failure. eg: `input`...
    trigger: false,
    // event(s) that will trigger validation after first failure.
    triggerAfterFailure: 'input',
    // Class that would be added on every failing validation Parsley field
    errorClass: 'parsley-error',
    // Same for success validation
    successClass: 'parsley-success',
    // Return the `$element` that will receive these above success or error classes
    // Could also be (and given directly from DOM) a valid selector like `'#div'`
    classHandler: function classHandler(Field) {},
    // Return the `$element` where errors will be appended
    // Could also be (and given directly from DOM) a valid selector like `'#div'`
    errorsContainer: function errorsContainer(Field) {},
    // ul elem that would receive errors' list
    errorsWrapper: '<ul class="parsley-errors-list"></ul>',
    // li elem that would receive error message
    errorTemplate: '<li></li>'
  };

  var Base = function Base() {
    this.__id__ = Utils.generateID();
  };

  Base.prototype = {
    asyncSupport: true,
    // Deprecated
    _pipeAccordingToValidationResult: function _pipeAccordingToValidationResult() {
      var _this = this;

      var pipe = function pipe() {
        var r = $.Deferred();
        if (true !== _this.validationResult) r.reject();
        return r.resolve().promise();
      };

      return [pipe, pipe];
    },
    actualizeOptions: function actualizeOptions() {
      Utils.attr(this.element, this.options.namespace, this.domOptions);
      if (this.parent && this.parent.actualizeOptions) this.parent.actualizeOptions();
      return this;
    },
    _resetOptions: function _resetOptions(initOptions) {
      this.domOptions = Utils.objectCreate(this.parent.options);
      this.options = Utils.objectCreate(this.domOptions); // Shallow copy of ownProperties of initOptions:

      for (var i in initOptions) {
        if (initOptions.hasOwnProperty(i)) this.options[i] = initOptions[i];
      }

      this.actualizeOptions();
    },
    _listeners: null,
    // Register a callback for the given event name
    // Callback is called with context as the first argument and the `this`
    // The context is the current parsley instance, or window.Parsley if global
    // A return value of `false` will interrupt the calls
    on: function on(name, fn) {
      this._listeners = this._listeners || {};
      var queue = this._listeners[name] = this._listeners[name] || [];
      queue.push(fn);
      return this;
    },
    // Deprecated. Use `on` instead
    subscribe: function subscribe(name, fn) {
      $.listenTo(this, name.toLowerCase(), fn);
    },
    // Unregister a callback (or all if none is given) for the given event name
    off: function off(name, fn) {
      var queue = this._listeners && this._listeners[name];

      if (queue) {
        if (!fn) {
          delete this._listeners[name];
        } else {
          for (var i = queue.length; i--;) {
            if (queue[i] === fn) queue.splice(i, 1);
          }
        }
      }

      return this;
    },
    // Deprecated. Use `off`
    unsubscribe: function unsubscribe(name, fn) {
      $.unsubscribeTo(this, name.toLowerCase());
    },
    // Trigger an event of the given name
    // A return value of `false` interrupts the callback chain
    // Returns false if execution was interrupted
    trigger: function trigger(name, target, extraArg) {
      target = target || this;
      var queue = this._listeners && this._listeners[name];
      var result;
      var parentResult;

      if (queue) {
        for (var i = queue.length; i--;) {
          result = queue[i].call(target, target, extraArg);
          if (result === false) return result;
        }
      }

      if (this.parent) {
        return this.parent.trigger(name, target, extraArg);
      }

      return true;
    },
    asyncIsValid: function asyncIsValid(group, force) {
      Utils.warnOnce("asyncIsValid is deprecated; please use whenValid instead");
      return this.whenValid({
        group: group,
        force: force
      });
    },
    _findRelated: function _findRelated() {
      return this.options.multiple ? $(this.parent.element.querySelectorAll('[' + this.options.namespace + 'multiple="' + this.options.multiple + '"]')) : this.$element;
    }
  };

  var convertArrayRequirement = function convertArrayRequirement(string, length) {
    var m = string.match(/^\s*\[(.*)\]\s*$/);
    if (!m) throw 'Requirement is not an array: "' + string + '"';
    var values = m[1].split(',').map(Utils.trimString);
    if (values.length !== length) throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';
    return values;
  };

  var convertExtraOptionRequirement = function convertExtraOptionRequirement(requirementSpec, string, extraOptionReader) {
    var main = null;
    var extra = {};

    for (var key in requirementSpec) {
      if (key) {
        var value = extraOptionReader(key);
        if ('string' === typeof value) value = Utils.parseRequirement(requirementSpec[key], value);
        extra[key] = value;
      } else {
        main = Utils.parseRequirement(requirementSpec[key], string);
      }
    }

    return [main, extra];
  }; // A Validator needs to implement the methods `validate` and `parseRequirements`


  var Validator = function Validator(spec) {
    $.extend(true, this, spec);
  };

  Validator.prototype = {
    // Returns `true` iff the given `value` is valid according the given requirements.
    validate: function validate(value, requirementFirstArg) {
      if (this.fn) {
        // Legacy style validator
        if (arguments.length > 3) // If more args then value, requirement, instance...
          requirementFirstArg = [].slice.call(arguments, 1, -1); // Skip first arg (value) and last (instance), combining the rest

        return this.fn(value, requirementFirstArg);
      }

      if (Array.isArray(value)) {
        if (!this.validateMultiple) throw 'Validator `' + this.name + '` does not handle multiple values';
        return this.validateMultiple.apply(this, arguments);
      } else {
        var instance = arguments[arguments.length - 1];

        if (this.validateDate && instance._isDateInput()) {
          arguments[0] = Utils.parse.date(arguments[0]);
          if (arguments[0] === null) return false;
          return this.validateDate.apply(this, arguments);
        }

        if (this.validateNumber) {
          if (isNaN(value)) return false;
          arguments[0] = parseFloat(arguments[0]);
          return this.validateNumber.apply(this, arguments);
        }

        if (this.validateString) {
          return this.validateString.apply(this, arguments);
        }

        throw 'Validator `' + this.name + '` only handles multiple values';
      }
    },
    // Parses `requirements` into an array of arguments,
    // according to `this.requirementType`
    parseRequirements: function parseRequirements(requirements, extraOptionReader) {
      if ('string' !== typeof requirements) {
        // Assume requirement already parsed
        // but make sure we return an array
        return Array.isArray(requirements) ? requirements : [requirements];
      }

      var type = this.requirementType;

      if (Array.isArray(type)) {
        var values = convertArrayRequirement(requirements, type.length);

        for (var i = 0; i < values.length; i++) {
          values[i] = Utils.parseRequirement(type[i], values[i]);
        }

        return values;
      } else if ($.isPlainObject(type)) {
        return convertExtraOptionRequirement(type, requirements, extraOptionReader);
      } else {
        return [Utils.parseRequirement(type, requirements)];
      }
    },
    // Defaults:
    requirementType: 'string',
    priority: 2
  };

  var ValidatorRegistry = function ValidatorRegistry(validators, catalog) {
    this.__class__ = 'ValidatorRegistry'; // Default Parsley locale is en

    this.locale = 'en';
    this.init(validators || {}, catalog || {});
  };

  var typeTesters = {
    email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/,
    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers
    number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i,
    integer: /^-?\d+$/,
    digits: /^\d+$/,
    alphanum: /^\w+$/i,
    date: {
      test: function test(value) {
        return Utils.parse.date(value) !== null;
      }
    },
    url: new RegExp("^" + // protocol identifier
    "(?:(?:https?|ftp)://)?" + // ** mod: make scheme optional
    // user:pass authentication
    "(?:\\S+(?::\\S*)?@)?" + "(?:" + // IP address exclusion
    // private & local networks
    // "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +   // ** mod: allow local networks
    // "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +  // ** mod: allow local networks
    // "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +  // ** mod: allow local networks
    // IP address dotted notation octets
    // excludes loopback network 0.0.0.0
    // excludes reserved space >= 224.0.0.0
    // excludes network & broacast addresses
    // (first & last IP address of each class)
    "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + // host name
    "(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)" + // domain name
    "(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*" + // TLD identifier
    "(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,}))" + ")" + // port number
    "(?::\\d{2,5})?" + // resource path
    "(?:/\\S*)?" + "$")
  };
  typeTesters.range = typeTesters.number; // See http://stackoverflow.com/a/10454560/8279

  var decimalPlaces = function decimalPlaces(num) {
    var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);

    if (!match) {
      return 0;
    }

    return Math.max(0, // Number of digits right of decimal point.
    (match[1] ? match[1].length : 0) - ( // Adjust for scientific notation.
    match[2] ? +match[2] : 0));
  }; // parseArguments('number', ['1', '2']) => [1, 2]


  var ValidatorRegistry__parseArguments = function ValidatorRegistry__parseArguments(type, args) {
    return args.map(Utils.parse[type]);
  }; // operatorToValidator returns a validating function for an operator function, applied to the given type


  var ValidatorRegistry__operatorToValidator = function ValidatorRegistry__operatorToValidator(type, operator) {
    return function (value) {
      for (var _len = arguments.length, requirementsAndInput = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        requirementsAndInput[_key - 1] = arguments[_key];
      }

      requirementsAndInput.pop(); // Get rid of `input` argument

      return operator.apply(undefined, [value].concat(_toConsumableArray(ValidatorRegistry__parseArguments(type, requirementsAndInput))));
    };
  };

  var ValidatorRegistry__comparisonOperator = function ValidatorRegistry__comparisonOperator(operator) {
    return {
      validateDate: ValidatorRegistry__operatorToValidator('date', operator),
      validateNumber: ValidatorRegistry__operatorToValidator('number', operator),
      requirementType: operator.length <= 2 ? 'string' : ['string', 'string'],
      // Support operators with a 1 or 2 requirement(s)
      priority: 30
    };
  };

  ValidatorRegistry.prototype = {
    init: function init(validators, catalog) {
      this.catalog = catalog; // Copy prototype's validators:

      this.validators = _extends({}, this.validators);

      for (var name in validators) {
        this.addValidator(name, validators[name].fn, validators[name].priority);
      }

      window.Parsley.trigger('parsley:validator:init');
    },
    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n
    setLocale: function setLocale(locale) {
      if ('undefined' === typeof this.catalog[locale]) throw new Error(locale + ' is not available in the catalog');
      this.locale = locale;
      return this;
    },
    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`
    addCatalog: function addCatalog(locale, messages, set) {
      if ('object' === _typeof(messages)) this.catalog[locale] = messages;
      if (true === set) return this.setLocale(locale);
      return this;
    },
    // Add a specific message for a given constraint in a given locale
    addMessage: function addMessage(locale, name, message) {
      if ('undefined' === typeof this.catalog[locale]) this.catalog[locale] = {};
      this.catalog[locale][name] = message;
      return this;
    },
    // Add messages for a given locale
    addMessages: function addMessages(locale, nameMessageObject) {
      for (var name in nameMessageObject) {
        this.addMessage(locale, name, nameMessageObject[name]);
      }

      return this;
    },
    // Add a new validator
    //
    //    addValidator('custom', {
    //        requirementType: ['integer', 'integer'],
    //        validateString: function(value, from, to) {},
    //        priority: 22,
    //        messages: {
    //          en: "Hey, that's no good",
    //          fr: "Aye aye, pas bon du tout",
    //        }
    //    })
    //
    // Old API was addValidator(name, function, priority)
    //
    addValidator: function addValidator(name, arg1, arg2) {
      if (this.validators[name]) Utils.warn('Validator "' + name + '" is already defined.');else if (Defaults.hasOwnProperty(name)) {
        Utils.warn('"' + name + '" is a restricted keyword and is not a valid validator name.');
        return;
      }
      return this._setValidator.apply(this, arguments);
    },
    hasValidator: function hasValidator(name) {
      return !!this.validators[name];
    },
    updateValidator: function updateValidator(name, arg1, arg2) {
      if (!this.validators[name]) {
        Utils.warn('Validator "' + name + '" is not already defined.');
        return this.addValidator.apply(this, arguments);
      }

      return this._setValidator.apply(this, arguments);
    },
    removeValidator: function removeValidator(name) {
      if (!this.validators[name]) Utils.warn('Validator "' + name + '" is not defined.');
      delete this.validators[name];
      return this;
    },
    _setValidator: function _setValidator(name, validator, priority) {
      if ('object' !== _typeof(validator)) {
        // Old style validator, with `fn` and `priority`
        validator = {
          fn: validator,
          priority: priority
        };
      }

      if (!validator.validate) {
        validator = new Validator(validator);
      }

      this.validators[name] = validator;

      for (var locale in validator.messages || {}) {
        this.addMessage(locale, name, validator.messages[locale]);
      }

      return this;
    },
    getErrorMessage: function getErrorMessage(constraint) {
      var message; // Type constraints are a bit different, we have to match their requirements too to find right error message

      if ('type' === constraint.name) {
        var typeMessages = this.catalog[this.locale][constraint.name] || {};
        message = typeMessages[constraint.requirements];
      } else message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);

      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;
    },
    // Kind of light `sprintf()` implementation
    formatMessage: function formatMessage(string, parameters) {
      if ('object' === _typeof(parameters)) {
        for (var i in parameters) {
          string = this.formatMessage(string, parameters[i]);
        }

        return string;
      }

      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';
    },
    // Here is the Parsley default validators list.
    // A validator is an object with the following key values:
    //  - priority: an integer
    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these
    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise
    // Alternatively, a validator can be a function that returns such an object
    //
    validators: {
      notblank: {
        validateString: function validateString(value) {
          return /\S/.test(value);
        },
        priority: 2
      },
      required: {
        validateMultiple: function validateMultiple(values) {
          return values.length > 0;
        },
        validateString: function validateString(value) {
          return /\S/.test(value);
        },
        priority: 512
      },
      type: {
        validateString: function validateString(value, type) {
          var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

          var _ref$step = _ref.step;
          var step = _ref$step === undefined ? 'any' : _ref$step;
          var _ref$base = _ref.base;
          var base = _ref$base === undefined ? 0 : _ref$base;
          var tester = typeTesters[type];

          if (!tester) {
            throw new Error('validator type `' + type + '` is not supported');
          }

          if (!tester.test(value)) return false;

          if ('number' === type) {
            if (!/^any$/i.test(step || '')) {
              var nb = Number(value);
              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));
              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals
                return false; // Be careful of rounding errors by using integers.

              var toInt = function toInt(f) {
                return Math.round(f * Math.pow(10, decimals));
              };

              if ((toInt(nb) - toInt(base)) % toInt(step) != 0) return false;
            }
          }

          return true;
        },
        requirementType: {
          '': 'string',
          step: 'string',
          base: 'number'
        },
        priority: 256
      },
      pattern: {
        validateString: function validateString(value, regexp) {
          return regexp.test(value);
        },
        requirementType: 'regexp',
        priority: 64
      },
      minlength: {
        validateString: function validateString(value, requirement) {
          return value.length >= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      maxlength: {
        validateString: function validateString(value, requirement) {
          return value.length <= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      length: {
        validateString: function validateString(value, min, max) {
          return value.length >= min && value.length <= max;
        },
        requirementType: ['integer', 'integer'],
        priority: 30
      },
      mincheck: {
        validateMultiple: function validateMultiple(values, requirement) {
          return values.length >= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      maxcheck: {
        validateMultiple: function validateMultiple(values, requirement) {
          return values.length <= requirement;
        },
        requirementType: 'integer',
        priority: 30
      },
      check: {
        validateMultiple: function validateMultiple(values, min, max) {
          return values.length >= min && values.length <= max;
        },
        requirementType: ['integer', 'integer'],
        priority: 30
      },
      min: ValidatorRegistry__comparisonOperator(function (value, requirement) {
        return value >= requirement;
      }),
      max: ValidatorRegistry__comparisonOperator(function (value, requirement) {
        return value <= requirement;
      }),
      range: ValidatorRegistry__comparisonOperator(function (value, min, max) {
        return value >= min && value <= max;
      }),
      equalto: {
        validateString: function validateString(value, refOrValue) {
          var $reference = $(refOrValue);
          if ($reference.length) return value === $reference.val();else return value === refOrValue;
        },
        priority: 256
      }
    }
  };
  var UI = {};

  var diffResults = function diffResults(newResult, oldResult, deep) {
    var added = [];
    var kept = [];

    for (var i = 0; i < newResult.length; i++) {
      var found = false;

      for (var j = 0; j < oldResult.length; j++) {
        if (newResult[i].assert.name === oldResult[j].assert.name) {
          found = true;
          break;
        }
      }

      if (found) kept.push(newResult[i]);else added.push(newResult[i]);
    }

    return {
      kept: kept,
      added: added,
      removed: !deep ? diffResults(oldResult, newResult, true).added : []
    };
  };

  UI.Form = {
    _actualizeTriggers: function _actualizeTriggers() {
      var _this2 = this;

      this.$element.on('submit.Parsley', function (evt) {
        _this2.onSubmitValidate(evt);
      });
      this.$element.on('click.Parsley', Utils._SubmitSelector, function (evt) {
        _this2.onSubmitButton(evt);
      }); // UI could be disabled

      if (false === this.options.uiEnabled) return;
      this.element.setAttribute('novalidate', '');
    },
    focus: function focus() {
      this._focusedField = null;
      if (true === this.validationResult || 'none' === this.options.focus) return null;

      for (var i = 0; i < this.fields.length; i++) {
        var field = this.fields[i];

        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {
          this._focusedField = field.$element;
          if ('first' === this.options.focus) break;
        }
      }

      if (null === this._focusedField) return null;
      return this._focusedField.focus();
    },
    _destroyUI: function _destroyUI() {
      // Reset all event listeners
      this.$element.off('.Parsley');
    }
  };
  UI.Field = {
    _reflowUI: function _reflowUI() {
      this._buildUI(); // If this field doesn't have an active UI don't bother doing something


      if (!this._ui) return; // Diff between two validation results

      var diff = diffResults(this.validationResult, this._ui.lastValidationResult); // Then store current validation result for next reflow

      this._ui.lastValidationResult = this.validationResult; // Handle valid / invalid / none field class

      this._manageStatusClass(); // Add, remove, updated errors messages


      this._manageErrorsMessages(diff); // Triggers impl


      this._actualizeTriggers(); // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user


      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {
        this._failedOnce = true;

        this._actualizeTriggers();
      }
    },
    // Returns an array of field's error message(s)
    getErrorsMessages: function getErrorsMessages() {
      // No error message, field is valid
      if (true === this.validationResult) return [];
      var messages = [];

      for (var i = 0; i < this.validationResult.length; i++) {
        messages.push(this.validationResult[i].errorMessage || this._getErrorMessage(this.validationResult[i].assert));
      }

      return messages;
    },
    // It's a goal of Parsley that this method is no longer required [#1073]
    addError: function addError(name) {
      var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var message = _ref2.message;
      var assert = _ref2.assert;
      var _ref2$updateClass = _ref2.updateClass;
      var updateClass = _ref2$updateClass === undefined ? true : _ref2$updateClass;

      this._buildUI();

      this._addError(name, {
        message: message,
        assert: assert
      });

      if (updateClass) this._errorClass();
    },
    // It's a goal of Parsley that this method is no longer required [#1073]
    updateError: function updateError(name) {
      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var message = _ref3.message;
      var assert = _ref3.assert;
      var _ref3$updateClass = _ref3.updateClass;
      var updateClass = _ref3$updateClass === undefined ? true : _ref3$updateClass;

      this._buildUI();

      this._updateError(name, {
        message: message,
        assert: assert
      });

      if (updateClass) this._errorClass();
    },
    // It's a goal of Parsley that this method is no longer required [#1073]
    removeError: function removeError(name) {
      var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var _ref4$updateClass = _ref4.updateClass;
      var updateClass = _ref4$updateClass === undefined ? true : _ref4$updateClass;

      this._buildUI();

      this._removeError(name); // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult
      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.


      if (updateClass) this._manageStatusClass();
    },
    _manageStatusClass: function _manageStatusClass() {
      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult) this._successClass();else if (this.validationResult.length > 0) this._errorClass();else this._resetClass();
    },
    _manageErrorsMessages: function _manageErrorsMessages(diff) {
      if ('undefined' !== typeof this.options.errorsMessagesDisabled) return; // Case where we have errorMessage option that configure an unique field error message, regardless failing validators

      if ('undefined' !== typeof this.options.errorMessage) {
        if (diff.added.length || diff.kept.length) {
          this._insertErrorWrapper();

          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length) this._ui.$errorsWrapper.append($(this.options.errorTemplate).addClass('parsley-custom-error-message'));
          return this._ui.$errorsWrapper.addClass('filled').find('.parsley-custom-error-message').html(this.options.errorMessage);
        }

        return this._ui.$errorsWrapper.removeClass('filled').find('.parsley-custom-error-message').remove();
      } // Show, hide, update failing constraints messages


      for (var i = 0; i < diff.removed.length; i++) {
        this._removeError(diff.removed[i].assert.name);
      }

      for (i = 0; i < diff.added.length; i++) {
        this._addError(diff.added[i].assert.name, {
          message: diff.added[i].errorMessage,
          assert: diff.added[i].assert
        });
      }

      for (i = 0; i < diff.kept.length; i++) {
        this._updateError(diff.kept[i].assert.name, {
          message: diff.kept[i].errorMessage,
          assert: diff.kept[i].assert
        });
      }
    },
    _addError: function _addError(name, _ref5) {
      var message = _ref5.message;
      var assert = _ref5.assert;

      this._insertErrorWrapper();

      this._ui.$errorClassHandler.attr('aria-describedby', this._ui.errorsWrapperId);

      this._ui.$errorsWrapper.addClass('filled').append($(this.options.errorTemplate).addClass('parsley-' + name).html(message || this._getErrorMessage(assert)));
    },
    _updateError: function _updateError(name, _ref6) {
      var message = _ref6.message;
      var assert = _ref6.assert;

      this._ui.$errorsWrapper.addClass('filled').find('.parsley-' + name).html(message || this._getErrorMessage(assert));
    },
    _removeError: function _removeError(name) {
      this._ui.$errorClassHandler.removeAttr('aria-describedby');

      this._ui.$errorsWrapper.removeClass('filled').find('.parsley-' + name).remove();
    },
    _getErrorMessage: function _getErrorMessage(constraint) {
      var customConstraintErrorMessage = constraint.name + 'Message';
      if ('undefined' !== typeof this.options[customConstraintErrorMessage]) return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);
      return window.Parsley.getErrorMessage(constraint);
    },
    _buildUI: function _buildUI() {
      // UI could be already built or disabled
      if (this._ui || false === this.options.uiEnabled) return;
      var _ui = {}; // Give field its Parsley id in DOM

      this.element.setAttribute(this.options.namespace + 'id', this.__id__);
      /** Generate important UI elements and store them in this **/
      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes

      _ui.$errorClassHandler = this._manageClassHandler(); // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer

      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);
      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId); // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly

      _ui.lastValidationResult = [];
      _ui.validationInformationVisible = false; // Store it in this for later

      this._ui = _ui;
    },
    // Determine which element will have `parsley-error` and `parsley-success` classes
    _manageClassHandler: function _manageClassHandler() {
      // Class handled could also be determined by function given in Parsley options
      if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length) return $(this.options.classHandler); // Class handled could also be determined by function given in Parsley options

      var $handlerFunction = this.options.classHandler; // It might also be the function name of a global function

      if ('string' === typeof this.options.classHandler && 'function' === typeof window[this.options.classHandler]) $handlerFunction = window[this.options.classHandler];

      if ('function' === typeof $handlerFunction) {
        var $handler = $handlerFunction.call(this, this); // If this function returned a valid existing DOM element, go for it

        if ('undefined' !== typeof $handler && $handler.length) return $handler;
      } else if ('object' === _typeof($handlerFunction) && $handlerFunction instanceof jQuery && $handlerFunction.length) {
        return $handlerFunction;
      } else if ($handlerFunction) {
        Utils.warn('The class handler `' + $handlerFunction + '` does not exist in DOM nor as a global JS function');
      }

      return this._inputHolder();
    },
    _inputHolder: function _inputHolder() {
      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container
      if (!this.options.multiple || this.element.nodeName === 'SELECT') return this.$element; // But if multiple element (radio, checkbox), that would be their parent

      return this.$element.parent();
    },
    _insertErrorWrapper: function _insertErrorWrapper() {
      var $errorsContainer = this.options.errorsContainer; // Nothing to do if already inserted

      if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();

      if ('string' === typeof $errorsContainer) {
        if ($($errorsContainer).length) return $($errorsContainer).append(this._ui.$errorsWrapper);else if ('function' === typeof window[$errorsContainer]) $errorsContainer = window[$errorsContainer];else Utils.warn('The errors container `' + $errorsContainer + '` does not exist in DOM nor as a global JS function');
      }

      if ('function' === typeof $errorsContainer) $errorsContainer = $errorsContainer.call(this, this);
      if ('object' === _typeof($errorsContainer) && $errorsContainer.length) return $errorsContainer.append(this._ui.$errorsWrapper);
      return this._inputHolder().after(this._ui.$errorsWrapper);
    },
    _actualizeTriggers: function _actualizeTriggers() {
      var _this3 = this;

      var $toBind = this._findRelated();

      var trigger; // Remove Parsley events already bound on this field

      $toBind.off('.Parsley');
      if (this._failedOnce) $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), function () {
        _this3._validateIfNeeded();
      });else if (trigger = Utils.namespaceEvents(this.options.trigger, 'Parsley')) {
        $toBind.on(trigger, function (event) {
          _this3._validateIfNeeded(event);
        });
      }
    },
    _validateIfNeeded: function _validateIfNeeded(event) {
      var _this4 = this; // For keyup, keypress, keydown, input... events that could be a little bit obstrusive
      // do not validate if val length < min threshold on first validation. Once field have been validated once and info
      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.


      if (event && /key|input/.test(event.type)) if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold) return;

      if (this.options.debounce) {
        window.clearTimeout(this._debounced);
        this._debounced = window.setTimeout(function () {
          return _this4.validate();
        }, this.options.debounce);
      } else this.validate();
    },
    _resetUI: function _resetUI() {
      // Reset all event listeners
      this._failedOnce = false;

      this._actualizeTriggers(); // Nothing to do if UI never initialized for this field


      if ('undefined' === typeof this._ui) return; // Reset all errors' li

      this._ui.$errorsWrapper.removeClass('filled').children().remove(); // Reset validation class


      this._resetClass(); // Reset validation flags and last validation result


      this._ui.lastValidationResult = [];
      this._ui.validationInformationVisible = false;
    },
    _destroyUI: function _destroyUI() {
      this._resetUI();

      if ('undefined' !== typeof this._ui) this._ui.$errorsWrapper.remove();
      delete this._ui;
    },
    _successClass: function _successClass() {
      this._ui.validationInformationVisible = true;

      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);
    },
    _errorClass: function _errorClass() {
      this._ui.validationInformationVisible = true;

      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);
    },
    _resetClass: function _resetClass() {
      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);
    }
  };

  var Form = function Form(element, domOptions, options) {
    this.__class__ = 'Form';
    this.element = element;
    this.$element = $(element);
    this.domOptions = domOptions;
    this.options = options;
    this.parent = window.Parsley;
    this.fields = [];
    this.validationResult = null;
  };

  var Form__statusMapping = {
    pending: null,
    resolved: true,
    rejected: false
  };
  Form.prototype = {
    onSubmitValidate: function onSubmitValidate(event) {
      var _this5 = this; // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior


      if (true === event.parsley) return; // If we didn't come here through a submit button, use the first one in the form

      var submitSource = this._submitSource || this.$element.find(Utils._SubmitSelector)[0];
      this._submitSource = null;
      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);
      if (submitSource && null !== submitSource.getAttribute('formnovalidate')) return;
      window.Parsley._remoteCache = {};
      var promise = this.whenValidate({
        event: event
      });

      if ('resolved' === promise.state() && false !== this._trigger('submit')) {// All good, let event go through. We make this distinction because browsers
        // differ in their handling of `submit` being called from inside a submit event [#1047]
      } else {
        // Rejected or pending: cancel this submit
        event.stopImmediatePropagation();
        event.preventDefault();
        if ('pending' === promise.state()) promise.done(function () {
          _this5._submit(submitSource);
        });
      }
    },
    onSubmitButton: function onSubmitButton(event) {
      this._submitSource = event.currentTarget;
    },
    // internal
    // _submit submits the form, this time without going through the validations.
    // Care must be taken to "fake" the actual submit button being clicked.
    _submit: function _submit(submitSource) {
      if (false === this._trigger('submit')) return; // Add submit button's data

      if (submitSource) {
        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);
        if (0 === $synthetic.length) $synthetic = $('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element);
        $synthetic.attr({
          name: submitSource.getAttribute('name'),
          value: submitSource.getAttribute('value')
        });
      }

      this.$element.trigger(_extends($.Event('submit'), {
        parsley: true
      }));
    },
    // Performs validation on fields while triggering events.
    // @returns `true` if all validations succeeds, `false`
    // if a failure is immediately detected, or `null`
    // if dependant on a promise.
    // Consider using `whenValidate` instead.
    validate: function validate(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');

        var _arguments = _slice.call(arguments);

        var group = _arguments[0];
        var force = _arguments[1];
        var event = _arguments[2];
        options = {
          group: group,
          force: force,
          event: event
        };
      }

      return Form__statusMapping[this.whenValidate(options).state()];
    },
    whenValidate: function whenValidate() {
      var _Utils$all$done$fail$always,
          _this6 = this;

      var _ref7 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var group = _ref7.group;
      var force = _ref7.force;
      var event = _ref7.event;
      this.submitEvent = event;

      if (event) {
        this.submitEvent = _extends({}, event, {
          preventDefault: function preventDefault() {
            Utils.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`");
            _this6.validationResult = false;
          }
        });
      }

      this.validationResult = true; // fire validate event to eventually modify things before every validation

      this._trigger('validate'); // Refresh form DOM options and form's fields that could have changed


      this._refreshFields();

      var promises = this._withoutReactualizingFormOptions(function () {
        return $.map(_this6.fields, function (field) {
          return field.whenValidate({
            force: force,
            group: group
          });
        });
      });

      return (_Utils$all$done$fail$always = Utils.all(promises).done(function () {
        _this6._trigger('success');
      }).fail(function () {
        _this6.validationResult = false;

        _this6.focus();

        _this6._trigger('error');
      }).always(function () {
        _this6._trigger('validated');
      })).pipe.apply(_Utils$all$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));
    },
    // Iterate over refreshed fields, and stop on first failure.
    // Returns `true` if all fields are valid, `false` if a failure is detected
    // or `null` if the result depends on an unresolved promise.
    // Prefer using `whenValid` instead.
    isValid: function isValid(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');

        var _arguments2 = _slice.call(arguments);

        var group = _arguments2[0];
        var force = _arguments2[1];
        options = {
          group: group,
          force: force
        };
      }

      return Form__statusMapping[this.whenValid(options).state()];
    },
    // Iterate over refreshed fields and validate them.
    // Returns a promise.
    // A validation that immediately fails will interrupt the validations.
    whenValid: function whenValid() {
      var _this7 = this;

      var _ref8 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var group = _ref8.group;
      var force = _ref8.force;

      this._refreshFields();

      var promises = this._withoutReactualizingFormOptions(function () {
        return $.map(_this7.fields, function (field) {
          return field.whenValid({
            group: group,
            force: force
          });
        });
      });

      return Utils.all(promises);
    },
    refresh: function refresh() {
      this._refreshFields();

      return this;
    },
    // Reset UI
    reset: function reset() {
      // Form case: emit a reset event for each field
      for (var i = 0; i < this.fields.length; i++) {
        this.fields[i].reset();
      }

      this._trigger('reset');
    },
    // Destroy Parsley instance (+ UI)
    destroy: function destroy() {
      // Field case: emit destroy event to clean UI and then destroy stored instance
      this._destroyUI(); // Form case: destroy all its fields and then destroy stored instance


      for (var i = 0; i < this.fields.length; i++) {
        this.fields[i].destroy();
      }

      this.$element.removeData('Parsley');

      this._trigger('destroy');
    },
    _refreshFields: function _refreshFields() {
      return this.actualizeOptions()._bindFields();
    },
    _bindFields: function _bindFields() {
      var _this8 = this;

      var oldFields = this.fields;
      this.fields = [];
      this.fieldsMappedById = {};

      this._withoutReactualizingFormOptions(function () {
        _this8.$element.find(_this8.options.inputs).not(_this8.options.excluded).each(function (_, element) {
          var fieldInstance = new window.Parsley.Factory(element, {}, _this8); // Only add valid and not excluded `Field` and `FieldMultiple` children

          if (('Field' === fieldInstance.__class__ || 'FieldMultiple' === fieldInstance.__class__) && true !== fieldInstance.options.excluded) {
            var uniqueId = fieldInstance.__class__ + '-' + fieldInstance.__id__;

            if ('undefined' === typeof _this8.fieldsMappedById[uniqueId]) {
              _this8.fieldsMappedById[uniqueId] = fieldInstance;

              _this8.fields.push(fieldInstance);
            }
          }
        });

        $.each(Utils.difference(oldFields, _this8.fields), function (_, field) {
          field.reset();
        });
      });

      return this;
    },
    // Internal only.
    // Looping on a form's fields to do validation or similar
    // will trigger reactualizing options on all of them, which
    // in turn will reactualize the form's options.
    // To avoid calling actualizeOptions so many times on the form
    // for nothing, _withoutReactualizingFormOptions temporarily disables
    // the method actualizeOptions on this form while `fn` is called.
    _withoutReactualizingFormOptions: function _withoutReactualizingFormOptions(fn) {
      var oldActualizeOptions = this.actualizeOptions;

      this.actualizeOptions = function () {
        return this;
      };

      var result = fn();
      this.actualizeOptions = oldActualizeOptions;
      return result;
    },
    // Internal only.
    // Shortcut to trigger an event
    // Returns true iff event is not interrupted and default not prevented.
    _trigger: function _trigger(eventName) {
      return this.trigger('form:' + eventName);
    }
  };

  var Constraint = function Constraint(parsleyField, name, requirements, priority, isDomConstraint) {
    var validatorSpec = window.Parsley._validatorRegistry.validators[name];
    var validator = new Validator(validatorSpec);
    priority = priority || parsleyField.options[name + 'Priority'] || validator.priority;
    isDomConstraint = true === isDomConstraint;

    _extends(this, {
      validator: validator,
      name: name,
      requirements: requirements,
      priority: priority,
      isDomConstraint: isDomConstraint
    });

    this._parseRequirements(parsleyField.options);
  };

  var capitalize = function capitalize(str) {
    var cap = str[0].toUpperCase();
    return cap + str.slice(1);
  };

  Constraint.prototype = {
    validate: function validate(value, instance) {
      var _validator;

      return (_validator = this.validator).validate.apply(_validator, [value].concat(_toConsumableArray(this.requirementList), [instance]));
    },
    _parseRequirements: function _parseRequirements(options) {
      var _this9 = this;

      this.requirementList = this.validator.parseRequirements(this.requirements, function (key) {
        return options[_this9.name + capitalize(key)];
      });
    }
  };

  var Field = function Field(field, domOptions, options, parsleyFormInstance) {
    this.__class__ = 'Field';
    this.element = field;
    this.$element = $(field); // Set parent if we have one

    if ('undefined' !== typeof parsleyFormInstance) {
      this.parent = parsleyFormInstance;
    }

    this.options = options;
    this.domOptions = domOptions; // Initialize some properties

    this.constraints = [];
    this.constraintsByName = {};
    this.validationResult = true; // Bind constraints

    this._bindConstraints();
  };

  var parsley_field__statusMapping = {
    pending: null,
    resolved: true,
    rejected: false
  };
  Field.prototype = {
    // # Public API
    // Validate field and trigger some events for mainly `UI`
    // @returns `true`, an array of the validators that failed, or
    // `null` if validation is not finished. Prefer using whenValidate
    validate: function validate(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');
        options = {
          options: options
        };
      }

      var promise = this.whenValidate(options);
      if (!promise) // If excluded with `group` option
        return true;

      switch (promise.state()) {
        case 'pending':
          return null;

        case 'resolved':
          return true;

        case 'rejected':
          return this.validationResult;
      }
    },
    // Validate field and trigger some events for mainly `UI`
    // @returns a promise that succeeds only when all validations do
    // or `undefined` if field is not in the given `group`.
    whenValidate: function whenValidate() {
      var _whenValid$always$done$fail$always,
          _this10 = this;

      var _ref9 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var force = _ref9.force;
      var group = _ref9.group; // do not validate a field if not the same as given validation group

      this.refresh();
      if (group && !this._isInGroup(group)) return;
      this.value = this.getValue(); // Field Validate event. `this.value` could be altered for custom needs

      this._trigger('validate');

      return (_whenValid$always$done$fail$always = this.whenValid({
        force: force,
        value: this.value,
        _refreshed: true
      }).always(function () {
        _this10._reflowUI();
      }).done(function () {
        _this10._trigger('success');
      }).fail(function () {
        _this10._trigger('error');
      }).always(function () {
        _this10._trigger('validated');
      })).pipe.apply(_whenValid$always$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));
    },
    hasConstraints: function hasConstraints() {
      return 0 !== this.constraints.length;
    },
    // An empty optional field does not need validation
    needsValidation: function needsValidation(value) {
      if ('undefined' === typeof value) value = this.getValue(); // If a field is empty and not required, it is valid
      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators

      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty) return false;
      return true;
    },
    _isInGroup: function _isInGroup(group) {
      if (Array.isArray(this.options.group)) return -1 !== $.inArray(group, this.options.group);
      return this.options.group === group;
    },
    // Just validate field. Do not trigger any event.
    // Returns `true` iff all constraints pass, `false` if there are failures,
    // or `null` if the result can not be determined yet (depends on a promise)
    // See also `whenValid`.
    isValid: function isValid(options) {
      if (arguments.length >= 1 && !$.isPlainObject(options)) {
        Utils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');

        var _arguments3 = _slice.call(arguments);

        var force = _arguments3[0];
        var value = _arguments3[1];
        options = {
          force: force,
          value: value
        };
      }

      var promise = this.whenValid(options);
      if (!promise) // Excluded via `group`
        return true;
      return parsley_field__statusMapping[promise.state()];
    },
    // Just validate field. Do not trigger any event.
    // @returns a promise that succeeds only when all validations do
    // or `undefined` if the field is not in the given `group`.
    // The argument `force` will force validation of empty fields.
    // If a `value` is given, it will be validated instead of the value of the input.
    whenValid: function whenValid() {
      var _this11 = this;

      var _ref10 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _ref10$force = _ref10.force;
      var force = _ref10$force === undefined ? false : _ref10$force;
      var value = _ref10.value;
      var group = _ref10.group;
      var _refreshed = _ref10._refreshed; // Recompute options and rebind constraints to have latest changes

      if (!_refreshed) this.refresh(); // do not validate a field if not the same as given validation group

      if (group && !this._isInGroup(group)) return;
      this.validationResult = true; // A field without constraint is valid

      if (!this.hasConstraints()) return $.when(); // Value could be passed as argument, needed to add more power to 'field:validate'

      if ('undefined' === typeof value || null === value) value = this.getValue();
      if (!this.needsValidation(value) && true !== force) return $.when();

      var groupedConstraints = this._getGroupedConstraints();

      var promises = [];
      $.each(groupedConstraints, function (_, constraints) {
        // Process one group of constraints at a time, we validate the constraints
        // and combine the promises together.
        var promise = Utils.all($.map(constraints, function (constraint) {
          return _this11._validateConstraint(value, constraint);
        }));
        promises.push(promise);
        if (promise.state() === 'rejected') return false; // Interrupt processing if a group has already failed
      });
      return Utils.all(promises);
    },
    // @returns a promise
    _validateConstraint: function _validateConstraint(value, constraint) {
      var _this12 = this;

      var result = constraint.validate(value, this); // Map false to a failed promise

      if (false === result) result = $.Deferred().reject(); // Make sure we return a promise and that we record failures

      return Utils.all([result]).fail(function (errorMessage) {
        if (!(_this12.validationResult instanceof Array)) _this12.validationResult = [];

        _this12.validationResult.push({
          assert: constraint,
          errorMessage: 'string' === typeof errorMessage && errorMessage
        });
      });
    },
    // @returns Parsley field computed value that could be overrided or configured in DOM
    getValue: function getValue() {
      var value; // Value could be overriden in DOM or with explicit options

      if ('function' === typeof this.options.value) value = this.options.value(this);else if ('undefined' !== typeof this.options.value) value = this.options.value;else value = this.$element.val(); // Handle wrong DOM or configurations

      if ('undefined' === typeof value || null === value) return '';
      return this._handleWhitespace(value);
    },
    // Reset UI
    reset: function reset() {
      this._resetUI();

      return this._trigger('reset');
    },
    // Destroy Parsley instance (+ UI)
    destroy: function destroy() {
      // Field case: emit destroy event to clean UI and then destroy stored instance
      this._destroyUI();

      this.$element.removeData('Parsley');
      this.$element.removeData('FieldMultiple');

      this._trigger('destroy');
    },
    // Actualize options and rebind constraints
    refresh: function refresh() {
      this._refreshConstraints();

      return this;
    },
    _refreshConstraints: function _refreshConstraints() {
      return this.actualizeOptions()._bindConstraints();
    },
    refreshConstraints: function refreshConstraints() {
      Utils.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh");
      return this.refresh();
    },

    /**
    * Add a new constraint to a field
    *
    * @param {String}   name
    * @param {Mixed}    requirements      optional
    * @param {Number}   priority          optional
    * @param {Boolean}  isDomConstraint   optional
    */
    addConstraint: function addConstraint(name, requirements, priority, isDomConstraint) {
      if (window.Parsley._validatorRegistry.validators[name]) {
        var constraint = new Constraint(this, name, requirements, priority, isDomConstraint); // if constraint already exist, delete it and push new version

        if ('undefined' !== this.constraintsByName[constraint.name]) this.removeConstraint(constraint.name);
        this.constraints.push(constraint);
        this.constraintsByName[constraint.name] = constraint;
      }

      return this;
    },
    // Remove a constraint
    removeConstraint: function removeConstraint(name) {
      for (var i = 0; i < this.constraints.length; i++) {
        if (name === this.constraints[i].name) {
          this.constraints.splice(i, 1);
          break;
        }
      }

      delete this.constraintsByName[name];
      return this;
    },
    // Update a constraint (Remove + re-add)
    updateConstraint: function updateConstraint(name, parameters, priority) {
      return this.removeConstraint(name).addConstraint(name, parameters, priority);
    },
    // # Internals
    // Internal only.
    // Bind constraints from config + options + DOM
    _bindConstraints: function _bindConstraints() {
      var constraints = [];
      var constraintsByName = {}; // clean all existing DOM constraints to only keep javascript user constraints

      for (var i = 0; i < this.constraints.length; i++) {
        if (false === this.constraints[i].isDomConstraint) {
          constraints.push(this.constraints[i]);
          constraintsByName[this.constraints[i].name] = this.constraints[i];
        }
      }

      this.constraints = constraints;
      this.constraintsByName = constraintsByName; // then re-add Parsley DOM-API constraints

      for (var name in this.options) {
        this.addConstraint(name, this.options[name], undefined, true);
      } // finally, bind special HTML5 constraints


      return this._bindHtml5Constraints();
    },
    // Internal only.
    // Bind specific HTML5 constraints to be HTML5 compliant
    _bindHtml5Constraints: function _bindHtml5Constraints() {
      // html5 required
      if (null !== this.element.getAttribute('required')) this.addConstraint('required', true, undefined, true); // html5 pattern

      if (null !== this.element.getAttribute('pattern')) this.addConstraint('pattern', this.element.getAttribute('pattern'), undefined, true); // range

      var min = this.element.getAttribute('min');
      var max = this.element.getAttribute('max');
      if (null !== min && null !== max) this.addConstraint('range', [min, max], undefined, true); // HTML5 min
      else if (null !== min) this.addConstraint('min', min, undefined, true); // HTML5 max
        else if (null !== max) this.addConstraint('max', max, undefined, true); // length

      if (null !== this.element.getAttribute('minlength') && null !== this.element.getAttribute('maxlength')) this.addConstraint('length', [this.element.getAttribute('minlength'), this.element.getAttribute('maxlength')], undefined, true); // HTML5 minlength
      else if (null !== this.element.getAttribute('minlength')) this.addConstraint('minlength', this.element.getAttribute('minlength'), undefined, true); // HTML5 maxlength
        else if (null !== this.element.getAttribute('maxlength')) this.addConstraint('maxlength', this.element.getAttribute('maxlength'), undefined, true); // html5 types

      var type = Utils.getType(this.element); // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise

      if ('number' === type) {
        return this.addConstraint('type', ['number', {
          step: this.element.getAttribute('step') || '1',
          base: min || this.element.getAttribute('value')
        }], undefined, true); // Regular other HTML5 supported types
      } else if (/^(email|url|range|date)$/i.test(type)) {
        return this.addConstraint('type', type, undefined, true);
      }

      return this;
    },
    // Internal only.
    // Field is required if have required constraint without `false` value
    _isRequired: function _isRequired() {
      if ('undefined' === typeof this.constraintsByName.required) return false;
      return false !== this.constraintsByName.required.requirements;
    },
    // Internal only.
    // Shortcut to trigger an event
    _trigger: function _trigger(eventName) {
      return this.trigger('field:' + eventName);
    },
    // Internal only
    // Handles whitespace in a value
    // Use `data-parsley-whitespace="squish"` to auto squish input value
    // Use `data-parsley-whitespace="trim"` to auto trim input value
    _handleWhitespace: function _handleWhitespace(value) {
      if (true === this.options.trimValue) Utils.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"');
      if ('squish' === this.options.whitespace) value = value.replace(/\s{2,}/g, ' ');
      if ('trim' === this.options.whitespace || 'squish' === this.options.whitespace || true === this.options.trimValue) value = Utils.trimString(value);
      return value;
    },
    _isDateInput: function _isDateInput() {
      var c = this.constraintsByName.type;
      return c && c.requirements === 'date';
    },
    // Internal only.
    // Returns the constraints, grouped by descending priority.
    // The result is thus an array of arrays of constraints.
    _getGroupedConstraints: function _getGroupedConstraints() {
      if (false === this.options.priorityEnabled) return [this.constraints];
      var groupedConstraints = [];
      var index = {}; // Create array unique of priorities

      for (var i = 0; i < this.constraints.length; i++) {
        var p = this.constraints[i].priority;
        if (!index[p]) groupedConstraints.push(index[p] = []);
        index[p].push(this.constraints[i]);
      } // Sort them by priority DESC


      groupedConstraints.sort(function (a, b) {
        return b[0].priority - a[0].priority;
      });
      return groupedConstraints;
    }
  };
  var parsley_field = Field;

  var Multiple = function Multiple() {
    this.__class__ = 'FieldMultiple';
  };

  Multiple.prototype = {
    // Add new `$element` sibling for multiple field
    addElement: function addElement($element) {
      this.$elements.push($element);
      return this;
    },
    // See `Field._refreshConstraints()`
    _refreshConstraints: function _refreshConstraints() {
      var fieldConstraints;
      this.constraints = []; // Select multiple special treatment

      if (this.element.nodeName === 'SELECT') {
        this.actualizeOptions()._bindConstraints();

        return this;
      } // Gather all constraints for each input in the multiple group


      for (var i = 0; i < this.$elements.length; i++) {
        // Check if element have not been dynamically removed since last binding
        if (!$('html').has(this.$elements[i]).length) {
          this.$elements.splice(i, 1);
          continue;
        }

        fieldConstraints = this.$elements[i].data('FieldMultiple')._refreshConstraints().constraints;

        for (var j = 0; j < fieldConstraints.length; j++) {
          this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);
        }
      }

      return this;
    },
    // See `Field.getValue()`
    getValue: function getValue() {
      // Value could be overriden in DOM
      if ('function' === typeof this.options.value) return this.options.value(this);else if ('undefined' !== typeof this.options.value) return this.options.value; // Radio input case

      if (this.element.nodeName === 'INPUT') {
        var type = Utils.getType(this.element);
        if (type === 'radio') return this._findRelated().filter(':checked').val() || ''; // checkbox input case

        if (type === 'checkbox') {
          var values = [];

          this._findRelated().filter(':checked').each(function () {
            values.push($(this).val());
          });

          return values;
        }
      } // Select multiple case


      if (this.element.nodeName === 'SELECT' && null === this.$element.val()) return []; // Default case that should never happen

      return this.$element.val();
    },
    _init: function _init() {
      this.$elements = [this.$element];
      return this;
    }
  };

  var Factory = function Factory(element, options, parsleyFormInstance) {
    this.element = element;
    this.$element = $(element); // If the element has already been bound, returns its saved Parsley instance

    var savedparsleyFormInstance = this.$element.data('Parsley');

    if (savedparsleyFormInstance) {
      // If the saved instance has been bound without a Form parent and there is one given in this call, add it
      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {
        savedparsleyFormInstance.parent = parsleyFormInstance;

        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);
      }

      if ('object' === _typeof(options)) {
        _extends(savedparsleyFormInstance.options, options);
      }

      return savedparsleyFormInstance;
    } // Parsley must be instantiated with a DOM element or jQuery $element


    if (!this.$element.length) throw new Error('You must bind Parsley on an existing element.');
    if ('undefined' !== typeof parsleyFormInstance && 'Form' !== parsleyFormInstance.__class__) throw new Error('Parent instance must be a Form instance');
    this.parent = parsleyFormInstance || window.Parsley;
    return this.init(options);
  };

  Factory.prototype = {
    init: function init(options) {
      this.__class__ = 'Parsley';
      this.__version__ = '2.8.1';
      this.__id__ = Utils.generateID(); // Pre-compute options

      this._resetOptions(options); // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute


      if (this.element.nodeName === 'FORM' || Utils.checkAttr(this.element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)) return this.bind('parsleyForm'); // Every other element is bound as a `Field` or `FieldMultiple`

      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');
    },
    isMultiple: function isMultiple() {
      var type = Utils.getType(this.element);
      return type === 'radio' || type === 'checkbox' || this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple');
    },
    // Multiples fields are a real nightmare :(
    // Maybe some refactoring would be appreciated here...
    handleMultiple: function handleMultiple() {
      var _this13 = this;

      var name;
      var multiple;
      var parsleyMultipleInstance; // Handle multiple name

      this.options.multiple = this.options.multiple || (name = this.element.getAttribute('name')) || this.element.getAttribute('id'); // Special select multiple input

      if (this.element.nodeName === 'SELECT' && null !== this.element.getAttribute('multiple')) {
        this.options.multiple = this.options.multiple || this.__id__;
        return this.bind('parsleyFieldMultiple'); // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it
      } else if (!this.options.multiple) {
        Utils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);
        return this;
      } // Remove special chars


      this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ''); // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name

      if (name) {
        $('input[name="' + name + '"]').each(function (i, input) {
          var type = Utils.getType(input);
          if (type === 'radio' || type === 'checkbox') input.setAttribute(_this13.options.namespace + 'multiple', _this13.options.multiple);
        });
      } // Check here if we don't already have a related multiple instance saved


      var $previouslyRelated = this._findRelated();

      for (var i = 0; i < $previouslyRelated.length; i++) {
        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');

        if ('undefined' !== typeof parsleyMultipleInstance) {
          if (!this.$element.data('FieldMultiple')) {
            parsleyMultipleInstance.addElement(this.$element);
          }

          break;
        }
      } // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`
      // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance


      this.bind('parsleyField', true);
      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');
    },
    // Return proper `Form`, `Field` or `FieldMultiple`
    bind: function bind(type, doNotStore) {
      var parsleyInstance;

      switch (type) {
        case 'parsleyForm':
          parsleyInstance = $.extend(new Form(this.element, this.domOptions, this.options), new Base(), window.ParsleyExtend)._bindFields();
          break;

        case 'parsleyField':
          parsleyInstance = $.extend(new parsley_field(this.element, this.domOptions, this.options, this.parent), new Base(), window.ParsleyExtend);
          break;

        case 'parsleyFieldMultiple':
          parsleyInstance = $.extend(new parsley_field(this.element, this.domOptions, this.options, this.parent), new Multiple(), new Base(), window.ParsleyExtend)._init();
          break;

        default:
          throw new Error(type + 'is not a supported Parsley type');
      }

      if (this.options.multiple) Utils.setAttr(this.element, this.options.namespace, 'multiple', this.options.multiple);

      if ('undefined' !== typeof doNotStore) {
        this.$element.data('FieldMultiple', parsleyInstance);
        return parsleyInstance;
      } // Store the freshly bound instance in a DOM element for later access using jQuery `data()`


      this.$element.data('Parsley', parsleyInstance); // Tell the world we have a new Form or Field instance!

      parsleyInstance._actualizeTriggers();

      parsleyInstance._trigger('init');

      return parsleyInstance;
    }
  };
  var vernums = $.fn.jquery.split('.');

  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {
    throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.";
  }

  if (!vernums.forEach) {
    Utils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');
  } // Inherit `on`, `off` & `trigger` to Parsley:


  var Parsley = _extends(new Base(), {
    element: document,
    $element: $(document),
    actualizeOptions: null,
    _resetOptions: null,
    Factory: Factory,
    version: '2.8.1'
  }); // Supplement Field and Form with Base
  // This way, the constructors will have access to those methods


  _extends(parsley_field.prototype, UI.Field, Base.prototype);

  _extends(Form.prototype, UI.Form, Base.prototype); // Inherit actualizeOptions and _resetOptions:


  _extends(Factory.prototype, Base.prototype); // ### jQuery API
  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`


  $.fn.parsley = $.fn.psly = function (options) {
    if (this.length > 1) {
      var instances = [];
      this.each(function () {
        instances.push($(this).parsley(options));
      });
      return instances;
    } // Return undefined if applied to non existing DOM element


    if (this.length == 0) {
      return;
    }

    return new Factory(this[0], options);
  }; // ### Field and Form extension
  // Ensure the extension is now defined if it wasn't previously


  if ('undefined' === typeof window.ParsleyExtend) window.ParsleyExtend = {}; // ### Parsley config
  // Inherit from ParsleyDefault, and copy over any existing values

  Parsley.options = _extends(Utils.objectCreate(Defaults), window.ParsleyConfig);
  window.ParsleyConfig = Parsley.options; // Old way of accessing global options
  // ### Globals

  window.Parsley = window.psly = Parsley;
  Parsley.Utils = Utils;
  window.ParsleyUtils = {};
  $.each(Utils, function (key, value) {
    if ('function' === typeof value) {
      window.ParsleyUtils[key] = function () {
        Utils.warnOnce('Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.');
        return Utils[key].apply(Utils, arguments);
      };
    }
  }); // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley

  var registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);
  window.ParsleyValidator = {};
  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator'.split(' '), function (i, method) {
    window.Parsley[method] = function () {
      return registry[method].apply(registry, arguments);
    };

    window.ParsleyValidator[method] = function () {
      var _window$Parsley;

      Utils.warnOnce('Accessing the method \'' + method + '\' through Validator is deprecated. Simply call \'window.Parsley.' + method + '(...)\'');
      return (_window$Parsley = window.Parsley)[method].apply(_window$Parsley, arguments);
    };
  }); // ### UI
  // Deprecated global object

  window.Parsley.UI = UI;
  window.ParsleyUI = {
    removeError: function removeError(instance, name, doNotUpdateClass) {
      var updateClass = true !== doNotUpdateClass;
      Utils.warnOnce('Accessing UI is deprecated. Call \'removeError\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');
      return instance.removeError(name, {
        updateClass: updateClass
      });
    },
    getErrorsMessages: function getErrorsMessages(instance) {
      Utils.warnOnce('Accessing UI is deprecated. Call \'getErrorsMessages\' on the instance directly.');
      return instance.getErrorsMessages();
    }
  };
  $.each('addError updateError'.split(' '), function (i, method) {
    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {
      var updateClass = true !== doNotUpdateClass;
      Utils.warnOnce('Accessing UI is deprecated. Call \'' + method + '\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');
      return instance[method](name, {
        message: message,
        assert: assert,
        updateClass: updateClass
      });
    };
  }); // ### PARSLEY auto-binding
  // Prevent it by setting `ParsleyConfig.autoBind` to `false`

  if (false !== window.ParsleyConfig.autoBind) {
    $(function () {
      // Works only on `data-parsley-validate`.
      if ($('[data-parsley-validate]').length) $('[data-parsley-validate]').parsley();
    });
  }

  var o = $({});

  var deprecated = function deprecated() {
    Utils.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley");
  }; // Returns an event handler that calls `fn` with the arguments it expects


  function adapt(fn, context) {
    // Store to allow unbinding
    if (!fn.parsleyAdaptedCallback) {
      fn.parsleyAdaptedCallback = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift(this);
        fn.apply(context || o, args);
      };
    }

    return fn.parsleyAdaptedCallback;
  }

  var eventPrefix = 'parsley:'; // Converts 'parsley:form:validate' into 'form:validate'

  function eventName(name) {
    if (name.lastIndexOf(eventPrefix, 0) === 0) return name.substr(eventPrefix.length);
    return name;
  } // $.listen is deprecated. Use Parsley.on instead.


  $.listen = function (name, callback) {
    var context;
    deprecated();

    if ('object' === _typeof(arguments[1]) && 'function' === typeof arguments[2]) {
      context = arguments[1];
      callback = arguments[2];
    }

    if ('function' !== typeof callback) throw new Error('Wrong parameters');
    window.Parsley.on(eventName(name), adapt(callback, context));
  };

  $.listenTo = function (instance, name, fn) {
    deprecated();
    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');
    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong parameters');
    instance.on(eventName(name), adapt(fn));
  };

  $.unsubscribe = function (name, fn) {
    deprecated();
    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong arguments');
    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);
  };

  $.unsubscribeTo = function (instance, name) {
    deprecated();
    if (!(instance instanceof parsley_field) && !(instance instanceof Form)) throw new Error('Must give Parsley instance');
    instance.off(eventName(name));
  };

  $.unsubscribeAll = function (name) {
    deprecated();
    window.Parsley.off(eventName(name));
    $('form,input,textarea,select').each(function () {
      var instance = $(this).data('Parsley');

      if (instance) {
        instance.off(eventName(name));
      }
    });
  }; // $.emit is deprecated. Use jQuery events instead.


  $.emit = function (name, instance) {
    var _instance;

    deprecated();
    var instanceGiven = instance instanceof parsley_field || instance instanceof Form;
    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);
    args.unshift(eventName(name));

    if (!instanceGiven) {
      instance = window.Parsley;
    }

    (_instance = instance).trigger.apply(_instance, _toConsumableArray(args));
  };

  var pubsub = {};
  $.extend(true, Parsley, {
    asyncValidators: {
      'default': {
        fn: function fn(xhr) {
          // By default, only status 2xx are deemed successful.
          // Note: we use status instead of state() because responses with status 200
          // but invalid messages (e.g. an empty body for content type set to JSON) will
          // result in state() === 'rejected'.
          return xhr.status >= 200 && xhr.status < 300;
        },
        url: false
      },
      reverse: {
        fn: function fn(xhr) {
          // If reverse option is set, a failing ajax request is considered successful
          return xhr.status < 200 || xhr.status >= 300;
        },
        url: false
      }
    },
    addAsyncValidator: function addAsyncValidator(name, fn, url, options) {
      Parsley.asyncValidators[name] = {
        fn: fn,
        url: url || false,
        options: options || {}
      };
      return this;
    }
  });
  Parsley.addValidator('remote', {
    requirementType: {
      '': 'string',
      'validator': 'string',
      'reverse': 'boolean',
      'options': 'object'
    },
    validateString: function validateString(value, url, options, instance) {
      var data = {};
      var ajaxOptions;
      var csr;
      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');
      if ('undefined' === typeof Parsley.asyncValidators[validator]) throw new Error('Calling an undefined async validator: `' + validator + '`');
      url = Parsley.asyncValidators[validator].url || url; // Fill current value

      if (url.indexOf('{value}') > -1) {
        url = url.replace('{value}', encodeURIComponent(value));
      } else {
        data[instance.element.getAttribute('name') || instance.element.getAttribute('id')] = value;
      } // Merge options passed in from the function with the ones in the attribute


      var remoteOptions = $.extend(true, options.options || {}, Parsley.asyncValidators[validator].options); // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`

      ajaxOptions = $.extend(true, {}, {
        url: url,
        data: data,
        type: 'GET'
      }, remoteOptions); // Generate store key based on ajax options

      instance.trigger('field:ajaxoptions', instance, ajaxOptions);
      csr = $.param(ajaxOptions); // Initialise querry cache

      if ('undefined' === typeof Parsley._remoteCache) Parsley._remoteCache = {}; // Try to retrieve stored xhr

      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);

      var handleXhr = function handleXhr() {
        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);
        if (!result) // Map falsy results to rejected promise
          result = $.Deferred().reject();
        return $.when(result);
      };

      return xhr.then(handleXhr, handleXhr);
    },
    priority: -1
  });
  Parsley.on('form:submit', function () {
    Parsley._remoteCache = {};
  });

  Base.prototype.addAsyncValidator = function () {
    Utils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');
    return Parsley.addAsyncValidator.apply(Parsley, arguments);
  }; // This is included with the Parsley library itself,
  // thus there is no use in adding it to your project.


  Parsley.addMessages('en', {
    defaultMessage: "This value seems to be invalid.",
    type: {
      email: "This value should be a valid email.",
      url: "This value should be a valid url.",
      number: "This value should be a valid number.",
      integer: "This value should be a valid integer.",
      digits: "This value should be digits.",
      alphanum: "This value should be alphanumeric."
    },
    notblank: "This value should not be blank.",
    required: "This value is required.",
    pattern: "This value seems to be invalid.",
    min: "This value should be greater than or equal to %s.",
    max: "This value should be lower than or equal to %s.",
    range: "This value should be between %s and %s.",
    minlength: "This value is too short. It should have %s characters or more.",
    maxlength: "This value is too long. It should have %s characters or fewer.",
    length: "This value length is invalid. It should be between %s and %s characters long.",
    mincheck: "You must select at least %s choices.",
    maxcheck: "You must select %s choices or fewer.",
    check: "You must select between %s and %s choices.",
    equalto: "This value should be the same."
  });
  Parsley.setLocale('en');
  /**
   * inputevent - Alleviate browser bugs for input events
   * https://github.com/marcandre/inputevent
   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)
   * @author Marc-Andre Lafortune <github@marc-andre.ca>
   * @license MIT
   */

  function InputEvent() {
    var _this14 = this;

    var globals = window || global; // Slightly odd way construct our object. This way methods are force bound.
    // Used to test for duplicate library.

    _extends(this, {
      // For browsers that do not support isTrusted, assumes event is native.
      isNativeEvent: function isNativeEvent(evt) {
        return evt.originalEvent && evt.originalEvent.isTrusted !== false;
      },
      fakeInputEvent: function fakeInputEvent(evt) {
        if (_this14.isNativeEvent(evt)) {
          $(evt.target).trigger('input');
        }
      },
      misbehaves: function misbehaves(evt) {
        if (_this14.isNativeEvent(evt)) {
          _this14.behavesOk(evt);

          $(document).on('change.inputevent', evt.data.selector, _this14.fakeInputEvent);

          _this14.fakeInputEvent(evt);
        }
      },
      behavesOk: function behavesOk(evt) {
        if (_this14.isNativeEvent(evt)) {
          $(document) // Simply unbinds the testing handler
          .off('input.inputevent', evt.data.selector, _this14.behavesOk).off('change.inputevent', evt.data.selector, _this14.misbehaves);
        }
      },
      // Bind the testing handlers
      install: function install() {
        if (globals.inputEventPatched) {
          return;
        }

        globals.inputEventPatched = '0.0.3';
        var _arr = ['select', 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]'];

        for (var _i = 0; _i < _arr.length; _i++) {
          var selector = _arr[_i];
          $(document).on('input.inputevent', selector, {
            selector: selector
          }, _this14.behavesOk).on('change.inputevent', selector, {
            selector: selector
          }, _this14.misbehaves);
        }
      },
      uninstall: function uninstall() {
        delete globals.inputEventPatched;
        $(document).off('.inputevent');
      }
    });
  }

  ;
  var inputevent = new InputEvent();
  inputevent.install();
  var parsley = Parsley;
  return parsley;
});

(function (window, factory) {
  var lazySizes = factory(window, window.document);
  window.lazySizes = lazySizes;

  if (( false ? undefined : _typeof(module)) == 'object' && module.exports) {
    module.exports = lazySizes;
  }
})(window, function l(window, document) {
  'use strict';
  /*jshint eqnull:true */

  if (!document.getElementsByClassName) {
    return;
  }

  var lazysizes, lazySizesConfig;
  var docElem = document.documentElement;
  var Date = window.Date;
  var supportPicture = window.HTMLPictureElement;
  var _addEventListener = 'addEventListener';
  var _getAttribute = 'getAttribute';
  var addEventListener = window[_addEventListener];
  var setTimeout = window.setTimeout;
  var requestAnimationFrame = window.requestAnimationFrame || setTimeout;
  var requestIdleCallback = window.requestIdleCallback;
  var regPicture = /^picture$/i;
  var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];
  var regClassCache = {};
  var forEach = Array.prototype.forEach;

  var hasClass = function hasClass(ele, cls) {
    if (!regClassCache[cls]) {
      regClassCache[cls] = new RegExp('(\\s|^)' + cls + '(\\s|$)');
    }

    return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
  };

  var addClass = function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
      ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
    }
  };

  var removeClass = function removeClass(ele, cls) {
    var reg;

    if (reg = hasClass(ele, cls)) {
      ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
    }
  };

  var addRemoveLoadEvents = function addRemoveLoadEvents(dom, fn, add) {
    var action = add ? _addEventListener : 'removeEventListener';

    if (add) {
      addRemoveLoadEvents(dom, fn);
    }

    loadEvents.forEach(function (evt) {
      dom[action](evt, fn);
    });
  };

  var triggerEvent = function triggerEvent(elem, name, detail, noBubbles, noCancelable) {
    var event = document.createEvent('Event');

    if (!detail) {
      detail = {};
    }

    detail.instance = lazysizes;
    event.initEvent(name, !noBubbles, !noCancelable);
    event.detail = detail;
    elem.dispatchEvent(event);
    return event;
  };

  var updatePolyfill = function updatePolyfill(el, full) {
    var polyfill;

    if (!supportPicture && (polyfill = window.picturefill || lazySizesConfig.pf)) {
      if (full && full.src && !el[_getAttribute]('srcset')) {
        el.setAttribute('srcset', full.src);
      }

      polyfill({
        reevaluate: true,
        elements: [el]
      });
    } else if (full && full.src) {
      el.src = full.src;
    }
  };

  var getCSS = function getCSS(elem, style) {
    return (getComputedStyle(elem, null) || {})[style];
  };

  var getWidth = function getWidth(elem, parent, width) {
    width = width || elem.offsetWidth;

    while (width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth) {
      width = parent.offsetWidth;
      parent = parent.parentNode;
    }

    return width;
  };

  var rAF = function () {
    var running, waiting;
    var firstFns = [];
    var secondFns = [];
    var fns = firstFns;

    var run = function run() {
      var runFns = fns;
      fns = firstFns.length ? secondFns : firstFns;
      running = true;
      waiting = false;

      while (runFns.length) {
        runFns.shift()();
      }

      running = false;
    };

    var rafBatch = function rafBatch(fn, queue) {
      if (running && !queue) {
        fn.apply(this, arguments);
      } else {
        fns.push(fn);

        if (!waiting) {
          waiting = true;
          (document.hidden ? setTimeout : requestAnimationFrame)(run);
        }
      }
    };

    rafBatch._lsFlush = run;
    return rafBatch;
  }();

  var rAFIt = function rAFIt(fn, simple) {
    return simple ? function () {
      rAF(fn);
    } : function () {
      var that = this;
      var args = arguments;
      rAF(function () {
        fn.apply(that, args);
      });
    };
  };

  var throttle = function throttle(fn) {
    var running;
    var lastTime = 0;
    var gDelay = lazySizesConfig.throttleDelay;
    var rICTimeout = lazySizesConfig.ricTimeout;

    var run = function run() {
      running = false;
      lastTime = Date.now();
      fn();
    };

    var idleCallback = requestIdleCallback && rICTimeout > 49 ? function () {
      requestIdleCallback(run, {
        timeout: rICTimeout
      });

      if (rICTimeout !== lazySizesConfig.ricTimeout) {
        rICTimeout = lazySizesConfig.ricTimeout;
      }
    } : rAFIt(function () {
      setTimeout(run);
    }, true);
    return function (isPriority) {
      var delay;

      if (isPriority = isPriority === true) {
        rICTimeout = 33;
      }

      if (running) {
        return;
      }

      running = true;
      delay = gDelay - (Date.now() - lastTime);

      if (delay < 0) {
        delay = 0;
      }

      if (isPriority || delay < 9) {
        idleCallback();
      } else {
        setTimeout(idleCallback, delay);
      }
    };
  }; //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html


  var debounce = function debounce(func) {
    var timeout, timestamp;
    var wait = 99;

    var run = function run() {
      timeout = null;
      func();
    };

    var later = function later() {
      var last = Date.now() - timestamp;

      if (last < wait) {
        setTimeout(later, wait - last);
      } else {
        (requestIdleCallback || run)(run);
      }
    };

    return function () {
      timestamp = Date.now();

      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
    };
  };

  (function () {
    var prop;
    var lazySizesDefaults = {
      lazyClass: 'lazyload',
      loadedClass: 'lazyloaded',
      loadingClass: 'lazyloading',
      preloadClass: 'lazypreload',
      errorClass: 'lazyerror',
      //strictClass: 'lazystrict',
      autosizesClass: 'lazyautosizes',
      srcAttr: 'data-src',
      srcsetAttr: 'data-srcset',
      sizesAttr: 'data-sizes',
      //preloadAfterLoad: false,
      minSize: 40,
      customMedia: {},
      init: true,
      expFactor: 1.5,
      hFac: 0.8,
      loadMode: 2,
      loadHidden: true,
      ricTimeout: 0,
      throttleDelay: 125
    };
    lazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};

    for (prop in lazySizesDefaults) {
      if (!(prop in lazySizesConfig)) {
        lazySizesConfig[prop] = lazySizesDefaults[prop];
      }
    }

    window.lazySizesConfig = lazySizesConfig;
    setTimeout(function () {
      if (lazySizesConfig.init) {
        init();
      }
    });
  })();

  var loader = function () {
    var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;
    var eLvW, elvH, eLtop, eLleft, eLright, eLbottom;
    var defaultExpand, preloadExpand, hFac;
    var regImg = /^img$/i;
    var regIframe = /^iframe$/i;
    var supportScroll = 'onscroll' in window && !/(gle|ing)bot/.test(navigator.userAgent);
    var shrinkExpand = 0;
    var currentExpand = 0;
    var isLoading = 0;
    var lowRuns = -1;

    var resetPreloading = function resetPreloading(e) {
      isLoading--;

      if (e && e.target) {
        addRemoveLoadEvents(e.target, resetPreloading);
      }

      if (!e || isLoading < 0 || !e.target) {
        isLoading = 0;
      }
    };

    var isNestedVisible = function isNestedVisible(elem, elemExpand) {
      var outerRect;
      var parent = elem;
      var visible = getCSS(document.body, 'visibility') == 'hidden' || getCSS(elem.parentNode, 'visibility') != 'hidden' && getCSS(elem, 'visibility') != 'hidden';
      eLtop -= elemExpand;
      eLbottom += elemExpand;
      eLleft -= elemExpand;
      eLright += elemExpand;

      while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {
        visible = (getCSS(parent, 'opacity') || 1) > 0;

        if (visible && getCSS(parent, 'overflow') != 'visible') {
          outerRect = parent.getBoundingClientRect();
          visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;
        }
      }

      return visible;
    };

    var checkElements = function checkElements() {
      var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal;
      var lazyloadElems = lazysizes.elements;

      if ((loadMode = lazySizesConfig.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
        i = 0;
        lowRuns++;

        if (preloadExpand == null) {
          if (!('expand' in lazySizesConfig)) {
            lazySizesConfig.expand = docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370;
          }

          defaultExpand = lazySizesConfig.expand;
          preloadExpand = defaultExpand * lazySizesConfig.expFactor;
        }

        if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden) {
          currentExpand = preloadExpand;
          lowRuns = 0;
        } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
          currentExpand = defaultExpand;
        } else {
          currentExpand = shrinkExpand;
        }

        for (; i < eLlen; i++) {
          if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
            continue;
          }

          if (!supportScroll) {
            unveilElement(lazyloadElems[i]);
            continue;
          }

          if (!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)) {
            elemExpand = currentExpand;
          }

          if (beforeExpandVal !== elemExpand) {
            eLvW = innerWidth + elemExpand * hFac;
            elvH = innerHeight + elemExpand;
            elemNegativeExpand = elemExpand * -1;
            beforeExpandVal = elemExpand;
          }

          rect = lazyloadElems[i].getBoundingClientRect();

          if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesConfig.loadHidden || getCSS(lazyloadElems[i], 'visibility') != 'hidden') && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i], elemExpand))) {
            unveilElement(lazyloadElems[i]);
            loadedSomething = true;

            if (isLoading > 9) {
              break;
            }
          } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesConfig.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || lazyloadElems[i][_getAttribute](lazySizesConfig.sizesAttr) != 'auto'))) {
            autoLoadElem = preloadElems[0] || lazyloadElems[i];
          }
        }

        if (autoLoadElem && !loadedSomething) {
          unveilElement(autoLoadElem);
        }
      }
    };

    var throttledCheckElements = throttle(checkElements);

    var switchLoadingClass = function switchLoadingClass(e) {
      addClass(e.target, lazySizesConfig.loadedClass);
      removeClass(e.target, lazySizesConfig.loadingClass);
      addRemoveLoadEvents(e.target, rafSwitchLoadingClass);
      triggerEvent(e.target, 'lazyloaded');
    };

    var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);

    var rafSwitchLoadingClass = function rafSwitchLoadingClass(e) {
      rafedSwitchLoadingClass({
        target: e.target
      });
    };

    var changeIframeSrc = function changeIframeSrc(elem, src) {
      try {
        elem.contentWindow.location.replace(src);
      } catch (e) {
        elem.src = src;
      }
    };

    var handleSources = function handleSources(source) {
      var customMedia;

      var sourceSrcset = source[_getAttribute](lazySizesConfig.srcsetAttr);

      if (customMedia = lazySizesConfig.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) {
        source.setAttribute('media', customMedia);
      }

      if (sourceSrcset) {
        source.setAttribute('srcset', sourceSrcset);
      }
    };

    var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg) {
      var src, srcset, parent, isPicture, event, firesLoad;

      if (!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented) {
        if (sizes) {
          if (isAuto) {
            addClass(elem, lazySizesConfig.autosizesClass);
          } else {
            elem.setAttribute('sizes', sizes);
          }
        }

        srcset = elem[_getAttribute](lazySizesConfig.srcsetAttr);
        src = elem[_getAttribute](lazySizesConfig.srcAttr);

        if (isImg) {
          parent = elem.parentNode;
          isPicture = parent && regPicture.test(parent.nodeName || '');
        }

        firesLoad = detail.firesLoad || 'src' in elem && (srcset || src || isPicture);
        event = {
          target: elem
        };

        if (firesLoad) {
          addRemoveLoadEvents(elem, resetPreloading, true);
          clearTimeout(resetPreloadingTimer);
          resetPreloadingTimer = setTimeout(resetPreloading, 2500);
          addClass(elem, lazySizesConfig.loadingClass);
          addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
        }

        if (isPicture) {
          forEach.call(parent.getElementsByTagName('source'), handleSources);
        }

        if (srcset) {
          elem.setAttribute('srcset', srcset);
        } else if (src && !isPicture) {
          if (regIframe.test(elem.nodeName)) {
            changeIframeSrc(elem, src);
          } else {
            elem.src = src;
          }
        }

        if (isImg && (srcset || isPicture)) {
          updatePolyfill(elem, {
            src: src
          });
        }
      }

      if (elem._lazyRace) {
        delete elem._lazyRace;
      }

      removeClass(elem, lazySizesConfig.lazyClass);
      rAF(function () {
        if (!firesLoad || elem.complete && elem.naturalWidth > 1) {
          if (firesLoad) {
            resetPreloading(event);
          } else {
            isLoading--;
          }

          switchLoadingClass(event);
        }
      }, true);
    });

    var unveilElement = function unveilElement(elem) {
      var detail;
      var isImg = regImg.test(elem.nodeName); //allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")

      var sizes = isImg && (elem[_getAttribute](lazySizesConfig.sizesAttr) || elem[_getAttribute]('sizes'));

      var isAuto = sizes == 'auto';

      if ((isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesConfig.errorClass) && hasClass(elem, lazySizesConfig.lazyClass)) {
        return;
      }

      detail = triggerEvent(elem, 'lazyunveilread').detail;

      if (isAuto) {
        autoSizer.updateElem(elem, true, elem.offsetWidth);
      }

      elem._lazyRace = true;
      isLoading++;
      lazyUnveil(elem, detail, isAuto, sizes, isImg);
    };

    var onload = function onload() {
      if (isCompleted) {
        return;
      }

      if (Date.now() - started < 999) {
        setTimeout(onload, 999);
        return;
      }

      var afterScroll = debounce(function () {
        lazySizesConfig.loadMode = 3;
        throttledCheckElements();
      });
      isCompleted = true;
      lazySizesConfig.loadMode = 3;
      throttledCheckElements();
      addEventListener('scroll', function () {
        if (lazySizesConfig.loadMode == 3) {
          lazySizesConfig.loadMode = 2;
        }

        afterScroll();
      }, true);
    };

    return {
      _: function _() {
        started = Date.now();
        lazysizes.elements = document.getElementsByClassName(lazySizesConfig.lazyClass);
        preloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass + ' ' + lazySizesConfig.preloadClass);
        hFac = lazySizesConfig.hFac;
        addEventListener('scroll', throttledCheckElements, true);
        addEventListener('resize', throttledCheckElements, true);

        if (window.MutationObserver) {
          new MutationObserver(throttledCheckElements).observe(docElem, {
            childList: true,
            subtree: true,
            attributes: true
          });
        } else {
          docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);

          docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);

          setInterval(throttledCheckElements, 999);
        }

        addEventListener('hashchange', throttledCheckElements, true); //, 'fullscreenchange'

        ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend', 'webkitAnimationEnd'].forEach(function (name) {
          document[_addEventListener](name, throttledCheckElements, true);
        });

        if (/d$|^c/.test(document.readyState)) {
          onload();
        } else {
          addEventListener('load', onload);

          document[_addEventListener]('DOMContentLoaded', throttledCheckElements);

          setTimeout(onload, 20000);
        }

        if (lazysizes.elements.length) {
          checkElements();

          rAF._lsFlush();
        } else {
          throttledCheckElements();
        }
      },
      checkElems: throttledCheckElements,
      unveil: unveilElement
    };
  }();

  var autoSizer = function () {
    var autosizesElems;
    var sizeElement = rAFIt(function (elem, parent, event, width) {
      var sources, i, len;
      elem._lazysizesWidth = width;
      width += 'px';
      elem.setAttribute('sizes', width);

      if (regPicture.test(parent.nodeName || '')) {
        sources = parent.getElementsByTagName('source');

        for (i = 0, len = sources.length; i < len; i++) {
          sources[i].setAttribute('sizes', width);
        }
      }

      if (!event.detail.dataAttr) {
        updatePolyfill(elem, event.detail);
      }
    });

    var getSizeElement = function getSizeElement(elem, dataAttr, width) {
      var event;
      var parent = elem.parentNode;

      if (parent) {
        width = getWidth(elem, parent, width);
        event = triggerEvent(elem, 'lazybeforesizes', {
          width: width,
          dataAttr: !!dataAttr
        });

        if (!event.defaultPrevented) {
          width = event.detail.width;

          if (width && width !== elem._lazysizesWidth) {
            sizeElement(elem, parent, event, width);
          }
        }
      }
    };

    var updateElementsSizes = function updateElementsSizes() {
      var i;
      var len = autosizesElems.length;

      if (len) {
        i = 0;

        for (; i < len; i++) {
          getSizeElement(autosizesElems[i]);
        }
      }
    };

    var debouncedUpdateElementsSizes = debounce(updateElementsSizes);
    return {
      _: function _() {
        autosizesElems = document.getElementsByClassName(lazySizesConfig.autosizesClass);
        addEventListener('resize', debouncedUpdateElementsSizes);
      },
      checkElems: debouncedUpdateElementsSizes,
      updateElem: getSizeElement
    };
  }();

  var init = function init() {
    if (!init.i) {
      init.i = true;

      autoSizer._();

      loader._();
    }
  };

  lazysizes = {
    cfg: lazySizesConfig,
    autoSizer: autoSizer,
    loader: loader,
    init: init,
    uP: updatePolyfill,
    aC: addClass,
    rC: removeClass,
    hC: hasClass,
    fire: triggerEvent,
    gW: getWidth,
    rAF: rAF
  };
  return lazysizes;
}); //
// Passive option for event listeners
// --------------------------------------------------
// Feature detection for addEventListener's 'passive' option.
// Allows for conditional setting of the third argument in an event listener.
// --------------------------------------------------
// Example usage:
// el.addEventListener('click', function(){...}, passiveEventListenerOptionSupported ? { passive: true } : false);
// --------------------------------------------------


var passiveEventListenerOptionSupported = false;

try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get() {
      passiveEventListenerOptionSupported = true;
    }
  });
  window.addEventListener("testPassiveOption", null, opts);
  window.removeEventListener("testPassiveOption", null, opts);
} catch (err) {} //
// Remove the scrolling increment/decrement behavior from number input elements
// --------------------------------------------------


document.addEventListener("wheel", function (event) {
  if (document.activeElement.type === "number") {
    document.activeElement.blur();
  }
}, passiveEventListenerOptionSupported ? {
  passive: true
} : false); //
// Exclude hidden elements from Parsley
// --------------------------------------------------

if (typeof Parsley !== 'undefined' && typeof Parsley.options !== 'undefined') {
  Parsley.options.excluded = 'input[type=button], input[type=submit], input[type=reset], input[type=hidden], [disabled], :hidden';
} //
// DOM loaded body class
// --------------------------------------------------
// When the page is loaded, add & remove classes from the body element
// --------------------------------------------------
// H/t to https://www.sitepoint.com/jquery-document-ready-plain-javascript/
// --------------------------------------------------


var domLoadedCallback = function domLoadedCallback() {
  document.body.classList.add('dom-has-loaded');
  document.body.classList.remove('dom-not-yet-loaded');
};

if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
  domLoadedCallback();
} else {
  document.addEventListener("DOMContentLoaded", domLoadedCallback);
} //
// Dispatcher.js
// v0.4.4
// ----------------------------------------------------------------------------
// Create actions & reactions in markup
// ----------------------------------------------------------------------------
// TODO
// - Change data-dispatcher-notify to accept an array of IDs to notify
// - Allow customization of .is-dispatcher-notified class name (for multiple uses of dispatcher)
// - Separate trigger, target, and notified dispatch into 3 functions?
// - Add a callback when dispatch is completed?
// - Rewrite in Vanilla JS (for event delegation, see https://gomakethings.com/checking-event-target-selectors-with-event-bubbling-in-vanilla-javascript/)
// ----------------------------------------------------------------------------
// Functions
// --------------------------------------------------


function clickDispatch(trigger) {
  // Feedback to the trigger element
  // --------------------------
  // if an attribute data-dispatcher-trigger-active-class __exists and has a value__
  if (trigger.attr("data-dispatcher-trigger-active-class")) {
    var $custom_trigger_class = trigger.data("dispatcher-trigger-active-class");
    trigger.toggleClass($custom_trigger_class);
  } else {
    // Toggle active class
    trigger.toggleClass("is-active");
  } // Toggle selected ARIA attributes if they exist


  if (trigger.attr("aria-pressed")) {
    var hasAriaPressedAttr = true;
  }

  if (trigger.attr("aria-expanded")) {
    var hasAriaExpandedAttr = true;
  }

  if (hasAriaPressedAttr) {
    trigger.attr("aria-pressed", trigger.attr("aria-pressed") == "false" ? true : false);
  }

  if (hasAriaExpandedAttr) {
    trigger.attr("aria-expanded", trigger.attr("aria-expanded") == "false" ? true : false);
  } // Notified element dispatch
  // --------------------------
  // If an element is to be notified (a value is given in the attribute),
  // notify it/them with toggled class "is-dispatching"


  if (trigger.attr("data-dispatcher-notify")) {
    var $notify_class = "." + trigger.data("dispatcher-notify");
    $($notify_class).toggleClass("is-dispatcher-notified");
  } // Target element dispatch
  // --------------------------
  // Get the targeted element via data-attribute


  var target = "#" + trigger.data("dispatcher-target");
  target = $(target); // if an attribute data-dispatcher-target-active-class __exists and has a value__

  if (trigger.attr("data-dispatcher-target-active-class")) {
    var $custom_target_class = trigger.data("dispatcher-target-active-class");
    target.toggleClass($custom_target_class);
  } else {
    target.toggleClass("is-active");
  } // ARIA attributes to flip


  target.attr("aria-hidden", target.attr("aria-hidden") == "false" ? true : false); // "One at a time, siblings" dispatch
  // --------------------------
  // For when only one child may be active at a time. (Like an accordion!)
  // --------------------------

  if (trigger.attr("data-dispatcher-parent")) {
    // Get the targeted element via data-attribute
    var $parent = "#" + trigger.data("dispatcher-parent"); // These may _seem_ reversed, but note that at the top of this function, the is-active class is toggled. So at this point, we're not checking "if the trigger had is-active before click", but "if the trigger has is-active now that it has been clicked".

    if (trigger.hasClass("is-active")) {
      $($parent).addClass("has-dispatched-active-child");
    } else {
      $($parent).removeClass("has-dispatched-active-child");
    }

    trigger.siblings(".dispatcher-trigger").removeClass("is-active");
  }
} // Logic
// --------------------------------------------------


$(document).ready(function () {
  // listen for a click or keydown event on elements with .dispatch-trigger. keydown is needed because some elements that are not native <button> or <a> elements  yet have tabindex="0" added allowing for keyboard access  need to receive a spacebar key press or return key press
  $("body").on("click keydown", ".dispatcher-trigger", function (event) {
    // Check if the event is either a click, a spacebar press, or a return press
    if (event.type === "click" || event.which == 13 || event.which == 32) {
      // restricts the "overpowered" preventDefault action ONLY to a direct click/keydown on .dispatch-triger element
      //   - this retains blocking of default actions when the trigger is an anchor itself
      //   - but allows child a, input, button, label, etc. to retain their functionality
      if (event.target === event.currentTarget) {
        // Prevent default click actions
        event.preventDefault();
      } // Fire the main function


      clickDispatch($(this));
    }
  });
}); //
// Perch Navigation / Menu System
// --------------------------------------------------
// Variables defined in perch-core-scripts.js
// --------------------------------------------------
// Variables
// ---------------------------------------

var $global_header = $('#global-header'),
    $nav_outer_wrapper = $('#global-outer-navigation-wrapper'),
    // $nav_parent      = $('.global-nav-item--has-children'),
$nav_active_parent = $('.global-nav-item--has-children.active-parent'),
    // $nav_parent_link     = $('.global-nav-item--has-children > .global-nav-link'),
$nav_child = $('.global-nav-child-list'),
    $nav_reveal_button = $('.hamburger-menu-button'); // Functions
// ---------------------------------------
// Mobile nav opening
// --------------------------

function openMobileNav() {
  $('html').addClass('mobile-nav-is-open is-mobile-scroll-locked');
  $nav_reveal_button.addClass('is-active').attr('aria-expanded', 'true').attr('aria-pressed', 'true');
  $nav_outer_wrapper.addClass('is-active');
  $global_header.addClass('mobile-nav-is-open');
} // Navigation opening
// --------------------------
// Opens the menu for both mobile and desktop.
// Also can accept an argument to open a specific child menu.
//  > Could be used to open the navigation by clicking a link or button on the page.
//  > Was once used on WMU/WordlCrafts sidebar
// --------------------------


function openNav(the_menu) {
  // Use interpolation to take the passed child menu name and then select it below
  var interpolated_selector = ".menu-" + the_menu;
  $(interpolated_selector).focus().addClass('is-open submenu-is-open');
  $(interpolated_selector).children($nav_child).addClass('is-open');
  $(interpolated_selector).children('.child-nav-opener').addClass('is-active'); // Feedback to the body: a child menu is open. Allows for making a backdrop show up over the content/beneath the menu.
  // $('body').addClass('child-menu-is-open');

  openMobileNav();

  if ($nav_outer_wrapper.hasClass('navigation-drawer-wrapper')) {
    drawerListenForClosingSwipe();
  }
} // Navigation closing
// --------------------------


function closeNav(closeNavMilliseconds) {
  $('html').removeClass('mobile-nav-is-open is-mobile-scroll-locked');
  $nav_outer_wrapper.addClass('animating-out');
  $nav_reveal_button.removeClass('is-active').attr('aria-expanded', 'false').attr('aria-pressed', 'false');
  $global_header.removeClass('mobile-nav-is-open'); // Close megamenus for mobile...before animation is finished

  $('.global-nav-item').removeClass('is-open submenu-is-open submenu-is-mobile-open');
  $('body').removeClass('child-menu-is-open'); // if a custom timeout is passed, 

  milliseconds = closeNavMilliseconds >= 0 ? closeNavMilliseconds : 250;
  var nav_close_timer = setTimeout(function () {
    // Close megamenus for mobile...after animation is finished
    $('.child-nav-opener').removeClass('is-active');
    $nav_child.removeClass('is-open');
    $nav_outer_wrapper.removeClass('is-active');
    $nav_outer_wrapper.removeClass('animating-out');
  }, milliseconds); // also close the search

  if (typeof closeSearch === 'function') {
    closeSearch();
  } // if a drawer, pass the false value to remove the swipe event listeners


  if ($nav_outer_wrapper.hasClass('navigation-drawer-wrapper')) {
    drawerListenForClosingSwipe(false);
  }

  return false;
} // Logic
// ---------------------------------------
// Navigation
// --------------------------
// Close the menu if it's currently active. Otherwise: run openNav function.


$nav_reveal_button.on('click keydown', function (e) {
  if (e.type == 'click' || e.keyCode == 32) {
    e.preventDefault();

    if ($(this).hasClass('is-active')) {
      closeNav();
      this.blur(); // Remove the focus from the button so :focus styles don't show on touch screens
    } else {
      openNav();
    }
  }
}); //
// Child Nav Open With Parent Click
// --------------------------------------------------
// If a nav link set to open its child is clicked,
// open the child menu.
// --------------------------------------------------
// Assumes an integration with:
// - navigation-system.js
// --------------------------------------------------
// Do not use alongside child-nav-open-with-generated-button.js
// --------------------------------------------------
// Variables
// ---------------------------------------

var $nav_link_opens_child = $('.global-nav-item--opens-child > .global-nav-link'); // ---------------------------------------
// Logic
// ---------------------------------------

$nav_link_opens_child.click(function (e) {
  // Prevent link from being followed
  e.preventDefault(); // set the parent

  var $the_parent = $(this).parent(); // remove is-open class if it's already there

  if ($the_parent.hasClass('submenu-is-open') || $the_parent.hasClass('submenu-is-mobile-open')) {
    $the_parent.removeClass('submenu-is-open submenu-is-mobile-open').children('.global-nav-child-list').removeClass('is-open');
    $(this).blur();
  } // otherwise, add it
  else {
      $the_parent.addClass('submenu-is-open').children('.global-nav-child-list').addClass('is-open');
    }
}); //
// Modal Search System
// --------------------------------------------------
// Variables defined in perch-core-scripts.js
// --------------------------------------------------
// Variables
// ---------------------------------------

var $search_reveal_button = $('.global-search-reveal-button'),
    $search_menu = $('#global-search-overlay'),
    $search_input = $('#global-search-overlay__input'),
    $search_submit = $('#global-search-overlay__submit'),
    $search_close_btn = $('#global-search-overlay__close-button'),
    // Global standard for triggering search.
// Example usage: rather than embed an additional search form input and submit on a 404 page, add a link or button with this class that summons the site search.
// If not using functionality in the modal search system, write something similar using this class name and variable.
$search_trigger = $('.global-search-trigger'); // ---------------------------------------
// Functions
// ---------------------------------------
// Search opening
// --------------------------

function openSearch() {
  // First, make the link highlighted & show the menu
  $search_reveal_button.addClass('is-active').attr('aria-expanded', 'true').attr('aria-pressed', 'true');
  $search_menu.addClass('is-active'); // Then, select the input field

  $search_input.select();
} // Search closing
// --------------------------


function closeSearch() {
  // Remove classes to the menu and the link
  // $(this).offsetWidth = $(this).offsetWidth;
  $search_menu.addClass('animating-out');
  setTimeout(function () {
    $search_reveal_button.removeClass('is-active').attr('aria-expanded', 'false').attr('aria-pressed', 'false');
    $search_menu.removeClass('is-active');
    $search_menu.removeClass('animating-out');
  }, 250);
  return false;
}

; // Logic
// ---------------------------------------
// Close the menu if it's currently active. Otherwise: run openSearch function.

$search_reveal_button.click(function () {
  if ($(this).hasClass('is-active')) {
    closeSearch();
  } else {
    openSearch();
  }
}); // Open the search menu if any anchor with a certain class is clicked

$search_trigger.click(function () {
  // if the selected search trigger is also a search reveal button, abort this function
  if ($(this).is($search_reveal_button)) {
    return false;
  } // Add classes to the menu and the link


  $search_reveal_button.addClass('is-active');
  $search_menu.addClass('is-active'); // Focus the search input

  $(this).blur();
  $search_input.select();
  return false;
}); // Clicking anywhere in the search's background overlay  except within the actual form  closes the overlay

$search_menu.click(closeSearch); // ...Do not close if the click is inside the inner container.

$('.global-search-overlay__inner').click(function (event) {
  event.stopPropagation();
});
$search_close_btn.click(closeSearch); // Search keyboard assist: when search menu is open, keep focus within the search menu
// by focusing "back to" the corner closer button, which allows the user to close if desired,
// or continue to the next focusable field, the input itself

$search_close_btn.on('focusout', function () {
  $search_input.focus();
}); //
// Keyboard shortcuts with MouseTrap.js
// --------------------------------------------------
// Assumes an integration with:
// - navigation-system.js
// - modal-search-system.js
// --------------------------------------------------
// open search

Mousetrap.bind('/', function (e) {
  if (typeof openSearch == 'function' && $search_menu.length) {
    // If the search menu is already open, nevermind, let the `/` through...
    if ($search_menu.hasClass('is-active')) {
      return true;
    } // But if it's not already open, capture the `/` and open the menu
    else {
        // Prevent '/' char from being typed into the newly-focused search field
        e.preventDefault();
        openSearch();
      }
  } // else {
  //  console.log("Either openSearch is not a function or $search_menu has not been assigned.");
  // }

}); // press escape (ESC) to close menus

Mousetrap.bind('esc', function () {
  if (typeof closeNav == 'function') {
    closeNav();
  }

  if (typeof closeSearch == 'function') {
    closeSearch();
  }
}); // open the menu/nav

Mousetrap.bind('u', function () {
  // Since search input is allowed to listen to Mousetrap (normally it's disabled  but we want it enabled for ESC key close), ignore the "u" character if it is open
  if (!_typeof($search_menu) === 'undefined' && $search_menu.hasClass('is-active')) {
    return true;
  } // Otherwise, if the mobile navigation is open, close it
  else if ($global_header.hasClass('mobile-nav-is-open')) {
      if (typeof closeNav == 'function') {
        closeNav();
      }
    } // ...and if it's not open, open it
    else {
        if (typeof openNav == 'function') {
          openNav();
        }
      }
}); // // konami code!
// Mousetrap.bind('up up down down left right left right b a', function() { //enter
//  document.body.classList.add('konami-code-is-active');
// });

/*!

Holder - client side image placeholders
Version 2.9.6+fblyy
 2018 Ivan Malopinsky - http://imsky.co

Site:     http://holderjs.com
Issues:   https://github.com/imsky/holder/issues
License:  MIT

*/

(function (window) {
  if (!window.document) return;
  var document = window.document; //https://github.com/inexorabletash/polyfill/blob/master/web.js

  if (!document.querySelectorAll) {
    document.querySelectorAll = function (selectors) {
      var style = document.createElement('style'),
          elements = [],
          element;
      document.documentElement.firstChild.appendChild(style);
      document._qsa = [];
      style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';
      window.scrollBy(0, 0);
      style.parentNode.removeChild(style);

      while (document._qsa.length) {
        element = document._qsa.shift();
        element.style.removeAttribute('x-qsa');
        elements.push(element);
      }

      document._qsa = null;
      return elements;
    };
  }

  if (!document.querySelector) {
    document.querySelector = function (selectors) {
      var elements = document.querySelectorAll(selectors);
      return elements.length ? elements[0] : null;
    };
  }

  if (!document.getElementsByClassName) {
    document.getElementsByClassName = function (classNames) {
      classNames = String(classNames).replace(/^|\s+/g, '.');
      return document.querySelectorAll(classNames);
    };
  } //https://github.com/inexorabletash/polyfill
  // ES5 15.2.3.14 Object.keys ( O )
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys


  if (!Object.keys) {
    Object.keys = function (o) {
      if (o !== Object(o)) {
        throw TypeError('Object.keys called on non-object');
      }

      var ret = [],
          p;

      for (p in o) {
        if (Object.prototype.hasOwnProperty.call(o, p)) {
          ret.push(p);
        }
      }

      return ret;
    };
  } // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )
  // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach


  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (fun
    /*, thisp */
    ) {
      if (this === void 0 || this === null) {
        throw TypeError();
      }

      var t = Object(this);
      var len = t.length >>> 0;

      if (typeof fun !== "function") {
        throw TypeError();
      }

      var thisp = arguments[1],
          i;

      for (i = 0; i < len; i++) {
        if (i in t) {
          fun.call(thisp, t[i], i, t);
        }
      }
    };
  } //https://github.com/inexorabletash/polyfill/blob/master/web.js


  (function (global) {
    var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    global.atob = global.atob || function (input) {
      input = String(input);
      var position = 0,
          output = [],
          buffer = 0,
          bits = 0,
          n;
      input = input.replace(/\s/g, '');

      if (input.length % 4 === 0) {
        input = input.replace(/=+$/, '');
      }

      if (input.length % 4 === 1) {
        throw Error('InvalidCharacterError');
      }

      if (/[^+/0-9A-Za-z]/.test(input)) {
        throw Error('InvalidCharacterError');
      }

      while (position < input.length) {
        n = B64_ALPHABET.indexOf(input.charAt(position));
        buffer = buffer << 6 | n;
        bits += 6;

        if (bits === 24) {
          output.push(String.fromCharCode(buffer >> 16 & 0xFF));
          output.push(String.fromCharCode(buffer >> 8 & 0xFF));
          output.push(String.fromCharCode(buffer & 0xFF));
          bits = 0;
          buffer = 0;
        }

        position += 1;
      }

      if (bits === 12) {
        buffer = buffer >> 4;
        output.push(String.fromCharCode(buffer & 0xFF));
      } else if (bits === 18) {
        buffer = buffer >> 2;
        output.push(String.fromCharCode(buffer >> 8 & 0xFF));
        output.push(String.fromCharCode(buffer & 0xFF));
      }

      return output.join('');
    };

    global.btoa = global.btoa || function (input) {
      input = String(input);
      var position = 0,
          out = [],
          o1,
          o2,
          o3,
          e1,
          e2,
          e3,
          e4;

      if (/[^\x00-\xFF]/.test(input)) {
        throw Error('InvalidCharacterError');
      }

      while (position < input.length) {
        o1 = input.charCodeAt(position++);
        o2 = input.charCodeAt(position++);
        o3 = input.charCodeAt(position++); // 111111 112222 222233 333333

        e1 = o1 >> 2;
        e2 = (o1 & 0x3) << 4 | o2 >> 4;
        e3 = (o2 & 0xf) << 2 | o3 >> 6;
        e4 = o3 & 0x3f;

        if (position === input.length + 2) {
          e3 = 64;
          e4 = 64;
        } else if (position === input.length + 1) {
          e4 = 64;
        }

        out.push(B64_ALPHABET.charAt(e1), B64_ALPHABET.charAt(e2), B64_ALPHABET.charAt(e3), B64_ALPHABET.charAt(e4));
      }

      return out.join('');
    };
  })(window); //https://gist.github.com/jimeh/332357


  if (!Object.prototype.hasOwnProperty) {
    /*jshint -W001, -W103 */
    Object.prototype.hasOwnProperty = function (prop) {
      var proto = this.__proto__ || this.constructor.prototype;
      return prop in this && (!(prop in proto) || proto[prop] !== this[prop]);
    };
    /*jshint +W001, +W103 */

  } // @license http://opensource.org/licenses/MIT
  // copyright Paul Irish 2015
  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill
  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js
  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values
  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page
  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed


  (function () {
    if ('performance' in window === false) {
      window.performance = {};
    }

    Date.now = Date.now || function () {
      // thanks IE8
      return new Date().getTime();
    };

    if ('now' in window.performance === false) {
      var nowOffset = Date.now();

      if (performance.timing && performance.timing.navigationStart) {
        nowOffset = performance.timing.navigationStart;
      }

      window.performance.now = function now() {
        return Date.now() - nowOffset;
      };
    }
  })(); //requestAnimationFrame polyfill for older Firefox/Chrome versions


  if (!window.requestAnimationFrame) {
    if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {
      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-webkit.js
      (function (global) {
        global.requestAnimationFrame = function (callback) {
          return webkitRequestAnimationFrame(function () {
            callback(global.performance.now());
          });
        };

        global.cancelAnimationFrame = global.webkitCancelAnimationFrame;
      })(window);
    } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {
      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-moz.js
      (function (global) {
        global.requestAnimationFrame = function (callback) {
          return mozRequestAnimationFrame(function () {
            callback(global.performance.now());
          });
        };

        global.cancelAnimationFrame = global.mozCancelAnimationFrame;
      })(window);
    } else {
      (function (global) {
        global.requestAnimationFrame = function (callback) {
          return global.setTimeout(callback, 1000 / 60);
        };

        global.cancelAnimationFrame = global.clearTimeout;
      })(window);
    }
  }
})(this);

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(this, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId])
          /******/
          return installedModules[moduleId].exports;
        /******/
        // Create a new module (and put it into the cache)

        /******/

        var module = installedModules[moduleId] = {
          /******/
          exports: {},

          /******/
          id: moduleId,

          /******/
          loaded: false
          /******/

        };
        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        // Flag the module as loaded

        /******/

        module.loaded = true;
        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/
      // __webpack_public_path__

      /******/

      __webpack_require__.p = "";
      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(0);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports, __webpack_require__) {
      /*
      Holder.js - client side image placeholders
      (c) 2012-2015 Ivan Malopinsky - http://imsky.co
      */
      module.exports = __webpack_require__(1);
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        /*
        Holder.js - client side image placeholders
        (c) 2012-2016 Ivan Malopinsky - http://imsky.co
        */
        //Libraries and functions
        var onDomReady = __webpack_require__(2);

        var querystring = __webpack_require__(3);

        var SceneGraph = __webpack_require__(6);

        var utils = __webpack_require__(7);

        var SVG = __webpack_require__(8);

        var DOM = __webpack_require__(9);

        var Color = __webpack_require__(10);

        var constants = __webpack_require__(11);

        var svgRenderer = __webpack_require__(12);

        var sgCanvasRenderer = __webpack_require__(15);

        var extend = utils.extend;
        var dimensionCheck = utils.dimensionCheck; //Constants and definitions

        var SVG_NS = constants.svg_ns;
        var Holder = {
          version: constants.version,

          /**
           * Adds a theme to default settings
           *
           * @param {string} name Theme name
           * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.
           */
          addTheme: function addTheme(name, theme) {
            name != null && theme != null && (App.settings.themes[name] = theme);
            delete App.vars.cache.themeKeys;
            return this;
          },

          /**
           * Appends a placeholder to an element
           *
           * @param {string} src Placeholder URL string
           * @param el A selector or a reference to a DOM node
           */
          addImage: function addImage(src, el) {
            //todo: use jquery fallback if available for all QSA references
            var nodes = DOM.getNodeArray(el);
            nodes.forEach(function (node) {
              var img = DOM.newEl('img');
              var domProps = {};
              domProps[App.setup.dataAttr] = src;
              DOM.setAttr(img, domProps);
              node.appendChild(img);
            });
            return this;
          },

          /**
           * Sets whether or not an image is updated on resize.
           * If an image is set to be updated, it is immediately rendered.
           *
           * @param {Object} el Image DOM element
           * @param {Boolean} value Resizable update flag value
           */
          setResizeUpdate: function setResizeUpdate(el, value) {
            if (el.holderData) {
              el.holderData.resizeUpdate = !!value;

              if (el.holderData.resizeUpdate) {
                updateResizableElements(el);
              }
            }
          },

          /**
           * Runs Holder with options. By default runs Holder on all images with "holder.js" in their source attributes.
           *
           * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties
           */
          run: function run(userOptions) {
            //todo: split processing into separate queues
            userOptions = userOptions || {};
            var engineSettings = {};
            var options = extend(App.settings, userOptions);
            App.vars.preempted = true;
            App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;
            engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;

            if (App.setup.renderers.join(',').indexOf(engineSettings.renderer) === -1) {
              engineSettings.renderer = App.setup.supportsSVG ? 'svg' : App.setup.supportsCanvas ? 'canvas' : 'html';
            }

            var images = DOM.getNodeArray(options.images);
            var bgnodes = DOM.getNodeArray(options.bgnodes);
            var stylenodes = DOM.getNodeArray(options.stylenodes);
            var objects = DOM.getNodeArray(options.objects);
            engineSettings.stylesheets = [];
            engineSettings.svgXMLStylesheet = true;
            engineSettings.noFontFallback = !!options.noFontFallback;
            engineSettings.noBackgroundSize = !!options.noBackgroundSize;
            stylenodes.forEach(function (styleNode) {
              if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == 'stylesheet') {
                var href = styleNode.attributes.href.value; //todo: write isomorphic relative-to-absolute URL function

                var proxyLink = DOM.newEl('a');
                proxyLink.href = href;
                var stylesheetURL = proxyLink.protocol + '//' + proxyLink.host + proxyLink.pathname + proxyLink.search;
                engineSettings.stylesheets.push(stylesheetURL);
              }
            });
            bgnodes.forEach(function (bgNode) {
              //Skip processing background nodes if getComputedStyle is unavailable, since only modern browsers would be able to use canvas or SVG to render to background
              if (!global.getComputedStyle) return;
              var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue('background-image');
              var dataBackgroundImage = bgNode.getAttribute('data-background-src');
              var rawURL = dataBackgroundImage || backgroundImage;
              var holderURL = null;
              var holderString = options.domain + '/';
              var holderStringIndex = rawURL.indexOf(holderString);

              if (holderStringIndex === 0) {
                holderURL = rawURL;
              } else if (holderStringIndex === 1 && rawURL[0] === '?') {
                holderURL = rawURL.slice(1);
              } else {
                var fragment = rawURL.substr(holderStringIndex).match(/([^\"]*)"?\)/);

                if (fragment !== null) {
                  holderURL = fragment[1];
                } else if (rawURL.indexOf('url(') === 0) {
                  throw 'Holder: unable to parse background URL: ' + rawURL;
                }
              }

              if (holderURL) {
                var holderFlags = parseURL(holderURL, options);

                if (holderFlags) {
                  prepareDOMElement({
                    mode: 'background',
                    el: bgNode,
                    flags: holderFlags,
                    engineSettings: engineSettings
                  });
                }
              }
            });
            objects.forEach(function (object) {
              var objectAttr = {};

              try {
                objectAttr.data = object.getAttribute('data');
                objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);
              } catch (e) {}

              var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;
              var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;

              if (objectHasSrcURL) {
                prepareImageElement(options, engineSettings, objectAttr.data, object);
              } else if (objectHasDataSrcURL) {
                prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);
              }
            });
            images.forEach(function (image) {
              var imageAttr = {};

              try {
                imageAttr.src = image.getAttribute('src');
                imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);
                imageAttr.rendered = image.getAttribute('data-holder-rendered');
              } catch (e) {}

              var imageHasSrc = imageAttr.src != null;
              var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;
              var imageRendered = imageAttr.rendered != null && imageAttr.rendered == 'true';

              if (imageHasSrc) {
                if (imageAttr.src.indexOf(options.domain) === 0) {
                  prepareImageElement(options, engineSettings, imageAttr.src, image);
                } else if (imageHasDataSrcURL) {
                  //Image has a valid data-src and an invalid src
                  if (imageRendered) {
                    //If the placeholder has already been render, re-render it
                    prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
                  } else {
                    //If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn't
                    (function (src, options, engineSettings, dataSrc, image) {
                      utils.imageExists(src, function (exists) {
                        if (!exists) {
                          prepareImageElement(options, engineSettings, dataSrc, image);
                        }
                      });
                    })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);
                  }
                }
              } else if (imageHasDataSrcURL) {
                prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
              }
            });
            return this;
          }
        };
        var App = {
          settings: {
            domain: 'holder.js',
            images: 'img',
            objects: 'object',
            bgnodes: 'body .holderjs',
            stylenodes: 'head link.holderjs',
            themes: {
              'gray': {
                bg: '#EEEEEE',
                fg: '#AAAAAA'
              },
              'social': {
                bg: '#3a5a97',
                fg: '#FFFFFF'
              },
              'industrial': {
                bg: '#434A52',
                fg: '#C2F200'
              },
              'sky': {
                bg: '#0D8FDB',
                fg: '#FFFFFF'
              },
              'vine': {
                bg: '#39DBAC',
                fg: '#1E292C'
              },
              'lava': {
                bg: '#F8591A',
                fg: '#1C2846'
              }
            }
          },
          defaults: {
            size: 10,
            units: 'pt',
            scale: 1 / 16
          }
        };
        /**
         * Processes provided source attribute and sets up the appropriate rendering workflow
         *
         * @private
         * @param options Instance options from Holder.run
         * @param renderSettings Instance configuration
         * @param src Image URL
         * @param el Image DOM element
         */

        function prepareImageElement(options, engineSettings, src, el) {
          var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);

          if (holderFlags) {
            prepareDOMElement({
              mode: null,
              el: el,
              flags: holderFlags,
              engineSettings: engineSettings
            });
          }
        }
        /**
         * Processes a Holder URL and extracts configuration from query string
         *
         * @private
         * @param url URL
         * @param instanceOptions Instance options from Holder.run
         */


        function parseURL(url, instanceOptions) {
          var holder = {
            theme: extend(App.settings.themes.gray, null),
            stylesheets: instanceOptions.stylesheets,
            instanceOptions: instanceOptions
          };
          var firstQuestionMark = url.indexOf('?');
          var parts = [url];

          if (firstQuestionMark !== -1) {
            parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];
          }

          var basics = parts[0].split('/');
          holder.holderURL = url;
          var dimensions = basics[1];
          var dimensionData = dimensions.match(/([\d]+p?)x([\d]+p?)/);
          if (!dimensionData) return false;
          holder.fluid = dimensions.indexOf('p') !== -1;
          holder.dimensions = {
            width: dimensionData[1].replace('p', '%'),
            height: dimensionData[2].replace('p', '%')
          };

          if (parts.length === 2) {
            var options = querystring.parse(parts[1]); // Dimensions

            if (utils.truthy(options.ratio)) {
              holder.fluid = true;
              var ratioWidth = parseFloat(holder.dimensions.width.replace('%', ''));
              var ratioHeight = parseFloat(holder.dimensions.height.replace('%', ''));
              ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));
              ratioWidth = 100;
              holder.dimensions.width = ratioWidth + '%';
              holder.dimensions.height = ratioHeight + '%';
            }

            holder.auto = utils.truthy(options.auto); // Colors

            if (options.bg) {
              holder.theme.bg = utils.parseColor(options.bg);
            }

            if (options.fg) {
              holder.theme.fg = utils.parseColor(options.fg);
            } //todo: add automatic foreground to themes without foreground


            if (options.bg && !options.fg) {
              holder.autoFg = true;
            }

            if (options.theme && holder.instanceOptions.themes.hasOwnProperty(options.theme)) {
              holder.theme = extend(holder.instanceOptions.themes[options.theme], null);
            } // Text


            if (options.text) {
              holder.text = options.text;
            }

            if (options.textmode) {
              holder.textmode = options.textmode;
            }

            if (options.size && parseFloat(options.size)) {
              holder.size = parseFloat(options.size);
            }

            if (options.font) {
              holder.font = options.font;
            }

            if (options.align) {
              holder.align = options.align;
            }

            if (options.lineWrap) {
              holder.lineWrap = options.lineWrap;
            }

            holder.nowrap = utils.truthy(options.nowrap); // Miscellaneous

            holder.outline = utils.truthy(options.outline);

            if (utils.truthy(options.random)) {
              App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);
              var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];
              holder.theme = extend(holder.instanceOptions.themes[_theme], null);
            }
          }

          return holder;
        }
        /**
         * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)
         *
         * @private
         * @param settings DOM prep settings
         */


        function prepareDOMElement(prepSettings) {
          var mode = prepSettings.mode;
          var el = prepSettings.el;
          var flags = prepSettings.flags;
          var _engineSettings = prepSettings.engineSettings;
          var dimensions = flags.dimensions,
              theme = flags.theme;
          var dimensionsCaption = dimensions.width + 'x' + dimensions.height;
          mode = mode == null ? flags.fluid ? 'fluid' : 'image' : mode;
          var holderTemplateRe = /holder_([a-z]+)/g;
          var dimensionsInText = false;

          if (flags.text != null) {
            theme.text = flags.text; //<object> SVG embedding doesn't parse Unicode properly

            if (el.nodeName.toLowerCase() === 'object') {
              var textLines = theme.text.split('\\n');

              for (var k = 0; k < textLines.length; k++) {
                textLines[k] = utils.encodeHtmlEntity(textLines[k]);
              }

              theme.text = textLines.join('\\n');
            }
          }

          if (theme.text) {
            var holderTemplateMatches = theme.text.match(holderTemplateRe);

            if (holderTemplateMatches !== null) {
              //todo: optimize template replacement
              holderTemplateMatches.forEach(function (match) {
                if (match === 'holder_dimensions') {
                  theme.text = theme.text.replace(match, dimensionsCaption);
                }
              });
            }
          }

          var holderURL = flags.holderURL;
          var engineSettings = extend(_engineSettings, null);

          if (flags.font) {
            /*
            If external fonts are used in a <img> placeholder rendered with SVG, Holder falls back to canvas.
             This is done because Firefox and Chrome disallow embedded SVGs from referencing external assets.
            The workaround is either to change the placeholder tag from <img> to <object> or to use the canvas renderer.
            */
            theme.font = flags.font;

            if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === 'img' && App.setup.supportsCanvas && engineSettings.renderer === 'svg') {
              engineSettings = extend(engineSettings, {
                renderer: 'canvas'
              });
            }
          } //Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas


          if (flags.font && engineSettings.renderer == 'canvas') {
            engineSettings.reRender = true;
          }

          if (mode == 'background') {
            if (el.getAttribute('data-background-src') == null) {
              DOM.setAttr(el, {
                'data-background-src': holderURL
              });
            }
          } else {
            var domProps = {};
            domProps[App.vars.dataAttr] = holderURL;
            DOM.setAttr(el, domProps);
          }

          flags.theme = theme; //todo consider using all renderSettings in holderData

          el.holderData = {
            flags: flags,
            engineSettings: engineSettings
          };

          if (mode == 'image' || mode == 'fluid') {
            DOM.setAttr(el, {
              'alt': theme.text ? dimensionsInText ? theme.text : theme.text + ' [' + dimensionsCaption + ']' : dimensionsCaption
            });
          }

          var renderSettings = {
            mode: mode,
            el: el,
            holderSettings: {
              dimensions: dimensions,
              theme: theme,
              flags: flags
            },
            engineSettings: engineSettings
          };

          if (mode == 'image') {
            if (!flags.auto) {
              el.style.width = dimensions.width + 'px';
              el.style.height = dimensions.height + 'px';
            }

            if (engineSettings.renderer == 'html') {
              el.style.backgroundColor = theme.bg;
            } else {
              render(renderSettings);

              if (flags.textmode == 'exact') {
                el.holderData.resizeUpdate = true;
                App.vars.resizableImages.push(el);
                updateResizableElements(el);
              }
            }
          } else if (mode == 'background' && engineSettings.renderer != 'html') {
            render(renderSettings);
          } else if (mode == 'fluid') {
            el.holderData.resizeUpdate = true;

            if (dimensions.height.slice(-1) == '%') {
              el.style.height = dimensions.height;
            } else if (flags.auto == null || !flags.auto) {
              el.style.height = dimensions.height + 'px';
            }

            if (dimensions.width.slice(-1) == '%') {
              el.style.width = dimensions.width;
            } else if (flags.auto == null || !flags.auto) {
              el.style.width = dimensions.width + 'px';
            }

            if (el.style.display == 'inline' || el.style.display === '' || el.style.display == 'none') {
              el.style.display = 'block';
            }

            setInitialDimensions(el);

            if (engineSettings.renderer == 'html') {
              el.style.backgroundColor = theme.bg;
            } else {
              App.vars.resizableImages.push(el);
              updateResizableElements(el);
            }
          }
        }
        /**
         * Core function that takes output from renderers and sets it as the source or background-image of the target element
         *
         * @private
         * @param renderSettings Renderer settings
         */


        function render(renderSettings) {
          var image = null;
          var mode = renderSettings.mode;
          var el = renderSettings.el;
          var holderSettings = renderSettings.holderSettings;
          var engineSettings = renderSettings.engineSettings;

          switch (engineSettings.renderer) {
            case 'svg':
              if (!App.setup.supportsSVG) return;
              break;

            case 'canvas':
              if (!App.setup.supportsCanvas) return;
              break;

            default:
              return;
          } //todo: move generation of scene up to flag generation to reduce extra object creation


          var scene = {
            width: holderSettings.dimensions.width,
            height: holderSettings.dimensions.height,
            theme: holderSettings.theme,
            flags: holderSettings.flags
          };
          var sceneGraph = buildSceneGraph(scene);

          function getRenderedImage() {
            var image = null;

            switch (engineSettings.renderer) {
              case 'canvas':
                image = sgCanvasRenderer(sceneGraph, renderSettings);
                break;

              case 'svg':
                image = svgRenderer(sceneGraph, renderSettings);
                break;

              default:
                throw 'Holder: invalid renderer: ' + engineSettings.renderer;
            }

            return image;
          }

          image = getRenderedImage();

          if (image == null) {
            throw 'Holder: couldn\'t render placeholder';
          } //todo: add <object> canvas rendering


          if (mode == 'background') {
            el.style.backgroundImage = 'url(' + image + ')';

            if (!engineSettings.noBackgroundSize) {
              el.style.backgroundSize = scene.width + 'px ' + scene.height + 'px';
            }
          } else {
            if (el.nodeName.toLowerCase() === 'img') {
              DOM.setAttr(el, {
                'src': image
              });
            } else if (el.nodeName.toLowerCase() === 'object') {
              DOM.setAttr(el, {
                'data': image,
                'type': 'image/svg+xml'
              });
            }

            if (engineSettings.reRender) {
              global.setTimeout(function () {
                var image = getRenderedImage();

                if (image == null) {
                  throw 'Holder: couldn\'t render placeholder';
                } //todo: refactor this code into a function


                if (el.nodeName.toLowerCase() === 'img') {
                  DOM.setAttr(el, {
                    'src': image
                  });
                } else if (el.nodeName.toLowerCase() === 'object') {
                  DOM.setAttr(el, {
                    'data': image,
                    'type': 'image/svg+xml'
                  });
                }
              }, 150);
            }
          } //todo: account for re-rendering


          DOM.setAttr(el, {
            'data-holder-rendered': true
          });
        }
        /**
         * Core function that takes a Holder scene description and builds a scene graph
         *
         * @private
         * @param scene Holder scene object
         */
        //todo: make this function reusable
        //todo: merge app defaults and setup properties into the scene argument


        function buildSceneGraph(scene) {
          var fontSize = App.defaults.size;

          if (parseFloat(scene.theme.size)) {
            fontSize = scene.theme.size;
          } else if (parseFloat(scene.flags.size)) {
            fontSize = scene.flags.size;
          }

          scene.font = {
            family: scene.theme.font ? scene.theme.font : 'Arial, Helvetica, Open Sans, sans-serif',
            size: textSize(scene.width, scene.height, fontSize, App.defaults.scale),
            units: scene.theme.units ? scene.theme.units : App.defaults.units,
            weight: scene.theme.fontweight ? scene.theme.fontweight : 'bold'
          };
          scene.text = scene.theme.text || Math.floor(scene.width) + 'x' + Math.floor(scene.height);
          scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;
          scene.align = scene.theme.align || scene.flags.align || 'center';

          switch (scene.flags.textmode) {
            case 'literal':
              scene.text = scene.flags.dimensions.width + 'x' + scene.flags.dimensions.height;
              break;

            case 'exact':
              if (!scene.flags.exactDimensions) break;
              scene.text = Math.floor(scene.flags.exactDimensions.width) + 'x' + Math.floor(scene.flags.exactDimensions.height);
              break;
          }

          var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;
          var sceneMargin = scene.width * lineWrap;
          var maxLineWidth = sceneMargin;
          var sceneGraph = new SceneGraph({
            width: scene.width,
            height: scene.height
          });
          var Shape = sceneGraph.Shape;
          var holderBg = new Shape.Rect('holderBg', {
            fill: scene.theme.bg
          });
          holderBg.resize(scene.width, scene.height);
          sceneGraph.root.add(holderBg);

          if (scene.flags.outline) {
            var outlineColor = new Color(holderBg.properties.fill);
            outlineColor = outlineColor.lighten(outlineColor.lighterThan('7f7f7f') ? -0.1 : 0.1);
            holderBg.properties.outline = {
              fill: outlineColor.toHex(true),
              width: 2
            };
          }

          var holderTextColor = scene.theme.fg;

          if (scene.flags.autoFg) {
            var holderBgColor = new Color(holderBg.properties.fill);
            var lightColor = new Color('fff');
            var darkColor = new Color('000', {
              'alpha': 0.285714
            });
            holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan('7f7f7f') ? darkColor : lightColor).toHex(true);
          }

          var holderTextGroup = new Shape.Group('holderTextGroup', {
            text: scene.text,
            align: scene.align,
            font: scene.font,
            fill: holderTextColor
          });
          holderTextGroup.moveTo(null, null, 1);
          sceneGraph.root.add(holderTextGroup);
          var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);

          if (!tpdata) {
            throw 'Holder: staging fallback not supported yet.';
          }

          holderTextGroup.properties.leading = tpdata.boundingBox.height;
          var textNode = null;
          var line = null;

          function finalizeLine(parent, line, width, height) {
            line.width = width;
            line.height = height;
            parent.width = Math.max(parent.width, line.width);
            parent.height += line.height;
          }

          if (tpdata.lineCount > 1) {
            var offsetX = 0;
            var offsetY = 0;
            var lineIndex = 0;
            var lineKey;
            line = new Shape.Group('line' + lineIndex); //Double margin so that left/right-aligned next is not flush with edge of image

            if (scene.align === 'left' || scene.align === 'right') {
              maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);
            }

            for (var i = 0; i < tpdata.words.length; i++) {
              var word = tpdata.words[i];
              textNode = new Shape.Text(word.text);
              var newline = word.text == '\\n';

              if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {
                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
                holderTextGroup.add(line);
                offsetX = 0;
                offsetY += holderTextGroup.properties.leading;
                lineIndex += 1;
                line = new Shape.Group('line' + lineIndex);
                line.y = offsetY;
              }

              if (newline === true) {
                continue;
              }

              textNode.moveTo(offsetX, 0);
              offsetX += tpdata.spaceWidth + word.width;
              line.add(textNode);
            }

            finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
            holderTextGroup.add(line);

            if (scene.align === 'left') {
              holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
            } else if (scene.align === 'right') {
              for (lineKey in holderTextGroup.children) {
                line = holderTextGroup.children[lineKey];
                line.moveTo(scene.width - line.width, null, null);
              }

              holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
            } else {
              for (lineKey in holderTextGroup.children) {
                line = holderTextGroup.children[lineKey];
                line.moveTo((holderTextGroup.width - line.width) / 2, null, null);
              }

              holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);
            }

            holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null); //If the text exceeds vertical space, move it down so the first line is visible

            if ((scene.height - holderTextGroup.height) / 2 < 0) {
              holderTextGroup.moveTo(null, 0, null);
            }
          } else {
            textNode = new Shape.Text(scene.text);
            line = new Shape.Group('line0');
            line.add(textNode);
            holderTextGroup.add(line);

            if (scene.align === 'left') {
              holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
            } else if (scene.align === 'right') {
              holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
            } else {
              holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);
            }

            holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);
          } //todo: renderlist


          return sceneGraph;
        }
        /**
         * Adaptive text sizing function
         *
         * @private
         * @param width Parent width
         * @param height Parent height
         * @param fontSize Requested text size
         * @param scale Proportional scale of text
         */


        function textSize(width, height, fontSize, scale) {
          var stageWidth = parseInt(width, 10);
          var stageHeight = parseInt(height, 10);
          var bigSide = Math.max(stageWidth, stageHeight);
          var smallSide = Math.min(stageWidth, stageHeight);
          var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);
          return Math.round(Math.max(fontSize, newHeight));
        }
        /**
         * Iterates over resizable (fluid or auto) placeholders and renders them
         *
         * @private
         * @param element Optional element selector, specified only if a specific element needs to be re-rendered
         */


        function updateResizableElements(element) {
          var images;

          if (element == null || element.nodeType == null) {
            images = App.vars.resizableImages;
          } else {
            images = [element];
          }

          for (var i = 0, l = images.length; i < l; i++) {
            var el = images[i];

            if (el.holderData) {
              var flags = el.holderData.flags;
              var dimensions = dimensionCheck(el);

              if (dimensions) {
                if (!el.holderData.resizeUpdate) {
                  continue;
                }

                if (flags.fluid && flags.auto) {
                  var fluidConfig = el.holderData.fluidConfig;

                  switch (fluidConfig.mode) {
                    case 'width':
                      dimensions.height = dimensions.width / fluidConfig.ratio;
                      break;

                    case 'height':
                      dimensions.width = dimensions.height * fluidConfig.ratio;
                      break;
                  }
                }

                var settings = {
                  mode: 'image',
                  holderSettings: {
                    dimensions: dimensions,
                    theme: flags.theme,
                    flags: flags
                  },
                  el: el,
                  engineSettings: el.holderData.engineSettings
                };

                if (flags.textmode == 'exact') {
                  flags.exactDimensions = dimensions;
                  settings.holderSettings.dimensions = flags.dimensions;
                }

                render(settings);
              } else {
                setInvisible(el);
              }
            }
          }
        }
        /**
         * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing
         *
         * @private
         * @param el Image DOM element
         */


        function setInitialDimensions(el) {
          if (el.holderData) {
            var dimensions = dimensionCheck(el);

            if (dimensions) {
              var flags = el.holderData.flags;
              var fluidConfig = {
                fluidHeight: flags.dimensions.height.slice(-1) == '%',
                fluidWidth: flags.dimensions.width.slice(-1) == '%',
                mode: null,
                initialDimensions: dimensions
              };

              if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {
                fluidConfig.mode = 'width';
                fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);
              } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {
                fluidConfig.mode = 'height';
                fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;
              }

              el.holderData.fluidConfig = fluidConfig;
            } else {
              setInvisible(el);
            }
          }
        }
        /**
         * Iterates through all current invisible images, and if they're visible, renders them and removes them from further checks. Runs every animation frame.
         *
         * @private
         */


        function visibilityCheck() {
          var renderableImages = [];
          var keys = Object.keys(App.vars.invisibleImages);
          var el;
          keys.forEach(function (key) {
            el = App.vars.invisibleImages[key];

            if (dimensionCheck(el) && el.nodeName.toLowerCase() == 'img') {
              renderableImages.push(el);
              delete App.vars.invisibleImages[key];
            }
          });

          if (renderableImages.length) {
            Holder.run({
              images: renderableImages
            });
          } // Done to prevent 100% CPU usage via aggressive calling of requestAnimationFrame


          setTimeout(function () {
            global.requestAnimationFrame(visibilityCheck);
          }, 10);
        }
        /**
         * Starts checking for invisible placeholders if not doing so yet. Does nothing otherwise.
         *
         * @private
         */


        function startVisibilityCheck() {
          if (!App.vars.visibilityCheckStarted) {
            global.requestAnimationFrame(visibilityCheck);
            App.vars.visibilityCheckStarted = true;
          }
        }
        /**
         * Sets a unique ID for an image detected to be invisible and adds it to the map of invisible images checked by visibilityCheck
         *
         * @private
         * @param el Invisible DOM element
         */


        function setInvisible(el) {
          if (!el.holderData.invisibleId) {
            App.vars.invisibleId += 1;
            App.vars.invisibleImages['i' + App.vars.invisibleId] = el;
            el.holderData.invisibleId = App.vars.invisibleId;
          }
        } //todo: see if possible to convert stagingRenderer to use HTML only


        var stagingRenderer = function () {
          var svg = null,
              stagingText = null,
              stagingTextNode = null;
          return function (graph) {
            var rootNode = graph.root;

            if (App.setup.supportsSVG) {
              var firstTimeSetup = false;

              var tnode = function tnode(text) {
                return document.createTextNode(text);
              };

              if (svg == null || svg.parentNode !== document.body) {
                firstTimeSetup = true;
              }

              svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height); //Show staging element before staging

              svg.style.display = 'block';

              if (firstTimeSetup) {
                stagingText = DOM.newEl('text', SVG_NS);
                stagingTextNode = tnode(null);
                DOM.setAttr(stagingText, {
                  x: 0
                });
                stagingText.appendChild(stagingTextNode);
                svg.appendChild(stagingText);
                document.body.appendChild(svg);
                svg.style.visibility = 'hidden';
                svg.style.position = 'absolute';
                svg.style.top = '-100%';
                svg.style.left = '-100%'; //todo: workaround for zero-dimension <svg> tag in Opera 12
                //svg.setAttribute('width', 0);
                //svg.setAttribute('height', 0);
              }

              var holderTextGroup = rootNode.children.holderTextGroup;
              var htgProps = holderTextGroup.properties;
              DOM.setAttr(stagingText, {
                'y': htgProps.font.size,
                'style': utils.cssProps({
                  'font-weight': htgProps.font.weight,
                  'font-size': htgProps.font.size + htgProps.font.units,
                  'font-family': htgProps.font.family
                })
              }); //Unescape HTML entities to get approximately the right width

              var txt = DOM.newEl('textarea');
              txt.innerHTML = htgProps.text;
              stagingTextNode.nodeValue = txt.value; //Get bounding box for the whole string (total width and height)

              var stagingTextBBox = stagingText.getBBox(); //Get line count and split the string into words

              var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);
              var words = htgProps.text.split(' ');
              var newlines = htgProps.text.match(/\\n/g);
              lineCount += newlines == null ? 0 : newlines.length; //Get bounding box for the string with spaces removed

              stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, '');
              var computedNoSpaceLength = stagingText.getComputedTextLength(); //Compute average space width

              var diffLength = stagingTextBBox.width - computedNoSpaceLength;
              var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1)); //Get widths for every word with space only if there is more than one line

              var wordWidths = [];

              if (lineCount > 1) {
                stagingTextNode.nodeValue = '';

                for (var i = 0; i < words.length; i++) {
                  if (words[i].length === 0) continue;
                  stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);
                  var bbox = stagingText.getBBox();
                  wordWidths.push({
                    text: words[i],
                    width: bbox.width
                  });
                }
              } //Hide staging element after staging


              svg.style.display = 'none';
              return {
                spaceWidth: spaceWidth,
                lineCount: lineCount,
                boundingBox: stagingTextBBox,
                words: wordWidths
              };
            } else {
              //todo: canvas fallback for measuring text on android 2.3
              return false;
            }
          };
        }(); //Helpers

        /**
         * Prevents a function from being called too often, waits until a timer elapses to call it again
         *
         * @param fn Function to call
         */


        function debounce(fn) {
          if (!App.vars.debounceTimer) fn.call(this);
          if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);
          App.vars.debounceTimer = global.setTimeout(function () {
            App.vars.debounceTimer = null;
            fn.call(this);
          }, App.setup.debounce);
        }
        /**
         * Holder-specific resize/orientation change callback, debounced to prevent excessive execution
         */


        function resizeEvent() {
          debounce(function () {
            updateResizableElements(null);
          });
        } //Set up flags


        for (var flag in App.flags) {
          if (!App.flags.hasOwnProperty(flag)) continue;

          App.flags[flag].match = function (val) {
            return val.match(this.regex);
          };
        } //Properties set once on setup


        App.setup = {
          renderer: 'html',
          debounce: 100,
          ratio: 1,
          supportsCanvas: false,
          supportsSVG: false,
          lineWrapRatio: 0.9,
          dataAttr: 'data-src',
          renderers: ['html', 'canvas', 'svg']
        }; //Properties modified during runtime

        App.vars = {
          preempted: false,
          resizableImages: [],
          invisibleImages: {},
          invisibleId: 0,
          visibilityCheckStarted: false,
          debounceTimer: null,
          cache: {}
        }; //Pre-flight

        (function () {
          var canvas = DOM.newEl('canvas');

          if (canvas.getContext) {
            if (canvas.toDataURL('image/png').indexOf('data:image/png') != -1) {
              App.setup.renderer = 'canvas';
              App.setup.supportsCanvas = true;
            }
          }

          if (!!document.createElementNS && !!document.createElementNS(SVG_NS, 'svg').createSVGRect) {
            App.setup.renderer = 'svg';
            App.setup.supportsSVG = true;
          }
        })(); //Starts checking for invisible placeholders


        startVisibilityCheck();

        if (onDomReady) {
          onDomReady(function () {
            if (!App.vars.preempted) {
              Holder.run();
            }

            if (global.addEventListener) {
              global.addEventListener('resize', resizeEvent, false);
              global.addEventListener('orientationchange', resizeEvent, false);
            } else {
              global.attachEvent('onresize', resizeEvent);
            }

            if (_typeof(global.Turbolinks) == 'object') {
              global.document.addEventListener('page:change', function () {
                Holder.run();
              });
            }
          });
        }

        module.exports = Holder;
        /* WEBPACK VAR INJECTION */
      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 2 */

    /***/
    function (module, exports) {
      /*!
       * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license
       *
       * Specially modified to work with Holder.js
       */
      function _onDomReady(win) {
        //Lazy loading fix for Firefox < 3.6
        //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
        if (document.readyState == null && document.addEventListener) {
          document.addEventListener("DOMContentLoaded", function DOMContentLoaded() {
            document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
            document.readyState = "complete";
          }, false);
          document.readyState = "loading";
        }

        var doc = win.document,
            docElem = doc.documentElement,
            LOAD = "load",
            FALSE = false,
            ONLOAD = "on" + LOAD,
            COMPLETE = "complete",
            READYSTATE = "readyState",
            ATTACHEVENT = "attachEvent",
            DETACHEVENT = "detachEvent",
            ADDEVENTLISTENER = "addEventListener",
            DOMCONTENTLOADED = "DOMContentLoaded",
            ONREADYSTATECHANGE = "onreadystatechange",
            REMOVEEVENTLISTENER = "removeEventListener",
            // W3C Event model
        w3c = ADDEVENTLISTENER in doc,
            _top = FALSE,
            // isReady: Is the DOM ready to be used? Set to true once it occurs.
        isReady = FALSE,
            // Callbacks pending execution until DOM is ready
        callbacks = []; // Handle when the DOM is ready

        function ready(fn) {
          if (!isReady) {
            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!doc.body) {
              return defer(ready);
            } // Remember that the DOM is ready


            isReady = true; // Execute all callbacks

            while (fn = callbacks.shift()) {
              defer(fn);
            }
          }
        } // The ready event handler


        function completed(event) {
          // readyState === "complete" is good enough for us to call the dom ready in oldIE
          if (w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE) {
            detach();
            ready();
          }
        } // Clean-up method for dom ready events


        function detach() {
          if (w3c) {
            doc[REMOVEEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE);
            win[REMOVEEVENTLISTENER](LOAD, completed, FALSE);
          } else {
            doc[DETACHEVENT](ONREADYSTATECHANGE, completed);
            win[DETACHEVENT](ONLOAD, completed);
          }
        } // Defers a function, scheduling it to run after the current call stack has cleared.


        function defer(fn, wait) {
          // Allow 0 to be passed
          setTimeout(fn, +wait >= 0 ? wait : 1);
        } // Attach the listeners:
        // Catch cases where onDomReady is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15


        if (doc[READYSTATE] === COMPLETE) {
          // Handle it asynchronously to allow scripts the opportunity to delay ready
          defer(ready); // Standards-based browsers support DOMContentLoaded
        } else if (w3c) {
          // Use the handy event callback
          doc[ADDEVENTLISTENER](DOMCONTENTLOADED, completed, FALSE); // A fallback to window.onload, that will always work

          win[ADDEVENTLISTENER](LOAD, completed, FALSE); // If IE event model is used
        } else {
          // Ensure firing before onload, maybe late but safe also for iframes
          doc[ATTACHEVENT](ONREADYSTATECHANGE, completed); // A fallback to window.onload, that will always work

          win[ATTACHEVENT](ONLOAD, completed); // If IE and not a frame
          // continually check to see if the document is ready

          try {
            _top = win.frameElement == null && docElem;
          } catch (e) {}

          if (_top && _top.doScroll) {
            (function doScrollCheck() {
              if (!isReady) {
                try {
                  // Use the trick by Diego Perini
                  // http://javascript.nwbox.com/IEContentLoaded/
                  _top.doScroll("left");
                } catch (e) {
                  return defer(doScrollCheck, 50);
                } // detach all dom ready events


                detach(); // and execute any waiting functions

                ready();
              }
            })();
          }
        }

        function onDomReady(fn) {
          // If DOM is ready, execute the function (async), otherwise wait
          isReady ? defer(fn) : callbacks.push(fn);
        } // Add version


        onDomReady.version = "1.4.0"; // Add method to check if DOM is ready

        onDomReady.isReady = function () {
          return isReady;
        };

        return onDomReady;
      }

      module.exports = typeof window !== "undefined" && _onDomReady(window);
      /***/
    },
    /* 3 */

    /***/
    function (module, exports, __webpack_require__) {
      //Modified version of component/querystring
      //Changes: updated dependencies, dot notation parsing, JSHint fixes
      //Fork at https://github.com/imsky/querystring

      /**
       * Module dependencies.
       */
      var encode = encodeURIComponent;
      var decode = decodeURIComponent;

      var trim = __webpack_require__(4);

      var type = __webpack_require__(5);

      var arrayRegex = /(\w+)\[(\d+)\]/;
      var objectRegex = /\w+\.\w+/;
      /**
       * Parse the given query `str`.
       *
       * @param {String} str
       * @return {Object}
       * @api public
       */

      exports.parse = function (str) {
        if ('string' !== typeof str) return {};
        str = trim(str);
        if ('' === str) return {};
        if ('?' === str.charAt(0)) str = str.slice(1);
        var obj = {};
        var pairs = str.split('&');

        for (var i = 0; i < pairs.length; i++) {
          var parts = pairs[i].split('=');
          var key = decode(parts[0]);
          var m, ctx, prop;

          if (m = arrayRegex.exec(key)) {
            obj[m[1]] = obj[m[1]] || [];
            obj[m[1]][m[2]] = decode(parts[1]);
            continue;
          }

          if (m = objectRegex.test(key)) {
            m = key.split('.');
            ctx = obj;

            while (m.length) {
              prop = m.shift();
              if (!prop.length) continue;

              if (!ctx[prop]) {
                ctx[prop] = {};
              } else if (ctx[prop] && _typeof(ctx[prop]) !== 'object') {
                break;
              }

              if (!m.length) {
                ctx[prop] = decode(parts[1]);
              }

              ctx = ctx[prop];
            }

            continue;
          }

          obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);
        }

        return obj;
      };
      /**
       * Stringify the given `obj`.
       *
       * @param {Object} obj
       * @return {String}
       * @api public
       */


      exports.stringify = function (obj) {
        if (!obj) return '';
        var pairs = [];

        for (var key in obj) {
          var value = obj[key];

          if ('array' == type(value)) {
            for (var i = 0; i < value.length; ++i) {
              pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));
            }

            continue;
          }

          pairs.push(encode(key) + '=' + encode(obj[key]));
        }

        return pairs.join('&');
      };
      /***/

    },
    /* 4 */

    /***/
    function (module, exports) {
      exports = module.exports = trim;

      function trim(str) {
        return str.replace(/^\s*|\s*$/g, '');
      }

      exports.left = function (str) {
        return str.replace(/^\s*/, '');
      };

      exports.right = function (str) {
        return str.replace(/\s*$/, '');
      };
      /***/

    },
    /* 5 */

    /***/
    function (module, exports) {
      /**
       * toString ref.
       */
      var toString = Object.prototype.toString;
      /**
       * Return the type of `val`.
       *
       * @param {Mixed} val
       * @return {String}
       * @api public
       */

      module.exports = function (val) {
        switch (toString.call(val)) {
          case '[object Date]':
            return 'date';

          case '[object RegExp]':
            return 'regexp';

          case '[object Arguments]':
            return 'arguments';

          case '[object Array]':
            return 'array';

          case '[object Error]':
            return 'error';
        }

        if (val === null) return 'null';
        if (val === undefined) return 'undefined';
        if (val !== val) return 'nan';
        if (val && val.nodeType === 1) return 'element';
        if (isBuffer(val)) return 'buffer';
        val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);
        return _typeof(val);
      }; // code borrowed from https://github.com/feross/is-buffer/blob/master/index.js


      function isBuffer(obj) {
        return !!(obj != null && (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
        obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)));
      }
      /***/

    },
    /* 6 */

    /***/
    function (module, exports) {
      var SceneGraph = function SceneGraph(sceneProperties) {
        var nodeCount = 1; //todo: move merge to helpers section

        function merge(parent, child) {
          for (var prop in child) {
            parent[prop] = child[prop];
          }

          return parent;
        }

        var SceneNode = function SceneNode(name) {
          nodeCount++;
          this.parent = null;
          this.children = {};
          this.id = nodeCount;
          this.name = 'n' + nodeCount;

          if (typeof name !== 'undefined') {
            this.name = name;
          }

          this.x = this.y = this.z = 0;
          this.width = this.height = 0;
        };

        SceneNode.prototype.resize = function (width, height) {
          if (width != null) {
            this.width = width;
          }

          if (height != null) {
            this.height = height;
          }
        };

        SceneNode.prototype.moveTo = function (x, y, z) {
          this.x = x != null ? x : this.x;
          this.y = y != null ? y : this.y;
          this.z = z != null ? z : this.z;
        };

        SceneNode.prototype.add = function (child) {
          var name = child.name;

          if (typeof this.children[name] === 'undefined') {
            this.children[name] = child;
            child.parent = this;
          } else {
            throw 'SceneGraph: child already exists: ' + name;
          }
        };

        var RootNode = function RootNode() {
          SceneNode.call(this, 'root');
          this.properties = sceneProperties;
        };

        RootNode.prototype = new SceneNode();

        var Shape = function Shape(name, props) {
          SceneNode.call(this, name);
          this.properties = {
            'fill': '#000000'
          };

          if (typeof props !== 'undefined') {
            merge(this.properties, props);
          } else if (typeof name !== 'undefined' && typeof name !== 'string') {
            throw 'SceneGraph: invalid node name';
          }
        };

        Shape.prototype = new SceneNode();

        var Group = function Group() {
          Shape.apply(this, arguments);
          this.type = 'group';
        };

        Group.prototype = new Shape();

        var Rect = function Rect() {
          Shape.apply(this, arguments);
          this.type = 'rect';
        };

        Rect.prototype = new Shape();

        var Text = function Text(text) {
          Shape.call(this);
          this.type = 'text';
          this.properties.text = text;
        };

        Text.prototype = new Shape();
        var root = new RootNode();
        this.Shape = {
          'Rect': Rect,
          'Text': Text,
          'Group': Group
        };
        this.root = root;
        return this;
      };

      module.exports = SceneGraph;
      /***/
    },
    /* 7 */

    /***/
    function (module, exports) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        /**
        * Shallow object clone and merge
        *
        * @param a Object A
        * @param b Object B
        * @returns {Object} New object with all of A's properties, and all of B's properties, overwriting A's properties
        */
        exports.extend = function (a, b) {
          var c = {};

          for (var x in a) {
            if (a.hasOwnProperty(x)) {
              c[x] = a[x];
            }
          }

          if (b != null) {
            for (var y in b) {
              if (b.hasOwnProperty(y)) {
                c[y] = b[y];
              }
            }
          }

          return c;
        };
        /**
         * Takes a k/v list of CSS properties and returns a rule
         *
         * @param props CSS properties object
         */


        exports.cssProps = function (props) {
          var ret = [];

          for (var p in props) {
            if (props.hasOwnProperty(p)) {
              ret.push(p + ':' + props[p]);
            }
          }

          return ret.join(';');
        };
        /**
         * Encodes HTML entities in a string
         *
         * @param str Input string
         */


        exports.encodeHtmlEntity = function (str) {
          var buf = [];
          var charCode = 0;

          for (var i = str.length - 1; i >= 0; i--) {
            charCode = str.charCodeAt(i);

            if (charCode > 128) {
              buf.unshift(['&#', charCode, ';'].join(''));
            } else {
              buf.unshift(str[i]);
            }
          }

          return buf.join('');
        };
        /**
         * Checks if an image exists
         *
         * @param src URL of image
         * @param callback Callback to call once image status has been found
         */


        exports.imageExists = function (src, callback) {
          var image = new Image();

          image.onerror = function () {
            callback.call(this, false);
          };

          image.onload = function () {
            callback.call(this, true);
          };

          image.src = src;
        };
        /**
         * Decodes HTML entities in a string
         *
         * @param str Input string
         */


        exports.decodeHtmlEntity = function (str) {
          return str.replace(/&#(\d+);/g, function (match, dec) {
            return String.fromCharCode(dec);
          });
        };
        /**
         * Returns an element's dimensions if it's visible, `false` otherwise.
         *
         * @param el DOM element
         */


        exports.dimensionCheck = function (el) {
          var dimensions = {
            height: el.clientHeight,
            width: el.clientWidth
          };

          if (dimensions.height && dimensions.width) {
            return dimensions;
          } else {
            return false;
          }
        };
        /**
         * Returns true if value is truthy or if it is "semantically truthy"
         * @param val
         */


        exports.truthy = function (val) {
          if (typeof val === 'string') {
            return val === 'true' || val === 'yes' || val === '1' || val === 'on' || val === '';
          }

          return !!val;
        };
        /**
         * Parses input into a well-formed CSS color
         * @param val
         */


        exports.parseColor = function (val) {
          var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;
          var rgbre = /^rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
          var rgbare = /^rgba\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0\.\d{1,}|1)\)$/;
          var match = val.match(hexre);
          var retval;

          if (match !== null) {
            retval = match[1] || match[2];

            if (retval[0] !== '#') {
              return '#' + retval;
            } else {
              return retval;
            }
          }

          match = val.match(rgbre);

          if (match !== null) {
            retval = 'rgb(' + match.slice(1).join(',') + ')';
            return retval;
          }

          match = val.match(rgbare);

          if (match !== null) {
            retval = 'rgba(' + match.slice(1).join(',') + ')';
            return retval;
          }

          return null;
        };
        /**
         * Provides the correct scaling ratio for canvas drawing operations on HiDPI screens (e.g. Retina displays)
         */


        exports.canvasRatio = function () {
          var devicePixelRatio = 1;
          var backingStoreRatio = 1;

          if (global.document) {
            var canvas = global.document.createElement('canvas');

            if (canvas.getContext) {
              var ctx = canvas.getContext('2d');
              devicePixelRatio = global.devicePixelRatio || 1;
              backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
            }
          }

          return devicePixelRatio / backingStoreRatio;
        };
        /* WEBPACK VAR INJECTION */

      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 8 */

    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        var DOM = __webpack_require__(9);

        var SVG_NS = 'http://www.w3.org/2000/svg';
        var NODE_TYPE_COMMENT = 8;
        /**
         * Generic SVG element creation function
         *
         * @param svg SVG context, set to null if new
         * @param width Document width
         * @param height Document height
         */

        exports.initSVG = function (svg, width, height) {
          var defs,
              style,
              initialize = false;

          if (svg && svg.querySelector) {
            style = svg.querySelector('style');

            if (style === null) {
              initialize = true;
            }
          } else {
            svg = DOM.newEl('svg', SVG_NS);
            initialize = true;
          }

          if (initialize) {
            defs = DOM.newEl('defs', SVG_NS);
            style = DOM.newEl('style', SVG_NS);
            DOM.setAttr(style, {
              'type': 'text/css'
            });
            defs.appendChild(style);
            svg.appendChild(defs);
          } //IE throws an exception if this is set and Chrome requires it to be set


          if (svg.webkitMatchesSelector) {
            svg.setAttribute('xmlns', SVG_NS);
          } //Remove comment nodes


          for (var i = 0; i < svg.childNodes.length; i++) {
            if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {
              svg.removeChild(svg.childNodes[i]);
            }
          } //Remove CSS


          while (style.childNodes.length) {
            style.removeChild(style.childNodes[0]);
          }

          DOM.setAttr(svg, {
            'width': width,
            'height': height,
            'viewBox': '0 0 ' + width + ' ' + height,
            'preserveAspectRatio': 'none'
          });
          return svg;
        };
        /**
         * Converts serialized SVG to a string suitable for data URI use
         * @param svgString Serialized SVG string
         * @param [base64] Use base64 encoding for data URI
         */


        exports.svgStringToDataURI = function () {
          var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';
          var base64Prefix = 'data:image/svg+xml;charset=UTF-8;base64,';
          return function (svgString, base64) {
            if (base64) {
              return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));
            } else {
              return rawPrefix + encodeURIComponent(svgString);
            }
          };
        }();
        /**
         * Returns serialized SVG with XML processing instructions
         *
         * @param svg SVG context
         * @param stylesheets CSS stylesheets to include
         */


        exports.serializeSVG = function (svg, engineSettings) {
          if (!global.XMLSerializer) return;
          var serializer = new XMLSerializer();
          var svgCSS = '';
          var stylesheets = engineSettings.stylesheets; //External stylesheets: Processing Instruction method

          if (engineSettings.svgXMLStylesheet) {
            var xml = DOM.createXML(); //Add <?xml-stylesheet ?> directives

            for (var i = stylesheets.length - 1; i >= 0; i--) {
              var csspi = xml.createProcessingInstruction('xml-stylesheet', 'href="' + stylesheets[i] + '" rel="stylesheet"');
              xml.insertBefore(csspi, xml.firstChild);
            }

            xml.removeChild(xml.documentElement);
            svgCSS = serializer.serializeToString(xml);
          }

          var svgText = serializer.serializeToString(svg);
          svgText = svgText.replace(/\&amp;(\#[0-9]{2,}\;)/g, '&$1');
          return svgCSS + svgText;
        };
        /* WEBPACK VAR INJECTION */

      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 9 */

    /***/
    function (module, exports) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        /**
        * Generic new DOM element function
        *
        * @param tag Tag to create
        * @param namespace Optional namespace value
        */
        exports.newEl = function (tag, namespace) {
          if (!global.document) return;

          if (namespace == null) {
            return global.document.createElement(tag);
          } else {
            return global.document.createElementNS(namespace, tag);
          }
        };
        /**
         * Generic setAttribute function
         *
         * @param el Reference to DOM element
         * @param attrs Object with attribute keys and values
         */


        exports.setAttr = function (el, attrs) {
          for (var a in attrs) {
            el.setAttribute(a, attrs[a]);
          }
        };
        /**
         * Creates a XML document
         * @private
         */


        exports.createXML = function () {
          if (!global.DOMParser) return;
          return new DOMParser().parseFromString('<xml />', 'application/xml');
        };
        /**
         * Converts a value into an array of DOM nodes
         *
         * @param val A string, a NodeList, a Node, or an HTMLCollection
         */


        exports.getNodeArray = function (val) {
          var retval = null;

          if (typeof val == 'string') {
            retval = document.querySelectorAll(val);
          } else if (global.NodeList && val instanceof global.NodeList) {
            retval = val;
          } else if (global.Node && val instanceof global.Node) {
            retval = [val];
          } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {
            retval = val;
          } else if (val instanceof Array) {
            retval = val;
          } else if (val === null) {
            retval = [];
          }

          retval = Array.prototype.slice.call(retval);
          return retval;
        };
        /* WEBPACK VAR INJECTION */

      }).call(exports, function () {
        return this;
      }());
      /***/
    },
    /* 10 */

    /***/
    function (module, exports) {
      var Color = function Color(color, options) {
        //todo: support rgba, hsla, and rrggbbaa notation
        //todo: use CIELAB internally
        //todo: add clamp function (with sign)
        if (typeof color !== 'string') return;
        this.original = color;

        if (color.charAt(0) === '#') {
          color = color.slice(1);
        }

        if (/[^a-f0-9]+/i.test(color)) return;

        if (color.length === 3) {
          color = color.replace(/./g, '$&$&');
        }

        if (color.length !== 6) return;
        this.alpha = 1;

        if (options && options.alpha) {
          this.alpha = options.alpha;
        }

        this.set(parseInt(color, 16));
      }; //todo: jsdocs


      Color.rgb2hex = function (r, g, b) {
        function format(decimal) {
          var hex = (decimal | 0).toString(16);

          if (decimal < 16) {
            hex = '0' + hex;
          }

          return hex;
        }

        return [r, g, b].map(format).join('');
      }; //todo: jsdocs


      Color.hsl2rgb = function (h, s, l) {
        var H = h / 60;
        var C = (1 - Math.abs(2 * l - 1)) * s;
        var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));
        var m = l - C / 2;
        var r = 0,
            g = 0,
            b = 0;

        if (H >= 0 && H < 1) {
          r = C;
          g = X;
        } else if (H >= 1 && H < 2) {
          r = X;
          g = C;
        } else if (H >= 2 && H < 3) {
          g = C;
          b = X;
        } else if (H >= 3 && H < 4) {
          g = X;
          b = C;
        } else if (H >= 4 && H < 5) {
          r = X;
          b = C;
        } else if (H >= 5 && H < 6) {
          r = C;
          b = X;
        }

        r += m;
        g += m;
        b += m;
        r = parseInt(r * 255);
        g = parseInt(g * 255);
        b = parseInt(b * 255);
        return [r, g, b];
      };
      /**
       * Sets the color from a raw RGB888 integer
       * @param raw RGB888 representation of color
       */
      //todo: refactor into a static method
      //todo: factor out individual color spaces
      //todo: add HSL, CIELAB, and CIELUV


      Color.prototype.set = function (val) {
        this.raw = val;
        var r = (this.raw & 0xFF0000) >> 16;
        var g = (this.raw & 0x00FF00) >> 8;
        var b = this.raw & 0x0000FF; // BT.709

        var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        var u = -0.09991 * r - 0.33609 * g + 0.436 * b;
        var v = 0.615 * r - 0.55861 * g - 0.05639 * b;
        this.rgb = {
          r: r,
          g: g,
          b: b
        };
        this.yuv = {
          y: y,
          u: u,
          v: v
        };
        return this;
      };
      /**
       * Lighten or darken a color
       * @param multiplier Amount to lighten or darken (-1 to 1)
       */


      Color.prototype.lighten = function (multiplier) {
        var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);
        var bm = 255 * cm | 0;
        var cr = Math.min(255, Math.max(0, this.rgb.r + bm));
        var cg = Math.min(255, Math.max(0, this.rgb.g + bm));
        var cb = Math.min(255, Math.max(0, this.rgb.b + bm));
        var hex = Color.rgb2hex(cr, cg, cb);
        return new Color(hex);
      };
      /**
       * Output color in hex format
       * @param addHash Add a hash character to the beginning of the output
       */


      Color.prototype.toHex = function (addHash) {
        return (addHash ? '#' : '') + this.raw.toString(16);
      };
      /**
       * Returns whether or not current color is lighter than another color
       * @param color Color to compare against
       */


      Color.prototype.lighterThan = function (color) {
        if (!(color instanceof Color)) {
          color = new Color(color);
        }

        return this.yuv.y > color.yuv.y;
      };
      /**
       * Returns the result of mixing current color with another color
       * @param color Color to mix with
       * @param multiplier How much to mix with the other color
       */

      /*
      Color.prototype.mix = function (color, multiplier) {
          if (!(color instanceof Color)) {
              color = new Color(color);
          }
           var r = this.rgb.r;
          var g = this.rgb.g;
          var b = this.rgb.b;
          var a = this.alpha;
           var m = typeof multiplier !== 'undefined' ? multiplier : 0.5;
           //todo: write a lerp function
          r = r + m * (color.rgb.r - r);
          g = g + m * (color.rgb.g - g);
          b = b + m * (color.rgb.b - b);
          a = a + m * (color.alpha - a);
           return new Color(Color.rgbToHex(r, g, b), {
              'alpha': a
          });
      };
      */

      /**
       * Returns the result of blending another color on top of current color with alpha
       * @param color Color to blend on top of current color, i.e. "Ca"
       */
      //todo: see if .blendAlpha can be merged into .mix


      Color.prototype.blendAlpha = function (color) {
        if (!(color instanceof Color)) {
          color = new Color(color);
        }

        var Ca = color;
        var Cb = this; //todo: write alpha blending function

        var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;
        var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;
        var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;
        return new Color(Color.rgb2hex(r, g, b));
      };

      module.exports = Color;
      /***/
    },
    /* 11 */

    /***/
    function (module, exports) {
      module.exports = {
        'version': '2.9.6',
        'svg_ns': 'http://www.w3.org/2000/svg'
      };
      /***/
    },
    /* 12 */

    /***/
    function (module, exports, __webpack_require__) {
      var shaven = __webpack_require__(13);

      var SVG = __webpack_require__(8);

      var constants = __webpack_require__(11);

      var utils = __webpack_require__(7);

      var SVG_NS = constants.svg_ns;
      var templates = {
        'element': function element(options) {
          var tag = options.tag;
          var content = options.content || '';
          delete options.tag;
          delete options.content;
          return [tag, content, options];
        }
      }; //todo: deprecate tag arg, infer tag from shape object

      function convertShape(shape, tag) {
        return templates.element({
          'tag': tag,
          'width': shape.width,
          'height': shape.height,
          'fill': shape.properties.fill
        });
      }

      function textCss(properties) {
        return utils.cssProps({
          'fill': properties.fill,
          'font-weight': properties.font.weight,
          'font-family': properties.font.family + ', monospace',
          'font-size': properties.font.size + properties.font.units
        });
      }

      function outlinePath(bgWidth, bgHeight, outlineWidth) {
        var outlineOffsetWidth = outlineWidth / 2;
        return ['M', outlineOffsetWidth, outlineOffsetWidth, 'H', bgWidth - outlineOffsetWidth, 'V', bgHeight - outlineOffsetWidth, 'H', outlineOffsetWidth, 'V', 0, 'M', 0, outlineOffsetWidth, 'L', bgWidth, bgHeight - outlineOffsetWidth, 'M', 0, bgHeight - outlineOffsetWidth, 'L', bgWidth, outlineOffsetWidth].join(' ');
      }

      module.exports = function (sceneGraph, renderSettings) {
        var engineSettings = renderSettings.engineSettings;
        var stylesheets = engineSettings.stylesheets;
        var stylesheetXml = stylesheets.map(function (stylesheet) {
          return '<?xml-stylesheet rel="stylesheet" href="' + stylesheet + '"?>';
        }).join('\n');
        var holderId = 'holder_' + Number(new Date()).toString(16);
        var root = sceneGraph.root;
        var textGroup = root.children.holderTextGroup;
        var css = '#' + holderId + ' text { ' + textCss(textGroup.properties) + ' } '; // push text down to be equally vertically aligned with canvas renderer

        textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;
        var wordTags = [];
        Object.keys(textGroup.children).forEach(function (lineKey) {
          var line = textGroup.children[lineKey];
          Object.keys(line.children).forEach(function (wordKey) {
            var word = line.children[wordKey];
            var x = textGroup.x + line.x + word.x;
            var y = textGroup.y + line.y + word.y;
            var wordTag = templates.element({
              'tag': 'text',
              'content': word.properties.text,
              'x': x,
              'y': y
            });
            wordTags.push(wordTag);
          });
        });
        var text = templates.element({
          'tag': 'g',
          'content': wordTags
        });
        var outline = null;

        if (root.children.holderBg.properties.outline) {
          var outlineProperties = root.children.holderBg.properties.outline;
          outline = templates.element({
            'tag': 'path',
            'd': outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),
            'stroke-width': outlineProperties.width,
            'stroke': outlineProperties.fill,
            'fill': 'none'
          });
        }

        var bg = convertShape(root.children.holderBg, 'rect');
        var sceneContent = [];
        sceneContent.push(bg);

        if (outlineProperties) {
          sceneContent.push(outline);
        }

        sceneContent.push(text);
        var scene = templates.element({
          'tag': 'g',
          'id': holderId,
          'content': sceneContent
        });
        var style = templates.element({
          'tag': 'style',
          //todo: figure out how to add CDATA directive
          'content': css,
          'type': 'text/css'
        });
        var defs = templates.element({
          'tag': 'defs',
          'content': style
        });
        var svg = templates.element({
          'tag': 'svg',
          'content': [defs, scene],
          'width': root.properties.width,
          'height': root.properties.height,
          'xmlns': SVG_NS,
          'viewBox': [0, 0, root.properties.width, root.properties.height].join(' '),
          'preserveAspectRatio': 'none'
        });
        var output = shaven(svg);

        if (/\&amp;(x)?#[0-9A-Fa-f]/.test(output[0])) {
          output[0] = output[0].replace(/&amp;#/gm, '&#');
        }

        output = stylesheetXml + output[0];
        var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === 'background');
        return svgString;
      };
      /***/

    },
    /* 13 */

    /***/
    function (module, exports, __webpack_require__) {
      var escape = __webpack_require__(14); // TODO: remove namespace


      module.exports = function shaven(array, namespace, returnObject) {
        'use strict';

        var i = 1;
        var doesEscape = true;
        var HTMLString;
        var attributeKey;
        var callback;
        var key;
        returnObject = returnObject || {};

        function createElement(sugarString) {
          var tags = sugarString.match(/^[\w-]+/);
          var element = {
            tag: tags ? tags[0] : 'div',
            attr: {},
            children: []
          };
          var id = sugarString.match(/#([\w-]+)/);
          var reference = sugarString.match(/\$([\w-]+)/);
          var classNames = sugarString.match(/\.[\w-]+/g); // Assign id if is set

          if (id) {
            element.attr.id = id[1]; // Add element to the return object

            returnObject[id[1]] = element;
          }

          if (reference) returnObject[reference[1]] = element;
          if (classNames) element.attr.class = classNames.join(' ').replace(/\./g, '');
          if (sugarString.match(/&$/g)) doesEscape = false;
          return element;
        }

        function replacer(key, value) {
          if (value === null || value === false || value === undefined) return;
          if (typeof value !== 'string' && _typeof(value) !== 'object') return String(value);
          return value;
        }

        function escapeAttribute(string) {
          return string || string === 0 ? String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;') : '';
        }

        function escapeHTML(string) {
          return String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        if (typeof array[0] === 'string') array[0] = createElement(array[0]);else if (Array.isArray(array[0])) i = 0;else throw new Error('First element of array must be a string, ' + 'or an array and not ' + JSON.stringify(array[0]));

        for (; i < array.length; i++) {
          // Don't render element if value is false or null
          if (array[i] === false || array[i] === null) {
            array[0] = false;
            break;
          } // Continue with next array value if current value is undefined or true
          else if (array[i] === undefined || array[i] === true) {
              continue;
            } else if (typeof array[i] === 'string') {
              if (doesEscape) array[i] = escapeHTML(array[i]);
              array[0].children.push(array[i]);
            } else if (typeof array[i] === 'number') {
              array[0].children.push(array[i]);
            } else if (Array.isArray(array[i])) {
              if (Array.isArray(array[i][0])) {
                array[i].reverse().forEach(function (subArray) {
                  array.splice(i + 1, 0, subArray);
                });
                if (i !== 0) continue;
                i++;
              }

              shaven(array[i], namespace, returnObject);
              if (array[i][0]) array[0].children.push(array[i][0]);
            } else if (typeof array[i] === 'function') callback = array[i];else if (_typeof(array[i]) === 'object') {
              for (attributeKey in array[i]) {
                if (array[i].hasOwnProperty(attributeKey)) if (array[i][attributeKey] !== null && array[i][attributeKey] !== false) if (attributeKey === 'style' && _typeof(array[i][attributeKey]) === 'object') array[0].attr[attributeKey] = JSON.stringify(array[i][attributeKey], replacer).slice(2, -2).replace(/","/g, ';').replace(/":"/g, ':').replace(/\\"/g, '\'');else array[0].attr[attributeKey] = array[i][attributeKey];
              }
            } else throw new TypeError('"' + array[i] + '" is not allowed as a value.');
        }

        if (array[0] !== false) {
          HTMLString = '<' + array[0].tag;

          for (key in array[0].attr) {
            if (array[0].attr.hasOwnProperty(key)) HTMLString += ' ' + key + '="' + escapeAttribute(array[0].attr[key]) + '"';
          }

          HTMLString += '>';
          array[0].children.forEach(function (child) {
            HTMLString += child;
          });
          HTMLString += '</' + array[0].tag + '>';
          array[0] = HTMLString;
        } // Return root element on index 0


        returnObject[0] = array[0];
        if (callback) callback(array[0]); // returns object containing all elements with an id and the root element

        return returnObject;
      };
      /***/

    },
    /* 14 */

    /***/
    function (module, exports) {
      /*!
       * escape-html
       * Copyright(c) 2012-2013 TJ Holowaychuk
       * Copyright(c) 2015 Andreas Lubbe
       * Copyright(c) 2015 Tiancheng "Timothy" Gu
       * MIT Licensed
       */
      'use strict';
      /**
       * Module variables.
       * @private
       */

      var matchHtmlRegExp = /["'&<>]/;
      /**
       * Module exports.
       * @public
       */

      module.exports = escapeHtml;
      /**
       * Escape special characters in the given string of html.
       *
       * @param  {string} string The string to escape for inserting into HTML
       * @return {string}
       * @public
       */

      function escapeHtml(string) {
        var str = '' + string;
        var match = matchHtmlRegExp.exec(str);

        if (!match) {
          return str;
        }

        var escape;
        var html = '';
        var index = 0;
        var lastIndex = 0;

        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              // "
              escape = '&quot;';
              break;

            case 38:
              // &
              escape = '&amp;';
              break;

            case 39:
              // '
              escape = '&#39;';
              break;

            case 60:
              // <
              escape = '&lt;';
              break;

            case 62:
              // >
              escape = '&gt;';
              break;

            default:
              continue;
          }

          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }

          lastIndex = index + 1;
          html += escape;
        }

        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      /***/

    },
    /* 15 */

    /***/
    function (module, exports, __webpack_require__) {
      var DOM = __webpack_require__(9);

      var utils = __webpack_require__(7);

      module.exports = function () {
        var canvas = DOM.newEl('canvas');
        var ctx = null;
        return function (sceneGraph) {
          if (ctx == null) {
            ctx = canvas.getContext('2d');
          }

          var dpr = utils.canvasRatio();
          var root = sceneGraph.root;
          canvas.width = dpr * root.properties.width;
          canvas.height = dpr * root.properties.height;
          ctx.textBaseline = 'middle';
          var bg = root.children.holderBg;
          var bgWidth = dpr * bg.width;
          var bgHeight = dpr * bg.height; //todo: parametrize outline width (e.g. in scene object)

          var outlineWidth = 2;
          var outlineOffsetWidth = outlineWidth / 2;
          ctx.fillStyle = bg.properties.fill;
          ctx.fillRect(0, 0, bgWidth, bgHeight);

          if (bg.properties.outline) {
            //todo: abstract this into a method
            ctx.strokeStyle = bg.properties.outline.fill;
            ctx.lineWidth = bg.properties.outline.width;
            ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth); // TL, TR, BR, BL

            ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);
            ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);
            ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);
            ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth); // Diagonals

            ctx.moveTo(0, outlineOffsetWidth);
            ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);
            ctx.moveTo(0, bgHeight - outlineOffsetWidth);
            ctx.lineTo(bgWidth, outlineOffsetWidth);
            ctx.stroke();
          }

          var textGroup = root.children.holderTextGroup;
          ctx.font = textGroup.properties.font.weight + ' ' + dpr * textGroup.properties.font.size + textGroup.properties.font.units + ' ' + textGroup.properties.font.family + ', monospace';
          ctx.fillStyle = textGroup.properties.fill;

          for (var lineKey in textGroup.children) {
            var line = textGroup.children[lineKey];

            for (var wordKey in line.children) {
              var word = line.children[wordKey];
              var x = dpr * (textGroup.x + line.x + word.x);
              var y = dpr * (textGroup.y + line.y + word.y + textGroup.properties.leading / 2);
              ctx.fillText(word.properties.text, x, y);
            }
          }

          return canvas.toDataURL('image/png');
        };
      }();
      /***/

    }])
  );
});

;

(function (ctx, isMeteorPackage) {
  if (isMeteorPackage) {
    Holder = ctx.Holder;
  }
})(this, typeof Meteor !== 'undefined' && typeof Package !== 'undefined');
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/less/editor-style.less":
/*!************************************!*\
  !*** ./src/less/editor-style.less ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/less/style.less":
/*!*****************************!*\
  !*** ./src/less/style.less ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/*!***********************************************************************************!*\
  !*** multi ./src/js/bundle.js ./src/less/style.less ./src/less/editor-style.less ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /Users/josiah/Local Sites/goshawk-theme/app/public/wp-content/themes/goshawk/src/js/bundle.js */"./src/js/bundle.js");
__webpack_require__(/*! /Users/josiah/Local Sites/goshawk-theme/app/public/wp-content/themes/goshawk/src/less/style.less */"./src/less/style.less");
module.exports = __webpack_require__(/*! /Users/josiah/Local Sites/goshawk-theme/app/public/wp-content/themes/goshawk/src/less/editor-style.less */"./src/less/editor-style.less");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bmb3J0YXdlc29tZS9mb250YXdlc29tZS1zdmctY29yZS9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZyZWUtYnJhbmRzLXN2Zy1pY29ucy9mYUZhY2Vib29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhRmFjZWJvb2tGLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhSW5zdGFncmFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhTGlua2VkaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFMaW5rZWRpbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhVHdpdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9idW5kbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2ljb25zLWltcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZXJuaXpyLWN1c3RvbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbmF2aWdhdGlvbi1kcm9wZG93bi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmFyZWJpcmQtaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xlc3MvZWRpdG9yLXN0eWxlLmxlc3M/NWRiOCIsIndlYnBhY2s6Ly8vLi9zcmMvbGVzcy9zdHlsZS5sZXNzP2E4MmMiXSwibmFtZXMiOlsibGlicmFyeSIsImFkZCIsImZhRmFjZWJvb2tGIiwiZmFGYWNlYm9vayIsImZhVHdpdHRlciIsImZhSW5zdGFncmFtIiwiZmFMaW5rZWRpbiIsImZhTGlua2VkaW5JbiIsImRvbSIsIndhdGNoIiwiZSIsInQiLCJuIiwiciIsInMiLCJvIiwiaSIsImwiLCJhIiwiUyIsImhhc093blByb3BlcnR5IiwibmFtZSIsInB1c2giLCJ0b0xvd2VyQ2FzZSIsIm9wdGlvbnMiLCJhbGlhc2VzIiwibGVuZ3RoIiwiZm4iLCJzcGxpdCIsIk1vZGVybml6ciIsIkJvb2xlYW4iLCJDIiwiam9pbiIsInciLCJjbGFzc05hbWUiLCJfY29uZmlnIiwiY2xhc3NQcmVmaXgiLCJiIiwiYmFzZVZhbCIsImVuYWJsZUpTQ2xhc3MiLCJSZWdFeHAiLCJyZXBsYWNlIiwiZW5hYmxlQ2xhc3NlcyIsInRvVXBwZXJDYXNlIiwiY3JlYXRlRWxlbWVudCIsImFyZ3VtZW50cyIsImNyZWF0ZUVsZW1lbnROUyIsImNhbGwiLCJhcHBseSIsImluZGV4T2YiLCJ1IiwiYm9keSIsImZha2UiLCJmIiwiZCIsInAiLCJjIiwicGFyc2VJbnQiLCJpZCIsImFwcGVuZENoaWxkIiwidHlwZSIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJzdHlsZSIsImJhY2tncm91bmQiLCJvdmVyZmxvdyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIm9mZnNldEhlaWdodCIsIm0iLCJnZXRDb21wdXRlZFN0eWxlIiwiY29uc29sZSIsImdldFByb3BlcnR5VmFsdWUiLCJlcnJvciIsImN1cnJlbnRTdHlsZSIsImciLCJDU1MiLCJzdXBwb3J0cyIsInkiLCJMIiwibW9kRWxlbSIsInYiLCJzaGlmdCIsImgiLCJjaGFyQXQiLCJzbGljZSIsInoiLCJQIiwieCIsIl92ZXJzaW9uIiwidXNlUHJlZml4ZXMiLCJfcSIsIm9uIiwic2V0VGltZW91dCIsImFkZFRlc3QiLCJhZGRBc3luY1Rlc3QiLCJwcm90b3R5cGUiLCJfIiwiX3ByZWZpeGVzIiwiZG9jdW1lbnRFbGVtZW50Iiwibm9kZU5hbWUiLCJUIiwiX2RvbVByZWZpeGVzIiwicG9zaXRpb24iLCJrIiwiRSIsIl9jc3NvbVByZWZpeGVzIiwiaiIsIkNTU1J1bGUiLCJhdFJ1bGUiLCJOIiwidGVzdFN0eWxlcyIsImVsZW0iLCJ1bnNoaWZ0IiwidGVzdFByb3AiLCJ0ZXN0QWxsUHJvcHMiLCJwcmVmaXhlZCIsImRvY3VtZW50TW9kZSIsIk8iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImpRdWVyeSIsInJlYWR5IiwiJCIsImVsbSIsIm9mZiIsIm9mZnNldCIsImxlZnQiLCJ3aWR0aCIsImRvY0giLCJoZWlnaHQiLCJkb2NXIiwiaXNFbnRpcmVseVZpc2libGUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiTm9kZUxpc3QiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwidHJhbnNpdGlvbkVuZCIsImVsIiwidHJhbnNFbmRFdmVudE5hbWVzIiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJPVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJ1bmRlZmluZWQiLCJlbmQiLCJlbXVsYXRlVHJhbnNpdGlvbkVuZCIsImR1cmF0aW9uIiwiY2FsbGVkIiwiJGVsIiwib25lIiwidHJpZ2dlciIsInN1cHBvcnQiLCJldmVudCIsInNwZWNpYWwiLCJic1RyYW5zaXRpb25FbmQiLCJiaW5kVHlwZSIsImRlbGVnYXRlVHlwZSIsImhhbmRsZSIsInRhcmdldCIsImlzIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsImRpc21pc3MiLCJBbGVydCIsImNsb3NlIiwiVkVSU0lPTiIsIlRSQU5TSVRJT05fRFVSQVRJT04iLCIkdGhpcyIsInNlbGVjdG9yIiwiYXR0ciIsIiRwYXJlbnQiLCJmaW5kIiwicHJldmVudERlZmF1bHQiLCJjbG9zZXN0IiwiRXZlbnQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyZW1vdmVFbGVtZW50IiwiZGV0YWNoIiwicmVtb3ZlIiwiaGFzQ2xhc3MiLCJQbHVnaW4iLCJvcHRpb24iLCJlYWNoIiwiZGF0YSIsIm9sZCIsImFsZXJ0IiwiQ29uc3RydWN0b3IiLCJub0NvbmZsaWN0IiwiTW9kYWwiLCJlbGVtZW50IiwiJGJvZHkiLCIkZWxlbWVudCIsIiRkaWFsb2ciLCIkYmFja2Ryb3AiLCJpc1Nob3duIiwib3JpZ2luYWxCb2R5UGFkIiwic2Nyb2xsYmFyV2lkdGgiLCJpZ25vcmVCYWNrZHJvcENsaWNrIiwicmVtb3RlIiwibG9hZCIsInByb3h5IiwiQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiIsIkRFRkFVTFRTIiwiYmFja2Ryb3AiLCJrZXlib2FyZCIsInNob3ciLCJ0b2dnbGUiLCJfcmVsYXRlZFRhcmdldCIsImhpZGUiLCJ0aGF0IiwicmVsYXRlZFRhcmdldCIsImNoZWNrU2Nyb2xsYmFyIiwic2V0U2Nyb2xsYmFyIiwiZXNjYXBlIiwicmVzaXplIiwicGFyZW50IiwiYXBwZW5kVG8iLCJzY3JvbGxUb3AiLCJhZGp1c3REaWFsb2ciLCJvZmZzZXRXaWR0aCIsImVuZm9yY2VGb2N1cyIsImhpZGVNb2RhbCIsImhhcyIsIndoaWNoIiwiaGFuZGxlVXBkYXRlIiwicmVzZXRBZGp1c3RtZW50cyIsInJlc2V0U2Nyb2xsYmFyIiwicmVtb3ZlQmFja2Ryb3AiLCJhbmltYXRlIiwiZG9BbmltYXRlIiwiY3VycmVudFRhcmdldCIsImZvY3VzIiwiY2FsbGJhY2tSZW1vdmUiLCJtb2RhbElzT3ZlcmZsb3dpbmciLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjc3MiLCJwYWRkaW5nTGVmdCIsImJvZHlJc092ZXJmbG93aW5nIiwicGFkZGluZ1JpZ2h0IiwiZnVsbFdpbmRvd1dpZHRoIiwiaW5uZXJXaWR0aCIsImRvY3VtZW50RWxlbWVudFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyaWdodCIsIk1hdGgiLCJhYnMiLCJjbGllbnRXaWR0aCIsIm1lYXN1cmVTY3JvbGxiYXIiLCJib2R5UGFkIiwic2Nyb2xsRGl2IiwiYXBwZW5kIiwiZXh0ZW5kIiwibW9kYWwiLCJocmVmIiwiJHRhcmdldCIsInRlc3QiLCJzaG93RXZlbnQiLCJfTUFQIiwiX0tFWUNPREVfTUFQIiwiX1NISUZUX01BUCIsIl9TUEVDSUFMX0FMSUFTRVMiLCJuYXZpZ2F0b3IiLCJwbGF0Zm9ybSIsIl9SRVZFUlNFX01BUCIsInRvU3RyaW5nIiwiX2FkZEV2ZW50Iiwib2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiX2NoYXJhY3RlckZyb21FdmVudCIsImNoYXJhY3RlciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNoaWZ0S2V5IiwiX21vZGlmaWVyc01hdGNoIiwibW9kaWZpZXJzMSIsIm1vZGlmaWVyczIiLCJzb3J0IiwiX2V2ZW50TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJfcHJldmVudERlZmF1bHQiLCJyZXR1cm5WYWx1ZSIsIl9zdG9wUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJfaXNNb2RpZmllciIsImtleSIsIl9nZXRSZXZlcnNlTWFwIiwiX3BpY2tCZXN0QWN0aW9uIiwiYWN0aW9uIiwiX2tleXNGcm9tU3RyaW5nIiwiY29tYmluYXRpb24iLCJfZ2V0S2V5SW5mbyIsImtleXMiLCJfYmVsb25nc1RvIiwiYW5jZXN0b3IiLCJNb3VzZXRyYXAiLCJ0YXJnZXRFbGVtZW50Iiwic2VsZiIsIl9jYWxsYmFja3MiLCJfZGlyZWN0TWFwIiwiX3NlcXVlbmNlTGV2ZWxzIiwiX3Jlc2V0VGltZXIiLCJfaWdub3JlTmV4dEtleXVwIiwiX2lnbm9yZU5leHRLZXlwcmVzcyIsIl9uZXh0RXhwZWN0ZWRBY3Rpb24iLCJfcmVzZXRTZXF1ZW5jZXMiLCJkb05vdFJlc2V0IiwiYWN0aXZlU2VxdWVuY2VzIiwiX2dldE1hdGNoZXMiLCJzZXF1ZW5jZU5hbWUiLCJsZXZlbCIsIm1hdGNoZXMiLCJzZXEiLCJkZWxldGVDb21ibyIsImNvbWJvIiwiZGVsZXRlU2VxdWVuY2UiLCJzcGxpY2UiLCJfZmlyZUNhbGxiYWNrIiwic2VxdWVuY2UiLCJzdG9wQ2FsbGJhY2siLCJzcmNFbGVtZW50IiwiX2hhbmRsZUtleSIsImNhbGxiYWNrcyIsIm1heExldmVsIiwicHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjayIsIm1heCIsImlnbm9yZVRoaXNLZXlwcmVzcyIsIl9oYW5kbGVLZXlFdmVudCIsImtleUNvZGUiLCJoYW5kbGVLZXkiLCJfcmVzZXRTZXF1ZW5jZVRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiX2JpbmRTZXF1ZW5jZSIsIl9pbmNyZWFzZVNlcXVlbmNlIiwibmV4dEFjdGlvbiIsIl9jYWxsYmFja0FuZFJlc2V0IiwiaXNGaW5hbCIsIndyYXBwZWRDYWxsYmFjayIsIl9iaW5kU2luZ2xlIiwiaW5mbyIsIl9iaW5kTXVsdGlwbGUiLCJjb21iaW5hdGlvbnMiLCJiaW5kIiwiQXJyYXkiLCJ1bmJpbmQiLCJyZXNldCIsInRhZ05hbWUiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImFkZEtleWNvZGVzIiwiaW5pdCIsImRvY3VtZW50TW91c2V0cmFwIiwibWV0aG9kIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmluZSIsIlBhcnNsZXlDb25maWciLCJ2YWxpZGF0b3JzIiwibHVobiIsInZhbHVlIiwiZGlnaXQiLCJfaiIsIl9sZW4xIiwiX3JlZjIiLCJzdW0iLCJyZXZlcnNlIiwicHJpb3JpdHkiLCJfc2xpY2UiLCJfc2xpY2VkVG9BcnJheSIsInNsaWNlSXRlcmF0b3IiLCJhcnIiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwibmV4dCIsImRvbmUiLCJlcnIiLCJpc0FycmF5IiwiT2JqZWN0IiwiVHlwZUVycm9yIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJzb3VyY2UiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIyIiwiZnJvbSIsImdsb2JhbCIsImZhY3RvcnkiLCJyZXF1aXJlIiwiZ2xvYmFsSUQiLCJwYXN0V2FybmluZ3MiLCJVdGlscyIsIm5hbWVzcGFjZSIsIm9iaiIsImF0dHJpYnV0ZSIsImF0dHJpYnV0ZXMiLCJyZWdleCIsInNwZWNpZmllZCIsImNhbWVsaXplIiwiZGVzZXJpYWxpemVWYWx1ZSIsImNoZWNrQXR0ciIsIl9jaGVja0F0dHIiLCJoYXNBdHRyaWJ1dGUiLCJzZXRBdHRyIiwic2V0QXR0cmlidXRlIiwiZGFzaGVyaXplIiwiZ2V0VHlwZSIsImdldEF0dHJpYnV0ZSIsImdlbmVyYXRlSUQiLCJudW0iLCJpc05hTiIsIk51bWJlciIsIkpTT04iLCJwYXJzZSIsInN0ciIsIm1hdGNoIiwiY2hyIiwid2FybiIsIl93aW5kb3ckY29uc29sZSIsIndhcm5PbmNlIiwibXNnIiwiX3Jlc2V0V2FybmluZ3MiLCJ0cmltU3RyaW5nIiwic3RyaW5nIiwiZGF0ZSIsInBhcnNlZCIsIl9wYXJzZWQkbWFwIiwibWFwIiwiX3BhcnNlZCRtYXAyIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiX3N0cmluZyIsImludGVnZXIiLCJudW1iZXIiLCJwYXJzZUZsb2F0IiwiX2Jvb2xlYW4iLCJyZWdleHAiLCJfcmVnZXhwIiwiZmxhZ3MiLCJwYXJzZVJlcXVpcmVtZW50IiwicmVxdWlyZW1lbnRUeXBlIiwiY29udmVydGVyIiwiY29udmVydGVkIiwibmFtZXNwYWNlRXZlbnRzIiwiZXZlbnRzIiwiZXZ0IiwiZGlmZmVyZW5jZSIsImFycmF5IiwicmVzdWx0IiwiYWxsIiwicHJvbWlzZXMiLCJ3aGVuIiwiY29uY2F0Iiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwiRXJyb3IiLCJfU3VibWl0U2VsZWN0b3IiLCJEZWZhdWx0cyIsImlucHV0cyIsImV4Y2x1ZGVkIiwicHJpb3JpdHlFbmFibGVkIiwibXVsdGlwbGUiLCJncm91cCIsInVpRW5hYmxlZCIsInZhbGlkYXRpb25UaHJlc2hvbGQiLCJ0cmlnZ2VyQWZ0ZXJGYWlsdXJlIiwiZXJyb3JDbGFzcyIsInN1Y2Nlc3NDbGFzcyIsImNsYXNzSGFuZGxlciIsIkZpZWxkIiwiZXJyb3JzQ29udGFpbmVyIiwiZXJyb3JzV3JhcHBlciIsImVycm9yVGVtcGxhdGUiLCJCYXNlIiwiX19pZF9fIiwiYXN5bmNTdXBwb3J0IiwiX3BpcGVBY2NvcmRpbmdUb1ZhbGlkYXRpb25SZXN1bHQiLCJfdGhpcyIsInBpcGUiLCJEZWZlcnJlZCIsInZhbGlkYXRpb25SZXN1bHQiLCJyZWplY3QiLCJyZXNvbHZlIiwicHJvbWlzZSIsImFjdHVhbGl6ZU9wdGlvbnMiLCJkb21PcHRpb25zIiwiX3Jlc2V0T3B0aW9ucyIsImluaXRPcHRpb25zIiwiX2xpc3RlbmVycyIsInF1ZXVlIiwic3Vic2NyaWJlIiwibGlzdGVuVG8iLCJ1bnN1YnNjcmliZSIsInVuc3Vic2NyaWJlVG8iLCJleHRyYUFyZyIsInBhcmVudFJlc3VsdCIsImFzeW5jSXNWYWxpZCIsImZvcmNlIiwid2hlblZhbGlkIiwiX2ZpbmRSZWxhdGVkIiwicXVlcnlTZWxlY3RvckFsbCIsImNvbnZlcnRBcnJheVJlcXVpcmVtZW50IiwidmFsdWVzIiwiY29udmVydEV4dHJhT3B0aW9uUmVxdWlyZW1lbnQiLCJyZXF1aXJlbWVudFNwZWMiLCJleHRyYU9wdGlvblJlYWRlciIsIm1haW4iLCJleHRyYSIsIlZhbGlkYXRvciIsInNwZWMiLCJ2YWxpZGF0ZSIsInJlcXVpcmVtZW50Rmlyc3RBcmciLCJ2YWxpZGF0ZU11bHRpcGxlIiwiaW5zdGFuY2UiLCJ2YWxpZGF0ZURhdGUiLCJfaXNEYXRlSW5wdXQiLCJ2YWxpZGF0ZU51bWJlciIsInZhbGlkYXRlU3RyaW5nIiwicGFyc2VSZXF1aXJlbWVudHMiLCJyZXF1aXJlbWVudHMiLCJpc1BsYWluT2JqZWN0IiwiVmFsaWRhdG9yUmVnaXN0cnkiLCJjYXRhbG9nIiwiX19jbGFzc19fIiwibG9jYWxlIiwidHlwZVRlc3RlcnMiLCJlbWFpbCIsImRpZ2l0cyIsImFscGhhbnVtIiwidXJsIiwicmFuZ2UiLCJkZWNpbWFsUGxhY2VzIiwiVmFsaWRhdG9yUmVnaXN0cnlfX3BhcnNlQXJndW1lbnRzIiwiYXJncyIsIlZhbGlkYXRvclJlZ2lzdHJ5X19vcGVyYXRvclRvVmFsaWRhdG9yIiwib3BlcmF0b3IiLCJfbGVuIiwicmVxdWlyZW1lbnRzQW5kSW5wdXQiLCJfa2V5IiwicG9wIiwiVmFsaWRhdG9yUmVnaXN0cnlfX2NvbXBhcmlzb25PcGVyYXRvciIsImFkZFZhbGlkYXRvciIsIlBhcnNsZXkiLCJzZXRMb2NhbGUiLCJhZGRDYXRhbG9nIiwibWVzc2FnZXMiLCJzZXQiLCJhZGRNZXNzYWdlIiwibWVzc2FnZSIsImFkZE1lc3NhZ2VzIiwibmFtZU1lc3NhZ2VPYmplY3QiLCJhcmcxIiwiYXJnMiIsIl9zZXRWYWxpZGF0b3IiLCJoYXNWYWxpZGF0b3IiLCJ1cGRhdGVWYWxpZGF0b3IiLCJyZW1vdmVWYWxpZGF0b3IiLCJ2YWxpZGF0b3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJjb25zdHJhaW50IiwidHlwZU1lc3NhZ2VzIiwiZm9ybWF0TWVzc2FnZSIsImRlZmF1bHRNZXNzYWdlIiwiZW4iLCJwYXJhbWV0ZXJzIiwibm90YmxhbmsiLCJyZXF1aXJlZCIsIl9yZWYiLCJfcmVmJHN0ZXAiLCJzdGVwIiwiX3JlZiRiYXNlIiwiYmFzZSIsInRlc3RlciIsIm5iIiwiZGVjaW1hbHMiLCJ0b0ludCIsInJvdW5kIiwicG93IiwicGF0dGVybiIsIm1pbmxlbmd0aCIsInJlcXVpcmVtZW50IiwibWF4bGVuZ3RoIiwibWluIiwibWluY2hlY2siLCJtYXhjaGVjayIsImNoZWNrIiwiZXF1YWx0byIsInJlZk9yVmFsdWUiLCIkcmVmZXJlbmNlIiwidmFsIiwiVUkiLCJkaWZmUmVzdWx0cyIsIm5ld1Jlc3VsdCIsIm9sZFJlc3VsdCIsImRlZXAiLCJhZGRlZCIsImtlcHQiLCJmb3VuZCIsImFzc2VydCIsInJlbW92ZWQiLCJGb3JtIiwiX2FjdHVhbGl6ZVRyaWdnZXJzIiwiX3RoaXMyIiwib25TdWJtaXRWYWxpZGF0ZSIsIm9uU3VibWl0QnV0dG9uIiwiX2ZvY3VzZWRGaWVsZCIsImZpZWxkcyIsImZpZWxkIiwibm9Gb2N1cyIsIl9kZXN0cm95VUkiLCJfcmVmbG93VUkiLCJfYnVpbGRVSSIsIl91aSIsImRpZmYiLCJsYXN0VmFsaWRhdGlvblJlc3VsdCIsIl9tYW5hZ2VTdGF0dXNDbGFzcyIsIl9tYW5hZ2VFcnJvcnNNZXNzYWdlcyIsIl9mYWlsZWRPbmNlIiwiZ2V0RXJyb3JzTWVzc2FnZXMiLCJlcnJvck1lc3NhZ2UiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiYWRkRXJyb3IiLCJfcmVmMiR1cGRhdGVDbGFzcyIsInVwZGF0ZUNsYXNzIiwiX2FkZEVycm9yIiwiX2Vycm9yQ2xhc3MiLCJ1cGRhdGVFcnJvciIsIl9yZWYzIiwiX3JlZjMkdXBkYXRlQ2xhc3MiLCJfdXBkYXRlRXJyb3IiLCJyZW1vdmVFcnJvciIsIl9yZWY0IiwiX3JlZjQkdXBkYXRlQ2xhc3MiLCJfcmVtb3ZlRXJyb3IiLCJoYXNDb25zdHJhaW50cyIsIm5lZWRzVmFsaWRhdGlvbiIsIl9zdWNjZXNzQ2xhc3MiLCJfcmVzZXRDbGFzcyIsImVycm9yc01lc3NhZ2VzRGlzYWJsZWQiLCJfaW5zZXJ0RXJyb3JXcmFwcGVyIiwiJGVycm9yc1dyYXBwZXIiLCJodG1sIiwiX3JlZjUiLCIkZXJyb3JDbGFzc0hhbmRsZXIiLCJlcnJvcnNXcmFwcGVySWQiLCJfcmVmNiIsInJlbW92ZUF0dHIiLCJjdXN0b21Db25zdHJhaW50RXJyb3JNZXNzYWdlIiwiX21hbmFnZUNsYXNzSGFuZGxlciIsInZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUiLCIkaGFuZGxlckZ1bmN0aW9uIiwiJGhhbmRsZXIiLCJfaW5wdXRIb2xkZXIiLCIkZXJyb3JzQ29udGFpbmVyIiwiYWZ0ZXIiLCJfdGhpczMiLCIkdG9CaW5kIiwiX3ZhbGlkYXRlSWZOZWVkZWQiLCJfdGhpczQiLCJnZXRWYWx1ZSIsImRlYm91bmNlIiwiX2RlYm91bmNlZCIsIl9yZXNldFVJIiwiY2hpbGRyZW4iLCJGb3JtX19zdGF0dXNNYXBwaW5nIiwicGVuZGluZyIsInJlc29sdmVkIiwicmVqZWN0ZWQiLCJfdGhpczUiLCJwYXJzbGV5Iiwic3VibWl0U291cmNlIiwiX3N1Ym1pdFNvdXJjZSIsInByb3AiLCJfcmVtb3RlQ2FjaGUiLCJ3aGVuVmFsaWRhdGUiLCJzdGF0ZSIsIl90cmlnZ2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX3N1Ym1pdCIsIiRzeW50aGV0aWMiLCJfYXJndW1lbnRzIiwiX1V0aWxzJGFsbCRkb25lJGZhaWwkYWx3YXlzIiwiX3RoaXM2IiwiX3JlZjciLCJzdWJtaXRFdmVudCIsIl9yZWZyZXNoRmllbGRzIiwiX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMiLCJmYWlsIiwiYWx3YXlzIiwiaXNWYWxpZCIsIl9hcmd1bWVudHMyIiwiX3RoaXM3IiwiX3JlZjgiLCJyZWZyZXNoIiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJfYmluZEZpZWxkcyIsIl90aGlzOCIsIm9sZEZpZWxkcyIsImZpZWxkc01hcHBlZEJ5SWQiLCJub3QiLCJmaWVsZEluc3RhbmNlIiwiRmFjdG9yeSIsInVuaXF1ZUlkIiwib2xkQWN0dWFsaXplT3B0aW9ucyIsImV2ZW50TmFtZSIsIkNvbnN0cmFpbnQiLCJwYXJzbGV5RmllbGQiLCJpc0RvbUNvbnN0cmFpbnQiLCJ2YWxpZGF0b3JTcGVjIiwiX3ZhbGlkYXRvclJlZ2lzdHJ5IiwiX3BhcnNlUmVxdWlyZW1lbnRzIiwiY2FwaXRhbGl6ZSIsImNhcCIsIl92YWxpZGF0b3IiLCJyZXF1aXJlbWVudExpc3QiLCJfdGhpczkiLCJwYXJzbGV5Rm9ybUluc3RhbmNlIiwiY29uc3RyYWludHMiLCJjb25zdHJhaW50c0J5TmFtZSIsIl9iaW5kQ29uc3RyYWludHMiLCJwYXJzbGV5X2ZpZWxkX19zdGF0dXNNYXBwaW5nIiwiX3doZW5WYWxpZCRhbHdheXMkZG9uZSRmYWlsJGFsd2F5cyIsIl90aGlzMTAiLCJfcmVmOSIsIl9pc0luR3JvdXAiLCJfcmVmcmVzaGVkIiwiX2lzUmVxdWlyZWQiLCJ2YWxpZGF0ZUlmRW1wdHkiLCJpbkFycmF5IiwiX2FyZ3VtZW50czMiLCJfdGhpczExIiwiX3JlZjEwIiwiX3JlZjEwJGZvcmNlIiwiZ3JvdXBlZENvbnN0cmFpbnRzIiwiX2dldEdyb3VwZWRDb25zdHJhaW50cyIsIl92YWxpZGF0ZUNvbnN0cmFpbnQiLCJfdGhpczEyIiwiX2hhbmRsZVdoaXRlc3BhY2UiLCJfcmVmcmVzaENvbnN0cmFpbnRzIiwicmVmcmVzaENvbnN0cmFpbnRzIiwiYWRkQ29uc3RyYWludCIsInJlbW92ZUNvbnN0cmFpbnQiLCJ1cGRhdGVDb25zdHJhaW50IiwiX2JpbmRIdG1sNUNvbnN0cmFpbnRzIiwidHJpbVZhbHVlIiwid2hpdGVzcGFjZSIsImluZGV4IiwicGFyc2xleV9maWVsZCIsIk11bHRpcGxlIiwiYWRkRWxlbWVudCIsIiRlbGVtZW50cyIsImZpZWxkQ29uc3RyYWludHMiLCJmaWx0ZXIiLCJfaW5pdCIsInNhdmVkcGFyc2xleUZvcm1JbnN0YW5jZSIsIl9fdmVyc2lvbl9fIiwiaXNNdWx0aXBsZSIsImhhbmRsZU11bHRpcGxlIiwiX3RoaXMxMyIsInBhcnNsZXlNdWx0aXBsZUluc3RhbmNlIiwiaW5wdXQiLCIkcHJldmlvdXNseVJlbGF0ZWQiLCJnZXQiLCJkb05vdFN0b3JlIiwicGFyc2xleUluc3RhbmNlIiwiUGFyc2xleUV4dGVuZCIsInZlcm51bXMiLCJqcXVlcnkiLCJ2ZXJzaW9uIiwicHNseSIsImluc3RhbmNlcyIsIlBhcnNsZXlVdGlscyIsInJlZ2lzdHJ5IiwiaTE4biIsIlBhcnNsZXlWYWxpZGF0b3IiLCJfd2luZG93JFBhcnNsZXkiLCJQYXJzbGV5VUkiLCJkb05vdFVwZGF0ZUNsYXNzIiwiYXV0b0JpbmQiLCJkZXByZWNhdGVkIiwiYWRhcHQiLCJjb250ZXh0IiwicGFyc2xleUFkYXB0ZWRDYWxsYmFjayIsImV2ZW50UHJlZml4IiwibGFzdEluZGV4T2YiLCJzdWJzdHIiLCJsaXN0ZW4iLCJ1bnN1YnNjcmliZUFsbCIsImVtaXQiLCJfaW5zdGFuY2UiLCJpbnN0YW5jZUdpdmVuIiwicHVic3ViIiwiYXN5bmNWYWxpZGF0b3JzIiwieGhyIiwic3RhdHVzIiwiYWRkQXN5bmNWYWxpZGF0b3IiLCJhamF4T3B0aW9ucyIsImNzciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlbW90ZU9wdGlvbnMiLCJwYXJhbSIsImFqYXgiLCJoYW5kbGVYaHIiLCJ0aGVuIiwiSW5wdXRFdmVudCIsIl90aGlzMTQiLCJnbG9iYWxzIiwiaXNOYXRpdmVFdmVudCIsIm9yaWdpbmFsRXZlbnQiLCJpc1RydXN0ZWQiLCJmYWtlSW5wdXRFdmVudCIsIm1pc2JlaGF2ZXMiLCJiZWhhdmVzT2siLCJpbnN0YWxsIiwiaW5wdXRFdmVudFBhdGNoZWQiLCJ1bmluc3RhbGwiLCJpbnB1dGV2ZW50IiwibGF6eVNpemVzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImxhenlzaXplcyIsImxhenlTaXplc0NvbmZpZyIsImRvY0VsZW0iLCJzdXBwb3J0UGljdHVyZSIsIkhUTUxQaWN0dXJlRWxlbWVudCIsIl9hZGRFdmVudExpc3RlbmVyIiwiX2dldEF0dHJpYnV0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJyZWdQaWN0dXJlIiwibG9hZEV2ZW50cyIsInJlZ0NsYXNzQ2FjaGUiLCJlbGUiLCJjbHMiLCJ0cmltIiwicmVnIiwiYWRkUmVtb3ZlTG9hZEV2ZW50cyIsInRyaWdnZXJFdmVudCIsImRldGFpbCIsIm5vQnViYmxlcyIsIm5vQ2FuY2VsYWJsZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInVwZGF0ZVBvbHlmaWxsIiwiZnVsbCIsInBvbHlmaWxsIiwicGljdHVyZWZpbGwiLCJwZiIsInNyYyIsInJlZXZhbHVhdGUiLCJlbGVtZW50cyIsImdldENTUyIsImdldFdpZHRoIiwibWluU2l6ZSIsIl9sYXp5c2l6ZXNXaWR0aCIsInJBRiIsInJ1bm5pbmciLCJ3YWl0aW5nIiwiZmlyc3RGbnMiLCJzZWNvbmRGbnMiLCJmbnMiLCJydW4iLCJydW5GbnMiLCJyYWZCYXRjaCIsImhpZGRlbiIsIl9sc0ZsdXNoIiwickFGSXQiLCJzaW1wbGUiLCJ0aHJvdHRsZSIsImxhc3RUaW1lIiwiZ0RlbGF5IiwidGhyb3R0bGVEZWxheSIsInJJQ1RpbWVvdXQiLCJyaWNUaW1lb3V0Iiwibm93IiwiaWRsZUNhbGxiYWNrIiwidGltZW91dCIsImlzUHJpb3JpdHkiLCJkZWxheSIsImZ1bmMiLCJ0aW1lc3RhbXAiLCJ3YWl0IiwibGF0ZXIiLCJsYXN0IiwibGF6eVNpemVzRGVmYXVsdHMiLCJsYXp5Q2xhc3MiLCJsb2FkZWRDbGFzcyIsImxvYWRpbmdDbGFzcyIsInByZWxvYWRDbGFzcyIsImF1dG9zaXplc0NsYXNzIiwic3JjQXR0ciIsInNyY3NldEF0dHIiLCJzaXplc0F0dHIiLCJjdXN0b21NZWRpYSIsImV4cEZhY3RvciIsImhGYWMiLCJsb2FkTW9kZSIsImxvYWRIaWRkZW4iLCJsYXp5c2l6ZXNDb25maWciLCJsb2FkZXIiLCJwcmVsb2FkRWxlbXMiLCJpc0NvbXBsZXRlZCIsInJlc2V0UHJlbG9hZGluZ1RpbWVyIiwic3RhcnRlZCIsImVMdlciLCJlbHZIIiwiZUx0b3AiLCJlTGxlZnQiLCJlTHJpZ2h0IiwiZUxib3R0b20iLCJkZWZhdWx0RXhwYW5kIiwicHJlbG9hZEV4cGFuZCIsInJlZ0ltZyIsInJlZ0lmcmFtZSIsInN1cHBvcnRTY3JvbGwiLCJ1c2VyQWdlbnQiLCJzaHJpbmtFeHBhbmQiLCJjdXJyZW50RXhwYW5kIiwiaXNMb2FkaW5nIiwibG93UnVucyIsInJlc2V0UHJlbG9hZGluZyIsImlzTmVzdGVkVmlzaWJsZSIsImVsZW1FeHBhbmQiLCJvdXRlclJlY3QiLCJ2aXNpYmxlIiwib2Zmc2V0UGFyZW50IiwidG9wIiwiYm90dG9tIiwiY2hlY2tFbGVtZW50cyIsImVMbGVuIiwicmVjdCIsImF1dG9Mb2FkRWxlbSIsImxvYWRlZFNvbWV0aGluZyIsImVsZW1OZWdhdGl2ZUV4cGFuZCIsImVsZW1FeHBhbmRWYWwiLCJiZWZvcmVFeHBhbmRWYWwiLCJsYXp5bG9hZEVsZW1zIiwiZXhwYW5kIiwiX2xhenlSYWNlIiwidW52ZWlsRWxlbWVudCIsImlubmVySGVpZ2h0IiwicHJlbG9hZEFmdGVyTG9hZCIsInRocm90dGxlZENoZWNrRWxlbWVudHMiLCJzd2l0Y2hMb2FkaW5nQ2xhc3MiLCJyYWZTd2l0Y2hMb2FkaW5nQ2xhc3MiLCJyYWZlZFN3aXRjaExvYWRpbmdDbGFzcyIsImNoYW5nZUlmcmFtZVNyYyIsImNvbnRlbnRXaW5kb3ciLCJsb2NhdGlvbiIsImhhbmRsZVNvdXJjZXMiLCJzb3VyY2VTcmNzZXQiLCJsYXp5VW52ZWlsIiwiaXNBdXRvIiwic2l6ZXMiLCJpc0ltZyIsInNyY3NldCIsImlzUGljdHVyZSIsImZpcmVzTG9hZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNvbXBsZXRlIiwibmF0dXJhbFdpZHRoIiwiYXV0b1NpemVyIiwidXBkYXRlRWxlbSIsIm9ubG9hZCIsImFmdGVyU2Nyb2xsIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwic2V0SW50ZXJ2YWwiLCJyZWFkeVN0YXRlIiwiY2hlY2tFbGVtcyIsInVudmVpbCIsImF1dG9zaXplc0VsZW1zIiwic2l6ZUVsZW1lbnQiLCJzb3VyY2VzIiwibGVuIiwiZGF0YUF0dHIiLCJnZXRTaXplRWxlbWVudCIsInVwZGF0ZUVsZW1lbnRzU2l6ZXMiLCJkZWJvdW5jZWRVcGRhdGVFbGVtZW50c1NpemVzIiwiY2ZnIiwidVAiLCJhQyIsInJDIiwiaEMiLCJmaXJlIiwiZ1ciLCJwYXNzaXZlRXZlbnRMaXN0ZW5lck9wdGlvblN1cHBvcnRlZCIsIm9wdHMiLCJkZWZpbmVQcm9wZXJ0eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsInBhc3NpdmUiLCJkb21Mb2FkZWRDYWxsYmFjayIsImNsYXNzTGlzdCIsImRvU2Nyb2xsIiwiY2xpY2tEaXNwYXRjaCIsIiRjdXN0b21fdHJpZ2dlcl9jbGFzcyIsInRvZ2dsZUNsYXNzIiwiaGFzQXJpYVByZXNzZWRBdHRyIiwiaGFzQXJpYUV4cGFuZGVkQXR0ciIsIiRub3RpZnlfY2xhc3MiLCIkY3VzdG9tX3RhcmdldF9jbGFzcyIsInNpYmxpbmdzIiwiJGdsb2JhbF9oZWFkZXIiLCIkbmF2X291dGVyX3dyYXBwZXIiLCIkbmF2X2FjdGl2ZV9wYXJlbnQiLCIkbmF2X2NoaWxkIiwiJG5hdl9yZXZlYWxfYnV0dG9uIiwib3Blbk1vYmlsZU5hdiIsIm9wZW5OYXYiLCJ0aGVfbWVudSIsImludGVycG9sYXRlZF9zZWxlY3RvciIsImRyYXdlckxpc3RlbkZvckNsb3NpbmdTd2lwZSIsImNsb3NlTmF2IiwiY2xvc2VOYXZNaWxsaXNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJuYXZfY2xvc2VfdGltZXIiLCJjbG9zZVNlYXJjaCIsIiRuYXZfbGlua19vcGVuc19jaGlsZCIsImNsaWNrIiwiJHRoZV9wYXJlbnQiLCIkc2VhcmNoX3JldmVhbF9idXR0b24iLCIkc2VhcmNoX21lbnUiLCIkc2VhcmNoX2lucHV0IiwiJHNlYXJjaF9zdWJtaXQiLCIkc2VhcmNoX2Nsb3NlX2J0biIsIiRzZWFyY2hfdHJpZ2dlciIsIm9wZW5TZWFyY2giLCJzZWxlY3QiLCJzZWxlY3RvcnMiLCJmaXJzdENoaWxkIiwiX3FzYSIsInNjcm9sbEJ5IiwicmVtb3ZlQXR0cmlidXRlIiwicXVlcnlTZWxlY3RvciIsImNsYXNzTmFtZXMiLCJyZXQiLCJmdW4iLCJ0aGlzcCIsIkI2NF9BTFBIQUJFVCIsImF0b2IiLCJvdXRwdXQiLCJidWZmZXIiLCJiaXRzIiwiYnRvYSIsIm91dCIsIm8xIiwibzIiLCJvMyIsImUxIiwiZTIiLCJlMyIsImU0IiwiY2hhckNvZGVBdCIsInByb3RvIiwiX19wcm90b19fIiwiY29uc3RydWN0b3IiLCJwZXJmb3JtYW5jZSIsImdldFRpbWUiLCJub3dPZmZzZXQiLCJ0aW1pbmciLCJuYXZpZ2F0aW9uU3RhcnQiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImxvYWRlZCIsIm9uRG9tUmVhZHkiLCJxdWVyeXN0cmluZyIsIlNjZW5lR3JhcGgiLCJ1dGlscyIsIlNWRyIsIkRPTSIsIkNvbG9yIiwiY29uc3RhbnRzIiwic3ZnUmVuZGVyZXIiLCJzZ0NhbnZhc1JlbmRlcmVyIiwiZGltZW5zaW9uQ2hlY2siLCJTVkdfTlMiLCJzdmdfbnMiLCJIb2xkZXIiLCJhZGRUaGVtZSIsInRoZW1lIiwiQXBwIiwic2V0dGluZ3MiLCJ0aGVtZXMiLCJ2YXJzIiwiY2FjaGUiLCJ0aGVtZUtleXMiLCJhZGRJbWFnZSIsIm5vZGVzIiwiZ2V0Tm9kZUFycmF5Iiwibm9kZSIsImltZyIsIm5ld0VsIiwiZG9tUHJvcHMiLCJzZXR1cCIsInNldFJlc2l6ZVVwZGF0ZSIsImhvbGRlckRhdGEiLCJyZXNpemVVcGRhdGUiLCJ1cGRhdGVSZXNpemFibGVFbGVtZW50cyIsInVzZXJPcHRpb25zIiwiZW5naW5lU2V0dGluZ3MiLCJwcmVlbXB0ZWQiLCJyZW5kZXJlciIsInJlbmRlcmVycyIsInN1cHBvcnRzU1ZHIiwic3VwcG9ydHNDYW52YXMiLCJpbWFnZXMiLCJiZ25vZGVzIiwic3R5bGVub2RlcyIsIm9iamVjdHMiLCJzdHlsZXNoZWV0cyIsInN2Z1hNTFN0eWxlc2hlZXQiLCJub0ZvbnRGYWxsYmFjayIsIm5vQmFja2dyb3VuZFNpemUiLCJzdHlsZU5vZGUiLCJyZWwiLCJwcm94eUxpbmsiLCJzdHlsZXNoZWV0VVJMIiwicHJvdG9jb2wiLCJob3N0IiwicGF0aG5hbWUiLCJzZWFyY2giLCJiZ05vZGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJkYXRhQmFja2dyb3VuZEltYWdlIiwicmF3VVJMIiwiaG9sZGVyVVJMIiwiaG9sZGVyU3RyaW5nIiwiZG9tYWluIiwiaG9sZGVyU3RyaW5nSW5kZXgiLCJmcmFnbWVudCIsImhvbGRlckZsYWdzIiwicGFyc2VVUkwiLCJwcmVwYXJlRE9NRWxlbWVudCIsIm1vZGUiLCJvYmplY3RBdHRyIiwiZGF0YVNyYyIsIm9iamVjdEhhc1NyY1VSTCIsIm9iamVjdEhhc0RhdGFTcmNVUkwiLCJwcmVwYXJlSW1hZ2VFbGVtZW50IiwiaW1hZ2UiLCJpbWFnZUF0dHIiLCJyZW5kZXJlZCIsImltYWdlSGFzU3JjIiwiaW1hZ2VIYXNEYXRhU3JjVVJMIiwiaW1hZ2VSZW5kZXJlZCIsImltYWdlRXhpc3RzIiwiZXhpc3RzIiwiYmciLCJmZyIsImRlZmF1bHRzIiwic2l6ZSIsInVuaXRzIiwic2NhbGUiLCJpbnN0YW5jZU9wdGlvbnMiLCJob2xkZXIiLCJncmF5IiwiZmlyc3RRdWVzdGlvbk1hcmsiLCJwYXJ0cyIsImJhc2ljcyIsImRpbWVuc2lvbnMiLCJkaW1lbnNpb25EYXRhIiwiZmx1aWQiLCJ0cnV0aHkiLCJyYXRpbyIsInJhdGlvV2lkdGgiLCJyYXRpb0hlaWdodCIsImZsb29yIiwiYXV0byIsInBhcnNlQ29sb3IiLCJhdXRvRmciLCJ0ZXh0IiwidGV4dG1vZGUiLCJmb250IiwiYWxpZ24iLCJsaW5lV3JhcCIsIm5vd3JhcCIsIm91dGxpbmUiLCJyYW5kb20iLCJfdGhlbWUiLCJwcmVwU2V0dGluZ3MiLCJfZW5naW5lU2V0dGluZ3MiLCJkaW1lbnNpb25zQ2FwdGlvbiIsImhvbGRlclRlbXBsYXRlUmUiLCJkaW1lbnNpb25zSW5UZXh0IiwidGV4dExpbmVzIiwiZW5jb2RlSHRtbEVudGl0eSIsImhvbGRlclRlbXBsYXRlTWF0Y2hlcyIsInJlUmVuZGVyIiwicmVuZGVyU2V0dGluZ3MiLCJob2xkZXJTZXR0aW5ncyIsImJhY2tncm91bmRDb2xvciIsInJlbmRlciIsInJlc2l6YWJsZUltYWdlcyIsImRpc3BsYXkiLCJzZXRJbml0aWFsRGltZW5zaW9ucyIsInNjZW5lIiwic2NlbmVHcmFwaCIsImJ1aWxkU2NlbmVHcmFwaCIsImdldFJlbmRlcmVkSW1hZ2UiLCJiYWNrZ3JvdW5kU2l6ZSIsImZvbnRTaXplIiwiZmFtaWx5IiwidGV4dFNpemUiLCJ3ZWlnaHQiLCJmb250d2VpZ2h0Iiwibm9XcmFwIiwiZXhhY3REaW1lbnNpb25zIiwibGluZVdyYXBSYXRpbyIsInNjZW5lTWFyZ2luIiwibWF4TGluZVdpZHRoIiwiU2hhcGUiLCJob2xkZXJCZyIsIlJlY3QiLCJmaWxsIiwib3V0bGluZUNvbG9yIiwicHJvcGVydGllcyIsImxpZ2h0ZW4iLCJsaWdodGVyVGhhbiIsInRvSGV4IiwiaG9sZGVyVGV4dENvbG9yIiwiaG9sZGVyQmdDb2xvciIsImxpZ2h0Q29sb3IiLCJkYXJrQ29sb3IiLCJibGVuZEFscGhhIiwiaG9sZGVyVGV4dEdyb3VwIiwiR3JvdXAiLCJtb3ZlVG8iLCJ0cGRhdGEiLCJ0ZXh0UG9zaXRpb25EYXRhIiwic3RhZ2luZ1JlbmRlcmVyIiwibGVhZGluZyIsImJvdW5kaW5nQm94IiwidGV4dE5vZGUiLCJsaW5lIiwiZmluYWxpemVMaW5lIiwibGluZUNvdW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJsaW5lSW5kZXgiLCJsaW5lS2V5Iiwid29yZHMiLCJ3b3JkIiwiVGV4dCIsIm5ld2xpbmUiLCJzcGFjZVdpZHRoIiwic3RhZ2VXaWR0aCIsInN0YWdlSGVpZ2h0IiwiYmlnU2lkZSIsInNtYWxsU2lkZSIsIm5ld0hlaWdodCIsIm5vZGVUeXBlIiwiZmx1aWRDb25maWciLCJzZXRJbnZpc2libGUiLCJmbHVpZEhlaWdodCIsImZsdWlkV2lkdGgiLCJpbml0aWFsRGltZW5zaW9ucyIsInZpc2liaWxpdHlDaGVjayIsInJlbmRlcmFibGVJbWFnZXMiLCJpbnZpc2libGVJbWFnZXMiLCJzdGFydFZpc2liaWxpdHlDaGVjayIsInZpc2liaWxpdHlDaGVja1N0YXJ0ZWQiLCJpbnZpc2libGVJZCIsInN2ZyIsInN0YWdpbmdUZXh0Iiwic3RhZ2luZ1RleHROb2RlIiwiZ3JhcGgiLCJyb290Tm9kZSIsImZpcnN0VGltZVNldHVwIiwidG5vZGUiLCJpbml0U1ZHIiwidmlzaWJpbGl0eSIsImh0Z1Byb3BzIiwiY3NzUHJvcHMiLCJ0eHQiLCJpbm5lckhUTUwiLCJub2RlVmFsdWUiLCJzdGFnaW5nVGV4dEJCb3giLCJnZXRCQm94IiwiY2VpbCIsIm5ld2xpbmVzIiwiY29tcHV0ZWROb1NwYWNlTGVuZ3RoIiwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoIiwiZGlmZkxlbmd0aCIsIndvcmRXaWR0aHMiLCJkZWNvZGVIdG1sRW50aXR5IiwiYmJveCIsImRlYm91bmNlVGltZXIiLCJyZXNpemVFdmVudCIsImZsYWciLCJjYW52YXMiLCJnZXRDb250ZXh0IiwidG9EYXRhVVJMIiwiY3JlYXRlU1ZHUmVjdCIsIlR1cmJvbGlua3MiLCJfb25Eb21SZWFkeSIsIndpbiIsIkRPTUNvbnRlbnRMb2FkZWQiLCJkb2MiLCJMT0FEIiwiRkFMU0UiLCJPTkxPQUQiLCJDT01QTEVURSIsIlJFQURZU1RBVEUiLCJBVFRBQ0hFVkVOVCIsIkRFVEFDSEVWRU5UIiwiQURERVZFTlRMSVNURU5FUiIsIkRPTUNPTlRFTlRMT0FERUQiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJSRU1PVkVFVkVOVExJU1RFTkVSIiwidzNjIiwiX3RvcCIsImlzUmVhZHkiLCJkZWZlciIsImNvbXBsZXRlZCIsImZyYW1lRWxlbWVudCIsImRvU2Nyb2xsQ2hlY2siLCJlbmNvZGUiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhcnJheVJlZ2V4Iiwib2JqZWN0UmVnZXgiLCJwYWlycyIsImN0eCIsImV4ZWMiLCJzdHJpbmdpZnkiLCJpc0J1ZmZlciIsInZhbHVlT2YiLCJfaXNCdWZmZXIiLCJzY2VuZVByb3BlcnRpZXMiLCJub2RlQ291bnQiLCJtZXJnZSIsImNoaWxkIiwiU2NlbmVOb2RlIiwiUm9vdE5vZGUiLCJwcm9wcyIsImJ1ZiIsImNoYXJDb2RlIiwiSW1hZ2UiLCJvbmVycm9yIiwiZGVjIiwiaGV4cmUiLCJyZ2JyZSIsInJnYmFyZSIsInJldHZhbCIsImNhbnZhc1JhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJOT0RFX1RZUEVfQ09NTUVOVCIsImRlZnMiLCJpbml0aWFsaXplIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiY2hpbGROb2RlcyIsInN2Z1N0cmluZ1RvRGF0YVVSSSIsInJhd1ByZWZpeCIsImJhc2U2NFByZWZpeCIsInN2Z1N0cmluZyIsImJhc2U2NCIsInVuZXNjYXBlIiwic2VyaWFsaXplU1ZHIiwiWE1MU2VyaWFsaXplciIsInNlcmlhbGl6ZXIiLCJzdmdDU1MiLCJ4bWwiLCJjcmVhdGVYTUwiLCJjc3NwaSIsImNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImluc2VydEJlZm9yZSIsInNlcmlhbGl6ZVRvU3RyaW5nIiwic3ZnVGV4dCIsInRhZyIsImF0dHJzIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiTm9kZSIsIkhUTUxDb2xsZWN0aW9uIiwiY29sb3IiLCJvcmlnaW5hbCIsImFscGhhIiwicmdiMmhleCIsImZvcm1hdCIsImRlY2ltYWwiLCJoZXgiLCJoc2wycmdiIiwiSCIsIlgiLCJyYXciLCJyZ2IiLCJ5dXYiLCJtdWx0aXBsaWVyIiwiY20iLCJibSIsImNyIiwiY2ciLCJjYiIsImFkZEhhc2giLCJDYSIsIkNiIiwic2hhdmVuIiwidGVtcGxhdGVzIiwiY29udGVudCIsImNvbnZlcnRTaGFwZSIsInNoYXBlIiwidGV4dENzcyIsIm91dGxpbmVQYXRoIiwiYmdXaWR0aCIsImJnSGVpZ2h0Iiwib3V0bGluZVdpZHRoIiwib3V0bGluZU9mZnNldFdpZHRoIiwic3R5bGVzaGVldFhtbCIsInN0eWxlc2hlZXQiLCJob2xkZXJJZCIsInRleHRHcm91cCIsIndvcmRUYWdzIiwid29yZEtleSIsIndvcmRUYWciLCJvdXRsaW5lUHJvcGVydGllcyIsInNjZW5lQ29udGVudCIsInJldHVybk9iamVjdCIsImRvZXNFc2NhcGUiLCJIVE1MU3RyaW5nIiwiYXR0cmlidXRlS2V5Iiwic3VnYXJTdHJpbmciLCJ0YWdzIiwicmVmZXJlbmNlIiwiY2xhc3MiLCJyZXBsYWNlciIsImVzY2FwZUF0dHJpYnV0ZSIsImVzY2FwZUhUTUwiLCJzdWJBcnJheSIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJsYXN0SW5kZXgiLCJzdWJzdHJpbmciLCJkcHIiLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbFRleHQiLCJpc01ldGVvclBhY2thZ2UiLCJNZXRlb3IiLCJQYWNrYWdlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFH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QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7QUFDSDs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ2pDLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7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RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFB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OztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDcjJVRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7QUN2THRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pMRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsbUJBQU8sQ0FBQyxpRUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7Q0FJQTtBQUVBOztBQUNBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0NBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQUEseUVBQU8sQ0FBQ0MsR0FBUixFQUNDO0FBQ0FDLDBGQUZELEVBR0NDLHdGQUhELEVBSUNDLHNGQUpELEVBS0M7QUFDQUMsMEZBTkQsRUFPQ0Msd0ZBUEQsRUFRQ0MsNEZBUkQsQ0FTQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQkQsRSxDQThCQTtBQUNBO0FBQ0E7O0FBQ0FDLHFFQUFHLENBQUNDLEtBQUosRzs7Ozs7Ozs7Ozs7OztBQzdGQTs7QUFFQSxD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a0IsUUFBekIsRUFBbUM7QUFDL0Isa0JBQUlpbEIsSUFBSSxHQUFHUixJQUFJLENBQUN6a0IsUUFBTCxDQUFja3dCLE9BQWQsQ0FBWDtBQUNBLGtCQUFJbDFDLENBQUMsR0FBR3MyQyxHQUFHLElBQUl0QixTQUFTLENBQUNoMUMsQ0FBVixHQUFjeXBDLElBQUksQ0FBQ3pwQyxDQUFuQixHQUF1QmlxQyxJQUFJLENBQUNqcUMsQ0FBaEMsQ0FBWDtBQUNBLGtCQUFJVixDQUFDLEdBQUdnM0MsR0FBRyxJQUFJdEIsU0FBUyxDQUFDMTFDLENBQVYsR0FBY21xQyxJQUFJLENBQUNucUMsQ0FBbkIsR0FBdUIycUMsSUFBSSxDQUFDM3FDLENBQTVCLEdBQWlDMDFDLFNBQVMsQ0FBQ3pNLFVBQVYsQ0FBcUJlLE9BQXJCLEdBQStCLENBQXBFLENBQVg7QUFFQTRGLGlCQUFHLENBQUM0SCxRQUFKLENBQWE3TSxJQUFJLENBQUMxQixVQUFMLENBQWdCN0MsSUFBN0IsRUFBbUMxbEMsQ0FBbkMsRUFBc0NWLENBQXRDO0FBQ0g7QUFDSjs7QUFFRCxpQkFBTzJ0QyxNQUFNLENBQUNFLFNBQVAsQ0FBaUIsV0FBakIsQ0FBUDtBQUNILFNBdkREO0FBd0RILE9BNURnQixFQUFqQjtBQThERjs7QUFBTyxLQTNzRkcsQ0ExQ007QUFBaEI7QUF1dkZDLENBandGRDs7QUFrd0ZBOztBQUNBLENBQUMsVUFBUytCLEdBQVQsRUFBYzZILGVBQWQsRUFBK0I7QUFDNUIsTUFBSUEsZUFBSixFQUFxQjtBQUNqQmxYLFVBQU0sR0FBR3FQLEdBQUcsQ0FBQ3JQLE1BQWI7QUFDSDtBQUNKLENBSkQsRUFJRyxJQUpILEVBSVMsT0FBT21YLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsT0FBT0MsT0FBUCxLQUFtQixXQUo3RCxFOzs7Ozs7Ozs7Ozs7QUMvc1FBLHlDOzs7Ozs7Ozs7OztBQ0FBLHlDIiwiZmlsZSI6Ii9kaXN0L2pzL2J1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBfV0lORE9XID0ge307XG52YXIgX0RPQ1VNRU5UID0ge307XG52YXIgX01VVEFUSU9OX09CU0VSVkVSID0gbnVsbDtcbnZhciBfUEVSRk9STUFOQ0UgPSB7XG4gIG1hcms6IG5vb3AsXG4gIG1lYXN1cmU6IG5vb3Bcbn07XG5cbnRyeSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgX1dJTkRPVyA9IHdpbmRvdztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIF9ET0NVTUVOVCA9IGRvY3VtZW50O1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSBfTVVUQVRJT05fT0JTRVJWRVIgPSBNdXRhdGlvbk9ic2VydmVyO1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJykgX1BFUkZPUk1BTkNFID0gcGVyZm9ybWFuY2U7XG59IGNhdGNoIChlKSB7fVxuXG52YXIgX3JlZiA9IF9XSU5ET1cubmF2aWdhdG9yIHx8IHt9LFxuICAgIF9yZWYkdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgdXNlckFnZW50ID0gX3JlZiR1c2VyQWdlbnQgPT09IHZvaWQgMCA/ICcnIDogX3JlZiR1c2VyQWdlbnQ7XG5cbnZhciBXSU5ET1cgPSBfV0lORE9XO1xudmFyIERPQ1VNRU5UID0gX0RPQ1VNRU5UO1xudmFyIE1VVEFUSU9OX09CU0VSVkVSID0gX01VVEFUSU9OX09CU0VSVkVSO1xudmFyIFBFUkZPUk1BTkNFID0gX1BFUkZPUk1BTkNFO1xudmFyIElTX0JST1dTRVIgPSAhIVdJTkRPVy5kb2N1bWVudDtcbnZhciBJU19ET00gPSAhIURPQ1VNRU5ULmRvY3VtZW50RWxlbWVudCAmJiAhIURPQ1VNRU5ULmhlYWQgJiYgdHlwZW9mIERPQ1VNRU5ULmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbic7XG52YXIgSVNfSUUgPSB+dXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSB8fCB+dXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQvJyk7XG5cbnZhciBOQU1FU1BBQ0VfSURFTlRJRklFUiA9ICdfX19GT05UX0FXRVNPTUVfX18nO1xudmFyIFVOSVRTX0lOX0dSSUQgPSAxNjtcbnZhciBERUZBVUxUX0ZBTUlMWV9QUkVGSVggPSAnZmEnO1xudmFyIERFRkFVTFRfUkVQTEFDRU1FTlRfQ0xBU1MgPSAnc3ZnLWlubGluZS0tZmEnO1xudmFyIERBVEFfRkFfSTJTVkcgPSAnZGF0YS1mYS1pMnN2Zyc7XG52YXIgREFUQV9GQV9QU0VVRE9fRUxFTUVOVCA9ICdkYXRhLWZhLXBzZXVkby1lbGVtZW50JztcbnZhciBEQVRBX0ZBX1BTRVVET19FTEVNRU5UX1BFTkRJTkcgPSAnZGF0YS1mYS1wc2V1ZG8tZWxlbWVudC1wZW5kaW5nJztcbnZhciBEQVRBX1BSRUZJWCA9ICdkYXRhLXByZWZpeCc7XG52YXIgREFUQV9JQ09OID0gJ2RhdGEtaWNvbic7XG52YXIgSFRNTF9DTEFTU19JMlNWR19CQVNFX0NMQVNTID0gJ2ZvbnRhd2Vzb21lLWkyc3ZnJztcbnZhciBNVVRBVElPTl9BUFBST0FDSF9BU1lOQyA9ICdhc3luYyc7XG52YXIgVEFHTkFNRVNfVE9fU0tJUF9GT1JfUFNFVURPRUxFTUVOVFMgPSBbJ0hUTUwnLCAnSEVBRCcsICdTVFlMRScsICdTQ1JJUFQnXTtcbnZhciBQUk9EVUNUSU9OID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KCk7XG52YXIgUFJFRklYX1RPX1NUWUxFID0ge1xuICAnZmFzJzogJ3NvbGlkJyxcbiAgJ2Zhcic6ICdyZWd1bGFyJyxcbiAgJ2ZhbCc6ICdsaWdodCcsXG4gICdmYWInOiAnYnJhbmRzJyxcbiAgJ2ZhJzogJ3NvbGlkJ1xufTtcbnZhciBTVFlMRV9UT19QUkVGSVggPSB7XG4gICdzb2xpZCc6ICdmYXMnLFxuICAncmVndWxhcic6ICdmYXInLFxuICAnbGlnaHQnOiAnZmFsJyxcbiAgJ2JyYW5kcyc6ICdmYWInXG59O1xudmFyIExBWUVSU19URVhUX0NMQVNTTkFNRSA9ICdmYS1sYXllcnMtdGV4dCc7XG52YXIgRk9OVF9GQU1JTFlfUEFUVEVSTiA9IC9Gb250IEF3ZXNvbWUgNSAoU29saWR8UmVndWxhcnxMaWdodHxCcmFuZHN8RnJlZXxQcm8pLztcbnZhciBGT05UX1dFSUdIVF9UT19QUkVGSVggPSB7XG4gICc5MDAnOiAnZmFzJyxcbiAgJzQwMCc6ICdmYXInLFxuICAnbm9ybWFsJzogJ2ZhcicsXG4gICczMDAnOiAnZmFsJ1xufTtcbnZhciBvbmVUb1RlbiA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF07XG52YXIgb25lVG9Ud2VudHkgPSBvbmVUb1Rlbi5jb25jYXQoWzExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwXSk7XG52YXIgQVRUUklCVVRFU19XQVRDSEVEX0ZPUl9NVVRBVElPTiA9IFsnY2xhc3MnLCAnZGF0YS1wcmVmaXgnLCAnZGF0YS1pY29uJywgJ2RhdGEtZmEtdHJhbnNmb3JtJywgJ2RhdGEtZmEtbWFzayddO1xudmFyIFJFU0VSVkVEX0NMQVNTRVMgPSBbJ3hzJywgJ3NtJywgJ2xnJywgJ2Z3JywgJ3VsJywgJ2xpJywgJ2JvcmRlcicsICdwdWxsLWxlZnQnLCAncHVsbC1yaWdodCcsICdzcGluJywgJ3B1bHNlJywgJ3JvdGF0ZS05MCcsICdyb3RhdGUtMTgwJywgJ3JvdGF0ZS0yNzAnLCAnZmxpcC1ob3Jpem9udGFsJywgJ2ZsaXAtdmVydGljYWwnLCAnZmxpcC1ib3RoJywgJ3N0YWNrJywgJ3N0YWNrLTF4JywgJ3N0YWNrLTJ4JywgJ2ludmVyc2UnLCAnbGF5ZXJzJywgJ2xheWVycy10ZXh0JywgJ2xheWVycy1jb3VudGVyJ10uY29uY2F0KG9uZVRvVGVuLm1hcChmdW5jdGlvbiAobikge1xuICByZXR1cm4gXCJcIi5jb25jYXQobiwgXCJ4XCIpO1xufSkpLmNvbmNhdChvbmVUb1R3ZW50eS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIFwidy1cIi5jb25jYXQobik7XG59KSk7XG5cbnZhciBpbml0aWFsID0gV0lORE9XLkZvbnRBd2Vzb21lQ29uZmlnIHx8IHt9O1xuXG5mdW5jdGlvbiBnZXRBdHRyQ29uZmlnKGF0dHIpIHtcbiAgdmFyIGVsZW1lbnQgPSBET0NVTUVOVC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbJyArIGF0dHIgKyAnXScpO1xuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgLy8gR2V0dGluZyBhbiBlbXB0eSBzdHJpbmcgd2lsbCBvY2N1ciBpZiB0aGUgYXR0cmlidXRlIGlzIHNldCBvbiB0aGUgSFRNTCB0YWcgYnV0IHdpdGhvdXQgYSB2YWx1ZVxuICAvLyBXZSdsbCBhc3N1bWUgdGhhdCB0aGlzIGlzIGFuIGluZGljYXRpb24gdGhhdCBpdCBzaG91bGQgYmUgdG9nZ2xlZCB0byB0cnVlXG4gIC8vIEZvciBleGFtcGxlIDxzY3JpcHQgZGF0YS1zZWFyY2gtcHNldWRvLWVsZW1lbnRzIHNyYz1cIi4uLlwiPjwvc2NyaXB0PlxuICBpZiAodmFsID09PSAnJykgcmV0dXJuIHRydWU7XG4gIGlmICh2YWwgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZTtcbiAgaWYgKHZhbCA9PT0gJ3RydWUnKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuaWYgKERPQ1VNRU5UICYmIHR5cGVvZiBET0NVTUVOVC5xdWVyeVNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBhdHRycyA9IFtbJ2RhdGEtZmFtaWx5LXByZWZpeCcsICdmYW1pbHlQcmVmaXgnXSwgWydkYXRhLXJlcGxhY2VtZW50LWNsYXNzJywgJ3JlcGxhY2VtZW50Q2xhc3MnXSwgWydkYXRhLWF1dG8tcmVwbGFjZS1zdmcnLCAnYXV0b1JlcGxhY2VTdmcnXSwgWydkYXRhLWF1dG8tYWRkLWNzcycsICdhdXRvQWRkQ3NzJ10sIFsnZGF0YS1hdXRvLWExMXknLCAnYXV0b0ExMXknXSwgWydkYXRhLXNlYXJjaC1wc2V1ZG8tZWxlbWVudHMnLCAnc2VhcmNoUHNldWRvRWxlbWVudHMnXSwgWydkYXRhLW9ic2VydmUtbXV0YXRpb25zJywgJ29ic2VydmVNdXRhdGlvbnMnXSwgWydkYXRhLW11dGF0ZS1hcHByb2FjaCcsICdtdXRhdGVBcHByb2FjaCddLCBbJ2RhdGEta2VlcC1vcmlnaW5hbC1zb3VyY2UnLCAna2VlcE9yaWdpbmFsU291cmNlJ10sIFsnZGF0YS1tZWFzdXJlLXBlcmZvcm1hbmNlJywgJ21lYXN1cmVQZXJmb3JtYW5jZSddLCBbJ2RhdGEtc2hvdy1taXNzaW5nLWljb25zJywgJ3Nob3dNaXNzaW5nSWNvbnMnXV07XG4gIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgYXR0ciA9IF9yZWYyWzBdLFxuICAgICAgICBrZXkgPSBfcmVmMlsxXTtcblxuICAgIHZhciB2YWwgPSBjb2VyY2UoZ2V0QXR0ckNvbmZpZyhhdHRyKSk7XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpbml0aWFsW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0ge1xuICBmYW1pbHlQcmVmaXg6IERFRkFVTFRfRkFNSUxZX1BSRUZJWCxcbiAgcmVwbGFjZW1lbnRDbGFzczogREVGQVVMVF9SRVBMQUNFTUVOVF9DTEFTUyxcbiAgYXV0b1JlcGxhY2VTdmc6IHRydWUsXG4gIGF1dG9BZGRDc3M6IHRydWUsXG4gIGF1dG9BMTF5OiB0cnVlLFxuICBzZWFyY2hQc2V1ZG9FbGVtZW50czogZmFsc2UsXG4gIG9ic2VydmVNdXRhdGlvbnM6IHRydWUsXG4gIG11dGF0ZUFwcHJvYWNoOiAnYXN5bmMnLFxuICBrZWVwT3JpZ2luYWxTb3VyY2U6IHRydWUsXG4gIG1lYXN1cmVQZXJmb3JtYW5jZTogZmFsc2UsXG4gIHNob3dNaXNzaW5nSWNvbnM6IHRydWVcbn07XG5cbnZhciBfY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgX2RlZmF1bHQsIGluaXRpYWwpO1xuXG5pZiAoIV9jb25maWcuYXV0b1JlcGxhY2VTdmcpIF9jb25maWcub2JzZXJ2ZU11dGF0aW9ucyA9IGZhbHNlO1xuXG52YXIgY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgX2NvbmZpZyk7XG5cbldJTkRPVy5Gb250QXdlc29tZUNvbmZpZyA9IGNvbmZpZztcblxudmFyIHcgPSBXSU5ET1cgfHwge307XG5pZiAoIXdbTkFNRVNQQUNFX0lERU5USUZJRVJdKSB3W05BTUVTUEFDRV9JREVOVElGSUVSXSA9IHt9O1xuaWYgKCF3W05BTUVTUEFDRV9JREVOVElGSUVSXS5zdHlsZXMpIHdbTkFNRVNQQUNFX0lERU5USUZJRVJdLnN0eWxlcyA9IHt9O1xuaWYgKCF3W05BTUVTUEFDRV9JREVOVElGSUVSXS5ob29rcykgd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uaG9va3MgPSB7fTtcbmlmICghd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uc2hpbXMpIHdbTkFNRVNQQUNFX0lERU5USUZJRVJdLnNoaW1zID0gW107XG52YXIgbmFtZXNwYWNlID0gd1tOQU1FU1BBQ0VfSURFTlRJRklFUl07XG5cbnZhciBmdW5jdGlvbnMgPSBbXTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gIERPQ1VNRU5ULnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBsaXN0ZW5lcik7XG4gIGxvYWRlZCA9IDE7XG4gIGZ1bmN0aW9ucy5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0pO1xufTtcblxudmFyIGxvYWRlZCA9IGZhbHNlO1xuXG5pZiAoSVNfRE9NKSB7XG4gIGxvYWRlZCA9IChET0NVTUVOVC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoRE9DVU1FTlQucmVhZHlTdGF0ZSk7XG4gIGlmICghbG9hZGVkKSBET0NVTUVOVC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgbGlzdGVuZXIpO1xufVxuXG5mdW5jdGlvbiBkb21yZWFkeSAoZm4pIHtcbiAgaWYgKCFJU19ET00pIHJldHVybjtcbiAgbG9hZGVkID8gc2V0VGltZW91dChmbiwgMCkgOiBmdW5jdGlvbnMucHVzaChmbik7XG59XG5cbnZhciBQRU5ESU5HID0gJ3BlbmRpbmcnO1xudmFyIFNFVFRMRUQgPSAnc2V0dGxlZCc7XG52YXIgRlVMRklMTEVEID0gJ2Z1bGZpbGxlZCc7XG52YXIgUkVKRUNURUQgPSAncmVqZWN0ZWQnO1xuXG52YXIgTk9PUCA9IGZ1bmN0aW9uIE5PT1AoKSB7fTtcblxudmFyIGlzTm9kZSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5wcm9jZXNzLmVtaXQgPT09ICdmdW5jdGlvbic7XG52YXIgYXN5bmNTZXRUaW1lciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnID8gc2V0VGltZW91dCA6IHNldEltbWVkaWF0ZTtcbnZhciBhc3luY1F1ZXVlID0gW107XG52YXIgYXN5bmNUaW1lcjtcblxuZnVuY3Rpb24gYXN5bmNGbHVzaCgpIHtcbiAgLy8gcnVuIHByb21pc2UgY2FsbGJhY2tzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXN5bmNRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGFzeW5jUXVldWVbaV1bMF0oYXN5bmNRdWV1ZVtpXVsxXSk7XG4gIH0gLy8gcmVzZXQgYXN5bmMgYXN5bmNRdWV1ZVxuXG5cbiAgYXN5bmNRdWV1ZSA9IFtdO1xuICBhc3luY1RpbWVyID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFzeW5jQ2FsbChjYWxsYmFjaywgYXJnKSB7XG4gIGFzeW5jUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ10pO1xuXG4gIGlmICghYXN5bmNUaW1lcikge1xuICAgIGFzeW5jVGltZXIgPSB0cnVlO1xuICAgIGFzeW5jU2V0VGltZXIoYXN5bmNGbHVzaCwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlUmVzb2x2ZXIocmVzb2x2ZXIsIHByb21pc2UpIHtcbiAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIH1cblxuICB0cnkge1xuICAgIHJlc29sdmVyKHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdFByb21pc2UoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc3Vic2NyaWJlcikge1xuICB2YXIgb3duZXIgPSBzdWJzY3JpYmVyLm93bmVyO1xuICB2YXIgc2V0dGxlZCA9IG93bmVyLl9zdGF0ZTtcbiAgdmFyIHZhbHVlID0gb3duZXIuX2RhdGE7XG4gIHZhciBjYWxsYmFjayA9IHN1YnNjcmliZXJbc2V0dGxlZF07XG4gIHZhciBwcm9taXNlID0gc3Vic2NyaWJlci50aGVuO1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZXR0bGVkID0gRlVMRklMTEVEO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuICAgIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpIHtcbiAgdmFyIHJlc29sdmVkO1xuXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnKSkge1xuICAgICAgLy8gdGhlbiBzaG91bGQgYmUgcmV0cmlldmVkIG9ubHkgb25jZVxuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuO1xuXG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZhbCkge1xuICAgICAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSB8fCAhaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICBwcm9taXNlLl9zdGF0ZSA9IFNFVFRMRUQ7XG4gICAgcHJvbWlzZS5fZGF0YSA9IHZhbHVlO1xuICAgIGFzeW5jQ2FsbChwdWJsaXNoRnVsZmlsbG1lbnQsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgcHJvbWlzZS5fc3RhdGUgPSBTRVRUTEVEO1xuICAgIHByb21pc2UuX2RhdGEgPSByZWFzb247XG4gICAgYXN5bmNDYWxsKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICBwcm9taXNlLl90aGVuID0gcHJvbWlzZS5fdGhlbi5mb3JFYWNoKGludm9rZUNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaEZ1bGZpbGxtZW50KHByb21pc2UpIHtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwdWJsaXNoKHByb21pc2UpO1xuXG4gIGlmICghcHJvbWlzZS5faGFuZGxlZCAmJiBpc05vZGUpIHtcbiAgICBnbG9iYWwucHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCBwcm9taXNlLl9kYXRhLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpZnlSZWplY3Rpb25IYW5kbGVkKHByb21pc2UpIHtcbiAgZ2xvYmFsLnByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xufVxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuXG5cbmZ1bmN0aW9uIFAocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgcmVzb2x2ZXIgJyArIHJlc29sdmVyICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBQID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnUHJvbWlzZVxcJzogUGxlYXNlIHVzZSB0aGUgXFwnbmV3XFwnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl90aGVuID0gW107XG4gIGludm9rZVJlc29sdmVyKHJlc29sdmVyLCB0aGlzKTtcbn1cblxuUC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQLFxuICBfc3RhdGU6IFBFTkRJTkcsXG4gIF90aGVuOiBudWxsLFxuICBfZGF0YTogdW5kZWZpbmVkLFxuICBfaGFuZGxlZDogZmFsc2UsXG4gIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHtcbiAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgdGhlbjogbmV3IHRoaXMuY29uc3RydWN0b3IoTk9PUCksXG4gICAgICBmdWxmaWxsZWQ6IG9uRnVsZmlsbG1lbnQsXG4gICAgICByZWplY3RlZDogb25SZWplY3Rpb25cbiAgICB9O1xuXG4gICAgaWYgKChvblJlamVjdGlvbiB8fCBvbkZ1bGZpbGxtZW50KSAmJiAhdGhpcy5faGFuZGxlZCkge1xuICAgICAgdGhpcy5faGFuZGxlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gUkVKRUNURUQgJiYgaXNOb2RlKSB7XG4gICAgICAgIGFzeW5jQ2FsbChub3RpZnlSZWplY3Rpb25IYW5kbGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZVTEZJTExFRCB8fCB0aGlzLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVzb2x2ZWQsIGNhbGwgY2FsbGJhY2sgYXN5bmNcbiAgICAgIGFzeW5jQ2FsbChpbnZva2VDYWxsYmFjaywgc3Vic2NyaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1YnNjcmliZVxuICAgICAgdGhpcy5fdGhlbi5wdXNoKHN1YnNjcmliZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpYmVyLnRoZW47XG4gIH0sXG4gIGNhdGNoOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfVxufTtcblxuUC5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb21pc2VzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gUHJvbWlzZS5hbGwoKS4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcmVtYWluaW5nID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKGluZGV4KSB7XG4gICAgICByZW1haW5pbmcrKztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAoISAtLXJlbWFpbmluZykge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG4gICAgICBpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHNbaV0gPSBwcm9taXNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVtYWluaW5nKSB7XG4gICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5QLnJhY2UgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb21pc2VzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gUHJvbWlzZS5yYWNlKCkuJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuICAgICAgaWYgKHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblAucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxudmFyIHBpY2tlZCA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nID8gUHJvbWlzZSA6IFA7XG5cbnZhciBkID0gVU5JVFNfSU5fR1JJRDtcbnZhciBtZWFuaW5nbGVzc1RyYW5zZm9ybSA9IHtcbiAgc2l6ZTogMTYsXG4gIHg6IDAsXG4gIHk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgZmxpcFg6IGZhbHNlLFxuICBmbGlwWTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQobmFtZSkge1xuICByZXR1cm4gflJFU0VSVkVEX0NMQVNTRVMuaW5kZXhPZihuYW1lKTtcbn1cbmZ1bmN0aW9uIGluc2VydENzcyhjc3MpIHtcbiAgaWYgKCFjc3MgfHwgIUlTX0RPTSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICBzdHlsZS5pbm5lckhUTUwgPSBjc3M7XG4gIHZhciBoZWFkQ2hpbGRyZW4gPSBET0NVTUVOVC5oZWFkLmNoaWxkTm9kZXM7XG4gIHZhciBiZWZvcmVDaGlsZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IGhlYWRDaGlsZHJlbi5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHZhciBjaGlsZCA9IGhlYWRDaGlsZHJlbltpXTtcbiAgICB2YXIgdGFnTmFtZSA9IChjaGlsZC50YWdOYW1lIHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKFsnU1RZTEUnLCAnTElOSyddLmluZGV4T2YodGFnTmFtZSkgPiAtMSkge1xuICAgICAgYmVmb3JlQ2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gIH1cblxuICBET0NVTUVOVC5oZWFkLmluc2VydEJlZm9yZShzdHlsZSwgYmVmb3JlQ2hpbGQpO1xuICByZXR1cm4gY3NzO1xufVxudmFyIGlkUG9vbCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XG5mdW5jdGlvbiBuZXh0VW5pcXVlSWQoKSB7XG4gIHZhciBzaXplID0gMTI7XG4gIHZhciBpZCA9ICcnO1xuXG4gIHdoaWxlIChzaXplLS0gPiAwKSB7XG4gICAgaWQgKz0gaWRQb29sW01hdGgucmFuZG9tKCkgKiA2MiB8IDBdO1xuICB9XG5cbiAgcmV0dXJuIGlkO1xufVxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IChvYmogfHwgW10pLmxlbmd0aCA+Pj4gMDsgaS0tOykge1xuICAgIGFycmF5W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2xhc3NBcnJheShub2RlKSB7XG4gIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgIHJldHVybiB0b0FycmF5KG5vZGUuY2xhc3NMaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgnICcpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEljb25OYW1lKGZhbWlseVByZWZpeCwgY2xzKSB7XG4gIHZhciBwYXJ0cyA9IGNscy5zcGxpdCgnLScpO1xuICB2YXIgcHJlZml4ID0gcGFydHNbMF07XG4gIHZhciBpY29uTmFtZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJy0nKTtcblxuICBpZiAocHJlZml4ID09PSBmYW1pbHlQcmVmaXggJiYgaWNvbk5hbWUgIT09ICcnICYmICFpc1Jlc2VydmVkKGljb25OYW1lKSkge1xuICAgIHJldHVybiBpY29uTmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaHRtbEVzY2FwZShzdHIpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHN0cikucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiMzOTsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuZnVuY3Rpb24gam9pbkF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcyB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gYWNjICsgXCJcIi5jb25jYXQoYXR0cmlidXRlTmFtZSwgXCI9XFxcIlwiKS5jb25jYXQoaHRtbEVzY2FwZShhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSwgXCJcXFwiIFwiKTtcbiAgfSwgJycpLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGpvaW5TdHlsZXMoc3R5bGVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMgfHwge30pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzdHlsZU5hbWUpIHtcbiAgICByZXR1cm4gYWNjICsgXCJcIi5jb25jYXQoc3R5bGVOYW1lLCBcIjogXCIpLmNvbmNhdChzdHlsZXNbc3R5bGVOYW1lXSwgXCI7XCIpO1xuICB9LCAnJyk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Jc01lYW5pbmdmdWwodHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm0uc2l6ZSAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0uc2l6ZSB8fCB0cmFuc2Zvcm0ueCAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0ueCB8fCB0cmFuc2Zvcm0ueSAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0ueSB8fCB0cmFuc2Zvcm0ucm90YXRlICE9PSBtZWFuaW5nbGVzc1RyYW5zZm9ybS5yb3RhdGUgfHwgdHJhbnNmb3JtLmZsaXBYIHx8IHRyYW5zZm9ybS5mbGlwWTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUZvclN2ZyhfcmVmKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gX3JlZi5jb250YWluZXJXaWR0aCxcbiAgICAgIGljb25XaWR0aCA9IF9yZWYuaWNvbldpZHRoO1xuICB2YXIgb3V0ZXIgPSB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoY29udGFpbmVyV2lkdGggLyAyLCBcIiAyNTYpXCIpXG4gIH07XG4gIHZhciBpbm5lclRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ueCAqIDMyLCBcIiwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAqIDMyLCBcIikgXCIpO1xuICB2YXIgaW5uZXJTY2FsZSA9IFwic2NhbGUoXCIuY29uY2F0KHRyYW5zZm9ybS5zaXplIC8gMTYgKiAodHJhbnNmb3JtLmZsaXBYID8gLTEgOiAxKSwgXCIsIFwiKS5jb25jYXQodHJhbnNmb3JtLnNpemUgLyAxNiAqICh0cmFuc2Zvcm0uZmxpcFkgPyAtMSA6IDEpLCBcIikgXCIpO1xuICB2YXIgaW5uZXJSb3RhdGUgPSBcInJvdGF0ZShcIi5jb25jYXQodHJhbnNmb3JtLnJvdGF0ZSwgXCIgMCAwKVwiKTtcbiAgdmFyIGlubmVyID0ge1xuICAgIHRyYW5zZm9ybTogXCJcIi5jb25jYXQoaW5uZXJUcmFuc2xhdGUsIFwiIFwiKS5jb25jYXQoaW5uZXJTY2FsZSwgXCIgXCIpLmNvbmNhdChpbm5lclJvdGF0ZSlcbiAgfTtcbiAgdmFyIHBhdGggPSB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoaWNvbldpZHRoIC8gMiAqIC0xLCBcIiAtMjU2KVwiKVxuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyOiBvdXRlcixcbiAgICBpbm5lcjogaW5uZXIsXG4gICAgcGF0aDogcGF0aFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRm9yQ3NzKF9yZWYyKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBfcmVmMi50cmFuc2Zvcm0sXG4gICAgICBfcmVmMiR3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgd2lkdGggPSBfcmVmMiR3aWR0aCA9PT0gdm9pZCAwID8gVU5JVFNfSU5fR1JJRCA6IF9yZWYyJHdpZHRoLFxuICAgICAgX3JlZjIkaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0LFxuICAgICAgaGVpZ2h0ID0gX3JlZjIkaGVpZ2h0ID09PSB2b2lkIDAgPyBVTklUU19JTl9HUklEIDogX3JlZjIkaGVpZ2h0LFxuICAgICAgX3JlZjIkc3RhcnRDZW50ZXJlZCA9IF9yZWYyLnN0YXJ0Q2VudGVyZWQsXG4gICAgICBzdGFydENlbnRlcmVkID0gX3JlZjIkc3RhcnRDZW50ZXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRzdGFydENlbnRlcmVkO1xuICB2YXIgdmFsID0gJyc7XG5cbiAgaWYgKHN0YXJ0Q2VudGVyZWQgJiYgSVNfSUUpIHtcbiAgICB2YWwgKz0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zZm9ybS54IC8gZCAtIHdpZHRoIC8gMiwgXCJlbSwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAvIGQgLSBoZWlnaHQgLyAyLCBcImVtKSBcIik7XG4gIH0gZWxzZSBpZiAoc3RhcnRDZW50ZXJlZCkge1xuICAgIHZhbCArPSBcInRyYW5zbGF0ZShjYWxjKC01MCUgKyBcIi5jb25jYXQodHJhbnNmb3JtLnggLyBkLCBcImVtKSwgY2FsYygtNTAlICsgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAvIGQsIFwiZW0pKSBcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFsICs9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ueCAvIGQsIFwiZW0sIFwiKS5jb25jYXQodHJhbnNmb3JtLnkgLyBkLCBcImVtKSBcIik7XG4gIH1cblxuICB2YWwgKz0gXCJzY2FsZShcIi5jb25jYXQodHJhbnNmb3JtLnNpemUgLyBkICogKHRyYW5zZm9ybS5mbGlwWCA/IC0xIDogMSksIFwiLCBcIikuY29uY2F0KHRyYW5zZm9ybS5zaXplIC8gZCAqICh0cmFuc2Zvcm0uZmxpcFkgPyAtMSA6IDEpLCBcIikgXCIpO1xuICB2YWwgKz0gXCJyb3RhdGUoXCIuY29uY2F0KHRyYW5zZm9ybS5yb3RhdGUsIFwiZGVnKSBcIik7XG4gIHJldHVybiB2YWw7XG59XG5cbnZhciBBTExfU1BBQ0UgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnXG59O1xuZnVuY3Rpb24gbWFrZUljb25NYXNraW5nIChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgbWFpbiA9IF9yZWYubWFpbixcbiAgICAgIG1hc2sgPSBfcmVmLm1hc2ssXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybTtcbiAgdmFyIG1haW5XaWR0aCA9IG1haW4ud2lkdGgsXG4gICAgICBtYWluUGF0aCA9IG1haW4uaWNvbjtcbiAgdmFyIG1hc2tXaWR0aCA9IG1hc2sud2lkdGgsXG4gICAgICBtYXNrUGF0aCA9IG1hc2suaWNvbjtcbiAgdmFyIHRyYW5zID0gdHJhbnNmb3JtRm9yU3ZnKHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBjb250YWluZXJXaWR0aDogbWFza1dpZHRoLFxuICAgIGljb25XaWR0aDogbWFpbldpZHRoXG4gIH0pO1xuICB2YXIgbWFza1JlY3QgPSB7XG4gICAgdGFnOiAncmVjdCcsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgQUxMX1NQQUNFLCB7XG4gICAgICBmaWxsOiAnd2hpdGUnXG4gICAgfSlcbiAgfTtcbiAgdmFyIG1hc2tJbm5lckdyb3VwID0ge1xuICAgIHRhZzogJ2cnLFxuICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIHRyYW5zLmlubmVyKSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIHRhZzogJ3BhdGgnLFxuICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgbWFpblBhdGguYXR0cmlidXRlcywgdHJhbnMucGF0aCwge1xuICAgICAgICBmaWxsOiAnYmxhY2snXG4gICAgICB9KVxuICAgIH1dXG4gIH07XG4gIHZhciBtYXNrT3V0ZXJHcm91cCA9IHtcbiAgICB0YWc6ICdnJyxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCB0cmFucy5vdXRlciksXG4gICAgY2hpbGRyZW46IFttYXNrSW5uZXJHcm91cF1cbiAgfTtcbiAgdmFyIG1hc2tJZCA9IFwibWFzay1cIi5jb25jYXQobmV4dFVuaXF1ZUlkKCkpO1xuICB2YXIgY2xpcElkID0gXCJjbGlwLVwiLmNvbmNhdChuZXh0VW5pcXVlSWQoKSk7XG4gIHZhciBtYXNrVGFnID0ge1xuICAgIHRhZzogJ21hc2snLFxuICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIEFMTF9TUEFDRSwge1xuICAgICAgaWQ6IG1hc2tJZCxcbiAgICAgIG1hc2tVbml0czogJ3VzZXJTcGFjZU9uVXNlJyxcbiAgICAgIG1hc2tDb250ZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcbiAgICB9KSxcbiAgICBjaGlsZHJlbjogW21hc2tSZWN0LCBtYXNrT3V0ZXJHcm91cF1cbiAgfTtcbiAgdmFyIGRlZnMgPSB7XG4gICAgdGFnOiAnZGVmcycsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICB0YWc6ICdjbGlwUGF0aCcsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGlkOiBjbGlwSWRcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogW21hc2tQYXRoXVxuICAgIH0sIG1hc2tUYWddXG4gIH07XG4gIGNoaWxkcmVuLnB1c2goZGVmcywge1xuICAgIHRhZzogJ3JlY3QnLFxuICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAnY2xpcC1wYXRoJzogXCJ1cmwoI1wiLmNvbmNhdChjbGlwSWQsIFwiKVwiKSxcbiAgICAgIG1hc2s6IFwidXJsKCNcIi5jb25jYXQobWFza0lkLCBcIilcIilcbiAgICB9LCBBTExfU1BBQ0UpXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VJY29uU3RhbmRhcmQgKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBtYWluID0gX3JlZi5tYWluLFxuICAgICAgdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICBzdHlsZXMgPSBfcmVmLnN0eWxlcztcbiAgdmFyIHN0eWxlU3RyaW5nID0gam9pblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmIChzdHlsZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IHN0eWxlU3RyaW5nO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybUlzTWVhbmluZ2Z1bCh0cmFuc2Zvcm0pKSB7XG4gICAgdmFyIHRyYW5zID0gdHJhbnNmb3JtRm9yU3ZnKHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgY29udGFpbmVyV2lkdGg6IG1haW4ud2lkdGgsXG4gICAgICBpY29uV2lkdGg6IG1haW4ud2lkdGhcbiAgICB9KTtcbiAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgIHRhZzogJ2cnLFxuICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgdHJhbnMub3V0ZXIpLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZzogJ2cnLFxuICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCB0cmFucy5pbm5lciksXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRhZzogbWFpbi5pY29uLnRhZyxcbiAgICAgICAgICBjaGlsZHJlbjogbWFpbi5pY29uLmNoaWxkcmVuLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQoe30sIG1haW4uaWNvbi5hdHRyaWJ1dGVzLCB0cmFucy5wYXRoKVxuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbi5wdXNoKG1haW4uaWNvbik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzSWNvbiAoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgbWFpbiA9IF9yZWYubWFpbixcbiAgICAgIG1hc2sgPSBfcmVmLm1hc2ssXG4gICAgICBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgc3R5bGVzID0gX3JlZi5zdHlsZXMsXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybTtcblxuICBpZiAodHJhbnNmb3JtSXNNZWFuaW5nZnVsKHRyYW5zZm9ybSkgJiYgbWFpbi5mb3VuZCAmJiAhbWFzay5mb3VuZCkge1xuICAgIHZhciB3aWR0aCA9IG1haW4ud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG1haW4uaGVpZ2h0O1xuICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICB4OiB3aWR0aCAvIGhlaWdodCAvIDIsXG4gICAgICB5OiAwLjVcbiAgICB9O1xuICAgIGF0dHJpYnV0ZXNbJ3N0eWxlJ10gPSBqb2luU3R5bGVzKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlcywge1xuICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiBcIlwiLmNvbmNhdChvZmZzZXQueCArIHRyYW5zZm9ybS54IC8gMTYsIFwiZW0gXCIpLmNvbmNhdChvZmZzZXQueSArIHRyYW5zZm9ybS55IC8gMTYsIFwiZW1cIilcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gW3tcbiAgICB0YWc6ICdzdmcnLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH1dO1xufVxuXG5mdW5jdGlvbiBhc1N5bWJvbCAoX3JlZikge1xuICB2YXIgcHJlZml4ID0gX3JlZi5wcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IF9yZWYuaWNvbk5hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgc3ltYm9sID0gX3JlZi5zeW1ib2w7XG4gIHZhciBpZCA9IHN5bWJvbCA9PT0gdHJ1ZSA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCItXCIpLmNvbmNhdChjb25maWcuZmFtaWx5UHJlZml4LCBcIi1cIikuY29uY2F0KGljb25OYW1lKSA6IHN5bWJvbDtcbiAgcmV0dXJuIFt7XG4gICAgdGFnOiAnc3ZnJyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBzdHlsZTogJ2Rpc3BsYXk6IG5vbmU7J1xuICAgIH0sXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICB0YWc6ICdzeW1ib2wnLFxuICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgYXR0cmlidXRlcywge1xuICAgICAgICBpZDogaWRcbiAgICAgIH0pLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfV1cbiAgfV07XG59XG5cbmZ1bmN0aW9uIG1ha2VJbmxpbmVTdmdBYnN0cmFjdChwYXJhbXMpIHtcbiAgdmFyIF9wYXJhbXMkaWNvbnMgPSBwYXJhbXMuaWNvbnMsXG4gICAgICBtYWluID0gX3BhcmFtcyRpY29ucy5tYWluLFxuICAgICAgbWFzayA9IF9wYXJhbXMkaWNvbnMubWFzayxcbiAgICAgIHByZWZpeCA9IHBhcmFtcy5wcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IHBhcmFtcy5pY29uTmFtZSxcbiAgICAgIHRyYW5zZm9ybSA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICBzeW1ib2wgPSBwYXJhbXMuc3ltYm9sLFxuICAgICAgdGl0bGUgPSBwYXJhbXMudGl0bGUsXG4gICAgICBleHRyYSA9IHBhcmFtcy5leHRyYSxcbiAgICAgIF9wYXJhbXMkd2F0Y2hhYmxlID0gcGFyYW1zLndhdGNoYWJsZSxcbiAgICAgIHdhdGNoYWJsZSA9IF9wYXJhbXMkd2F0Y2hhYmxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJhbXMkd2F0Y2hhYmxlO1xuXG4gIHZhciBfcmVmID0gbWFzay5mb3VuZCA/IG1hc2sgOiBtYWluLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgdmFyIHdpZHRoQ2xhc3MgPSBcImZhLXctXCIuY29uY2F0KE1hdGguY2VpbCh3aWR0aCAvIGhlaWdodCAqIDE2KSk7XG4gIHZhciBhdHRyQ2xhc3MgPSBbY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MsIGljb25OYW1lID8gXCJcIi5jb25jYXQoY29uZmlnLmZhbWlseVByZWZpeCwgXCItXCIpLmNvbmNhdChpY29uTmFtZSkgOiAnJywgd2lkdGhDbGFzc10uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGV4dHJhLmNsYXNzZXMuaW5kZXhPZihjKSA9PT0gLTE7XG4gIH0pLmNvbmNhdChleHRyYS5jbGFzc2VzKS5qb2luKCcgJyk7XG4gIHZhciBjb250ZW50ID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBleHRyYS5hdHRyaWJ1dGVzLCB7XG4gICAgICAnZGF0YS1wcmVmaXgnOiBwcmVmaXgsXG4gICAgICAnZGF0YS1pY29uJzogaWNvbk5hbWUsXG4gICAgICAnY2xhc3MnOiBhdHRyQ2xhc3MsXG4gICAgICAncm9sZSc6IGV4dHJhLmF0dHJpYnV0ZXMucm9sZSB8fCAnaW1nJyxcbiAgICAgICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgICAndmlld0JveCc6IFwiMCAwIFwiLmNvbmNhdCh3aWR0aCwgXCIgXCIpLmNvbmNhdChoZWlnaHQpXG4gICAgfSlcbiAgfTtcblxuICBpZiAod2F0Y2hhYmxlKSB7XG4gICAgY29udGVudC5hdHRyaWJ1dGVzW0RBVEFfRkFfSTJTVkddID0gJyc7XG4gIH1cblxuICBpZiAodGl0bGUpIGNvbnRlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgdGFnOiAndGl0bGUnLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIGlkOiBjb250ZW50LmF0dHJpYnV0ZXNbJ2FyaWEtbGFiZWxsZWRieSddIHx8IFwidGl0bGUtXCIuY29uY2F0KG5leHRVbmlxdWVJZCgpKVxuICAgIH0sXG4gICAgY2hpbGRyZW46IFt0aXRsZV1cbiAgfSk7XG5cbiAgdmFyIGFyZ3MgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb250ZW50LCB7XG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgIG1haW46IG1haW4sXG4gICAgbWFzazogbWFzayxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICBzdHlsZXM6IGV4dHJhLnN0eWxlc1xuICB9KTtcblxuICB2YXIgX3JlZjIgPSBtYXNrLmZvdW5kICYmIG1haW4uZm91bmQgPyBtYWtlSWNvbk1hc2tpbmcoYXJncykgOiBtYWtlSWNvblN0YW5kYXJkKGFyZ3MpLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmMi5hdHRyaWJ1dGVzO1xuXG4gIGFyZ3MuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgYXJncy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICBpZiAoc3ltYm9sKSB7XG4gICAgcmV0dXJuIGFzU3ltYm9sKGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc0ljb24oYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1ha2VMYXllcnNUZXh0QWJzdHJhY3QocGFyYW1zKSB7XG4gIHZhciBjb250ZW50ID0gcGFyYW1zLmNvbnRlbnQsXG4gICAgICB3aWR0aCA9IHBhcmFtcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IHBhcmFtcy5oZWlnaHQsXG4gICAgICB0cmFuc2Zvcm0gPSBwYXJhbXMudHJhbnNmb3JtLFxuICAgICAgdGl0bGUgPSBwYXJhbXMudGl0bGUsXG4gICAgICBleHRyYSA9IHBhcmFtcy5leHRyYSxcbiAgICAgIF9wYXJhbXMkd2F0Y2hhYmxlMiA9IHBhcmFtcy53YXRjaGFibGUsXG4gICAgICB3YXRjaGFibGUgPSBfcGFyYW1zJHdhdGNoYWJsZTIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhcmFtcyR3YXRjaGFibGUyO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gX29iamVjdFNwcmVhZCh7fSwgZXh0cmEuYXR0cmlidXRlcywgdGl0bGUgPyB7XG4gICAgJ3RpdGxlJzogdGl0bGVcbiAgfSA6IHt9LCB7XG4gICAgJ2NsYXNzJzogZXh0cmEuY2xhc3Nlcy5qb2luKCcgJylcbiAgfSk7XG5cbiAgaWYgKHdhdGNoYWJsZSkge1xuICAgIGF0dHJpYnV0ZXNbREFUQV9GQV9JMlNWR10gPSAnJztcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBfb2JqZWN0U3ByZWFkKHt9LCBleHRyYS5zdHlsZXMpO1xuXG4gIGlmICh0cmFuc2Zvcm1Jc01lYW5pbmdmdWwodHJhbnNmb3JtKSkge1xuICAgIHN0eWxlc1sndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm1Gb3JDc3Moe1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBzdGFydENlbnRlcmVkOiB0cnVlLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgICBzdHlsZXNbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBzdHlsZXNbJ3RyYW5zZm9ybSddO1xuICB9XG5cbiAgdmFyIHN0eWxlU3RyaW5nID0gam9pblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmIChzdHlsZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IHN0eWxlU3RyaW5nO1xuICB9XG5cbiAgdmFyIHZhbCA9IFtdO1xuICB2YWwucHVzaCh7XG4gICAgdGFnOiAnc3BhbicsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogW2NvbnRlbnRdXG4gIH0pO1xuXG4gIGlmICh0aXRsZSkge1xuICAgIHZhbC5wdXNoKHtcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBjbGFzczogJ3NyLW9ubHknXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFt0aXRsZV1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBtYWtlTGF5ZXJzQ291bnRlckFic3RyYWN0KHBhcmFtcykge1xuICB2YXIgY29udGVudCA9IHBhcmFtcy5jb250ZW50LFxuICAgICAgdGl0bGUgPSBwYXJhbXMudGl0bGUsXG4gICAgICBleHRyYSA9IHBhcmFtcy5leHRyYTtcblxuICB2YXIgYXR0cmlidXRlcyA9IF9vYmplY3RTcHJlYWQoe30sIGV4dHJhLmF0dHJpYnV0ZXMsIHRpdGxlID8ge1xuICAgICd0aXRsZSc6IHRpdGxlXG4gIH0gOiB7fSwge1xuICAgICdjbGFzcyc6IGV4dHJhLmNsYXNzZXMuam9pbignICcpXG4gIH0pO1xuXG4gIHZhciBzdHlsZVN0cmluZyA9IGpvaW5TdHlsZXMoZXh0cmEuc3R5bGVzKTtcblxuICBpZiAoc3R5bGVTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGF0dHJpYnV0ZXNbJ3N0eWxlJ10gPSBzdHlsZVN0cmluZztcbiAgfVxuXG4gIHZhciB2YWwgPSBbXTtcbiAgdmFsLnB1c2goe1xuICAgIHRhZzogJ3NwYW4nLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW46IFtjb250ZW50XVxuICB9KTtcblxuICBpZiAodGl0bGUpIHtcbiAgICB2YWwucHVzaCh7XG4gICAgICB0YWc6ICdzcGFuJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgY2xhc3M6ICdzci1vbmx5J1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbdGl0bGVdXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG52YXIgbm9vcCQxID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgcCA9IGNvbmZpZy5tZWFzdXJlUGVyZm9ybWFuY2UgJiYgUEVSRk9STUFOQ0UgJiYgUEVSRk9STUFOQ0UubWFyayAmJiBQRVJGT1JNQU5DRS5tZWFzdXJlID8gUEVSRk9STUFOQ0UgOiB7XG4gIG1hcms6IG5vb3AkMSxcbiAgbWVhc3VyZTogbm9vcCQxXG59O1xudmFyIHByZWFtYmxlID0gXCJGQSBcXFwiNS45LjBcXFwiXCI7XG5cbnZhciBiZWdpbiA9IGZ1bmN0aW9uIGJlZ2luKG5hbWUpIHtcbiAgcC5tYXJrKFwiXCIuY29uY2F0KHByZWFtYmxlLCBcIiBcIikuY29uY2F0KG5hbWUsIFwiIGJlZ2luc1wiKSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVuZChuYW1lKTtcbiAgfTtcbn07XG5cbnZhciBlbmQgPSBmdW5jdGlvbiBlbmQobmFtZSkge1xuICBwLm1hcmsoXCJcIi5jb25jYXQocHJlYW1ibGUsIFwiIFwiKS5jb25jYXQobmFtZSwgXCIgZW5kc1wiKSk7XG4gIHAubWVhc3VyZShcIlwiLmNvbmNhdChwcmVhbWJsZSwgXCIgXCIpLmNvbmNhdChuYW1lKSwgXCJcIi5jb25jYXQocHJlYW1ibGUsIFwiIFwiKS5jb25jYXQobmFtZSwgXCIgYmVnaW5zXCIpLCBcIlwiLmNvbmNhdChwcmVhbWJsZSwgXCIgXCIpLmNvbmNhdChuYW1lLCBcIiBlbmRzXCIpKTtcbn07XG5cbnZhciBwZXJmID0ge1xuICBiZWdpbjogYmVnaW4sXG4gIGVuZDogZW5kXG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciB0byBiaW5kIGEgZnVuY3Rpb24ga25vd24gdG8gaGF2ZSA0IGFyZ3VtZW50c1xuICogdG8gYSBnaXZlbiBjb250ZXh0LlxuICovXG5cbnZhciBiaW5kSW50ZXJuYWw0ID0gZnVuY3Rpb24gYmluZEludGVybmFsNChmdW5jLCB0aGlzQ29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNDb250ZXh0LCBhLCBiLCBjLCBkKTtcbiAgfTtcbn07XG5cbi8qKlxuICogIyBSZWR1Y2VcbiAqXG4gKiBBIGZhc3Qgb2JqZWN0IGAucmVkdWNlKClgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gICBzdWJqZWN0ICAgICAgVGhlIG9iamVjdCB0byByZWR1Y2Ugb3Zlci5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgVGhlIHJlZHVjZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHttaXhlZH0gICAgaW5pdGlhbFZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgcmVkdWNlciwgZGVmYXVsdHMgdG8gc3ViamVjdFswXS5cbiAqIEBwYXJhbSAge09iamVjdH0gICB0aGlzQ29udGV4dCAgVGhlIGNvbnRleHQgZm9yIHRoZSByZWR1Y2VyLlxuICogQHJldHVybiB7bWl4ZWR9ICAgICAgICAgICAgICAgICBUaGUgZmluYWwgcmVzdWx0LlxuICovXG5cblxudmFyIHJlZHVjZSA9IGZ1bmN0aW9uIGZhc3RSZWR1Y2VPYmplY3Qoc3ViamVjdCwgZm4sIGluaXRpYWxWYWx1ZSwgdGhpc0NvbnRleHQpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdWJqZWN0KSxcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgaXRlcmF0b3IgPSB0aGlzQ29udGV4dCAhPT0gdW5kZWZpbmVkID8gYmluZEludGVybmFsNChmbiwgdGhpc0NvbnRleHQpIDogZm4sXG4gICAgICBpLFxuICAgICAga2V5LFxuICAgICAgcmVzdWx0O1xuXG4gIGlmIChpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGkgPSAxO1xuICAgIHJlc3VsdCA9IHN1YmplY3Rba2V5c1swXV07XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gICAgcmVzdWx0ID0gaW5pdGlhbFZhbHVlO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgcmVzdWx0ID0gaXRlcmF0b3IocmVzdWx0LCBzdWJqZWN0W2tleV0sIGtleSwgc3ViamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdG9IZXgodW5pY29kZSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmljb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhleCA9IHVuaWNvZGUuY2hhckNvZGVBdChpKS50b1N0cmluZygxNik7XG4gICAgcmVzdWx0ICs9ICgnMDAwJyArIGhleCkuc2xpY2UoLTQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lSWNvbnMocHJlZml4LCBpY29ucykge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkc2tpcEhvb2tzID0gcGFyYW1zLnNraXBIb29rcyxcbiAgICAgIHNraXBIb29rcyA9IF9wYXJhbXMkc2tpcEhvb2tzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJhbXMkc2tpcEhvb2tzO1xuICB2YXIgbm9ybWFsaXplZCA9IE9iamVjdC5rZXlzKGljb25zKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaWNvbk5hbWUpIHtcbiAgICB2YXIgaWNvbiA9IGljb25zW2ljb25OYW1lXTtcbiAgICB2YXIgZXhwYW5kZWQgPSAhIWljb24uaWNvbjtcblxuICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgYWNjW2ljb24uaWNvbk5hbWVdID0gaWNvbi5pY29uO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NbaWNvbk5hbWVdID0gaWNvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgaWYgKHR5cGVvZiBuYW1lc3BhY2UuaG9va3MuYWRkUGFjayA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2tpcEhvb2tzKSB7XG4gICAgbmFtZXNwYWNlLmhvb2tzLmFkZFBhY2socHJlZml4LCBub3JtYWxpemVkKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lc3BhY2Uuc3R5bGVzW3ByZWZpeF0gPSBfb2JqZWN0U3ByZWFkKHt9LCBuYW1lc3BhY2Uuc3R5bGVzW3ByZWZpeF0gfHwge30sIG5vcm1hbGl6ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBGb250IEF3ZXNvbWUgNCB1c2VkIHRoZSBwcmVmaXggb2YgYGZhYCBmb3IgYWxsIGljb25zLiBXaXRoIHRoZSBpbnRyb2R1Y3Rpb25cbiAgICogb2YgbmV3IHN0eWxlcyB3ZSBuZWVkZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZW0uIFByZWZpeCBgZmFgIGlzIG5vdyBhbiBhbGlhc1xuICAgKiBmb3IgYGZhc2Agc28gd2UnbGwgZWFzeSB0aGUgdXBncmFkZSBwcm9jZXNzIGZvciBvdXIgdXNlcnMgYnkgYXV0b21hdGljYWxseSBkZWZpbmluZ1xuICAgKiB0aGlzIGFzIHdlbGwuXG4gICAqL1xuXG5cbiAgaWYgKHByZWZpeCA9PT0gJ2ZhcycpIHtcbiAgICBkZWZpbmVJY29ucygnZmEnLCBpY29ucyk7XG4gIH1cbn1cblxudmFyIHN0eWxlcyA9IG5hbWVzcGFjZS5zdHlsZXMsXG4gICAgc2hpbXMgPSBuYW1lc3BhY2Uuc2hpbXM7XG52YXIgX2J5VW5pY29kZSA9IHt9O1xudmFyIF9ieUxpZ2F0dXJlID0ge307XG52YXIgX2J5T2xkTmFtZSA9IHt9O1xudmFyIGJ1aWxkID0gZnVuY3Rpb24gYnVpbGQoKSB7XG4gIHZhciBsb29rdXAgPSBmdW5jdGlvbiBsb29rdXAocmVkdWNlcikge1xuICAgIHJldHVybiByZWR1Y2Uoc3R5bGVzLCBmdW5jdGlvbiAobywgc3R5bGUsIHByZWZpeCkge1xuICAgICAgb1twcmVmaXhdID0gcmVkdWNlKHN0eWxlLCByZWR1Y2VyLCB7fSk7XG4gICAgICByZXR1cm4gbztcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgX2J5VW5pY29kZSA9IGxvb2t1cChmdW5jdGlvbiAoYWNjLCBpY29uLCBpY29uTmFtZSkge1xuICAgIGlmIChpY29uWzNdKSB7XG4gICAgICBhY2NbaWNvblszXV0gPSBpY29uTmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9KTtcbiAgX2J5TGlnYXR1cmUgPSBsb29rdXAoZnVuY3Rpb24gKGFjYywgaWNvbiwgaWNvbk5hbWUpIHtcbiAgICB2YXIgbGlnYXR1cmVzID0gaWNvblsyXTtcbiAgICBhY2NbaWNvbk5hbWVdID0gaWNvbk5hbWU7XG4gICAgbGlnYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGxpZ2F0dXJlKSB7XG4gICAgICBhY2NbbGlnYXR1cmVdID0gaWNvbk5hbWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSk7XG4gIHZhciBoYXNSZWd1bGFyID0gJ2ZhcicgaW4gc3R5bGVzO1xuICBfYnlPbGROYW1lID0gcmVkdWNlKHNoaW1zLCBmdW5jdGlvbiAoYWNjLCBzaGltKSB7XG4gICAgdmFyIG9sZE5hbWUgPSBzaGltWzBdO1xuICAgIHZhciBwcmVmaXggPSBzaGltWzFdO1xuICAgIHZhciBpY29uTmFtZSA9IHNoaW1bMl07XG5cbiAgICBpZiAocHJlZml4ID09PSAnZmFyJyAmJiAhaGFzUmVndWxhcikge1xuICAgICAgcHJlZml4ID0gJ2Zhcyc7XG4gICAgfVxuXG4gICAgYWNjW29sZE5hbWVdID0ge1xuICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICBpY29uTmFtZTogaWNvbk5hbWVcbiAgICB9O1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5idWlsZCgpO1xuZnVuY3Rpb24gYnlVbmljb2RlKHByZWZpeCwgdW5pY29kZSkge1xuICByZXR1cm4gKF9ieVVuaWNvZGVbcHJlZml4XSB8fCB7fSlbdW5pY29kZV07XG59XG5mdW5jdGlvbiBieUxpZ2F0dXJlKHByZWZpeCwgbGlnYXR1cmUpIHtcbiAgcmV0dXJuIChfYnlMaWdhdHVyZVtwcmVmaXhdIHx8IHt9KVtsaWdhdHVyZV07XG59XG5mdW5jdGlvbiBieU9sZE5hbWUobmFtZSkge1xuICByZXR1cm4gX2J5T2xkTmFtZVtuYW1lXSB8fCB7XG4gICAgcHJlZml4OiBudWxsLFxuICAgIGljb25OYW1lOiBudWxsXG4gIH07XG59XG5cbnZhciBzdHlsZXMkMSA9IG5hbWVzcGFjZS5zdHlsZXM7XG52YXIgZW1wdHlDYW5vbmljYWxJY29uID0gZnVuY3Rpb24gZW1wdHlDYW5vbmljYWxJY29uKCkge1xuICByZXR1cm4ge1xuICAgIHByZWZpeDogbnVsbCxcbiAgICBpY29uTmFtZTogbnVsbCxcbiAgICByZXN0OiBbXVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldENhbm9uaWNhbEljb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNscykge1xuICAgIHZhciBpY29uTmFtZSA9IGdldEljb25OYW1lKGNvbmZpZy5mYW1pbHlQcmVmaXgsIGNscyk7XG5cbiAgICBpZiAoc3R5bGVzJDFbY2xzXSkge1xuICAgICAgYWNjLnByZWZpeCA9IGNscztcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5hdXRvRmV0Y2hTdmcgJiYgWydmYXMnLCAnZmFyJywgJ2ZhbCcsICdmYWInLCAnZmEnXS5pbmRleE9mKGNscykgPiAtMSkge1xuICAgICAgYWNjLnByZWZpeCA9IGNscztcbiAgICB9IGVsc2UgaWYgKGljb25OYW1lKSB7XG4gICAgICB2YXIgc2hpbSA9IGFjYy5wcmVmaXggPT09ICdmYScgPyBieU9sZE5hbWUoaWNvbk5hbWUpIDoge307XG4gICAgICBhY2MuaWNvbk5hbWUgPSBzaGltLmljb25OYW1lIHx8IGljb25OYW1lO1xuICAgICAgYWNjLnByZWZpeCA9IHNoaW0ucHJlZml4IHx8IGFjYy5wcmVmaXg7XG4gICAgfSBlbHNlIGlmIChjbHMgIT09IGNvbmZpZy5yZXBsYWNlbWVudENsYXNzICYmIGNscy5pbmRleE9mKCdmYS13LScpICE9PSAwKSB7XG4gICAgICBhY2MucmVzdC5wdXNoKGNscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgZW1wdHlDYW5vbmljYWxJY29uKCkpO1xufVxuZnVuY3Rpb24gaWNvbkZyb21NYXBwaW5nKG1hcHBpbmcsIHByZWZpeCwgaWNvbk5hbWUpIHtcbiAgaWYgKG1hcHBpbmcgJiYgbWFwcGluZ1twcmVmaXhdICYmIG1hcHBpbmdbcHJlZml4XVtpY29uTmFtZV0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICBpY29uTmFtZTogaWNvbk5hbWUsXG4gICAgICBpY29uOiBtYXBwaW5nW3ByZWZpeF1baWNvbk5hbWVdXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b0h0bWwoYWJzdHJhY3ROb2Rlcykge1xuICB2YXIgdGFnID0gYWJzdHJhY3ROb2Rlcy50YWcsXG4gICAgICBfYWJzdHJhY3ROb2RlcyRhdHRyaWIgPSBhYnN0cmFjdE5vZGVzLmF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX2Fic3RyYWN0Tm9kZXMkYXR0cmliID09PSB2b2lkIDAgPyB7fSA6IF9hYnN0cmFjdE5vZGVzJGF0dHJpYixcbiAgICAgIF9hYnN0cmFjdE5vZGVzJGNoaWxkciA9IGFic3RyYWN0Tm9kZXMuY2hpbGRyZW4sXG4gICAgICBjaGlsZHJlbiA9IF9hYnN0cmFjdE5vZGVzJGNoaWxkciA9PT0gdm9pZCAwID8gW10gOiBfYWJzdHJhY3ROb2RlcyRjaGlsZHI7XG5cbiAgaWYgKHR5cGVvZiBhYnN0cmFjdE5vZGVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBodG1sRXNjYXBlKGFic3RyYWN0Tm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIjxcIi5jb25jYXQodGFnLCBcIiBcIikuY29uY2F0KGpvaW5BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLCBcIj5cIikuY29uY2F0KGNoaWxkcmVuLm1hcCh0b0h0bWwpLmpvaW4oJycpLCBcIjwvXCIpLmNvbmNhdCh0YWcsIFwiPlwiKTtcbiAgfVxufVxuXG52YXIgbm9vcCQyID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG5mdW5jdGlvbiBpc1dhdGNoZWQobm9kZSkge1xuICB2YXIgaTJzdmcgPSBub2RlLmdldEF0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKERBVEFfRkFfSTJTVkcpIDogbnVsbDtcbiAgcmV0dXJuIHR5cGVvZiBpMnN2ZyA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGdldE11dGF0b3IoKSB7XG4gIGlmIChjb25maWcuYXV0b1JlcGxhY2VTdmcgPT09IHRydWUpIHtcbiAgICByZXR1cm4gbXV0YXRvcnMucmVwbGFjZTtcbiAgfVxuXG4gIHZhciBtdXRhdG9yID0gbXV0YXRvcnNbY29uZmlnLmF1dG9SZXBsYWNlU3ZnXTtcbiAgcmV0dXJuIG11dGF0b3IgfHwgbXV0YXRvcnMucmVwbGFjZTtcbn1cblxudmFyIG11dGF0b3JzID0ge1xuICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG11dGF0aW9uKSB7XG4gICAgdmFyIG5vZGUgPSBtdXRhdGlvblswXTtcbiAgICB2YXIgYWJzdHJhY3QgPSBtdXRhdGlvblsxXTtcbiAgICB2YXIgbmV3T3V0ZXJIVE1MID0gYWJzdHJhY3QubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gdG9IdG1sKGEpO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuXG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLm91dGVySFRNTCkge1xuICAgICAgbm9kZS5vdXRlckhUTUwgPSBuZXdPdXRlckhUTUwgKyAoY29uZmlnLmtlZXBPcmlnaW5hbFNvdXJjZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3N2ZycgPyBcIjwhLS0gXCIuY29uY2F0KG5vZGUub3V0ZXJIVE1MLCBcIiAtLT5cIikgOiAnJyk7XG4gICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBuZXdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBub2RlKTtcbiAgICAgIG5ld05vZGUub3V0ZXJIVE1MID0gbmV3T3V0ZXJIVE1MO1xuICAgIH1cbiAgfSxcbiAgbmVzdDogZnVuY3Rpb24gbmVzdChtdXRhdGlvbikge1xuICAgIHZhciBub2RlID0gbXV0YXRpb25bMF07XG4gICAgdmFyIGFic3RyYWN0ID0gbXV0YXRpb25bMV07IC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIHJlcGxhY2VkIG5vZGUgd2UgZG8gbm90IHdhbnQgdG8gY29udGludWUgbmVzdGluZyB3aXRoaW4gaXQuXG4gICAgLy8gU2hvcnQtY2lyY3VpdCB0byB0aGUgc3RhbmRhcmQgcmVwbGFjZW1lbnRcblxuICAgIGlmICh+Y2xhc3NBcnJheShub2RlKS5pbmRleE9mKGNvbmZpZy5yZXBsYWNlbWVudENsYXNzKSkge1xuICAgICAgcmV0dXJuIG11dGF0b3JzLnJlcGxhY2UobXV0YXRpb24pO1xuICAgIH1cblxuICAgIHZhciBmb3JTdmcgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KGNvbmZpZy5mYW1pbHlQcmVmaXgsIFwiLS4qXCIpKTtcbiAgICBkZWxldGUgYWJzdHJhY3RbMF0uYXR0cmlidXRlcy5zdHlsZTtcbiAgICB2YXIgc3BsaXRDbGFzc2VzID0gYWJzdHJhY3RbMF0uYXR0cmlidXRlcy5jbGFzcy5zcGxpdCgnICcpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjbHMpIHtcbiAgICAgIGlmIChjbHMgPT09IGNvbmZpZy5yZXBsYWNlbWVudENsYXNzIHx8IGNscy5tYXRjaChmb3JTdmcpKSB7XG4gICAgICAgIGFjYy50b1N2Zy5wdXNoKGNscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2MudG9Ob2RlLnB1c2goY2xzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7XG4gICAgICB0b05vZGU6IFtdLFxuICAgICAgdG9Tdmc6IFtdXG4gICAgfSk7XG4gICAgYWJzdHJhY3RbMF0uYXR0cmlidXRlcy5jbGFzcyA9IHNwbGl0Q2xhc3Nlcy50b1N2Zy5qb2luKCcgJyk7XG4gICAgdmFyIG5ld0lubmVySFRNTCA9IGFic3RyYWN0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIHRvSHRtbChhKTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBzcGxpdENsYXNzZXMudG9Ob2RlLmpvaW4oJyAnKSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoREFUQV9GQV9JMlNWRywgJycpO1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbmV3SW5uZXJIVE1MO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwZXJmb3JtT3BlcmF0aW9uU3luYyhvcCkge1xuICBvcCgpO1xufVxuXG5mdW5jdGlvbiBwZXJmb3JtKG11dGF0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxiYWNrRnVuY3Rpb24gPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG5vb3AkMjtcblxuICBpZiAobXV0YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNhbGxiYWNrRnVuY3Rpb24oKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZnJhbWUgPSBwZXJmb3JtT3BlcmF0aW9uU3luYztcblxuICAgIGlmIChjb25maWcubXV0YXRlQXBwcm9hY2ggPT09IE1VVEFUSU9OX0FQUFJPQUNIX0FTWU5DKSB7XG4gICAgICBmcmFtZSA9IFdJTkRPVy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgcGVyZm9ybU9wZXJhdGlvblN5bmM7XG4gICAgfVxuXG4gICAgZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG11dGF0b3IgPSBnZXRNdXRhdG9yKCk7XG4gICAgICB2YXIgbWFyayA9IHBlcmYuYmVnaW4oJ211dGF0ZScpO1xuICAgICAgbXV0YXRpb25zLm1hcChtdXRhdG9yKTtcbiAgICAgIG1hcmsoKTtcbiAgICAgIGNhbGxiYWNrRnVuY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxufVxudmFyIGRpc2FibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBkaXNhYmxlT2JzZXJ2YXRpb24oKSB7XG4gIGRpc2FibGVkID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuYWJsZU9ic2VydmF0aW9uKCkge1xuICBkaXNhYmxlZCA9IGZhbHNlO1xufVxudmFyIG1vID0gbnVsbDtcbmZ1bmN0aW9uIG9ic2VydmUob3B0aW9ucykge1xuICBpZiAoIU1VVEFUSU9OX09CU0VSVkVSKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjb25maWcub2JzZXJ2ZU11dGF0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0cmVlQ2FsbGJhY2sgPSBvcHRpb25zLnRyZWVDYWxsYmFjayxcbiAgICAgIG5vZGVDYWxsYmFjayA9IG9wdGlvbnMubm9kZUNhbGxiYWNrLFxuICAgICAgcHNldWRvRWxlbWVudHNDYWxsYmFjayA9IG9wdGlvbnMucHNldWRvRWxlbWVudHNDYWxsYmFjayxcbiAgICAgIF9vcHRpb25zJG9ic2VydmVNdXRhdCA9IG9wdGlvbnMub2JzZXJ2ZU11dGF0aW9uc1Jvb3QsXG4gICAgICBvYnNlcnZlTXV0YXRpb25zUm9vdCA9IF9vcHRpb25zJG9ic2VydmVNdXRhdCA9PT0gdm9pZCAwID8gRE9DVU1FTlQgOiBfb3B0aW9ucyRvYnNlcnZlTXV0YXQ7XG4gIG1vID0gbmV3IE1VVEFUSU9OX09CU0VSVkVSKGZ1bmN0aW9uIChvYmplY3RzKSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgdG9BcnJheShvYmplY3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvblJlY29yZCkge1xuICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnICYmIG11dGF0aW9uUmVjb3JkLmFkZGVkTm9kZXMubGVuZ3RoID4gMCAmJiAhaXNXYXRjaGVkKG11dGF0aW9uUmVjb3JkLmFkZGVkTm9kZXNbMF0pKSB7XG4gICAgICAgIGlmIChjb25maWcuc2VhcmNoUHNldWRvRWxlbWVudHMpIHtcbiAgICAgICAgICBwc2V1ZG9FbGVtZW50c0NhbGxiYWNrKG11dGF0aW9uUmVjb3JkLnRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmVlQ2FsbGJhY2sobXV0YXRpb25SZWNvcmQudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiBtdXRhdGlvblJlY29yZC50YXJnZXQucGFyZW50Tm9kZSAmJiBjb25maWcuc2VhcmNoUHNldWRvRWxlbWVudHMpIHtcbiAgICAgICAgcHNldWRvRWxlbWVudHNDYWxsYmFjayhtdXRhdGlvblJlY29yZC50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtdXRhdGlvblJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycgJiYgaXNXYXRjaGVkKG11dGF0aW9uUmVjb3JkLnRhcmdldCkgJiYgfkFUVFJJQlVURVNfV0FUQ0hFRF9GT1JfTVVUQVRJT04uaW5kZXhPZihtdXRhdGlvblJlY29yZC5hdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAobXV0YXRpb25SZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgIHZhciBfZ2V0Q2Fub25pY2FsSWNvbiA9IGdldENhbm9uaWNhbEljb24oY2xhc3NBcnJheShtdXRhdGlvblJlY29yZC50YXJnZXQpKSxcbiAgICAgICAgICAgICAgcHJlZml4ID0gX2dldENhbm9uaWNhbEljb24ucHJlZml4LFxuICAgICAgICAgICAgICBpY29uTmFtZSA9IF9nZXRDYW5vbmljYWxJY29uLmljb25OYW1lO1xuXG4gICAgICAgICAgaWYgKHByZWZpeCkgbXV0YXRpb25SZWNvcmQudGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1wcmVmaXgnLCBwcmVmaXgpO1xuICAgICAgICAgIGlmIChpY29uTmFtZSkgbXV0YXRpb25SZWNvcmQudGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1pY29uJywgaWNvbk5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVDYWxsYmFjayhtdXRhdGlvblJlY29yZC50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICBtby5vYnNlcnZlKG9ic2VydmVNdXRhdGlvbnNSb290LCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgaWYgKCFtbykgcmV0dXJuO1xuICBtby5kaXNjb25uZWN0KCk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlUGFyc2VyIChub2RlKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICB2YXIgdmFsID0gW107XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFsID0gc3R5bGUuc3BsaXQoJzsnKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3R5bGUpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIHByb3AgPSBzdHlsZXNbMF07XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZXMuc2xpY2UoMSk7XG5cbiAgICAgIGlmIChwcm9wICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWNjW3Byb3BdID0gdmFsdWUuam9pbignOicpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBjbGFzc1BhcnNlciAobm9kZSkge1xuICB2YXIgZXhpc3RpbmdQcmVmaXggPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wcmVmaXgnKTtcbiAgdmFyIGV4aXN0aW5nSWNvbk5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1pY29uJyk7XG4gIHZhciBpbm5lclRleHQgPSBub2RlLmlubmVyVGV4dCAhPT0gdW5kZWZpbmVkID8gbm9kZS5pbm5lclRleHQudHJpbSgpIDogJyc7XG4gIHZhciB2YWwgPSBnZXRDYW5vbmljYWxJY29uKGNsYXNzQXJyYXkobm9kZSkpO1xuXG4gIGlmIChleGlzdGluZ1ByZWZpeCAmJiBleGlzdGluZ0ljb25OYW1lKSB7XG4gICAgdmFsLnByZWZpeCA9IGV4aXN0aW5nUHJlZml4O1xuICAgIHZhbC5pY29uTmFtZSA9IGV4aXN0aW5nSWNvbk5hbWU7XG4gIH1cblxuICBpZiAodmFsLnByZWZpeCAmJiBpbm5lclRleHQubGVuZ3RoID4gMSkge1xuICAgIHZhbC5pY29uTmFtZSA9IGJ5TGlnYXR1cmUodmFsLnByZWZpeCwgbm9kZS5pbm5lclRleHQpO1xuICB9IGVsc2UgaWYgKHZhbC5wcmVmaXggJiYgaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbC5pY29uTmFtZSA9IGJ5VW5pY29kZSh2YWwucHJlZml4LCB0b0hleChub2RlLmlubmVyVGV4dCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIHBhcnNlVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtU3RyaW5nKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSB7XG4gICAgc2l6ZTogMTYsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGZsaXBYOiBmYWxzZSxcbiAgICBmbGlwWTogZmFsc2UsXG4gICAgcm90YXRlOiAwXG4gIH07XG5cbiAgaWYgKCF0cmFuc2Zvcm1TdHJpbmcpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJpbmcudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuKSB7XG4gICAgICB2YXIgcGFydHMgPSBuLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgIHZhciBmaXJzdCA9IHBhcnRzWzBdO1xuICAgICAgdmFyIHJlc3QgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCctJyk7XG5cbiAgICAgIGlmIChmaXJzdCAmJiByZXN0ID09PSAnaCcpIHtcbiAgICAgICAgYWNjLmZsaXBYID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0ICYmIHJlc3QgPT09ICd2Jykge1xuICAgICAgICBhY2MuZmxpcFkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICByZXN0ID0gcGFyc2VGbG9hdChyZXN0KTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3QpKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZmlyc3QpIHtcbiAgICAgICAgY2FzZSAnZ3Jvdyc6XG4gICAgICAgICAgYWNjLnNpemUgPSBhY2Muc2l6ZSArIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2hyaW5rJzpcbiAgICAgICAgICBhY2Muc2l6ZSA9IGFjYy5zaXplIC0gcmVzdDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBhY2MueCA9IGFjYy54IC0gcmVzdDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgYWNjLnggPSBhY2MueCArIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndXAnOlxuICAgICAgICAgIGFjYy55ID0gYWNjLnkgLSByZXN0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgIGFjYy55ID0gYWNjLnkgKyByZXN0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgYWNjLnJvdGF0ZSA9IGFjYy5yb3RhdGUgKyByZXN0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRyYW5zZm9ybSk7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1QYXJzZXIgKG5vZGUpIHtcbiAgcmV0dXJuIHBhcnNlVHJhbnNmb3JtU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZhLXRyYW5zZm9ybScpKTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sUGFyc2VyIChub2RlKSB7XG4gIHZhciBzeW1ib2wgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1mYS1zeW1ib2wnKTtcbiAgcmV0dXJuIHN5bWJvbCA9PT0gbnVsbCA/IGZhbHNlIDogc3ltYm9sID09PSAnJyA/IHRydWUgOiBzeW1ib2w7XG59XG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNQYXJzZXIgKG5vZGUpIHtcbiAgdmFyIGV4dHJhQXR0cmlidXRlcyA9IHRvQXJyYXkobm9kZS5hdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikge1xuICAgIGlmIChhY2MubmFtZSAhPT0gJ2NsYXNzJyAmJiBhY2MubmFtZSAhPT0gJ3N0eWxlJykge1xuICAgICAgYWNjW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIHRpdGxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG5cbiAgaWYgKGNvbmZpZy5hdXRvQTExeSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzWydhcmlhLWxhYmVsbGVkYnknXSA9IFwiXCIuY29uY2F0KGNvbmZpZy5yZXBsYWNlbWVudENsYXNzLCBcIi10aXRsZS1cIikuY29uY2F0KG5leHRVbmlxdWVJZCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzWydhcmlhLWhpZGRlbiddID0gJ3RydWUnO1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzWydmb2N1c2FibGUnXSA9ICdmYWxzZSc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4dHJhQXR0cmlidXRlcztcbn1cblxuZnVuY3Rpb24gbWFza1BhcnNlciAobm9kZSkge1xuICB2YXIgbWFzayA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZhLW1hc2snKTtcblxuICBpZiAoIW1hc2spIHtcbiAgICByZXR1cm4gZW1wdHlDYW5vbmljYWxJY29uKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldENhbm9uaWNhbEljb24obWFzay5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkudHJpbSgpO1xuICAgIH0pKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBibGFua01ldGEoKSB7XG4gIHJldHVybiB7XG4gICAgaWNvbk5hbWU6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgcHJlZml4OiBudWxsLFxuICAgIHRyYW5zZm9ybTogbWVhbmluZ2xlc3NUcmFuc2Zvcm0sXG4gICAgc3ltYm9sOiBmYWxzZSxcbiAgICBtYXNrOiBudWxsLFxuICAgIGV4dHJhOiB7XG4gICAgICBjbGFzc2VzOiBbXSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlTWV0YShub2RlKSB7XG4gIHZhciBfY2xhc3NQYXJzZXIgPSBjbGFzc1BhcnNlcihub2RlKSxcbiAgICAgIGljb25OYW1lID0gX2NsYXNzUGFyc2VyLmljb25OYW1lLFxuICAgICAgcHJlZml4ID0gX2NsYXNzUGFyc2VyLnByZWZpeCxcbiAgICAgIGV4dHJhQ2xhc3NlcyA9IF9jbGFzc1BhcnNlci5yZXN0O1xuXG4gIHZhciBleHRyYVN0eWxlcyA9IHN0eWxlUGFyc2VyKG5vZGUpO1xuICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3JtUGFyc2VyKG5vZGUpO1xuICB2YXIgc3ltYm9sID0gc3ltYm9sUGFyc2VyKG5vZGUpO1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVzID0gYXR0cmlidXRlc1BhcnNlcihub2RlKTtcbiAgdmFyIG1hc2sgPSBtYXNrUGFyc2VyKG5vZGUpO1xuICByZXR1cm4ge1xuICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICB0aXRsZTogbm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyksXG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgbWFzazogbWFzayxcbiAgICBleHRyYToge1xuICAgICAgY2xhc3NlczogZXh0cmFDbGFzc2VzLFxuICAgICAgc3R5bGVzOiBleHRyYVN0eWxlcyxcbiAgICAgIGF0dHJpYnV0ZXM6IGV4dHJhQXR0cmlidXRlc1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gTWlzc2luZ0ljb24oZXJyb3IpIHtcbiAgdGhpcy5uYW1lID0gJ01pc3NpbmdJY29uJztcbiAgdGhpcy5tZXNzYWdlID0gZXJyb3IgfHwgJ0ljb24gdW5hdmFpbGFibGUnO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG59XG5NaXNzaW5nSWNvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5NaXNzaW5nSWNvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNaXNzaW5nSWNvbjtcblxudmFyIEZJTEwgPSB7XG4gIGZpbGw6ICdjdXJyZW50Q29sb3InXG59O1xudmFyIEFOSU1BVElPTl9CQVNFID0ge1xuICBhdHRyaWJ1dGVUeXBlOiAnWE1MJyxcbiAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJyxcbiAgZHVyOiAnMnMnXG59O1xudmFyIFJJTkcgPSB7XG4gIHRhZzogJ3BhdGgnLFxuICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBGSUxMLCB7XG4gICAgZDogJ00xNTYuNSw0NDcuN2wtMTIuNiwyOS41Yy0xOC43LTkuNS0zNS45LTIxLjItNTEuNS0zNC45bDIyLjctMjIuN0MxMjcuNiw0MzAuNSwxNDEuNSw0NDAsMTU2LjUsNDQ3Ljd6IE00MC42LDI3Mkg4LjUgYzEuNCwyMS4yLDUuNCw0MS43LDExLjcsNjEuMUw1MCwzMjEuMkM0NS4xLDMwNS41LDQxLjgsMjg5LDQwLjYsMjcyeiBNNDAuNiwyNDBjMS40LTE4LjgsNS4yLTM3LDExLjEtNTQuMWwtMjkuNS0xMi42IEMxNC43LDE5NC4zLDEwLDIxNi43LDguNSwyNDBINDAuNnogTTY0LjMsMTU2LjVjNy44LTE0LjksMTcuMi0yOC44LDI4LjEtNDEuNUw2OS43LDkyLjNjLTEzLjcsMTUuNi0yNS41LDMyLjgtMzQuOSw1MS41IEw2NC4zLDE1Ni41eiBNMzk3LDQxOS42Yy0xMy45LDEyLTI5LjQsMjIuMy00Ni4xLDMwLjRsMTEuOSwyOS44YzIwLjctOS45LDM5LjgtMjIuNiw1Ni45LTM3LjZMMzk3LDQxOS42eiBNMTE1LDkyLjQgYzEzLjktMTIsMjkuNC0yMi4zLDQ2LjEtMzAuNGwtMTEuOS0yOS44Yy0yMC43LDkuOS0zOS44LDIyLjYtNTYuOCwzNy42TDExNSw5Mi40eiBNNDQ3LjcsMzU1LjVjLTcuOCwxNC45LTE3LjIsMjguOC0yOC4xLDQxLjUgbDIyLjcsMjIuN2MxMy43LTE1LjYsMjUuNS0zMi45LDM0LjktNTEuNUw0NDcuNywzNTUuNXogTTQ3MS40LDI3MmMtMS40LDE4LjgtNS4yLDM3LTExLjEsNTQuMWwyOS41LDEyLjYgYzcuNS0yMS4xLDEyLjItNDMuNSwxMy42LTY2LjhINDcxLjR6IE0zMjEuMiw0NjJjLTE1LjcsNS0zMi4yLDguMi00OS4yLDkuNHYzMi4xYzIxLjItMS40LDQxLjctNS40LDYxLjEtMTEuN0wzMjEuMiw0NjJ6IE0yNDAsNDcxLjRjLTE4LjgtMS40LTM3LTUuMi01NC4xLTExLjFsLTEyLjYsMjkuNWMyMS4xLDcuNSw0My41LDEyLjIsNjYuOCwxMy42VjQ3MS40eiBNNDYyLDE5MC44YzUsMTUuNyw4LjIsMzIuMiw5LjQsNDkuMmgzMi4xIGMtMS40LTIxLjItNS40LTQxLjctMTEuNy02MS4xTDQ2MiwxOTAuOHogTTkyLjQsMzk3Yy0xMi0xMy45LTIyLjMtMjkuNC0zMC40LTQ2LjFsLTI5LjgsMTEuOWM5LjksMjAuNywyMi42LDM5LjgsMzcuNiw1Ni45IEw5Mi40LDM5N3ogTTI3Miw0MC42YzE4LjgsMS40LDM2LjksNS4yLDU0LjEsMTEuMWwxMi42LTI5LjVDMzE3LjcsMTQuNywyOTUuMywxMCwyNzIsOC41VjQwLjZ6IE0xOTAuOCw1MCBjMTUuNy01LDMyLjItOC4yLDQ5LjItOS40VjguNWMtMjEuMiwxLjQtNDEuNyw1LjQtNjEuMSwxMS43TDE5MC44LDUweiBNNDQyLjMsOTIuM0w0MTkuNiwxMTVjMTIsMTMuOSwyMi4zLDI5LjQsMzAuNSw0Ni4xIGwyOS44LTExLjlDNDcwLDEyOC41LDQ1Ny4zLDEwOS40LDQ0Mi4zLDkyLjN6IE0zOTcsOTIuNGwyMi43LTIyLjdjLTE1LjYtMTMuNy0zMi44LTI1LjUtNTEuNS0zNC45bC0xMi42LDI5LjUgQzM3MC40LDcyLjEsMzg0LjQsODEuNSwzOTcsOTIuNHonXG4gIH0pXG59O1xuXG52YXIgT1BBQ0lUWV9BTklNQVRFID0gX29iamVjdFNwcmVhZCh7fSwgQU5JTUFUSU9OX0JBU0UsIHtcbiAgYXR0cmlidXRlTmFtZTogJ29wYWNpdHknXG59KTtcblxudmFyIERPVCA9IHtcbiAgdGFnOiAnY2lyY2xlJyxcbiAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgRklMTCwge1xuICAgIGN4OiAnMjU2JyxcbiAgICBjeTogJzM2NCcsXG4gICAgcjogJzI4J1xuICB9KSxcbiAgY2hpbGRyZW46IFt7XG4gICAgdGFnOiAnYW5pbWF0ZScsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgQU5JTUFUSU9OX0JBU0UsIHtcbiAgICAgIGF0dHJpYnV0ZU5hbWU6ICdyJyxcbiAgICAgIHZhbHVlczogJzI4OzE0OzI4OzI4OzE0OzI4OydcbiAgICB9KVxuICB9LCB7XG4gICAgdGFnOiAnYW5pbWF0ZScsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgT1BBQ0lUWV9BTklNQVRFLCB7XG4gICAgICB2YWx1ZXM6ICcxOzA7MTsxOzA7MTsnXG4gICAgfSlcbiAgfV1cbn07XG52YXIgUVVFU1RJT04gPSB7XG4gIHRhZzogJ3BhdGgnLFxuICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBGSUxMLCB7XG4gICAgb3BhY2l0eTogJzEnLFxuICAgIGQ6ICdNMjYzLjcsMzEyaC0xNmMtNi42LDAtMTItNS40LTEyLTEyYzAtNzEsNzcuNC02My45LDc3LjQtMTA3LjhjMC0yMC0xNy44LTQwLjItNTcuNC00MC4yYy0yOS4xLDAtNDQuMyw5LjYtNTkuMiwyOC43IGMtMy45LDUtMTEuMSw2LTE2LjIsMi40bC0xMy4xLTkuMmMtNS42LTMuOS02LjktMTEuOC0yLjYtMTcuMmMyMS4yLTI3LjIsNDYuNC00NC43LDkxLjItNDQuN2M1Mi4zLDAsOTcuNCwyOS44LDk3LjQsODAuMiBjMCw2Ny42LTc3LjQsNjMuNS03Ny40LDEwNy44QzI3NS43LDMwNi42LDI3MC4zLDMxMiwyNjMuNywzMTJ6J1xuICB9KSxcbiAgY2hpbGRyZW46IFt7XG4gICAgdGFnOiAnYW5pbWF0ZScsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgT1BBQ0lUWV9BTklNQVRFLCB7XG4gICAgICB2YWx1ZXM6ICcxOzA7MDswOzA7MTsnXG4gICAgfSlcbiAgfV1cbn07XG52YXIgRVhDTEFNQVRJT04gPSB7XG4gIHRhZzogJ3BhdGgnLFxuICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkKHt9LCBGSUxMLCB7XG4gICAgb3BhY2l0eTogJzAnLFxuICAgIGQ6ICdNMjMyLjUsMTM0LjVsNywxNjhjMC4zLDYuNCw1LjYsMTEuNSwxMiwxMS41aDljNi40LDAsMTEuNy01LjEsMTItMTEuNWw3LTE2OGMwLjMtNi44LTUuMi0xMi41LTEyLTEyLjVoLTIzIEMyMzcuNywxMjIsMjMyLjIsMTI3LjcsMjMyLjUsMTM0LjV6J1xuICB9KSxcbiAgY2hpbGRyZW46IFt7XG4gICAgdGFnOiAnYW5pbWF0ZScsXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZCh7fSwgT1BBQ0lUWV9BTklNQVRFLCB7XG4gICAgICB2YWx1ZXM6ICcwOzA7MTsxOzA7MDsnXG4gICAgfSlcbiAgfV1cbn07XG52YXIgbWlzc2luZyA9IHtcbiAgdGFnOiAnZycsXG4gIGNoaWxkcmVuOiBbUklORywgRE9ULCBRVUVTVElPTiwgRVhDTEFNQVRJT05dXG59O1xuXG52YXIgc3R5bGVzJDIgPSBuYW1lc3BhY2Uuc3R5bGVzO1xuZnVuY3Rpb24gZmluZEljb24oaWNvbk5hbWUsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IHBpY2tlZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHZhbCA9IHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIHdpZHRoOiA1MTIsXG4gICAgICBoZWlnaHQ6IDUxMixcbiAgICAgIGljb246IG1pc3NpbmdcbiAgICB9O1xuXG4gICAgaWYgKGljb25OYW1lICYmIHByZWZpeCAmJiBzdHlsZXMkMltwcmVmaXhdICYmIHN0eWxlcyQyW3ByZWZpeF1baWNvbk5hbWVdKSB7XG4gICAgICB2YXIgaWNvbiA9IHN0eWxlcyQyW3ByZWZpeF1baWNvbk5hbWVdO1xuICAgICAgdmFyIHdpZHRoID0gaWNvblswXTtcbiAgICAgIHZhciBoZWlnaHQgPSBpY29uWzFdO1xuICAgICAgdmFyIHZlY3RvckRhdGEgPSBpY29uLnNsaWNlKDQpO1xuICAgICAgdmFsID0ge1xuICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgaWNvbjoge1xuICAgICAgICAgIHRhZzogJ3BhdGgnLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgICAgICAgZDogdmVjdG9yRGF0YVswXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXNvbHZlKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKGljb25OYW1lICYmIHByZWZpeCAmJiAhY29uZmlnLnNob3dNaXNzaW5nSWNvbnMpIHtcbiAgICAgIHJlamVjdChuZXcgTWlzc2luZ0ljb24oXCJJY29uIGlzIG1pc3NpbmcgZm9yIHByZWZpeCBcIi5jb25jYXQocHJlZml4LCBcIiB3aXRoIGljb24gbmFtZSBcIikuY29uY2F0KGljb25OYW1lKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHZhbCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHN0eWxlcyQzID0gbmFtZXNwYWNlLnN0eWxlcztcblxuZnVuY3Rpb24gZ2VuZXJhdGVTdmdSZXBsYWNlbWVudE11dGF0aW9uKG5vZGUsIG5vZGVNZXRhKSB7XG4gIHZhciBpY29uTmFtZSA9IG5vZGVNZXRhLmljb25OYW1lLFxuICAgICAgdGl0bGUgPSBub2RlTWV0YS50aXRsZSxcbiAgICAgIHByZWZpeCA9IG5vZGVNZXRhLnByZWZpeCxcbiAgICAgIHRyYW5zZm9ybSA9IG5vZGVNZXRhLnRyYW5zZm9ybSxcbiAgICAgIHN5bWJvbCA9IG5vZGVNZXRhLnN5bWJvbCxcbiAgICAgIG1hc2sgPSBub2RlTWV0YS5tYXNrLFxuICAgICAgZXh0cmEgPSBub2RlTWV0YS5leHRyYTtcbiAgcmV0dXJuIG5ldyBwaWNrZWQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHBpY2tlZC5hbGwoW2ZpbmRJY29uKGljb25OYW1lLCBwcmVmaXgpLCBmaW5kSWNvbihtYXNrLmljb25OYW1lLCBtYXNrLnByZWZpeCldKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICBtYWluID0gX3JlZjJbMF0sXG4gICAgICAgICAgbWFzayA9IF9yZWYyWzFdO1xuXG4gICAgICByZXNvbHZlKFtub2RlLCBtYWtlSW5saW5lU3ZnQWJzdHJhY3Qoe1xuICAgICAgICBpY29uczoge1xuICAgICAgICAgIG1haW46IG1haW4sXG4gICAgICAgICAgbWFzazogbWFza1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICAgIG1hc2s6IG1hc2ssXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZXh0cmE6IGV4dHJhLFxuICAgICAgICB3YXRjaGFibGU6IHRydWVcbiAgICAgIH0pXSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUxheWVyc1RleHQobm9kZSwgbm9kZU1ldGEpIHtcbiAgdmFyIHRpdGxlID0gbm9kZU1ldGEudGl0bGUsXG4gICAgICB0cmFuc2Zvcm0gPSBub2RlTWV0YS50cmFuc2Zvcm0sXG4gICAgICBleHRyYSA9IG5vZGVNZXRhLmV4dHJhO1xuICB2YXIgd2lkdGggPSBudWxsO1xuICB2YXIgaGVpZ2h0ID0gbnVsbDtcblxuICBpZiAoSVNfSUUpIHtcbiAgICB2YXIgY29tcHV0ZWRGb250U2l6ZSA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUobm9kZSkuZm9udFNpemUsIDEwKTtcbiAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB3aWR0aCA9IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCAvIGNvbXB1dGVkRm9udFNpemU7XG4gICAgaGVpZ2h0ID0gYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAvIGNvbXB1dGVkRm9udFNpemU7XG4gIH1cblxuICBpZiAoY29uZmlnLmF1dG9BMTF5ICYmICF0aXRsZSkge1xuICAgIGV4dHJhLmF0dHJpYnV0ZXNbJ2FyaWEtaGlkZGVuJ10gPSAndHJ1ZSc7XG4gIH1cblxuICByZXR1cm4gcGlja2VkLnJlc29sdmUoW25vZGUsIG1ha2VMYXllcnNUZXh0QWJzdHJhY3Qoe1xuICAgIGNvbnRlbnQ6IG5vZGUuaW5uZXJIVE1MLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICB0aXRsZTogdGl0bGUsXG4gICAgZXh0cmE6IGV4dHJhLFxuICAgIHdhdGNoYWJsZTogdHJ1ZVxuICB9KV0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU11dGF0aW9uKG5vZGUpIHtcbiAgdmFyIG5vZGVNZXRhID0gcGFyc2VNZXRhKG5vZGUpO1xuXG4gIGlmICh+bm9kZU1ldGEuZXh0cmEuY2xhc3Nlcy5pbmRleE9mKExBWUVSU19URVhUX0NMQVNTTkFNRSkpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVMYXllcnNUZXh0KG5vZGUsIG5vZGVNZXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVTdmdSZXBsYWNlbWVudE11dGF0aW9uKG5vZGUsIG5vZGVNZXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblRyZWUocm9vdCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGlmICghSVNfRE9NKSByZXR1cm47XG4gIHZhciBodG1sQ2xhc3NMaXN0ID0gRE9DVU1FTlQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdDtcblxuICB2YXIgaGNsQWRkID0gZnVuY3Rpb24gaGNsQWRkKHN1ZmZpeCkge1xuICAgIHJldHVybiBodG1sQ2xhc3NMaXN0LmFkZChcIlwiLmNvbmNhdChIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MsIFwiLVwiKS5jb25jYXQoc3VmZml4KSk7XG4gIH07XG5cbiAgdmFyIGhjbFJlbW92ZSA9IGZ1bmN0aW9uIGhjbFJlbW92ZShzdWZmaXgpIHtcbiAgICByZXR1cm4gaHRtbENsYXNzTGlzdC5yZW1vdmUoXCJcIi5jb25jYXQoSFRNTF9DTEFTU19JMlNWR19CQVNFX0NMQVNTLCBcIi1cIikuY29uY2F0KHN1ZmZpeCkpO1xuICB9O1xuXG4gIHZhciBwcmVmaXhlcyA9IGNvbmZpZy5hdXRvRmV0Y2hTdmcgPyBPYmplY3Qua2V5cyhQUkVGSVhfVE9fU1RZTEUpIDogT2JqZWN0LmtleXMoc3R5bGVzJDMpO1xuICB2YXIgcHJlZml4ZXNEb21RdWVyeSA9IFtcIi5cIi5jb25jYXQoTEFZRVJTX1RFWFRfQ0xBU1NOQU1FLCBcIjpub3QoW1wiKS5jb25jYXQoREFUQV9GQV9JMlNWRywgXCJdKVwiKV0uY29uY2F0KHByZWZpeGVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBcIi5cIi5jb25jYXQocCwgXCI6bm90KFtcIikuY29uY2F0KERBVEFfRkFfSTJTVkcsIFwiXSlcIik7XG4gIH0pKS5qb2luKCcsICcpO1xuXG4gIGlmIChwcmVmaXhlc0RvbVF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gW107XG5cbiAgdHJ5IHtcbiAgICBjYW5kaWRhdGVzID0gdG9BcnJheShyb290LnF1ZXJ5U2VsZWN0b3JBbGwocHJlZml4ZXNEb21RdWVyeSkpO1xuICB9IGNhdGNoIChlKSB7Ly8gbm9vcFxuICB9XG5cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgIGhjbEFkZCgncGVuZGluZycpO1xuICAgIGhjbFJlbW92ZSgnY29tcGxldGUnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFyayA9IHBlcmYuYmVnaW4oJ29uVHJlZScpO1xuICB2YXIgbXV0YXRpb25zID0gY2FuZGlkYXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgbXV0YXRpb24gPSBnZW5lcmF0ZU11dGF0aW9uKG5vZGUpO1xuXG4gICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgYWNjLnB1c2gobXV0YXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghUFJPRFVDVElPTikge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE1pc3NpbmdJY29uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG5ldyBwaWNrZWQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHBpY2tlZC5hbGwobXV0YXRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZE11dGF0aW9ucykge1xuICAgICAgcGVyZm9ybShyZXNvbHZlZE11dGF0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICBoY2xBZGQoJ2FjdGl2ZScpO1xuICAgICAgICBoY2xBZGQoJ2NvbXBsZXRlJyk7XG4gICAgICAgIGhjbFJlbW92ZSgncGVuZGluZycpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICBtYXJrKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hcmsoKTtcbiAgICAgIHJlamVjdCgpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9uTm9kZShub2RlKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgZ2VuZXJhdGVNdXRhdGlvbihub2RlKS50aGVuKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgcGVyZm9ybShbbXV0YXRpb25dLCBjYWxsYmFjayk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUZvclBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gIHZhciBwZW5kaW5nQXR0cmlidXRlID0gXCJcIi5jb25jYXQoREFUQV9GQV9QU0VVRE9fRUxFTUVOVF9QRU5ESU5HKS5jb25jYXQocG9zaXRpb24ucmVwbGFjZSgnOicsICctJykpO1xuICByZXR1cm4gbmV3IHBpY2tlZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKHBlbmRpbmdBdHRyaWJ1dGUpICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIG5vZGUgaXMgYWxyZWFkeSBiZWluZyBwcm9jZXNzZWRcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdG9BcnJheShub2RlLmNoaWxkcmVuKTtcbiAgICB2YXIgYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQgPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmdldEF0dHJpYnV0ZShEQVRBX0ZBX1BTRVVET19FTEVNRU5UKSA9PT0gcG9zaXRpb247XG4gICAgfSlbMF07XG4gICAgdmFyIHN0eWxlcyA9IFdJTkRPVy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIHBvc2l0aW9uKTtcbiAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LWZhbWlseScpLm1hdGNoKEZPTlRfRkFNSUxZX1BBVFRFUk4pO1xuICAgIHZhciBmb250V2VpZ2h0ID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtd2VpZ2h0Jyk7XG5cbiAgICBpZiAoYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQgJiYgIWZvbnRGYW1pbHkpIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIGl0IGJ1dCB0aGUgY3VycmVudCBjb21wdXRlZCBzdHlsZSBkb2VzIG5vdCByZXN1bHQgaW4gYSBmb250LWZhbWlseSxcbiAgICAgIC8vIHRoYXQgcHJvYmFibHkgbWVhbnMgdGhhdCBhIGNsYXNzIG5hbWUgdGhhdCB3YXMgcHJldmlvdXNseSBwcmVzZW50IHRvIG1ha2UgdGhlIGljb24gaGFzIGJlZW5cbiAgICAgIC8vIHJlbW92ZWQuIFNvIHdlIG5vdyBzaG91bGQgZGVsZXRlIHRoZSBpY29uLlxuICAgICAgbm9kZS5yZW1vdmVDaGlsZChhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudCk7XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoZm9udEZhbWlseSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnY29udGVudCcpO1xuICAgICAgdmFyIHByZWZpeCA9IH5bJ0xpZ2h0JywgJ1JlZ3VsYXInLCAnU29saWQnLCAnQnJhbmRzJ10uaW5kZXhPZihmb250RmFtaWx5WzFdKSA/IFNUWUxFX1RPX1BSRUZJWFtmb250RmFtaWx5WzFdLnRvTG93ZXJDYXNlKCldIDogRk9OVF9XRUlHSFRfVE9fUFJFRklYW2ZvbnRXZWlnaHRdO1xuICAgICAgdmFyIGhleFZhbHVlID0gdG9IZXgoY29udGVudC5sZW5ndGggPT09IDMgPyBjb250ZW50LnN1YnN0cigxLCAxKSA6IGNvbnRlbnQpO1xuICAgICAgdmFyIGljb25OYW1lID0gYnlVbmljb2RlKHByZWZpeCwgaGV4VmFsdWUpO1xuICAgICAgdmFyIGljb25JZGVudGlmaWVyID0gaWNvbk5hbWU7IC8vIE9ubHkgY29udmVydCB0aGUgcHNldWRvIGVsZW1lbnQgaW4gdGhpcyA6YmVmb3JlLzphZnRlciBwb3NpdGlvbiBpbnRvIGFuIGljb24gaWYgd2UgaGF2ZW4ndFxuICAgICAgLy8gYWxyZWFkeSBkb25lIHNvIHdpdGggdGhlIHNhbWUgcHJlZml4IGFuZCBpY29uTmFtZVxuXG4gICAgICBpZiAoaWNvbk5hbWUgJiYgKCFhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudCB8fCBhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoREFUQV9QUkVGSVgpICE9PSBwcmVmaXggfHwgYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQuZ2V0QXR0cmlidXRlKERBVEFfSUNPTikgIT09IGljb25JZGVudGlmaWVyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShwZW5kaW5nQXR0cmlidXRlLCBpY29uSWRlbnRpZmllcik7XG5cbiAgICAgICAgaWYgKGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50KSB7XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvbGQgb25lLCBzaW5jZSB3ZSdyZSByZXBsYWNpbmcgaXQgd2l0aCBhIG5ldyBvbmVcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRhID0gYmxhbmtNZXRhKCk7XG4gICAgICAgIHZhciBleHRyYSA9IG1ldGEuZXh0cmE7XG4gICAgICAgIGV4dHJhLmF0dHJpYnV0ZXNbREFUQV9GQV9QU0VVRE9fRUxFTUVOVF0gPSBwb3NpdGlvbjtcbiAgICAgICAgZmluZEljb24oaWNvbk5hbWUsIHByZWZpeCkudGhlbihmdW5jdGlvbiAobWFpbikge1xuICAgICAgICAgIHZhciBhYnN0cmFjdCA9IG1ha2VJbmxpbmVTdmdBYnN0cmFjdChfb2JqZWN0U3ByZWFkKHt9LCBtZXRhLCB7XG4gICAgICAgICAgICBpY29uczoge1xuICAgICAgICAgICAgICBtYWluOiBtYWluLFxuICAgICAgICAgICAgICBtYXNrOiBlbXB0eUNhbm9uaWNhbEljb24oKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgaWNvbk5hbWU6IGljb25JZGVudGlmaWVyLFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxuICAgICAgICAgICAgd2F0Y2hhYmxlOiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gRE9DVU1FTlQuY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG5cbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICc6YmVmb3JlJykge1xuICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50Lm91dGVySFRNTCA9IGFic3RyYWN0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvSHRtbChhKTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwZW5kaW5nQXR0cmlidXRlKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcbiAgcmV0dXJuIHBpY2tlZC5hbGwoW3JlcGxhY2VGb3JQb3NpdGlvbihub2RlLCAnOmJlZm9yZScpLCByZXBsYWNlRm9yUG9zaXRpb24obm9kZSwgJzphZnRlcicpXSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NhYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuaGVhZCAmJiAhflRBR05BTUVTX1RPX1NLSVBfRk9SX1BTRVVET0VMRU1FTlRTLmluZGV4T2Yobm9kZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkpICYmICFub2RlLmdldEF0dHJpYnV0ZShEQVRBX0ZBX1BTRVVET19FTEVNRU5UKSAmJiAoIW5vZGUucGFyZW50Tm9kZSB8fCBub2RlLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ3N2ZycpO1xufVxuXG5mdW5jdGlvbiBzZWFyY2hQc2V1ZG9FbGVtZW50cyAocm9vdCkge1xuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICByZXR1cm4gbmV3IHBpY2tlZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSB0b0FycmF5KHJvb3QucXVlcnlTZWxlY3RvckFsbCgnKicpKS5maWx0ZXIocHJvY2Vzc2FibGUpLm1hcChyZXBsYWNlKTtcbiAgICB2YXIgZW5kID0gcGVyZi5iZWdpbignc2VhcmNoUHNldWRvRWxlbWVudHMnKTtcbiAgICBkaXNhYmxlT2JzZXJ2YXRpb24oKTtcbiAgICBwaWNrZWQuYWxsKG9wZXJhdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgZW5kKCk7XG4gICAgICBlbmFibGVPYnNlcnZhdGlvbigpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVuZCgpO1xuICAgICAgZW5hYmxlT2JzZXJ2YXRpb24oKTtcbiAgICAgIHJlamVjdCgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxudmFyIGJhc2VTdHlsZXMgPSBcInN2Zzpub3QoOnJvb3QpLnN2Zy1pbmxpbmUtLWZhIHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbn1cXG5cXG4uc3ZnLWlubGluZS0tZmEge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgaGVpZ2h0OiAxZW07XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIHZlcnRpY2FsLWFsaWduOiAtMC4xMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLWxnIHtcXG4gIHZlcnRpY2FsLWFsaWduOiAtMC4yMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMSB7XFxuICB3aWR0aDogMC4wNjI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTIge1xcbiAgd2lkdGg6IDAuMTI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTMge1xcbiAgd2lkdGg6IDAuMTg3NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy00IHtcXG4gIHdpZHRoOiAwLjI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTUge1xcbiAgd2lkdGg6IDAuMzEyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy02IHtcXG4gIHdpZHRoOiAwLjM3NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy03IHtcXG4gIHdpZHRoOiAwLjQzNzVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctOCB7XFxuICB3aWR0aDogMC41ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTkge1xcbiAgd2lkdGg6IDAuNTYyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xMCB7XFxuICB3aWR0aDogMC42MjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTEge1xcbiAgd2lkdGg6IDAuNjg3NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xMiB7XFxuICB3aWR0aDogMC43NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xMyB7XFxuICB3aWR0aDogMC44MTI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTE0IHtcXG4gIHdpZHRoOiAwLjg3NWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtdy0xNSB7XFxuICB3aWR0aDogMC45Mzc1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTE2IHtcXG4gIHdpZHRoOiAxZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTE3IHtcXG4gIHdpZHRoOiAxLjA2MjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTgge1xcbiAgd2lkdGg6IDEuMTI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS13LTE5IHtcXG4gIHdpZHRoOiAxLjE4NzVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXctMjAge1xcbiAgd2lkdGg6IDEuMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXB1bGwtbGVmdCB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuM2VtO1xcbiAgd2lkdGg6IGF1dG87XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS1wdWxsLXJpZ2h0IHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjNlbTtcXG4gIHdpZHRoOiBhdXRvO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtYm9yZGVyIHtcXG4gIGhlaWdodDogMS41ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS1saSB7XFxuICB3aWR0aDogMmVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtZncge1xcbiAgd2lkdGg6IDEuMjVlbTtcXG59XFxuXFxuLmZhLWxheWVycyBzdmcuc3ZnLWlubGluZS0tZmEge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIG1hcmdpbjogYXV0bztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbn1cXG5cXG4uZmEtbGF5ZXJzIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGhlaWdodDogMWVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjEyNWVtO1xcbiAgd2lkdGg6IDFlbTtcXG59XFxuLmZhLWxheWVycyBzdmcuc3ZnLWlubGluZS0tZmEge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbn1cXG5cXG4uZmEtbGF5ZXJzLWNvdW50ZXIsIC5mYS1sYXllcnMtdGV4dCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5mYS1sYXllcnMtdGV4dCB7XFxuICBsZWZ0OiA1MCU7XFxuICB0b3A6IDUwJTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbn1cXG5cXG4uZmEtbGF5ZXJzLWNvdW50ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmMjUzYTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgaGVpZ2h0OiAxLjVlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgbWF4LXdpZHRoOiA1ZW07XFxuICBtaW4td2lkdGg6IDEuNWVtO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBhZGRpbmc6IDAuMjVlbTtcXG4gIHJpZ2h0OiAwO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB0b3A6IDA7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IHRvcCByaWdodDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIHJpZ2h0O1xcbn1cXG5cXG4uZmEtbGF5ZXJzLWJvdHRvbS1yaWdodCB7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMDtcXG4gIHRvcDogYXV0bztcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjI1KTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjI1KTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIHJpZ2h0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gcmlnaHQ7XFxufVxcblxcbi5mYS1sYXllcnMtYm90dG9tLWxlZnQge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiBhdXRvO1xcbiAgdG9wOiBhdXRvO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gbGVmdDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIGxlZnQ7XFxufVxcblxcbi5mYS1sYXllcnMtdG9wLXJpZ2h0IHtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiB0b3AgcmlnaHQ7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCByaWdodDtcXG59XFxuXFxuLmZhLWxheWVycy10b3AtbGVmdCB7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IGF1dG87XFxuICB0b3A6IDA7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcXG59XFxuXFxuLmZhLWxnIHtcXG4gIGZvbnQtc2l6ZTogMS4zMzMzMzMzMzMzZW07XFxuICBsaW5lLWhlaWdodDogMC43NWVtO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjA2NjdlbTtcXG59XFxuXFxuLmZhLXhzIHtcXG4gIGZvbnQtc2l6ZTogMC43NWVtO1xcbn1cXG5cXG4uZmEtc20ge1xcbiAgZm9udC1zaXplOiAwLjg3NWVtO1xcbn1cXG5cXG4uZmEtMXgge1xcbiAgZm9udC1zaXplOiAxZW07XFxufVxcblxcbi5mYS0yeCB7XFxuICBmb250LXNpemU6IDJlbTtcXG59XFxuXFxuLmZhLTN4IHtcXG4gIGZvbnQtc2l6ZTogM2VtO1xcbn1cXG5cXG4uZmEtNHgge1xcbiAgZm9udC1zaXplOiA0ZW07XFxufVxcblxcbi5mYS01eCB7XFxuICBmb250LXNpemU6IDVlbTtcXG59XFxuXFxuLmZhLTZ4IHtcXG4gIGZvbnQtc2l6ZTogNmVtO1xcbn1cXG5cXG4uZmEtN3gge1xcbiAgZm9udC1zaXplOiA3ZW07XFxufVxcblxcbi5mYS04eCB7XFxuICBmb250LXNpemU6IDhlbTtcXG59XFxuXFxuLmZhLTl4IHtcXG4gIGZvbnQtc2l6ZTogOWVtO1xcbn1cXG5cXG4uZmEtMTB4IHtcXG4gIGZvbnQtc2l6ZTogMTBlbTtcXG59XFxuXFxuLmZhLWZ3IHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHdpZHRoOiAxLjI1ZW07XFxufVxcblxcbi5mYS11bCB7XFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBtYXJnaW4tbGVmdDogMi41ZW07XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxufVxcbi5mYS11bCA+IGxpIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLmZhLWxpIHtcXG4gIGxlZnQ6IC0yZW07XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB3aWR0aDogMmVtO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxufVxcblxcbi5mYS1ib3JkZXIge1xcbiAgYm9yZGVyOiBzb2xpZCAwLjA4ZW0gI2VlZTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMWVtO1xcbiAgcGFkZGluZzogMC4yZW0gMC4yNWVtIDAuMTVlbTtcXG59XFxuXFxuLmZhLXB1bGwtbGVmdCB7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuXFxuLmZhLXB1bGwtcmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5cXG4uZmEuZmEtcHVsbC1sZWZ0LFxcbi5mYXMuZmEtcHVsbC1sZWZ0LFxcbi5mYXIuZmEtcHVsbC1sZWZ0LFxcbi5mYWwuZmEtcHVsbC1sZWZ0LFxcbi5mYWIuZmEtcHVsbC1sZWZ0IHtcXG4gIG1hcmdpbi1yaWdodDogMC4zZW07XFxufVxcbi5mYS5mYS1wdWxsLXJpZ2h0LFxcbi5mYXMuZmEtcHVsbC1yaWdodCxcXG4uZmFyLmZhLXB1bGwtcmlnaHQsXFxuLmZhbC5mYS1wdWxsLXJpZ2h0LFxcbi5mYWIuZmEtcHVsbC1yaWdodCB7XFxuICBtYXJnaW4tbGVmdDogMC4zZW07XFxufVxcblxcbi5mYS1zcGluIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBmYS1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtcXG4gICAgICAgICAgYW5pbWF0aW9uOiBmYS1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtcXG59XFxuXFxuLmZhLXB1bHNlIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBmYS1zcGluIDFzIGluZmluaXRlIHN0ZXBzKDgpO1xcbiAgICAgICAgICBhbmltYXRpb246IGZhLXNwaW4gMXMgaW5maW5pdGUgc3RlcHMoOCk7XFxufVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBmYS1zcGluIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBmYS1zcGluIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuLmZhLXJvdGF0ZS05MCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MSlcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG59XFxuXFxuLmZhLXJvdGF0ZS0xODAge1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG59XFxuXFxuLmZhLXJvdGF0ZS0yNzAge1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTMpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG59XFxuXFxuLmZhLWZsaXAtaG9yaXpvbnRhbCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MCwgbWlycm9yPTEpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xcbn1cXG5cXG4uZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MiwgbWlycm9yPTEpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpO1xcbn1cXG5cXG4uZmEtZmxpcC1ib3RoLCAuZmEtZmxpcC1ob3Jpem9udGFsLmZhLWZsaXAtdmVydGljYWwge1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIsIG1pcnJvcj0xKVxcXCI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoLTEsIC0xKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgLTEpO1xcbn1cXG5cXG46cm9vdCAuZmEtcm90YXRlLTkwLFxcbjpyb290IC5mYS1yb3RhdGUtMTgwLFxcbjpyb290IC5mYS1yb3RhdGUtMjcwLFxcbjpyb290IC5mYS1mbGlwLWhvcml6b250YWwsXFxuOnJvb3QgLmZhLWZsaXAtdmVydGljYWwsXFxuOnJvb3QgLmZhLWZsaXAtYm90aCB7XFxuICAtd2Via2l0LWZpbHRlcjogbm9uZTtcXG4gICAgICAgICAgZmlsdGVyOiBub25lO1xcbn1cXG5cXG4uZmEtc3RhY2sge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAyZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMi41ZW07XFxufVxcblxcbi5mYS1zdGFjay0xeCxcXG4uZmEtc3RhY2stMngge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIG1hcmdpbjogYXV0bztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbn1cXG5cXG4uc3ZnLWlubGluZS0tZmEuZmEtc3RhY2stMXgge1xcbiAgaGVpZ2h0OiAxZW07XFxuICB3aWR0aDogMS4yNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtc3RhY2stMngge1xcbiAgaGVpZ2h0OiAyZW07XFxuICB3aWR0aDogMi41ZW07XFxufVxcblxcbi5mYS1pbnZlcnNlIHtcXG4gIGNvbG9yOiAjZmZmO1xcbn1cXG5cXG4uc3Itb25seSB7XFxuICBib3JkZXI6IDA7XFxuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApO1xcbiAgaGVpZ2h0OiAxcHg7XFxuICBtYXJnaW46IC0xcHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgcGFkZGluZzogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxcHg7XFxufVxcblxcbi5zci1vbmx5LWZvY3VzYWJsZTphY3RpdmUsIC5zci1vbmx5LWZvY3VzYWJsZTpmb2N1cyB7XFxuICBjbGlwOiBhdXRvO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgbWFyZ2luOiAwO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICBwb3NpdGlvbjogc3RhdGljO1xcbiAgd2lkdGg6IGF1dG87XFxufVwiO1xuXG5mdW5jdGlvbiBjc3MgKCkge1xuICB2YXIgZGZwID0gREVGQVVMVF9GQU1JTFlfUFJFRklYO1xuICB2YXIgZHJjID0gREVGQVVMVF9SRVBMQUNFTUVOVF9DTEFTUztcbiAgdmFyIGZwID0gY29uZmlnLmZhbWlseVByZWZpeDtcbiAgdmFyIHJjID0gY29uZmlnLnJlcGxhY2VtZW50Q2xhc3M7XG4gIHZhciBzID0gYmFzZVN0eWxlcztcblxuICBpZiAoZnAgIT09IGRmcCB8fCByYyAhPT0gZHJjKSB7XG4gICAgdmFyIGRQYXR0ID0gbmV3IFJlZ0V4cChcIlxcXFwuXCIuY29uY2F0KGRmcCwgXCJcXFxcLVwiKSwgJ2cnKTtcbiAgICB2YXIgclBhdHQgPSBuZXcgUmVnRXhwKFwiXFxcXC5cIi5jb25jYXQoZHJjKSwgJ2cnKTtcbiAgICBzID0gcy5yZXBsYWNlKGRQYXR0LCBcIi5cIi5jb25jYXQoZnAsIFwiLVwiKSkucmVwbGFjZShyUGF0dCwgXCIuXCIuY29uY2F0KHJjKSk7XG4gIH1cblxuICByZXR1cm4gcztcbn1cblxudmFyIExpYnJhcnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaWJyYXJ5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaWJyYXJ5KTtcblxuICAgIHRoaXMuZGVmaW5pdGlvbnMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaWJyYXJ5LCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRlZmluaXRpb25zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBkZWZpbml0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFkZGl0aW9ucyA9IGRlZmluaXRpb25zLnJlZHVjZSh0aGlzLl9wdWxsRGVmaW5pdGlvbnMsIHt9KTtcbiAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF90aGlzLmRlZmluaXRpb25zW2tleV0gPSBfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5kZWZpbml0aW9uc1trZXldIHx8IHt9LCBhZGRpdGlvbnNba2V5XSk7XG4gICAgICAgIGRlZmluZUljb25zKGtleSwgYWRkaXRpb25zW2tleV0pO1xuICAgICAgICBidWlsZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHVsbERlZmluaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wdWxsRGVmaW5pdGlvbnMoYWRkaXRpb25zLCBkZWZpbml0aW9uKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZCA9IGRlZmluaXRpb24ucHJlZml4ICYmIGRlZmluaXRpb24uaWNvbk5hbWUgJiYgZGVmaW5pdGlvbi5pY29uID8ge1xuICAgICAgICAwOiBkZWZpbml0aW9uXG4gICAgICB9IDogZGVmaW5pdGlvbjtcbiAgICAgIE9iamVjdC5rZXlzKG5vcm1hbGl6ZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfbm9ybWFsaXplZCRrZXkgPSBub3JtYWxpemVkW2tleV0sXG4gICAgICAgICAgICBwcmVmaXggPSBfbm9ybWFsaXplZCRrZXkucHJlZml4LFxuICAgICAgICAgICAgaWNvbk5hbWUgPSBfbm9ybWFsaXplZCRrZXkuaWNvbk5hbWUsXG4gICAgICAgICAgICBpY29uID0gX25vcm1hbGl6ZWQka2V5Lmljb247XG4gICAgICAgIGlmICghYWRkaXRpb25zW3ByZWZpeF0pIGFkZGl0aW9uc1twcmVmaXhdID0ge307XG4gICAgICAgIGFkZGl0aW9uc1twcmVmaXhdW2ljb25OYW1lXSA9IGljb247XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZGRpdGlvbnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpYnJhcnk7XG59KCk7XG5cbmZ1bmN0aW9uIHByZXBJY29uKGljb24pIHtcbiAgdmFyIHdpZHRoID0gaWNvblswXTtcbiAgdmFyIGhlaWdodCA9IGljb25bMV07XG4gIHZhciB2ZWN0b3JEYXRhID0gaWNvbi5zbGljZSg0KTtcbiAgcmV0dXJuIHtcbiAgICBmb3VuZDogdHJ1ZSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgaWNvbjoge1xuICAgICAgdGFnOiAncGF0aCcsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgICBkOiB2ZWN0b3JEYXRhWzBdXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVDc3MoKSB7XG4gIGlmIChjb25maWcuYXV0b0FkZENzcyAmJiAhX2Nzc0luc2VydGVkKSB7XG4gICAgaW5zZXJ0Q3NzKGNzcygpKTtcblxuICAgIF9jc3NJbnNlcnRlZCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBpT2JqZWN0KHZhbCwgYWJzdHJhY3RDcmVhdG9yKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWwsICdhYnN0cmFjdCcsIHtcbiAgICBnZXQ6IGFic3RyYWN0Q3JlYXRvclxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ2h0bWwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsLmFic3RyYWN0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdG9IdG1sKGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ25vZGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IHZhbC5odG1sO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBmaW5kSWNvbkRlZmluaXRpb24oaWNvbkxvb2t1cCkge1xuICB2YXIgX2ljb25Mb29rdXAkcHJlZml4ID0gaWNvbkxvb2t1cC5wcmVmaXgsXG4gICAgICBwcmVmaXggPSBfaWNvbkxvb2t1cCRwcmVmaXggPT09IHZvaWQgMCA/ICdmYScgOiBfaWNvbkxvb2t1cCRwcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IGljb25Mb29rdXAuaWNvbk5hbWU7XG4gIGlmICghaWNvbk5hbWUpIHJldHVybjtcbiAgcmV0dXJuIGljb25Gcm9tTWFwcGluZyhsaWJyYXJ5LmRlZmluaXRpb25zLCBwcmVmaXgsIGljb25OYW1lKSB8fCBpY29uRnJvbU1hcHBpbmcobmFtZXNwYWNlLnN0eWxlcywgcHJlZml4LCBpY29uTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJY29ucyhuZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF5YmVJY29uRGVmaW5pdGlvbikge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBpY29uRGVmaW5pdGlvbiA9IChtYXliZUljb25EZWZpbml0aW9uIHx8IHt9KS5pY29uID8gbWF5YmVJY29uRGVmaW5pdGlvbiA6IGZpbmRJY29uRGVmaW5pdGlvbihtYXliZUljb25EZWZpbml0aW9uIHx8IHt9KTtcbiAgICB2YXIgbWFzayA9IHBhcmFtcy5tYXNrO1xuXG4gICAgaWYgKG1hc2spIHtcbiAgICAgIG1hc2sgPSAobWFzayB8fCB7fSkuaWNvbiA/IG1hc2sgOiBmaW5kSWNvbkRlZmluaXRpb24obWFzayB8fCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQoaWNvbkRlZmluaXRpb24sIF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcywge1xuICAgICAgbWFzazogbWFza1xuICAgIH0pKTtcbiAgfTtcbn1cblxudmFyIGxpYnJhcnkgPSBuZXcgTGlicmFyeSgpO1xudmFyIG5vQXV0byA9IGZ1bmN0aW9uIG5vQXV0bygpIHtcbiAgY29uZmlnLmF1dG9SZXBsYWNlU3ZnID0gZmFsc2U7XG4gIGNvbmZpZy5vYnNlcnZlTXV0YXRpb25zID0gZmFsc2U7XG4gIGRpc2Nvbm5lY3QoKTtcbn07XG52YXIgX2Nzc0luc2VydGVkID0gZmFsc2U7XG52YXIgZG9tID0ge1xuICBpMnN2ZzogZnVuY3Rpb24gaTJzdmcoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoSVNfRE9NKSB7XG4gICAgICBlbnN1cmVDc3MoKTtcbiAgICAgIHZhciBfcGFyYW1zJG5vZGUgPSBwYXJhbXMubm9kZSxcbiAgICAgICAgICBub2RlID0gX3BhcmFtcyRub2RlID09PSB2b2lkIDAgPyBET0NVTUVOVCA6IF9wYXJhbXMkbm9kZSxcbiAgICAgICAgICBfcGFyYW1zJGNhbGxiYWNrID0gcGFyYW1zLmNhbGxiYWNrLFxuICAgICAgICAgIGNhbGxiYWNrID0gX3BhcmFtcyRjYWxsYmFjayA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcGFyYW1zJGNhbGxiYWNrO1xuXG4gICAgICBpZiAoY29uZmlnLnNlYXJjaFBzZXVkb0VsZW1lbnRzKSB7XG4gICAgICAgIHNlYXJjaFBzZXVkb0VsZW1lbnRzKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb25UcmVlKG5vZGUsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBpY2tlZC5yZWplY3QoJ09wZXJhdGlvbiByZXF1aXJlcyBhIERPTSBvZiBzb21lIGtpbmQuJyk7XG4gICAgfVxuICB9LFxuICBjc3M6IGNzcyxcbiAgaW5zZXJ0Q3NzOiBmdW5jdGlvbiBpbnNlcnRDc3MkJDEoKSB7XG4gICAgaWYgKCFfY3NzSW5zZXJ0ZWQpIHtcbiAgICAgIGluc2VydENzcyhjc3MoKSk7XG5cbiAgICAgIF9jc3NJbnNlcnRlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuICB3YXRjaDogZnVuY3Rpb24gd2F0Y2goKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGF1dG9SZXBsYWNlU3ZnUm9vdCA9IHBhcmFtcy5hdXRvUmVwbGFjZVN2Z1Jvb3QsXG4gICAgICAgIG9ic2VydmVNdXRhdGlvbnNSb290ID0gcGFyYW1zLm9ic2VydmVNdXRhdGlvbnNSb290O1xuXG4gICAgaWYgKGNvbmZpZy5hdXRvUmVwbGFjZVN2ZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbmZpZy5hdXRvUmVwbGFjZVN2ZyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uZmlnLm9ic2VydmVNdXRhdGlvbnMgPSB0cnVlO1xuICAgIGRvbXJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGF1dG9SZXBsYWNlKHtcbiAgICAgICAgYXV0b1JlcGxhY2VTdmdSb290OiBhdXRvUmVwbGFjZVN2Z1Jvb3RcbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZSh7XG4gICAgICAgIHRyZWVDYWxsYmFjazogb25UcmVlLFxuICAgICAgICBub2RlQ2FsbGJhY2s6IG9uTm9kZSxcbiAgICAgICAgcHNldWRvRWxlbWVudHNDYWxsYmFjazogc2VhcmNoUHNldWRvRWxlbWVudHMsXG4gICAgICAgIG9ic2VydmVNdXRhdGlvbnNSb290OiBvYnNlcnZlTXV0YXRpb25zUm9vdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgcGFyc2UgPSB7XG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xuICAgIHJldHVybiBwYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1TdHJpbmcpO1xuICB9XG59O1xudmFyIGljb24gPSByZXNvbHZlSWNvbnMoZnVuY3Rpb24gKGljb25EZWZpbml0aW9uKSB7XG4gIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgX3BhcmFtcyR0cmFuc2Zvcm0gPSBwYXJhbXMudHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtID0gX3BhcmFtcyR0cmFuc2Zvcm0gPT09IHZvaWQgMCA/IG1lYW5pbmdsZXNzVHJhbnNmb3JtIDogX3BhcmFtcyR0cmFuc2Zvcm0sXG4gICAgICBfcGFyYW1zJHN5bWJvbCA9IHBhcmFtcy5zeW1ib2wsXG4gICAgICBzeW1ib2wgPSBfcGFyYW1zJHN5bWJvbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGFyYW1zJHN5bWJvbCxcbiAgICAgIF9wYXJhbXMkbWFzayA9IHBhcmFtcy5tYXNrLFxuICAgICAgbWFzayA9IF9wYXJhbXMkbWFzayA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkbWFzayxcbiAgICAgIF9wYXJhbXMkdGl0bGUgPSBwYXJhbXMudGl0bGUsXG4gICAgICB0aXRsZSA9IF9wYXJhbXMkdGl0bGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcGFyYW1zJHRpdGxlLFxuICAgICAgX3BhcmFtcyRjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMsXG4gICAgICBjbGFzc2VzID0gX3BhcmFtcyRjbGFzc2VzID09PSB2b2lkIDAgPyBbXSA6IF9wYXJhbXMkY2xhc3NlcyxcbiAgICAgIF9wYXJhbXMkYXR0cmlidXRlcyA9IHBhcmFtcy5hdHRyaWJ1dGVzLFxuICAgICAgYXR0cmlidXRlcyA9IF9wYXJhbXMkYXR0cmlidXRlcyA9PT0gdm9pZCAwID8ge30gOiBfcGFyYW1zJGF0dHJpYnV0ZXMsXG4gICAgICBfcGFyYW1zJHN0eWxlcyA9IHBhcmFtcy5zdHlsZXMsXG4gICAgICBzdHlsZXMgPSBfcGFyYW1zJHN0eWxlcyA9PT0gdm9pZCAwID8ge30gOiBfcGFyYW1zJHN0eWxlcztcbiAgaWYgKCFpY29uRGVmaW5pdGlvbikgcmV0dXJuO1xuICB2YXIgcHJlZml4ID0gaWNvbkRlZmluaXRpb24ucHJlZml4LFxuICAgICAgaWNvbk5hbWUgPSBpY29uRGVmaW5pdGlvbi5pY29uTmFtZSxcbiAgICAgIGljb24gPSBpY29uRGVmaW5pdGlvbi5pY29uO1xuICByZXR1cm4gYXBpT2JqZWN0KF9vYmplY3RTcHJlYWQoe1xuICAgIHR5cGU6ICdpY29uJ1xuICB9LCBpY29uRGVmaW5pdGlvbiksIGZ1bmN0aW9uICgpIHtcbiAgICBlbnN1cmVDc3MoKTtcblxuICAgIGlmIChjb25maWcuYXV0b0ExMXkpIHtcbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBhdHRyaWJ1dGVzWydhcmlhLWxhYmVsbGVkYnknXSA9IFwiXCIuY29uY2F0KGNvbmZpZy5yZXBsYWNlbWVudENsYXNzLCBcIi10aXRsZS1cIikuY29uY2F0KG5leHRVbmlxdWVJZCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbJ2FyaWEtaGlkZGVuJ10gPSAndHJ1ZSc7XG4gICAgICAgIGF0dHJpYnV0ZXNbJ2ZvY3VzYWJsZSddID0gJ2ZhbHNlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZUlubGluZVN2Z0Fic3RyYWN0KHtcbiAgICAgIGljb25zOiB7XG4gICAgICAgIG1haW46IHByZXBJY29uKGljb24pLFxuICAgICAgICBtYXNrOiBtYXNrID8gcHJlcEljb24obWFzay5pY29uKSA6IHtcbiAgICAgICAgICBmb3VuZDogZmFsc2UsXG4gICAgICAgICAgd2lkdGg6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgICAgIGljb246IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICAgIHRyYW5zZm9ybTogX29iamVjdFNwcmVhZCh7fSwgbWVhbmluZ2xlc3NUcmFuc2Zvcm0sIHRyYW5zZm9ybSksXG4gICAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICBjbGFzc2VzOiBjbGFzc2VzXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG52YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQoY29udGVudCkge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkdHJhbnNmb3JtMiA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcGFyYW1zJHRyYW5zZm9ybTIgPT09IHZvaWQgMCA/IG1lYW5pbmdsZXNzVHJhbnNmb3JtIDogX3BhcmFtcyR0cmFuc2Zvcm0yLFxuICAgICAgX3BhcmFtcyR0aXRsZTIgPSBwYXJhbXMudGl0bGUsXG4gICAgICB0aXRsZSA9IF9wYXJhbXMkdGl0bGUyID09PSB2b2lkIDAgPyBudWxsIDogX3BhcmFtcyR0aXRsZTIsXG4gICAgICBfcGFyYW1zJGNsYXNzZXMyID0gcGFyYW1zLmNsYXNzZXMsXG4gICAgICBjbGFzc2VzID0gX3BhcmFtcyRjbGFzc2VzMiA9PT0gdm9pZCAwID8gW10gOiBfcGFyYW1zJGNsYXNzZXMyLFxuICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzMiA9IHBhcmFtcy5hdHRyaWJ1dGVzLFxuICAgICAgYXR0cmlidXRlcyA9IF9wYXJhbXMkYXR0cmlidXRlczIgPT09IHZvaWQgMCA/IHt9IDogX3BhcmFtcyRhdHRyaWJ1dGVzMixcbiAgICAgIF9wYXJhbXMkc3R5bGVzMiA9IHBhcmFtcy5zdHlsZXMsXG4gICAgICBzdHlsZXMgPSBfcGFyYW1zJHN0eWxlczIgPT09IHZvaWQgMCA/IHt9IDogX3BhcmFtcyRzdHlsZXMyO1xuICByZXR1cm4gYXBpT2JqZWN0KHtcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgY29udGVudDogY29udGVudFxuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgZW5zdXJlQ3NzKCk7XG4gICAgcmV0dXJuIG1ha2VMYXllcnNUZXh0QWJzdHJhY3Qoe1xuICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgIHRyYW5zZm9ybTogX29iamVjdFNwcmVhZCh7fSwgbWVhbmluZ2xlc3NUcmFuc2Zvcm0sIHRyYW5zZm9ybSksXG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBleHRyYToge1xuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgY2xhc3NlczogW1wiXCIuY29uY2F0KGNvbmZpZy5mYW1pbHlQcmVmaXgsIFwiLWxheWVycy10ZXh0XCIpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNsYXNzZXMpKVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG52YXIgY291bnRlciA9IGZ1bmN0aW9uIGNvdW50ZXIoY29udGVudCkge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkdGl0bGUzID0gcGFyYW1zLnRpdGxlLFxuICAgICAgdGl0bGUgPSBfcGFyYW1zJHRpdGxlMyA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkdGl0bGUzLFxuICAgICAgX3BhcmFtcyRjbGFzc2VzMyA9IHBhcmFtcy5jbGFzc2VzLFxuICAgICAgY2xhc3NlcyA9IF9wYXJhbXMkY2xhc3NlczMgPT09IHZvaWQgMCA/IFtdIDogX3BhcmFtcyRjbGFzc2VzMyxcbiAgICAgIF9wYXJhbXMkYXR0cmlidXRlczMgPSBwYXJhbXMuYXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcGFyYW1zJGF0dHJpYnV0ZXMzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkYXR0cmlidXRlczMsXG4gICAgICBfcGFyYW1zJHN0eWxlczMgPSBwYXJhbXMuc3R5bGVzLFxuICAgICAgc3R5bGVzID0gX3BhcmFtcyRzdHlsZXMzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkc3R5bGVzMztcbiAgcmV0dXJuIGFwaU9iamVjdCh7XG4gICAgdHlwZTogJ2NvdW50ZXInLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIGVuc3VyZUNzcygpO1xuICAgIHJldHVybiBtYWtlTGF5ZXJzQ291bnRlckFic3RyYWN0KHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudG9TdHJpbmcoKSxcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICBjbGFzc2VzOiBbXCJcIi5jb25jYXQoY29uZmlnLmZhbWlseVByZWZpeCwgXCItbGF5ZXJzLWNvdW50ZXJcIildLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NlcykpXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcbnZhciBsYXllciA9IGZ1bmN0aW9uIGxheWVyKGFzc2VtYmxlcikge1xuICByZXR1cm4gYXBpT2JqZWN0KHtcbiAgICB0eXBlOiAnbGF5ZXInXG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBlbnN1cmVDc3MoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBhc3NlbWJsZXIoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChhLmFic3RyYWN0KTtcbiAgICAgIH0pIDogY2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoYXJncy5hYnN0cmFjdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt7XG4gICAgICB0YWc6ICdzcGFuJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgY2xhc3M6IFwiXCIuY29uY2F0KGNvbmZpZy5mYW1pbHlQcmVmaXgsIFwiLWxheWVyc1wiKVxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH1dO1xuICB9KTtcbn07XG52YXIgYXBpID0ge1xuICBub0F1dG86IG5vQXV0byxcbiAgY29uZmlnOiBjb25maWcsXG4gIGRvbTogZG9tLFxuICBsaWJyYXJ5OiBsaWJyYXJ5LFxuICBwYXJzZTogcGFyc2UsXG4gIGZpbmRJY29uRGVmaW5pdGlvbjogZmluZEljb25EZWZpbml0aW9uLFxuICBpY29uOiBpY29uLFxuICB0ZXh0OiB0ZXh0LFxuICBjb3VudGVyOiBjb3VudGVyLFxuICBsYXllcjogbGF5ZXIsXG4gIHRvSHRtbDogdG9IdG1sXG59O1xuXG52YXIgYXV0b1JlcGxhY2UgPSBmdW5jdGlvbiBhdXRvUmVwbGFjZSgpIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBfcGFyYW1zJGF1dG9SZXBsYWNlU3YgPSBwYXJhbXMuYXV0b1JlcGxhY2VTdmdSb290LFxuICAgICAgYXV0b1JlcGxhY2VTdmdSb290ID0gX3BhcmFtcyRhdXRvUmVwbGFjZVN2ID09PSB2b2lkIDAgPyBET0NVTUVOVCA6IF9wYXJhbXMkYXV0b1JlcGxhY2VTdjtcbiAgaWYgKChPYmplY3Qua2V5cyhuYW1lc3BhY2Uuc3R5bGVzKS5sZW5ndGggPiAwIHx8IGNvbmZpZy5hdXRvRmV0Y2hTdmcpICYmIElTX0RPTSAmJiBjb25maWcuYXV0b1JlcGxhY2VTdmcpIGFwaS5kb20uaTJzdmcoe1xuICAgIG5vZGU6IGF1dG9SZXBsYWNlU3ZnUm9vdFxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGljb24sIG5vQXV0bywgY29uZmlnLCB0b0h0bWwsIGxheWVyLCB0ZXh0LCBjb3VudGVyLCBsaWJyYXJ5LCBkb20sIHBhcnNlLCBmaW5kSWNvbkRlZmluaXRpb24gfTtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAnZmFjZWJvb2snO1xudmFyIHdpZHRoID0gNTEyO1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2YwOWEnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ001MDQgMjU2QzUwNCAxMTkgMzkzIDggMjU2IDhTOCAxMTkgOCAyNTZjMCAxMjMuNzggOTAuNjkgMjI2LjM4IDIwOS4yNSAyNDVWMzI3LjY5aC02M1YyNTZoNjN2LTU0LjY0YzAtNjIuMTUgMzctOTYuNDggOTMuNjctOTYuNDggMjcuMTQgMCA1NS41MiA0Ljg0IDU1LjUyIDQuODR2NjFoLTMxLjI4Yy0zMC44IDAtNDAuNDEgMTkuMTItNDAuNDEgMzguNzNWMjU2aDY4Ljc4bC0xMSA3MS42OWgtNTcuNzhWNTAxQzQxMy4zMSA0ODIuMzggNTA0IDM3OS43OCA1MDQgMjU2eic7XG5cbmV4cG9ydHMuZGVmaW5pdGlvbiA9IHtcbiAgcHJlZml4OiBwcmVmaXgsXG4gIGljb25OYW1lOiBpY29uTmFtZSxcbiAgaWNvbjogW1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsaWdhdHVyZXMsXG4gICAgdW5pY29kZSxcbiAgICBzdmdQYXRoRGF0YVxuICBdfTtcblxuZXhwb3J0cy5mYUZhY2Vib29rID0gZXhwb3J0cy5kZWZpbml0aW9uO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLmljb25OYW1lID0gaWNvbk5hbWU7XG5leHBvcnRzLndpZHRoID0gd2lkdGg7XG5leHBvcnRzLmhlaWdodCA9IGhlaWdodDtcbmV4cG9ydHMubGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbmV4cG9ydHMuc3ZnUGF0aERhdGEgPSBzdmdQYXRoRGF0YTsiLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWZpeCA9ICdmYWInO1xudmFyIGljb25OYW1lID0gJ2ZhY2Vib29rLWYnO1xudmFyIHdpZHRoID0gMzIwO1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2YzOWUnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ00yNzkuMTQgMjg4bDE0LjIyLTkyLjY2aC04OC45MXYtNjAuMTNjMC0yNS4zNSAxMi40Mi01MC4wNiA1Mi4yNC01MC4wNmg0MC40MlY2LjI2UzI2MC40MyAwIDIyNS4zNiAwYy03My4yMiAwLTEyMS4wOCA0NC4zOC0xMjEuMDggMTI0LjcydjcwLjYySDIyLjg5VjI4OGg4MS4zOXYyMjRoMTAwLjE3VjI4OHonO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFGYWNlYm9va0YgPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAnaW5zdGFncmFtJztcbnZhciB3aWR0aCA9IDQ0ODtcbnZhciBoZWlnaHQgPSA1MTI7XG52YXIgbGlnYXR1cmVzID0gW107XG52YXIgdW5pY29kZSA9ICdmMTZkJztcbnZhciBzdmdQYXRoRGF0YSA9ICdNMjI0LjEgMTQxYy02My42IDAtMTE0LjkgNTEuMy0xMTQuOSAxMTQuOXM1MS4zIDExNC45IDExNC45IDExNC45UzMzOSAzMTkuNSAzMzkgMjU1LjkgMjg3LjcgMTQxIDIyNC4xIDE0MXptMCAxODkuNmMtNDEuMSAwLTc0LjctMzMuNS03NC43LTc0LjdzMzMuNS03NC43IDc0LjctNzQuNyA3NC43IDMzLjUgNzQuNyA3NC43LTMzLjYgNzQuNy03NC43IDc0Ljd6bTE0Ni40LTE5NC4zYzAgMTQuOS0xMiAyNi44LTI2LjggMjYuOC0xNC45IDAtMjYuOC0xMi0yNi44LTI2LjhzMTItMjYuOCAyNi44LTI2LjggMjYuOCAxMiAyNi44IDI2Ljh6bTc2LjEgMjcuMmMtMS43LTM1LjktOS45LTY3LjctMzYuMi05My45LTI2LjItMjYuMi01OC0zNC40LTkzLjktMzYuMi0zNy0yLjEtMTQ3LjktMi4xLTE4NC45IDAtMzUuOCAxLjctNjcuNiA5LjktOTMuOSAzNi4xcy0zNC40IDU4LTM2LjIgOTMuOWMtMi4xIDM3LTIuMSAxNDcuOSAwIDE4NC45IDEuNyAzNS45IDkuOSA2Ny43IDM2LjIgOTMuOXM1OCAzNC40IDkzLjkgMzYuMmMzNyAyLjEgMTQ3LjkgMi4xIDE4NC45IDAgMzUuOS0xLjcgNjcuNy05LjkgOTMuOS0zNi4yIDI2LjItMjYuMiAzNC40LTU4IDM2LjItOTMuOSAyLjEtMzcgMi4xLTE0Ny44IDAtMTg0Ljh6TTM5OC44IDM4OGMtNy44IDE5LjYtMjIuOSAzNC43LTQyLjYgNDIuNi0yOS41IDExLjctOTkuNSA5LTEzMi4xIDlzLTEwMi43IDIuNi0xMzIuMS05Yy0xOS42LTcuOC0zNC43LTIyLjktNDIuNi00Mi42LTExLjctMjkuNS05LTk5LjUtOS0xMzIuMXMtMi42LTEwMi43IDktMTMyLjFjNy44LTE5LjYgMjIuOS0zNC43IDQyLjYtNDIuNiAyOS41LTExLjcgOTkuNS05IDEzMi4xLTlzMTAyLjctMi42IDEzMi4xIDljMTkuNiA3LjggMzQuNyAyMi45IDQyLjYgNDIuNiAxMS43IDI5LjUgOSA5OS41IDkgMTMyLjFzMi43IDEwMi43LTkgMTMyLjF6JztcblxuZXhwb3J0cy5kZWZpbml0aW9uID0ge1xuICBwcmVmaXg6IHByZWZpeCxcbiAgaWNvbk5hbWU6IGljb25OYW1lLFxuICBpY29uOiBbXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxpZ2F0dXJlcyxcbiAgICB1bmljb2RlLFxuICAgIHN2Z1BhdGhEYXRhXG4gIF19O1xuXG5leHBvcnRzLmZhSW5zdGFncmFtID0gZXhwb3J0cy5kZWZpbml0aW9uO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLmljb25OYW1lID0gaWNvbk5hbWU7XG5leHBvcnRzLndpZHRoID0gd2lkdGg7XG5leHBvcnRzLmhlaWdodCA9IGhlaWdodDtcbmV4cG9ydHMubGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbmV4cG9ydHMuc3ZnUGF0aERhdGEgPSBzdmdQYXRoRGF0YTsiLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWZpeCA9ICdmYWInO1xudmFyIGljb25OYW1lID0gJ2xpbmtlZGluJztcbnZhciB3aWR0aCA9IDQ0ODtcbnZhciBoZWlnaHQgPSA1MTI7XG52YXIgbGlnYXR1cmVzID0gW107XG52YXIgdW5pY29kZSA9ICdmMDhjJztcbnZhciBzdmdQYXRoRGF0YSA9ICdNNDE2IDMySDMxLjlDMTQuMyAzMiAwIDQ2LjUgMCA2NC4zdjM4My40QzAgNDY1LjUgMTQuMyA0ODAgMzEuOSA0ODBINDE2YzE3LjYgMCAzMi0xNC41IDMyLTMyLjNWNjQuM2MwLTE3LjgtMTQuNC0zMi4zLTMyLTMyLjN6TTEzNS40IDQxNkg2OVYyMDIuMmg2Ni41VjQxNnptLTMzLjItMjQzYy0yMS4zIDAtMzguNS0xNy4zLTM4LjUtMzguNVM4MC45IDk2IDEwMi4yIDk2YzIxLjIgMCAzOC41IDE3LjMgMzguNSAzOC41IDAgMjEuMy0xNy4yIDM4LjUtMzguNSAzOC41em0yODIuMSAyNDNoLTY2LjRWMzEyYzAtMjQuOC0uNS01Ni43LTM0LjUtNTYuNy0zNC42IDAtMzkuOSAyNy0zOS45IDU0LjlWNDE2aC02Ni40VjIwMi4yaDYzLjd2MjkuMmguOWM4LjktMTYuOCAzMC42LTM0LjUgNjIuOS0zNC41IDY3LjIgMCA3OS43IDQ0LjMgNzkuNyAxMDEuOVY0MTZ6JztcblxuZXhwb3J0cy5kZWZpbml0aW9uID0ge1xuICBwcmVmaXg6IHByZWZpeCxcbiAgaWNvbk5hbWU6IGljb25OYW1lLFxuICBpY29uOiBbXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxpZ2F0dXJlcyxcbiAgICB1bmljb2RlLFxuICAgIHN2Z1BhdGhEYXRhXG4gIF19O1xuXG5leHBvcnRzLmZhTGlua2VkaW4gPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAnbGlua2VkaW4taW4nO1xudmFyIHdpZHRoID0gNDQ4O1xudmFyIGhlaWdodCA9IDUxMjtcbnZhciBsaWdhdHVyZXMgPSBbXTtcbnZhciB1bmljb2RlID0gJ2YwZTEnO1xudmFyIHN2Z1BhdGhEYXRhID0gJ00xMDAuMjggNDQ4SDcuNFYxNDguOWg5Mi44OHpNNTMuNzkgMTA4LjFDMjQuMDkgMTA4LjEgMCA4My41IDAgNTMuOGE1My43OSA1My43OSAwIDAgMSAxMDcuNTggMGMwIDI5LjctMjQuMSA1NC4zLTUzLjc5IDU0LjN6TTQ0Ny45IDQ0OGgtOTIuNjhWMzAyLjRjMC0zNC43LS43LTc5LjItNDguMjktNzkuMi00OC4yOSAwLTU1LjY5IDM3LjctNTUuNjkgNzYuN1Y0NDhoLTkyLjc4VjE0OC45aDg5LjA4djQwLjhoMS4zYzEyLjQtMjMuNSA0Mi42OS00OC4zIDg3Ljg4LTQ4LjMgOTQgMCAxMTEuMjggNjEuOSAxMTEuMjggMTQyLjNWNDQ4eic7XG5cbmV4cG9ydHMuZGVmaW5pdGlvbiA9IHtcbiAgcHJlZml4OiBwcmVmaXgsXG4gIGljb25OYW1lOiBpY29uTmFtZSxcbiAgaWNvbjogW1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsaWdhdHVyZXMsXG4gICAgdW5pY29kZSxcbiAgICBzdmdQYXRoRGF0YVxuICBdfTtcblxuZXhwb3J0cy5mYUxpbmtlZGluSW4gPSBleHBvcnRzLmRlZmluaXRpb247XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMuaWNvbk5hbWUgPSBpY29uTmFtZTtcbmV4cG9ydHMud2lkdGggPSB3aWR0aDtcbmV4cG9ydHMuaGVpZ2h0ID0gaGVpZ2h0O1xuZXhwb3J0cy5saWdhdHVyZXMgPSBsaWdhdHVyZXM7XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuZXhwb3J0cy5zdmdQYXRoRGF0YSA9IHN2Z1BhdGhEYXRhOyIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZml4ID0gJ2ZhYic7XG52YXIgaWNvbk5hbWUgPSAndHdpdHRlcic7XG52YXIgd2lkdGggPSA1MTI7XG52YXIgaGVpZ2h0ID0gNTEyO1xudmFyIGxpZ2F0dXJlcyA9IFtdO1xudmFyIHVuaWNvZGUgPSAnZjA5OSc7XG52YXIgc3ZnUGF0aERhdGEgPSAnTTQ1OS4zNyAxNTEuNzE2Yy4zMjUgNC41NDguMzI1IDkuMDk3LjMyNSAxMy42NDUgMCAxMzguNzItMTA1LjU4MyAyOTguNTU4LTI5OC41NTggMjk4LjU1OC01OS40NTIgMC0xMTQuNjgtMTcuMjE5LTE2MS4xMzctNDcuMTA2IDguNDQ3Ljk3NCAxNi41NjggMS4yOTkgMjUuMzQgMS4yOTkgNDkuMDU1IDAgOTQuMjEzLTE2LjU2OCAxMzAuMjc0LTQ0LjgzMi00Ni4xMzItLjk3NS04NC43OTItMzEuMTg4LTk4LjExMi03Mi43NzIgNi40OTguOTc0IDEyLjk5NSAxLjYyNCAxOS44MTggMS42MjQgOS40MjEgMCAxOC44NDMtMS4zIDI3LjYxNC0zLjU3My00OC4wODEtOS43NDctODQuMTQzLTUxLjk4LTg0LjE0My0xMDIuOTg1di0xLjI5OWMxMy45NjkgNy43OTcgMzAuMjE0IDEyLjY3IDQ3LjQzMSAxMy4zMTktMjguMjY0LTE4Ljg0My00Ni43ODEtNTEuMDA1LTQ2Ljc4MS04Ny4zOTEgMC0xOS40OTIgNS4xOTctMzcuMzYgMTQuMjk0LTUyLjk1NCA1MS42NTUgNjMuNjc1IDEyOS4zIDEwNS4yNTggMjE2LjM2NSAxMDkuODA3LTEuNjI0LTcuNzk3LTIuNTk5LTE1LjkxOC0yLjU5OS0yNC4wNCAwLTU3LjgyOCA0Ni43ODItMTA0LjkzNCAxMDQuOTM0LTEwNC45MzQgMzAuMjEzIDAgNTcuNTAyIDEyLjY3IDc2LjY3IDMzLjEzNyAyMy43MTUtNC41NDggNDYuNDU2LTEzLjMyIDY2LjU5OS0yNS4zNC03Ljc5OCAyNC4zNjYtMjQuMzY2IDQ0LjgzMy00Ni4xMzIgNTcuODI3IDIxLjExNy0yLjI3MyA0MS41ODQtOC4xMjIgNjAuNDI2LTE2LjI0My0xNC4yOTIgMjAuNzkxLTMyLjE2MSAzOS4zMDgtNTIuNjI4IDU0LjI1M3onO1xuXG5leHBvcnRzLmRlZmluaXRpb24gPSB7XG4gIHByZWZpeDogcHJlZml4LFxuICBpY29uTmFtZTogaWNvbk5hbWUsXG4gIGljb246IFtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGlnYXR1cmVzLFxuICAgIHVuaWNvZGUsXG4gICAgc3ZnUGF0aERhdGFcbiAgXX07XG5cbmV4cG9ydHMuZmFUd2l0dGVyID0gZXhwb3J0cy5kZWZpbml0aW9uO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLmljb25OYW1lID0gaWNvbk5hbWU7XG5leHBvcnRzLndpZHRoID0gd2lkdGg7XG5leHBvcnRzLmhlaWdodCA9IGhlaWdodDtcbmV4cG9ydHMubGlnYXR1cmVzID0gbGlnYXR1cmVzO1xuZXhwb3J0cy51bmljb2RlID0gdW5pY29kZTtcbmV4cG9ydHMuc3ZnUGF0aERhdGEgPSBzdmdQYXRoRGF0YTsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJpbXBvcnQgJy4vbW9kZXJuaXpyLWN1c3RvbSc7XG5pbXBvcnQgJy4vcmFyZWJpcmQtaW5jbHVkZXMnO1xuaW1wb3J0ICcuL25hdmlnYXRpb24tZHJvcGRvd24nO1xuaW1wb3J0ICcuL2ljb25zLWltcG9ydCc7IiwiLy9cbi8vIEljb25zIGltcG9ydCBmaWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVXNlcyBGb250IEF3ZXNvbWUgNSBpY29ucyArIEFQSTpcbi8vIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2hvdy10by11c2Uvb24tdGhlLXdlYi9hZHZhbmNlZC9zdmctamF2YXNjcmlwdC1jb3JlXG4vLyBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9ob3ctdG8tdXNlL3dpdGgtdGhlLWFwaS9zZXR1cC9nZXR0aW5nLXN0YXJ0ZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHdWxwIGlzIHVzZWQgdG8gY29tbWFuZCBSb2xsdXAgdG8gdHVybiB0aGlzIGltcG9ydFxuLy8gZmlsZSBpbiB0byBhIHJlbmRlcmVkLCB0cmVlLXNoYWtlbiBmaWxlLCB0aGF0IG9ubHlcbi8vIGluY2x1ZGVzIHRoZSBpY29ucyBkZXNpcmVkLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBbU3RlcCAxXSBJbXBvcnQgZGVzaXJlZCBpY29ucy4uLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEZpcnN0LCBpbXBvcnQgdGhlIGxpYnJhcnkgYW5kIERPTSBtYW5pcHVsYXRpb24gdXRpbGl0aWVzXG5pbXBvcnQgeyBsaWJyYXJ5LCBkb20gfSBmcm9tICdAZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtc3ZnLWNvcmUnO1xuXG5cbi8vIEFkZCB0aGUgaWNvbnMgeW91IHdhbnQgdG8gdXNlIGhlcmUsIEFORCBpbmNsdWRlIHRoZW0gaW4gdGhlIExpYnJhcnkgLmFkZCgpIGZ1bmN0aW9uIGJlbG93XG5cbi8vIENvbW1vbiBCcmFuZHMgX19fX19fX19fXG5pbXBvcnQgeyBmYUZhY2Vib29rRiB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFGYWNlYm9va0YnO1xuaW1wb3J0IHsgZmFGYWNlYm9vayB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFGYWNlYm9vayc7XG5cbmltcG9ydCB7IGZhVHdpdHRlciB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFUd2l0dGVyJztcbi8vIGltcG9ydCB7IGZhUGludGVyZXN0IH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtYnJhbmRzLXN2Zy1pY29ucyc7XG5pbXBvcnQgeyBmYUluc3RhZ3JhbSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFJbnN0YWdyYW0nO1xuaW1wb3J0IHsgZmFMaW5rZWRpbiB9IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLWJyYW5kcy1zdmctaWNvbnMvZmFMaW5rZWRpbic7XG5pbXBvcnQgeyBmYUxpbmtlZGluSW4gfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zL2ZhTGlua2VkaW5Jbic7XG4vLyBpbXBvcnQgeyBmYVlvdXR1YmUgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1icmFuZHMtc3ZnLWljb25zJztcblxuLy8gRGVtbzogTGlnaHQsIFNvbGlkLCBhbmQgUmVndWxhciB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBpY29uIF9fX19fX19fX1xuLy8gaW1wb3J0IHsgZmFFbnZlbG9wZSBhcyBmYWxFbnZlbG9wZSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tbGlnaHQtc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhRW52ZWxvcGUgYXMgZmFzRW52ZWxvcGUgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXNvbGlkLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUVudmVsb3BlIGFzIGZhckVudmVsb3BlIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG5cbi8vIENvbW1vbiBJY29ucyB0aGF0IFJCIHVzZXMgb24gc2l0ZXMgX19fX19fX19fXG4vLyBpbXBvcnQgeyBmYUVudmVsb3BlIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUZpbHRlciB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFGaWxlUGRmIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUV4Y2xhbWF0aW9uVHJpYW5nbGUgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhSW5mb0NpcmNsZSB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFMaW5rIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYVNlYXJjaCB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFQcmludCB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFQbHVzIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYU1pbnVzIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYVRpbWVzIH0gZnJvbSAnQGZvcnRhd2Vzb21lL3Byby1yZWd1bGFyLXN2Zy1pY29ucyc7XG4vLyBpbXBvcnQgeyBmYUNoZXZyb25VcCB9IGZyb20gJ0Bmb3J0YXdlc29tZS9wcm8tcmVndWxhci1zdmctaWNvbnMnO1xuLy8gaW1wb3J0IHsgZmFDaGV2cm9uUmlnaHQgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhQ2hldnJvbkRvd24gfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcbi8vIGltcG9ydCB7IGZhQ2hldnJvbkxlZnQgfSBmcm9tICdAZm9ydGF3ZXNvbWUvcHJvLXJlZ3VsYXItc3ZnLWljb25zJztcblxuXG4vLyBbU3RlcCAyXSBBZGQgZGVzaXJlZCBpY29ucyB0byBsaWJyYXJ5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxpYnJhcnkuYWRkKFxuXHQvLyBmYUVudmVsb3BlLFxuXHRmYUZhY2Vib29rRixcblx0ZmFGYWNlYm9vayxcblx0ZmFUd2l0dGVyLFxuXHQvLyBmYVBpbnRlcmVzdCxcblx0ZmFJbnN0YWdyYW0sXG5cdGZhTGlua2VkaW4sXG5cdGZhTGlua2VkaW5Jbixcblx0Ly8gZmFZb3V0dWJlLFxuXHQvLyBmYWxFbnZlbG9wZSxcblx0Ly8gZmFzRW52ZWxvcGUsXG5cdC8vIGZhckVudmVsb3BlLFxuXHQvLyBmYUZpbHRlcixcblx0Ly8gZmFGaWxlUGRmLFxuXHQvLyBmYUV4Y2xhbWF0aW9uVHJpYW5nbGUsXG5cdC8vIGZhSW5mb0NpcmNsZSxcblx0Ly8gZmFMaW5rLFxuXHQvLyBmYVNlYXJjaCxcblx0Ly8gZmFQcmludCxcblx0Ly8gZmFQbHVzLFxuXHQvLyBmYU1pbnVzLFxuXHQvLyBmYVRpbWVzLFxuXHQvLyBmYUNoZXZyb25VcCxcblx0Ly8gZmFDaGV2cm9uUmlnaHQsXG5cdC8vIGZhQ2hldnJvbkRvd24sXG5cdC8vIGZhQ2hldnJvbkxlZnQsXG4pO1xuXG5cbi8vIFJlcGxhY2UgYW55IGV4aXN0aW5nIDxpPiB0YWdzIHdpdGggPHN2Zz4gYW5kIHNldCB1cCBhIE11dGF0aW9uT2JzZXJ2ZXIgdG9cbi8vIGNvbnRpbnVlIGRvaW5nIHRoaXMgYXMgdGhlIERPTSBjaGFuZ2VzLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kb20ud2F0Y2goKTtcbiIsIi8qISBtb2Rlcm5penIgMy42LjAgKEN1c3RvbSBCdWlsZCkgfCBNSVQgKlxuICogaHR0cHM6Ly9tb2Rlcm5penIuY29tL2Rvd25sb2FkLz8tYmFja2Ryb3BmaWx0ZXItYmFja2dyb3VuZGNsaXB0ZXh0LWNzc2ZpbHRlcnMtY3NzZ3JpZF9jc3NncmlkbGVnYWN5LWNzc3Bvc2l0aW9uc3RpY2t5LXBpY3R1cmUtZG9tcHJlZml4ZXMtcHJlZml4ZWQtcHJlZml4ZXMtc2V0Y2xhc3Nlcy10ZXN0YWxscHJvcHMtdGVzdHByb3AtdGVzdHN0eWxlcy1jc3NjbGFzc3ByZWZpeDptb2QtICEqL1xuIWZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIHR5cGVvZiBlPT09dH1mdW5jdGlvbiBzKCl7dmFyIGUsdCxuLHMsbyxpLGw7Zm9yKHZhciBhIGluIFMpaWYoUy5oYXNPd25Qcm9wZXJ0eShhKSl7aWYoZT1bXSx0PVNbYV0sdC5uYW1lJiYoZS5wdXNoKHQubmFtZS50b0xvd2VyQ2FzZSgpKSx0Lm9wdGlvbnMmJnQub3B0aW9ucy5hbGlhc2VzJiZ0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpKWZvcihuPTA7bjx0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGg7bisrKWUucHVzaCh0Lm9wdGlvbnMuYWxpYXNlc1tuXS50b0xvd2VyQ2FzZSgpKTtmb3Iocz1yKHQuZm4sXCJmdW5jdGlvblwiKT90LmZuKCk6dC5mbixvPTA7bzxlLmxlbmd0aDtvKyspaT1lW29dLGw9aS5zcGxpdChcIi5cIiksMT09PWwubGVuZ3RoP01vZGVybml6cltsWzBdXT1zOighTW9kZXJuaXpyW2xbMF1dfHxNb2Rlcm5penJbbFswXV1pbnN0YW5jZW9mIEJvb2xlYW58fChNb2Rlcm5penJbbFswXV09bmV3IEJvb2xlYW4oTW9kZXJuaXpyW2xbMF1dKSksTW9kZXJuaXpyW2xbMF1dW2xbMV1dPXMpLEMucHVzaCgocz9cIlwiOlwibm8tXCIpK2wuam9pbihcIi1cIikpfX1mdW5jdGlvbiBvKGUpe3ZhciB0PXcuY2xhc3NOYW1lLG49TW9kZXJuaXpyLl9jb25maWcuY2xhc3NQcmVmaXh8fFwiXCI7aWYoYiYmKHQ9dC5iYXNlVmFsKSxNb2Rlcm5penIuX2NvbmZpZy5lbmFibGVKU0NsYXNzKXt2YXIgcj1uZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIrbitcIm5vLWpzKFxcXFxzfCQpXCIpO3Q9dC5yZXBsYWNlKHIsXCIkMVwiK24rXCJqcyQyXCIpfU1vZGVybml6ci5fY29uZmlnLmVuYWJsZUNsYXNzZXMmJih0Kz1cIiBcIituK2Uuam9pbihcIiBcIituKSxiP3cuY2xhc3NOYW1lLmJhc2VWYWw9dDp3LmNsYXNzTmFtZT10KX1mdW5jdGlvbiBpKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbYS16XSktKFthLXpdKS9nLGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdCtuLnRvVXBwZXJDYXNlKCl9KS5yZXBsYWNlKC9eLS8sXCJcIil9ZnVuY3Rpb24gbCgpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuY3JlYXRlRWxlbWVudD90LmNyZWF0ZUVsZW1lbnQoYXJndW1lbnRzWzBdKTpiP3QuY3JlYXRlRWxlbWVudE5TLmNhbGwodCxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsYXJndW1lbnRzWzBdKTp0LmNyZWF0ZUVsZW1lbnQuYXBwbHkodCxhcmd1bWVudHMpfWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4hIX4oXCJcIitlKS5pbmRleE9mKHQpfWZ1bmN0aW9uIHUoKXt2YXIgZT10LmJvZHk7cmV0dXJuIGV8fChlPWwoYj9cInN2Z1wiOlwiYm9keVwiKSxlLmZha2U9ITApLGV9ZnVuY3Rpb24gZihlLG4scixzKXt2YXIgbyxpLGEsZixkPVwibW9kZXJuaXpyXCIscD1sKFwiZGl2XCIpLGM9dSgpO2lmKHBhcnNlSW50KHIsMTApKWZvcig7ci0tOylhPWwoXCJkaXZcIiksYS5pZD1zP3Nbcl06ZCsocisxKSxwLmFwcGVuZENoaWxkKGEpO3JldHVybiBvPWwoXCJzdHlsZVwiKSxvLnR5cGU9XCJ0ZXh0L2Nzc1wiLG8uaWQ9XCJzXCIrZCwoYy5mYWtlP2M6cCkuYXBwZW5kQ2hpbGQobyksYy5hcHBlbmRDaGlsZChwKSxvLnN0eWxlU2hlZXQ/by5zdHlsZVNoZWV0LmNzc1RleHQ9ZTpvLmFwcGVuZENoaWxkKHQuY3JlYXRlVGV4dE5vZGUoZSkpLHAuaWQ9ZCxjLmZha2UmJihjLnN0eWxlLmJhY2tncm91bmQ9XCJcIixjLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsZj13LnN0eWxlLm92ZXJmbG93LHcuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIix3LmFwcGVuZENoaWxkKGMpKSxpPW4ocCxlKSxjLmZha2U/KGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSx3LnN0eWxlLm92ZXJmbG93PWYsdy5vZmZzZXRIZWlnaHQpOnAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwKSwhIWl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsYXJndW1lbnRzKX19ZnVuY3Rpb24gcChlLHQsbil7dmFyIHM7Zm9yKHZhciBvIGluIGUpaWYoZVtvXWluIHQpcmV0dXJuIG49PT0hMT9lW29dOihzPXRbZVtvXV0scihzLFwiZnVuY3Rpb25cIik/ZChzLG58fHQpOnMpO3JldHVybiExfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFtBLVpdKS9nLGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCItXCIrdC50b0xvd2VyQ2FzZSgpfSkucmVwbGFjZSgvXm1zLS8sXCItbXMtXCIpfWZ1bmN0aW9uIG0odCxuLHIpe3ZhciBzO2lmKFwiZ2V0Q29tcHV0ZWRTdHlsZVwiaW4gZSl7cz1nZXRDb21wdXRlZFN0eWxlLmNhbGwoZSx0LG4pO3ZhciBvPWUuY29uc29sZTtpZihudWxsIT09cylyJiYocz1zLmdldFByb3BlcnR5VmFsdWUocikpO2Vsc2UgaWYobyl7dmFyIGk9by5lcnJvcj9cImVycm9yXCI6XCJsb2dcIjtvW2ldLmNhbGwobyxcImdldENvbXB1dGVkU3R5bGUgcmV0dXJuaW5nIG51bGwsIGl0cyBwb3NzaWJsZSBtb2Rlcm5penIgdGVzdCByZXN1bHRzIGFyZSBpbmFjY3VyYXRlXCIpfX1lbHNlIHM9IW4mJnQuY3VycmVudFN0eWxlJiZ0LmN1cnJlbnRTdHlsZVtyXTtyZXR1cm4gc31mdW5jdGlvbiBnKHQscil7dmFyIHM9dC5sZW5ndGg7aWYoXCJDU1NcImluIGUmJlwic3VwcG9ydHNcImluIGUuQ1NTKXtmb3IoO3MtLTspaWYoZS5DU1Muc3VwcG9ydHMoYyh0W3NdKSxyKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihcIkNTU1N1cHBvcnRzUnVsZVwiaW4gZSl7Zm9yKHZhciBvPVtdO3MtLTspby5wdXNoKFwiKFwiK2ModFtzXSkrXCI6XCIrcitcIilcIik7cmV0dXJuIG89by5qb2luKFwiIG9yIFwiKSxmKFwiQHN1cHBvcnRzIChcIitvK1wiKSB7ICNtb2Rlcm5penIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IH0gfVwiLGZ1bmN0aW9uKGUpe3JldHVyblwiYWJzb2x1dGVcIj09bShlLG51bGwsXCJwb3NpdGlvblwiKX0pfXJldHVybiBufWZ1bmN0aW9uIHkoZSx0LHMsbyl7ZnVuY3Rpb24gdSgpe2QmJihkZWxldGUgTC5zdHlsZSxkZWxldGUgTC5tb2RFbGVtKX1pZihvPXIobyxcInVuZGVmaW5lZFwiKT8hMTpvLCFyKHMsXCJ1bmRlZmluZWRcIikpe3ZhciBmPWcoZSxzKTtpZighcihmLFwidW5kZWZpbmVkXCIpKXJldHVybiBmfWZvcih2YXIgZCxwLGMsbSx5LHY9W1wibW9kZXJuaXpyXCIsXCJ0c3BhblwiLFwic2FtcFwiXTshTC5zdHlsZSYmdi5sZW5ndGg7KWQ9ITAsTC5tb2RFbGVtPWwodi5zaGlmdCgpKSxMLnN0eWxlPUwubW9kRWxlbS5zdHlsZTtmb3IoYz1lLmxlbmd0aCxwPTA7Yz5wO3ArKylpZihtPWVbcF0seT1MLnN0eWxlW21dLGEobSxcIi1cIikmJihtPWkobSkpLEwuc3R5bGVbbV0hPT1uKXtpZihvfHxyKHMsXCJ1bmRlZmluZWRcIikpcmV0dXJuIHUoKSxcInBmeFwiPT10P206ITA7dHJ5e0wuc3R5bGVbbV09c31jYXRjaChoKXt9aWYoTC5zdHlsZVttXSE9eSlyZXR1cm4gdSgpLFwicGZ4XCI9PXQ/bTohMH1yZXR1cm4gdSgpLCExfWZ1bmN0aW9uIHYoZSx0LG4scyxvKXt2YXIgaT1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSksbD0oZStcIiBcIit6LmpvaW4oaStcIiBcIikraSkuc3BsaXQoXCIgXCIpO3JldHVybiByKHQsXCJzdHJpbmdcIil8fHIodCxcInVuZGVmaW5lZFwiKT95KGwsdCxzLG8pOihsPShlK1wiIFwiK1Auam9pbihpK1wiIFwiKStpKS5zcGxpdChcIiBcIikscChsLHQsbikpfWZ1bmN0aW9uIGgoZSx0LHIpe3JldHVybiB2KGUsbixuLHQscil9dmFyIEM9W10sUz1bXSx4PXtfdmVyc2lvbjpcIjMuNi4wXCIsX2NvbmZpZzp7Y2xhc3NQcmVmaXg6XCJtb2QtXCIsZW5hYmxlQ2xhc3NlczohMCxlbmFibGVKU0NsYXNzOiEwLHVzZVByZWZpeGVzOiEwfSxfcTpbXSxvbjpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe3QobltlXSl9LDApfSxhZGRUZXN0OmZ1bmN0aW9uKGUsdCxuKXtTLnB1c2goe25hbWU6ZSxmbjp0LG9wdGlvbnM6bn0pfSxhZGRBc3luY1Rlc3Q6ZnVuY3Rpb24oZSl7Uy5wdXNoKHtuYW1lOm51bGwsZm46ZX0pfX0sTW9kZXJuaXpyPWZ1bmN0aW9uKCl7fTtNb2Rlcm5penIucHJvdG90eXBlPXgsTW9kZXJuaXpyPW5ldyBNb2Rlcm5penIsTW9kZXJuaXpyLmFkZFRlc3QoXCJwaWN0dXJlXCIsXCJIVE1MUGljdHVyZUVsZW1lbnRcImluIGUpO3ZhciBfPXguX2NvbmZpZy51c2VQcmVmaXhlcz9cIiAtd2Via2l0LSAtbW96LSAtby0gLW1zLSBcIi5zcGxpdChcIiBcIik6W1wiXCIsXCJcIl07eC5fcHJlZml4ZXM9Xzt2YXIgdz10LmRvY3VtZW50RWxlbWVudCxiPVwic3ZnXCI9PT13Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksVD1cIk1veiBPIG1zIFdlYmtpdFwiLFA9eC5fY29uZmlnLnVzZVByZWZpeGVzP1QudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIik6W107eC5fZG9tUHJlZml4ZXM9UCxNb2Rlcm5penIuYWRkVGVzdChcImNzc3Bvc2l0aW9uc3RpY2t5XCIsZnVuY3Rpb24oKXt2YXIgZT1cInBvc2l0aW9uOlwiLHQ9XCJzdGlja3lcIixuPWwoXCJhXCIpLHI9bi5zdHlsZTtyZXR1cm4gci5jc3NUZXh0PWUrXy5qb2luKHQrXCI7XCIrZSkuc2xpY2UoMCwtZS5sZW5ndGgpLC0xIT09ci5wb3NpdGlvbi5pbmRleE9mKHQpfSk7dmFyIGs9XCJDU1NcImluIGUmJlwic3VwcG9ydHNcImluIGUuQ1NTLEU9XCJzdXBwb3J0c0NTU1wiaW4gZTtNb2Rlcm5penIuYWRkVGVzdChcInN1cHBvcnRzXCIsa3x8RSk7dmFyIHo9eC5fY29uZmlnLnVzZVByZWZpeGVzP1Quc3BsaXQoXCIgXCIpOltdO3guX2Nzc29tUHJlZml4ZXM9ejt2YXIgaj1mdW5jdGlvbih0KXt2YXIgcixzPV8ubGVuZ3RoLG89ZS5DU1NSdWxlO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBvKXJldHVybiBuO2lmKCF0KXJldHVybiExO2lmKHQ9dC5yZXBsYWNlKC9eQC8sXCJcIikscj10LnJlcGxhY2UoLy0vZyxcIl9cIikudG9VcHBlckNhc2UoKStcIl9SVUxFXCIsciBpbiBvKXJldHVyblwiQFwiK3Q7Zm9yKHZhciBpPTA7cz5pO2krKyl7dmFyIGw9X1tpXSxhPWwudG9VcHBlckNhc2UoKStcIl9cIityO2lmKGEgaW4gbylyZXR1cm5cIkAtXCIrbC50b0xvd2VyQ2FzZSgpK1wiLVwiK3R9cmV0dXJuITF9O3guYXRSdWxlPWo7dmFyIE49KHgudGVzdFN0eWxlcz1mLHtlbGVtOmwoXCJtb2Rlcm5penJcIil9KTtNb2Rlcm5penIuX3EucHVzaChmdW5jdGlvbigpe2RlbGV0ZSBOLmVsZW19KTt2YXIgTD17c3R5bGU6Ti5lbGVtLnN0eWxlfTtNb2Rlcm5penIuX3EudW5zaGlmdChmdW5jdGlvbigpe2RlbGV0ZSBMLnN0eWxlfSk7eC50ZXN0UHJvcD1mdW5jdGlvbihlLHQscil7cmV0dXJuIHkoW2VdLG4sdCxyKX07eC50ZXN0QWxsUHJvcHM9djt4LnByZWZpeGVkPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gMD09PWUuaW5kZXhPZihcIkBcIik/aihlKTooLTEhPWUuaW5kZXhPZihcIi1cIikmJihlPWkoZSkpLHQ/dihlLHQsbik6dihlLFwicGZ4XCIpKX07eC50ZXN0QWxsUHJvcHM9aCxNb2Rlcm5penIuYWRkVGVzdChcImJhY2tkcm9wZmlsdGVyXCIsaChcImJhY2tkcm9wRmlsdGVyXCIpKSxNb2Rlcm5penIuYWRkVGVzdChcImJhY2tncm91bmRjbGlwdGV4dFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGgoXCJiYWNrZ3JvdW5kQ2xpcFwiLFwidGV4dFwiKX0pLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzZ3JpZGxlZ2FjeVwiLGgoXCJncmlkLWNvbHVtbnNcIixcIjEwcHhcIiwhMCkpLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzZ3JpZFwiLGgoXCJncmlkLXRlbXBsYXRlLXJvd3NcIixcIm5vbmVcIiwhMCkpLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzZmlsdGVyc1wiLGZ1bmN0aW9uKCl7aWYoTW9kZXJuaXpyLnN1cHBvcnRzKXJldHVybiBoKFwiZmlsdGVyXCIsXCJibHVyKDJweClcIik7dmFyIGU9bChcImFcIik7cmV0dXJuIGUuc3R5bGUuY3NzVGV4dD1fLmpvaW4oXCJmaWx0ZXI6Ymx1cigycHgpOyBcIiksISFlLnN0eWxlLmxlbmd0aCYmKHQuZG9jdW1lbnRNb2RlPT09bnx8dC5kb2N1bWVudE1vZGU+OSl9KSxzKCksbyhDKSxkZWxldGUgeC5hZGRUZXN0LGRlbGV0ZSB4LmFkZEFzeW5jVGVzdDtmb3IodmFyIE89MDtPPE1vZGVybml6ci5fcS5sZW5ndGg7TysrKU1vZGVybml6ci5fcVtPXSgpO2UuTW9kZXJuaXpyPU1vZGVybml6cn0od2luZG93LGRvY3VtZW50KTtcbiIsImpRdWVyeShkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgJChcIi5tYWluLW5hdmlnYXRpb24gLm1lbnUtaXRlbS1oYXMtY2hpbGRyZW5cIikub24oJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKCd1bCcsIHRoaXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVsbSA9ICQoJ3VsOmZpcnN0JywgdGhpcyk7XG4gICAgICAgICAgICB2YXIgb2ZmID0gZWxtLm9mZnNldCgpO1xuICAgICAgICAgICAgdmFyIGwgPSBvZmYubGVmdDtcbiAgICAgICAgICAgIHZhciB3ID0gZWxtLndpZHRoKCk7XG4gICAgICAgICAgICB2YXIgZG9jSCA9ICQoXCIubWFpbi1uYXZpZ2F0aW9uXCIpLmhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIGRvY1cgPSAkKFwiLm1haW4tbmF2aWdhdGlvblwiKS53aWR0aCgpO1xuXG4gICAgICAgICAgICB2YXIgaXNFbnRpcmVseVZpc2libGUgPSAobCArIHcgPD0gZG9jVyk7XG5cbiAgICAgICAgICAgIGlmICghaXNFbnRpcmVseVZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdlZGdlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2VkZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSkgICAgIiwiXG4vL1xuLy8gQ29tcGlsZWQgU2l0ZSBTY3JpcHRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXYXJuaW5nOiBHbG9iYWwuanMgaXMgYSBDT01QSUxFRCBmaWxlISBFZGl0IGEgc291cmNlIGZpbGUsIG9yIGNyZWF0ZSBhIG5ld1xuLy8gb25lLiBTZWUgZ3VscGZpbGUuanMhXG4vL1xuLy8gICMjIyMjIyNcbi8vICAgICAjICAgICMgICAgIyAjICAjIyMjICAgICAgIyAgIyMjIyAgICAgICAgIyNcbi8vICAgICAjICAgICMgICAgIyAjICMgICAgICAgICAgIyAjICAgICAgICAgICAjICAjXG4vLyAgICAgIyAgICAjIyMjIyMgIyAgIyMjIyAgICAgICMgICMjIyMgICAgICAjICAgICNcbi8vICAgICAjICAgICMgICAgIyAjICAgICAgIyAgICAgIyAgICAgICMgICAgICMjIyMjI1xuLy8gICAgICMgICAgIyAgICAjICMgIyAgICAjICAgICAjICMgICAgIyAgICAgIyAgICAjXG4vLyAgICAgIyAgICAjICAgICMgIyAgIyMjIyAgICAgICMgICMjIyMgICAgICAjICAgICNcblxuLy8gICMjIyMjICAjIyMjIyMjICMgICAgICMgIyMjIyMjICAjIyMgIyAgICAgICAjIyMjIyMjICMjIyMjI1xuLy8gIyAgICAgIyAjICAgICAjICMjICAgIyMgIyAgICAgIyAgIyAgIyAgICAgICAjICAgICAgICMgICAgICNcbi8vICMgICAgICAgIyAgICAgIyAjICMgIyAjICMgICAgICMgICMgICMgICAgICAgIyAgICAgICAjICAgICAjXG4vLyAjICAgICAgICMgICAgICMgIyAgIyAgIyAjIyMjIyMgICAjICAjICAgICAgICMjIyMjICAgIyAgICAgI1xuLy8gIyAgICAgICAjICAgICAjICMgICAgICMgIyAgICAgICAgIyAgIyAgICAgICAjICAgICAgICMgICAgICNcbi8vICMgICAgICMgIyAgICAgIyAjICAgICAjICMgICAgICAgICMgICMgICAgICAgIyAgICAgICAjICAgICAjXG4vLyAgIyMjIyMgICMjIyMjIyMgIyAgICAgIyAjICAgICAgICMjIyAjIyMjIyMjICMjIyMjIyMgIyMjIyMjXG4vL1xuLy8gIyMjIyMjIyAjIyMgIyAgICAgICAjIyMjIyMjXG4vLyAjICAgICAgICAjICAjICAgICAgICNcbi8vICMgICAgICAgICMgICMgICAgICAgI1xuLy8gIyMjIyMgICAgIyAgIyAgICAgICAjIyMjI1xuLy8gIyAgICAgICAgIyAgIyAgICAgICAjXG4vLyAjICAgICAgICAjICAjICAgICAgICNcbi8vICMgICAgICAgIyMjICMjIyMjIyMgIyMjIyMjI1xuLy9cbi8vIFdhcm5pbmc6IEdsb2JhbC5qcyBpcyBhIENPTVBJTEVEIGZpbGUhIEVkaXQgYSBzb3VyY2UgZmlsZSwgb3IgY3JlYXRlIGEgbmV3XG4vLyBvbmUuIFNlZSBndWxwZmlsZS5iYWJlbC5qcyFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cblxuLy9cbi8vIFBvbHlmaWxsIGZvciB1c2luZyBmb3JFYWNoKCkgb24gTm9kZUxpc3RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQWRkcyBzdXBwb3J0IGZvciBJRSAxMSB3aXRob3V0IGNhbGxpbmcgaW4gYSBcbi8vIEJhYmVsIGR1bXB0cnVjay5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVMaXN0L2ZvckVhY2gjUG9seWZpbGxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pZiAod2luZG93Lk5vZGVMaXN0ICYmICFOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHRoaXNBcmcgPSB0aGlzQXJnIHx8IHdpbmRvdztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpc1tpXSwgaSwgdGhpcyk7XG4gICAgfVxuICB9O1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdHJhbnNpdGlvbi5qcyB2My40LjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RyYW5zaXRpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ1NTIFRSQU5TSVRJT04gU1VQUE9SVCAoU2hvdXRvdXQ6IGh0dHA6Ly93d3cubW9kZXJuaXpyLmNvbS8pXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9vdHN0cmFwJylcblxuICAgIHZhciB0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XG4gICAgICBXZWJraXRUcmFuc2l0aW9uIDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICAgTW96VHJhbnNpdGlvbiAgICA6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgIE9UcmFuc2l0aW9uICAgICAgOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxuICAgICAgdHJhbnNpdGlvbiAgICAgICA6ICd0cmFuc2l0aW9uZW5kJ1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyBlbmQ6IHRyYW5zRW5kRXZlbnROYW1lc1tuYW1lXSB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlIC8vIGV4cGxpY2l0IGZvciBpZTggKCAgLl8uKVxuICB9XG5cbiAgLy8gaHR0cDovL2Jsb2cuYWxleG1hY2Nhdy5jb20vY3NzLXRyYW5zaXRpb25zXG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgJGVsID0gdGhpc1xuICAgICQodGhpcykub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWUgfSlcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7IGlmICghY2FsbGVkKSAkKCRlbCkudHJpZ2dlcigkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpIH1cbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkdXJhdGlvbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgJChmdW5jdGlvbiAoKSB7XG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRW5kKClcblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVyblxuXG4gICAgJC5ldmVudC5zcGVjaWFsLmJzVHJhbnNpdGlvbkVuZCA9IHtcbiAgICAgIGJpbmRUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBkZWxlZ2F0ZVR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoaXMpKSByZXR1cm4gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhbGVydC5qcyB2My40LjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FsZXJ0c1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEFMRVJUIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBkaXNtaXNzID0gJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXSdcbiAgdmFyIEFsZXJ0ICAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAkKGVsKS5vbignY2xpY2snLCBkaXNtaXNzLCB0aGlzLmNsb3NlKVxuICB9XG5cbiAgQWxlcnQuVkVSU0lPTiA9ICczLjQuMCdcblxuICBBbGVydC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgQWxlcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICAgPSAkKHRoaXMpXG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICBzZWxlY3RvciAgICA9IHNlbGVjdG9yID09PSAnIycgPyBbXSA6IHNlbGVjdG9yXG4gICAgdmFyICRwYXJlbnQgPSAkKGRvY3VtZW50KS5maW5kKHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IG1vZGFsLmpzIHYzLjQuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRkaWFsb2cgICAgICAgICAgICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLmlzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBNb2RhbC5WRVJTSU9OICA9ICczLjQuMCdcblxuICBNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBNb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ3Nob3cuYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICh0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSB0cnVlXG5cbiAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9kYWwtb3BlbicpXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG5cbiAgICB0aGlzLiRkaWFsb2cub24oJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kZWxlbWVudC5vbmUoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGF0LiRlbGVtZW50KSkgdGhhdC5pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuYXBwZW5kVG8odGhhdC4kYm9keSkgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuc2Nyb2xsVG9wKDApXG5cbiAgICAgIHRoYXQuYWRqdXN0RGlhbG9nKClcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRkaWFsb2cgLy8gd2FpdCBmb3IgbW9kYWwgdG8gc2xpZGUgaW5cbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGUgPSAkLkV2ZW50KCdoaWRlLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZVxuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgICQoZG9jdW1lbnQpLm9mZignZm9jdXNpbi5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgIC5vZmYoJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnKVxuICAgICAgLm9mZignbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGRpYWxvZy5vZmYoJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkodGhpcy5oaWRlTW9kYWwsIHRoaXMpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgdGhpcy5oaWRlTW9kYWwoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKGRvY3VtZW50KVxuICAgICAgLm9mZignZm9jdXNpbi5icy5tb2RhbCcpIC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKCdmb2N1c2luLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZG9jdW1lbnQgIT09IGUudGFyZ2V0ICYmXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldCAmJlxuICAgICAgICAgICAgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcykpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUud2hpY2ggPT0gMjcgJiYgdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duKSB7XG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5icy5tb2RhbCcsICQucHJveHkodGhpcy5oYW5kbGVVcGRhdGUsIHRoaXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuICAgICAgdGhhdC5yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoYXQucmVzZXRTY3JvbGxiYXIoKVxuICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4uYnMubW9kYWwnKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYmFja2Ryb3AgJiYgdGhpcy4kYmFja2Ryb3AucmVtb3ZlKClcbiAgICB0aGlzLiRiYWNrZHJvcCA9IG51bGxcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5iYWNrZHJvcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBhbmltYXRlID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID8gJ2ZhZGUnIDogJydcblxuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICB2YXIgZG9BbmltYXRlID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgYW5pbWF0ZVxuXG4gICAgICB0aGlzLiRiYWNrZHJvcCA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgIC5hZGRDbGFzcygnbW9kYWwtYmFja2Ryb3AgJyArIGFuaW1hdGUpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLiRib2R5KVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkgcmV0dXJuXG4gICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgID8gdGhpcy4kZWxlbWVudFswXS5mb2N1cygpXG4gICAgICAgICAgOiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBNb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgIW1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJ1xuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBpZiAoIWZ1bGxXaW5kb3dXaWR0aCkgeyAvLyB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIHdpbmRvdy5pbm5lcldpZHRoIGluIElFOFxuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGZ1bGxXaW5kb3dXaWR0aCA9IGRvY3VtZW50RWxlbWVudFJlY3QucmlnaHQgLSBNYXRoLmFicyhkb2N1bWVudEVsZW1lbnRSZWN0LmxlZnQpXG4gICAgfVxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgZnVsbFdpbmRvd1dpZHRoXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMubWVhc3VyZVNjcm9sbGJhcigpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcbiAgICBpZiAodGhpcy5ib2R5SXNPdmVyZmxvd2luZykgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIHRoaXMub3JpZ2luYWxCb2R5UGFkKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLm1vZGFsXG5cbiAgJC5mbi5tb2RhbCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLm1vZGFsLkNvbnN0cnVjdG9yID0gTW9kYWxcblxuXG4gIC8vIE1PREFMIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5tb2RhbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ubW9kYWwgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBNT0RBTCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5tb2RhbC5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgdmFyIGhyZWYgICAgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICB2YXIgdGFyZ2V0ICA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHxcbiAgICAgIChocmVmICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSAvLyBzdHJpcCBmb3IgaWU3XG5cbiAgICB2YXIgJHRhcmdldCA9ICQoZG9jdW1lbnQpLmZpbmQodGFyZ2V0KVxuICAgIHZhciBvcHRpb24gID0gJHRhcmdldC5kYXRhKCdicy5tb2RhbCcpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7IHJlbW90ZTogIS8jLy50ZXN0KGhyZWYpICYmIGhyZWYgfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgIGlmICgkdGhpcy5pcygnYScpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICR0YXJnZXQub25lKCdzaG93LmJzLm1vZGFsJywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICR0YXJnZXQub25lKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICR0aGlzLmlzKCc6dmlzaWJsZScpICYmICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24sIHRoaXMpXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLypnbG9iYWwgZGVmaW5lOmZhbHNlICovXG4vKipcbiAqIENvcHlyaWdodCAyMDEyLTIwMTcgQ3JhaWcgQ2FtcGJlbGxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBNb3VzZXRyYXAgaXMgYSBzaW1wbGUga2V5Ym9hcmQgc2hvcnRjdXQgbGlicmFyeSBmb3IgSmF2YXNjcmlwdCB3aXRoXG4gKiBubyBleHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAdmVyc2lvbiAxLjYuMlxuICogQHVybCBjcmFpZy5pcy9raWxsaW5nL21pY2VcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gICAgLy8gQ2hlY2sgaWYgbW91c2V0cmFwIGlzIHVzZWQgaW5zaWRlIGJyb3dzZXIsIGlmIG5vdCwgcmV0dXJuXG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1hcHBpbmcgb2Ygc3BlY2lhbCBrZXljb2RlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIGtleXNcbiAgICAgKlxuICAgICAqIGV2ZXJ5dGhpbmcgaW4gdGhpcyBkaWN0aW9uYXJ5IGNhbm5vdCB1c2Uga2V5cHJlc3MgZXZlbnRzXG4gICAgICogc28gaXQgaGFzIHRvIGJlIGhlcmUgdG8gbWFwIHRvIHRoZSBjb3JyZWN0IGtleWNvZGVzIGZvclxuICAgICAqIGtleXVwL2tleWRvd24gZXZlbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfTUFQID0ge1xuICAgICAgICA4OiAnYmFja3NwYWNlJyxcbiAgICAgICAgOTogJ3RhYicsXG4gICAgICAgIDEzOiAnZW50ZXInLFxuICAgICAgICAxNjogJ3NoaWZ0JyxcbiAgICAgICAgMTc6ICdjdHJsJyxcbiAgICAgICAgMTg6ICdhbHQnLFxuICAgICAgICAyMDogJ2NhcHNsb2NrJyxcbiAgICAgICAgMjc6ICdlc2MnLFxuICAgICAgICAzMjogJ3NwYWNlJyxcbiAgICAgICAgMzM6ICdwYWdldXAnLFxuICAgICAgICAzNDogJ3BhZ2Vkb3duJyxcbiAgICAgICAgMzU6ICdlbmQnLFxuICAgICAgICAzNjogJ2hvbWUnLFxuICAgICAgICAzNzogJ2xlZnQnLFxuICAgICAgICAzODogJ3VwJyxcbiAgICAgICAgMzk6ICdyaWdodCcsXG4gICAgICAgIDQwOiAnZG93bicsXG4gICAgICAgIDQ1OiAnaW5zJyxcbiAgICAgICAgNDY6ICdkZWwnLFxuICAgICAgICA5MTogJ21ldGEnLFxuICAgICAgICA5MzogJ21ldGEnLFxuICAgICAgICAyMjQ6ICdtZXRhJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtYXBwaW5nIGZvciBzcGVjaWFsIGNoYXJhY3RlcnMgc28gdGhleSBjYW4gc3VwcG9ydFxuICAgICAqXG4gICAgICogdGhpcyBkaWN0aW9uYXJ5IGlzIG9ubHkgdXNlZCBpbmNhc2UgeW91IHdhbnQgdG8gYmluZCBhXG4gICAgICoga2V5dXAgb3Iga2V5ZG93biBldmVudCB0byBvbmUgb2YgdGhlc2Uga2V5c1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX0tFWUNPREVfTUFQID0ge1xuICAgICAgICAxMDY6ICcqJyxcbiAgICAgICAgMTA3OiAnKycsXG4gICAgICAgIDEwOTogJy0nLFxuICAgICAgICAxMTA6ICcuJyxcbiAgICAgICAgMTExIDogJy8nLFxuICAgICAgICAxODY6ICc7JyxcbiAgICAgICAgMTg3OiAnPScsXG4gICAgICAgIDE4ODogJywnLFxuICAgICAgICAxODk6ICctJyxcbiAgICAgICAgMTkwOiAnLicsXG4gICAgICAgIDE5MTogJy8nLFxuICAgICAgICAxOTI6ICdgJyxcbiAgICAgICAgMjE5OiAnWycsXG4gICAgICAgIDIyMDogJ1xcXFwnLFxuICAgICAgICAyMjE6ICddJyxcbiAgICAgICAgMjIyOiAnXFwnJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGEgbWFwcGluZyBvZiBrZXlzIHRoYXQgcmVxdWlyZSBzaGlmdCBvbiBhIFVTIGtleXBhZFxuICAgICAqIGJhY2sgdG8gdGhlIG5vbiBzaGlmdCBlcXVpdmVsZW50c1xuICAgICAqXG4gICAgICogdGhpcyBpcyBzbyB5b3UgY2FuIHVzZSBrZXl1cCBldmVudHMgd2l0aCB0aGVzZSBrZXlzXG4gICAgICpcbiAgICAgKiBub3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayByZWxpYWJseSBvbiBVUyBrZXlib2FyZHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9TSElGVF9NQVAgPSB7XG4gICAgICAgICd+JzogJ2AnLFxuICAgICAgICAnISc6ICcxJyxcbiAgICAgICAgJ0AnOiAnMicsXG4gICAgICAgICcjJzogJzMnLFxuICAgICAgICAnJCc6ICc0JyxcbiAgICAgICAgJyUnOiAnNScsXG4gICAgICAgICdeJzogJzYnLFxuICAgICAgICAnJic6ICc3JyxcbiAgICAgICAgJyonOiAnOCcsXG4gICAgICAgICcoJzogJzknLFxuICAgICAgICAnKSc6ICcwJyxcbiAgICAgICAgJ18nOiAnLScsXG4gICAgICAgICcrJzogJz0nLFxuICAgICAgICAnOic6ICc7JyxcbiAgICAgICAgJ1xcXCInOiAnXFwnJyxcbiAgICAgICAgJzwnOiAnLCcsXG4gICAgICAgICc+JzogJy4nLFxuICAgICAgICAnPyc6ICcvJyxcbiAgICAgICAgJ3wnOiAnXFxcXCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBpcyBhIGxpc3Qgb2Ygc3BlY2lhbCBzdHJpbmdzIHlvdSBjYW4gdXNlIHRvIG1hcFxuICAgICAqIHRvIG1vZGlmaWVyIGtleXMgd2hlbiB5b3Ugc3BlY2lmeSB5b3VyIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX1NQRUNJQUxfQUxJQVNFUyA9IHtcbiAgICAgICAgJ29wdGlvbic6ICdhbHQnLFxuICAgICAgICAnY29tbWFuZCc6ICdtZXRhJyxcbiAgICAgICAgJ3JldHVybic6ICdlbnRlcicsXG4gICAgICAgICdlc2NhcGUnOiAnZXNjJyxcbiAgICAgICAgJ3BsdXMnOiAnKycsXG4gICAgICAgICdtb2QnOiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA/ICdtZXRhJyA6ICdjdHJsJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB2YXJpYWJsZSB0byBzdG9yZSB0aGUgZmxpcHBlZCB2ZXJzaW9uIG9mIF9NQVAgZnJvbSBhYm92ZVxuICAgICAqIG5lZWRlZCB0byBjaGVjayBpZiB3ZSBzaG91bGQgdXNlIGtleXByZXNzIG9yIG5vdCB3aGVuIG5vIGFjdGlvblxuICAgICAqIGlzIHNwZWNpZmllZFxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdmFyIF9SRVZFUlNFX01BUDtcblxuICAgIC8qKlxuICAgICAqIGxvb3AgdGhyb3VnaCB0aGUgZiBrZXlzLCBmMSB0byBmMTkgYW5kIGFkZCB0aGVtIHRvIHRoZSBtYXBcbiAgICAgKiBwcm9ncmFtYXRpY2FsbHlcbiAgICAgKi9cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDIwOyArK2kpIHtcbiAgICAgICAgX01BUFsxMTEgKyBpXSA9ICdmJyArIGk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9vcCB0aHJvdWdoIHRvIG1hcCBudW1iZXJzIG9uIHRoZSBudW1lcmljIGtleXBhZFxuICAgICAqL1xuICAgIGZvciAoaSA9IDA7IGkgPD0gOTsgKytpKSB7XG5cbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byB1c2UgYSBzdHJpbmcgY2F1c2Ugb3RoZXJ3aXNlIHNpbmNlIDAgaXMgZmFsc2V5XG4gICAgICAgIC8vIG1vdXNldHJhcCB3aWxsIG5ldmVyIGZpcmUgZm9yIG51bXBhZCAwIHByZXNzZWQgYXMgcGFydCBvZiBhIGtleWRvd25cbiAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NjYW1wYmVsbC9tb3VzZXRyYXAvcHVsbC8yNThcbiAgICAgICAgX01BUFtpICsgOTZdID0gaS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyb3NzIGJyb3dzZXIgYWRkIGV2ZW50IG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEhUTUxEb2N1bWVudH0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYWRkRXZlbnQob2JqZWN0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAob2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3QuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyB0aGUgZXZlbnQgYW5kIHJldHVybnMgdGhlIGtleSBjaGFyYWN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2NoYXJhY3RlckZyb21FdmVudChlKSB7XG5cbiAgICAgICAgLy8gZm9yIGtleXByZXNzIGV2ZW50cyB3ZSBzaG91bGQgcmV0dXJuIHRoZSBjaGFyYWN0ZXIgYXMgaXNcbiAgICAgICAgaWYgKGUudHlwZSA9PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBub3QgcHJlc3NlZCB0aGVuIGl0IGlzIHNhZmUgdG8gYXNzdW1lXG4gICAgICAgICAgICAvLyB0aGF0IHdlIHdhbnQgdGhlIGNoYXJhY3RlciB0byBiZSBsb3dlcmNhc2UuICB0aGlzIG1lYW5zIGlmXG4gICAgICAgICAgICAvLyB5b3UgYWNjaWRlbnRhbGx5IGhhdmUgY2FwcyBsb2NrIG9uIHRoZW4geW91ciBrZXkgYmluZGluZ3NcbiAgICAgICAgICAgIC8vIHdpbGwgY29udGludWUgdG8gd29ya1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IHNpZGUgZWZmZWN0IHRoYXQgbWlnaHQgbm90IGJlIGRlc2lyZWQgaXMgaWYgeW91XG4gICAgICAgICAgICAvLyBiaW5kIHNvbWV0aGluZyBsaWtlICdBJyBjYXVzZSB5b3Ugd2FudCB0byB0cmlnZ2VyIGFuXG4gICAgICAgICAgICAvLyBldmVudCB3aGVuIGNhcGl0YWwgQSBpcyBwcmVzc2VkIGNhcHMgbG9jayB3aWxsIG5vIGxvbmdlclxuICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnQuICBzaGlmdCthIHdpbGwgdGhvdWdoLlxuICAgICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3Igbm9uIGtleXByZXNzIGV2ZW50cyB0aGUgc3BlY2lhbCBtYXBzIGFyZSBuZWVkZWRcbiAgICAgICAgaWYgKF9NQVBbZS53aGljaF0pIHtcbiAgICAgICAgICAgIHJldHVybiBfTUFQW2Uud2hpY2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9LRVlDT0RFX01BUFtlLndoaWNoXSkge1xuICAgICAgICAgICAgcmV0dXJuIF9LRVlDT0RFX01BUFtlLndoaWNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBpbiB0aGUgc3BlY2lhbCBtYXBcblxuICAgICAgICAvLyB3aXRoIGtleWRvd24gYW5kIGtleXVwIGV2ZW50cyB0aGUgY2hhcmFjdGVyIHNlZW1zIHRvIGFsd2F5c1xuICAgICAgICAvLyBjb21lIGluIGFzIGFuIHVwcGVyY2FzZSBjaGFyYWN0ZXIgd2hldGhlciB5b3UgYXJlIHByZXNzaW5nIHNoaWZ0XG4gICAgICAgIC8vIG9yIG5vdC4gIHdlIHNob3VsZCBtYWtlIHN1cmUgaXQgaXMgYWx3YXlzIGxvd2VyY2FzZSBmb3IgY29tcGFyaXNvbnNcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgdHdvIGFycmF5cyBhcmUgZXF1YWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyczFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gX21vZGlmaWVyc01hdGNoKG1vZGlmaWVyczEsIG1vZGlmaWVyczIpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyczEuc29ydCgpLmpvaW4oJywnKSA9PT0gbW9kaWZpZXJzMi5zb3J0KCkuam9pbignLCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRha2VzIGEga2V5IGV2ZW50IGFuZCBmaWd1cmVzIG91dCB3aGF0IHRoZSBtb2RpZmllcnMgYXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9ldmVudE1vZGlmaWVycyhlKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSBbXTtcblxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3NoaWZ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdhbHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdjdHJsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnbWV0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmV2ZW50cyBkZWZhdWx0IGZvciB0aGlzIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9wcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RvcHMgcHJvcG9nYXRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3N0b3BQcm9wYWdhdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmVzIGlmIHRoZSBrZXljb2RlIHNwZWNpZmllZCBpcyBhIG1vZGlmaWVyIGtleSBvciBub3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaXNNb2RpZmllcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2hpZnQnIHx8IGtleSA9PSAnY3RybCcgfHwga2V5ID09ICdhbHQnIHx8IGtleSA9PSAnbWV0YSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV2ZXJzZXMgdGhlIG1hcCBsb29rdXAgc28gdGhhdCB3ZSBjYW4gbG9vayBmb3Igc3BlY2lmaWMga2V5c1xuICAgICAqIHRvIHNlZSB3aGF0IGNhbiBhbmQgY2FuJ3QgdXNlIGtleXByZXNzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFJldmVyc2VNYXAoKSB7XG4gICAgICAgIGlmICghX1JFVkVSU0VfTUFQKSB7XG4gICAgICAgICAgICBfUkVWRVJTRV9NQVAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfTUFQKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBwdWxsIG91dCB0aGUgbnVtZXJpYyBrZXlwYWQgZnJvbSBoZXJlIGNhdXNlIGtleXByZXNzIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGFibGUgdG8gZGV0ZWN0IHRoZSBrZXlzIGZyb20gdGhlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPiA5NSAmJiBrZXkgPCAxMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9NQVAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBfUkVWRVJTRV9NQVBbX01BUFtrZXldXSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9SRVZFUlNFX01BUDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwaWNrcyB0aGUgYmVzdCBhY3Rpb24gYmFzZWQgb24gdGhlIGtleSBjb21iaW5hdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGNoYXJhY3RlciBmb3Iga2V5XG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb24gcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3BpY2tCZXN0QWN0aW9uKGtleSwgbW9kaWZpZXJzLCBhY3Rpb24pIHtcblxuICAgICAgICAvLyBpZiBubyBhY3Rpb24gd2FzIHBpY2tlZCBpbiB3ZSBzaG91bGQgdHJ5IHRvIHBpY2sgdGhlIG9uZVxuICAgICAgICAvLyB0aGF0IHdlIHRoaW5rIHdvdWxkIHdvcmsgYmVzdCBmb3IgdGhpcyBrZXlcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IF9nZXRSZXZlcnNlTWFwKClba2V5XSA/ICdrZXlkb3duJyA6ICdrZXlwcmVzcyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb2RpZmllciBrZXlzIGRvbid0IHdvcmsgYXMgZXhwZWN0ZWQgd2l0aCBrZXlwcmVzcyxcbiAgICAgICAgLy8gc3dpdGNoIHRvIGtleWRvd25cbiAgICAgICAgaWYgKGFjdGlvbiA9PSAna2V5cHJlc3MnICYmIG1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICdrZXlkb3duJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZnJvbSBhIHN0cmluZyBrZXkgY29tYmluYXRpb24gdG8gYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29tYmluYXRpb24gbGlrZSBcImNvbW1hbmQrc2hpZnQrbFwiXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2tleXNGcm9tU3RyaW5nKGNvbWJpbmF0aW9uKSB7XG4gICAgICAgIGlmIChjb21iaW5hdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgICByZXR1cm4gWycrJ107XG4gICAgICAgIH1cblxuICAgICAgICBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uLnJlcGxhY2UoL1xcK3syfS9nLCAnK3BsdXMnKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmF0aW9uLnNwbGl0KCcrJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvIGZvciBhIHNwZWNpZmljIGtleSBjb21iaW5hdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb21iaW5hdGlvbiBrZXkgY29tYmluYXRpb24gKFwiY29tbWFuZCtzXCIgb3IgXCJhXCIgb3IgXCIqXCIpXG4gICAgICogQHBhcmFtICB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZ2V0S2V5SW5mbyhjb21iaW5hdGlvbiwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBrZXlzO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFtdO1xuXG4gICAgICAgIC8vIHRha2UgdGhlIGtleXMgZnJvbSB0aGlzIHBhdHRlcm4gYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgYWN0dWFsXG4gICAgICAgIC8vIHBhdHRlcm4gaXMgYWxsIGFib3V0XG4gICAgICAgIGtleXMgPSBfa2V5c0Zyb21TdHJpbmcoY29tYmluYXRpb24pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUga2V5IG5hbWVzXG4gICAgICAgICAgICBpZiAoX1NQRUNJQUxfQUxJQVNFU1trZXldKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gX1NQRUNJQUxfQUxJQVNFU1trZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGtleXByZXNzIGV2ZW50IHRoZW4gd2Ugc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSBzbWFydCBhYm91dCB1c2luZyBzaGlmdCBrZXlzXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgb25seSB3b3JrIGZvciBVUyBrZXlib2FyZHMgaG93ZXZlclxuICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24gIT0gJ2tleXByZXNzJyAmJiBfU0hJRlRfTUFQW2tleV0pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBfU0hJRlRfTUFQW2tleV07XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3NoaWZ0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMga2V5IGlzIGEgbW9kaWZpZXIgdGhlbiBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgbW9kaWZpZXJzXG4gICAgICAgICAgICBpZiAoX2lzTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gd2hhdCB0aGUga2V5IGNvbWJpbmF0aW9uIGlzXG4gICAgICAgIC8vIHdlIHdpbGwgdHJ5IHRvIHBpY2sgdGhlIGJlc3QgZXZlbnQgZm9yIGl0XG4gICAgICAgIGFjdGlvbiA9IF9waWNrQmVzdEFjdGlvbihrZXksIG1vZGlmaWVycywgYWN0aW9uKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2JlbG9uZ3NUbyhlbGVtZW50LCBhbmNlc3Rvcikge1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfYmVsb25nc1RvKGVsZW1lbnQucGFyZW50Tm9kZSwgYW5jZXN0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE1vdXNldHJhcCh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudCB8fCBkb2N1bWVudDtcblxuICAgICAgICBpZiAoIShzZWxmIGluc3RhbmNlb2YgTW91c2V0cmFwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3VzZXRyYXAodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZWxlbWVudCB0byBhdHRhY2gga2V5IGV2ZW50cyB0b1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYudGFyZ2V0ID0gdGFyZ2V0RWxlbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYSBsaXN0IG9mIGFsbCB0aGUgY2FsbGJhY2tzIHNldHVwIHZpYSBNb3VzZXRyYXAuYmluZCgpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLl9jYWxsYmFja3MgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGlyZWN0IG1hcCBvZiBzdHJpbmcgY29tYmluYXRpb25zIHRvIGNhbGxiYWNrcyB1c2VkIGZvciB0cmlnZ2VyKClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2RpcmVjdE1hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBrZWVwcyB0cmFjayBvZiB3aGF0IGxldmVsIGVhY2ggc2VxdWVuY2UgaXMgYXQgc2luY2UgbXVsdGlwbGVcbiAgICAgICAgICogc2VxdWVuY2VzIGNhbiBzdGFydCBvdXQgd2l0aCB0aGUgc2FtZSBzZXF1ZW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9zZXF1ZW5jZUxldmVscyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YXJpYWJsZSB0byBzdG9yZSB0aGUgc2V0VGltZW91dCBjYWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudWxsfG51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfcmVzZXRUaW1lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGVtcG9yYXJ5IHN0YXRlIHdoZXJlIHdlIHdpbGwgaWdub3JlIHRoZSBuZXh0IGtleXVwXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfaWdub3JlTmV4dEtleXVwID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRlbXBvcmFyeSBzdGF0ZSB3aGVyZSB3ZSB3aWxsIGlnbm9yZSB0aGUgbmV4dCBrZXlwcmVzc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfaWdub3JlTmV4dEtleXByZXNzID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFyZSB3ZSBjdXJyZW50bHkgaW5zaWRlIG9mIGEgc2VxdWVuY2U/XG4gICAgICAgICAqIHR5cGUgb2YgYWN0aW9uIChcImtleXVwXCIgb3IgXCJrZXlkb3duXCIgb3IgXCJrZXlwcmVzc1wiKSBvciBmYWxzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX25leHRFeHBlY3RlZEFjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXNldHMgYWxsIHNlcXVlbmNlIGNvdW50ZXJzIGV4Y2VwdCBmb3IgdGhlIG9uZXMgcGFzc2VkIGluXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkb05vdFJlc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9yZXNldFNlcXVlbmNlcyhkb05vdFJlc2V0KSB7XG4gICAgICAgICAgICBkb05vdFJlc2V0ID0gZG9Ob3RSZXNldCB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIGFjdGl2ZVNlcXVlbmNlcyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtleTtcblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gX3NlcXVlbmNlTGV2ZWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvTm90UmVzZXRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVTZXF1ZW5jZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3NlcXVlbmNlTGV2ZWxzW2tleV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVNlcXVlbmNlcykge1xuICAgICAgICAgICAgICAgIF9uZXh0RXhwZWN0ZWRBY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaW5kcyBhbGwgY2FsbGJhY2tzIHRoYXQgbWF0Y2ggYmFzZWQgb24gdGhlIGtleWNvZGUsIG1vZGlmaWVycyxcbiAgICAgICAgICogYW5kIGFjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fE9iamVjdH0gZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNlcXVlbmNlTmFtZSAtIG5hbWUgb2YgdGhlIHNlcXVlbmNlIHdlIGFyZSBsb29raW5nIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGNvbWJpbmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGV2ZWxcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2dldE1hdGNoZXMoY2hhcmFjdGVyLCBtb2RpZmllcnMsIGUsIHNlcXVlbmNlTmFtZSwgY29tYmluYXRpb24sIGxldmVsKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gZS50eXBlO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIHJlbGF0ZWQgdG8gdGhpcyBrZXljb2RlXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhIG1vZGlmaWVyIGtleSBpcyBjb21pbmcgdXAgb24gaXRzIG93biB3ZSBzaG91bGQgYWxsb3cgaXRcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gJ2tleXVwJyAmJiBfaXNNb2RpZmllcihjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzID0gW2NoYXJhY3Rlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgY2FsbGJhY2tzIGZvciB0aGUga2V5IHRoYXQgd2FzIHByZXNzZWRcbiAgICAgICAgICAgIC8vIGFuZCBzZWUgaWYgYW55IG9mIHRoZW0gbWF0Y2hcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLl9jYWxsYmFja3NbY2hhcmFjdGVyXS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl1baV07XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhIHNlcXVlbmNlIG5hbWUgaXMgbm90IHNwZWNpZmllZCwgYnV0IHRoaXMgaXMgYSBzZXF1ZW5jZSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSB3cm9uZyBsZXZlbCB0aGVuIG1vdmUgb250byB0aGUgbmV4dCBtYXRjaFxuICAgICAgICAgICAgICAgIGlmICghc2VxdWVuY2VOYW1lICYmIGNhbGxiYWNrLnNlcSAmJiBfc2VxdWVuY2VMZXZlbHNbY2FsbGJhY2suc2VxXSAhPSBjYWxsYmFjay5sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYWN0aW9uIHdlIGFyZSBsb29raW5nIGZvciBkb2Vzbid0IG1hdGNoIHRoZSBhY3Rpb24gd2UgZ290XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBzaG91bGQga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT0gY2FsbGJhY2suYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBrZXlwcmVzcyBldmVudCBhbmQgdGhlIG1ldGEga2V5IGFuZCBjb250cm9sIGtleVxuICAgICAgICAgICAgICAgIC8vIGFyZSBub3QgcHJlc3NlZCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBvbmx5IGxvb2sgYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBvdGhlcndpc2UgY2hlY2sgdGhlIG1vZGlmaWVycyBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBjaHJvbWUgd2lsbCBub3QgZmlyZSBhIGtleXByZXNzIGlmIG1ldGEgb3IgY29udHJvbCBpcyBkb3duXG4gICAgICAgICAgICAgICAgLy8gc2FmYXJpIHdpbGwgZmlyZSBhIGtleXByZXNzIGlmIG1ldGEgb3IgbWV0YStzaGlmdCBpcyBkb3duXG4gICAgICAgICAgICAgICAgLy8gZmlyZWZveCB3aWxsIGZpcmUgYSBrZXlwcmVzcyBpZiBtZXRhIG9yIGNvbnRyb2wgaXMgZG93blxuICAgICAgICAgICAgICAgIGlmICgoYWN0aW9uID09ICdrZXlwcmVzcycgJiYgIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5KSB8fCBfbW9kaWZpZXJzTWF0Y2gobW9kaWZpZXJzLCBjYWxsYmFjay5tb2RpZmllcnMpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB5b3UgYmluZCBhIGNvbWJpbmF0aW9uIG9yIHNlcXVlbmNlIGEgc2Vjb25kIHRpbWUgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lLiAgaWYgYSBzZXF1ZW5jZU5hbWUgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tYmluYXRpb24gaXMgc3BlY2lmaWVkIGluIHRoaXMgY2FsbCBpdCBkb2VzIGp1c3QgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbyBtYWtlIGRlbGV0aW5nIGl0cyBvd24gbWV0aG9kP1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlQ29tYm8gPSAhc2VxdWVuY2VOYW1lICYmIGNhbGxiYWNrLmNvbWJvID09IGNvbWJpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlU2VxdWVuY2UgPSBzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2suc2VxID09IHNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5sZXZlbCA9PSBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUNvbWJvIHx8IGRlbGV0ZVNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYWxsYmFja3NbY2hhcmFjdGVyXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYWN0dWFsbHkgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIGlmIHlvdXIgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB0aGlzIHdpbGwgdXNlIHRoZSBqcXVlcnlcbiAgICAgICAgICogY29udmVudGlvbiAtIHByZXZlbnQgZGVmYXVsdCBhbmQgc3RvcCBwcm9wb2dhdGlvbiBvbiB0aGUgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrLCBlLCBjb21ibywgc2VxdWVuY2UpIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBldmVudCBzaG91bGQgbm90IGhhcHBlbiBzdG9wIGhlcmVcbiAgICAgICAgICAgIGlmIChzZWxmLnN0b3BDYWxsYmFjayhlLCBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsIGNvbWJvLCBzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhlLCBjb21ibykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgICAgIF9zdG9wUHJvcGFnYXRpb24oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaGFuZGxlcyBhIGNoYXJhY3RlciBrZXkgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLl9oYW5kbGVLZXkgPSBmdW5jdGlvbihjaGFyYWN0ZXIsIG1vZGlmaWVycywgZSkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF9nZXRNYXRjaGVzKGNoYXJhY3RlciwgbW9kaWZpZXJzLCBlKTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGRvTm90UmVzZXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtYXhMZXZlbCA9IDA7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG1heExldmVsIGZvciBzZXF1ZW5jZXMgc28gd2UgY2FuIG9ubHkgZXhlY3V0ZSB0aGUgbG9uZ2VzdCBjYWxsYmFjayBzZXF1ZW5jZVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3NbaV0uc2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heExldmVsID0gTWF0aC5tYXgobWF4TGV2ZWwsIGNhbGxiYWNrc1tpXS5sZXZlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggbWF0Y2hpbmcgY2FsbGJhY2tzIGZvciB0aGlzIGtleSBldmVudFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyZSBmb3IgYWxsIHNlcXVlbmNlIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBpZiBmb3IgZXhhbXBsZSB5b3UgaGF2ZSBtdWx0aXBsZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyBib3VuZCBzdWNoIGFzIFwiZyBpXCIgYW5kIFwiZyB0XCIgdGhleSBib3RoIG5lZWQgdG8gZmlyZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayBmb3IgbWF0Y2hpbmcgZyBjYXVzZSBvdGhlcndpc2UgeW91IGNhbiBvbmx5IGV2ZXJcbiAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXS5zZXEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGZpcmUgY2FsbGJhY2tzIGZvciB0aGUgbWF4TGV2ZWwgdG8gcHJldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW5jZXMgZnJvbSBhbHNvIGZpcmluZ1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSAnYSBvcHRpb24gYicgc2hvdWxkIG5vdCBjYXVzZSAnb3B0aW9uIGInIHRvIGZpcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiB0aG91Z2ggJ29wdGlvbiBiJyBpcyBwYXJ0IG9mIHRoZSBvdGhlciBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc2VxdWVuY2VzIHRoYXQgZG8gbm90IG1hdGNoIGhlcmUgd2lsbCBiZSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVsb3cgYnkgdGhlIF9yZXNldFNlcXVlbmNlcyBjYWxsXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3NbaV0ubGV2ZWwgIT0gbWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjayA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIGxpc3Qgb2Ygd2hpY2ggc2VxdWVuY2VzIHdlcmUgbWF0Y2hlcyBmb3IgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgZG9Ob3RSZXNldFtjYWxsYmFja3NbaV0uc2VxXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2tzW2ldLmNhbGxiYWNrLCBlLCBjYWxsYmFja3NbaV0uY29tYm8sIGNhbGxiYWNrc1tpXS5zZXEpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3ZXJlIG5vIHNlcXVlbmNlIG1hdGNoZXMgYnV0IHdlIGFyZSBzdGlsbCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBtZWFucyB0aGlzIGlzIGEgcmVndWxhciBtYXRjaCBzbyB3ZSBzaG91bGQgZmlyZSB0aGF0XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2tzW2ldLmNhbGxiYWNrLCBlLCBjYWxsYmFja3NbaV0uY29tYm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIGtleSB5b3UgcHJlc3NlZCBtYXRjaGVzIHRoZSB0eXBlIG9mIHNlcXVlbmNlIHdpdGhvdXRcbiAgICAgICAgICAgIC8vIGJlaW5nIGEgbW9kaWZpZXIgKGllIFwia2V5dXBcIiBvciBcImtleXByZXNzXCIpIHRoZW4gd2Ugc2hvdWxkXG4gICAgICAgICAgICAvLyByZXNldCBhbGwgc2VxdWVuY2VzIHRoYXQgd2VyZSBub3QgbWF0Y2hlZCBieSB0aGlzIGV2ZW50XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBzbywgZm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIHRoZSBzZXF1ZW5jZSBcImggYSB0XCIgYW5kIHlvdVxuICAgICAgICAgICAgLy8gdHlwZSBcImggZSBhIHIgdFwiIGl0IGRvZXMgbm90IG1hdGNoLiAgaW4gdGhpcyBjYXNlIHRoZSBcImVcIiB3aWxsXG4gICAgICAgICAgICAvLyBjYXVzZSB0aGUgc2VxdWVuY2UgdG8gcmVzZXRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBtb2RpZmllciBrZXlzIGFyZSBpZ25vcmVkIGJlY2F1c2UgeW91IGNhbiBoYXZlIGEgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIHRoYXQgY29udGFpbnMgbW9kaWZpZXJzIHN1Y2ggYXMgXCJlbnRlciBjdHJsK3NwYWNlXCIgYW5kIGluIG1vc3RcbiAgICAgICAgICAgIC8vIGNhc2VzIHRoZSBtb2RpZmllciBrZXkgd2lsbCBiZSBwcmVzc2VkIGJlZm9yZSB0aGUgbmV4dCBrZXlcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBhbHNvIGlmIHlvdSBoYXZlIGEgc2VxdWVuY2Ugc3VjaCBhcyBcImN0cmwrYiBhXCIgdGhlbiBwcmVzc2luZyB0aGVcbiAgICAgICAgICAgIC8vIFwiYlwiIGtleSB3aWxsIHRyaWdnZXIgYSBcImtleXByZXNzXCIgYW5kIGEgXCJrZXlkb3duXCJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGUgXCJrZXlkb3duXCIgaXMgZXhwZWN0ZWQgd2hlbiB0aGVyZSBpcyBhIG1vZGlmaWVyLCBidXQgdGhlXG4gICAgICAgICAgICAvLyBcImtleXByZXNzXCIgZW5kcyB1cCBtYXRjaGluZyB0aGUgX25leHRFeHBlY3RlZEFjdGlvbiBzaW5jZSBpdCBvY2N1cnNcbiAgICAgICAgICAgIC8vIGFmdGVyIGFuZCB0aGF0IGNhdXNlcyB0aGUgc2VxdWVuY2UgdG8gcmVzZXRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB3ZSBpZ25vcmUga2V5cHJlc3NlcyBpbiBhIHNlcXVlbmNlIHRoYXQgZGlyZWN0bHkgZm9sbG93IGEga2V5ZG93blxuICAgICAgICAgICAgLy8gZm9yIHRoZSBzYW1lIGNoYXJhY3RlclxuICAgICAgICAgICAgdmFyIGlnbm9yZVRoaXNLZXlwcmVzcyA9IGUudHlwZSA9PSAna2V5cHJlc3MnICYmIF9pZ25vcmVOZXh0S2V5cHJlc3M7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09IF9uZXh0RXhwZWN0ZWRBY3Rpb24gJiYgIV9pc01vZGlmaWVyKGNoYXJhY3RlcikgJiYgIWlnbm9yZVRoaXNLZXlwcmVzcykge1xuICAgICAgICAgICAgICAgIF9yZXNldFNlcXVlbmNlcyhkb05vdFJlc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lnbm9yZU5leHRLZXlwcmVzcyA9IHByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2sgJiYgZS50eXBlID09ICdrZXlkb3duJztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGFuZGxlcyBhIGtleWRvd24gZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfaGFuZGxlS2V5RXZlbnQoZSkge1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgZS53aGljaCBmb3Iga2V5IGV2ZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyODU2MjcvamF2YXNjcmlwdC1rZXljb2RlLXZzLWNoYXJjb2RlLXV0dGVyLWNvbmZ1c2lvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlLndoaWNoICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGUud2hpY2ggPSBlLmtleUNvZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBfY2hhcmFjdGVyRnJvbUV2ZW50KGUpO1xuXG4gICAgICAgICAgICAvLyBubyBjaGFyYWN0ZXIgZm91bmQgdGhlbiBzdG9wXG4gICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgPT09IGZvciB0aGUgY2hhcmFjdGVyIGNoZWNrIGJlY2F1c2UgdGhlIGNoYXJhY3RlciBjYW4gYmUgMFxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PSAna2V5dXAnICYmIF9pZ25vcmVOZXh0S2V5dXAgPT09IGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIF9pZ25vcmVOZXh0S2V5dXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuaGFuZGxlS2V5KGNoYXJhY3RlciwgX2V2ZW50TW9kaWZpZXJzKGUpLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYWxsZWQgdG8gc2V0IGEgMSBzZWNvbmQgdGltZW91dCBvbiB0aGUgc3BlY2lmaWVkIHNlcXVlbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIHRoaXMgaXMgc28gYWZ0ZXIgZWFjaCBrZXkgcHJlc3MgaW4gdGhlIHNlcXVlbmNlIHlvdSBoYXZlIDEgc2Vjb25kXG4gICAgICAgICAqIHRvIHByZXNzIHRoZSBuZXh0IGtleSBiZWZvcmUgeW91IGhhdmUgdG8gc3RhcnQgb3ZlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfcmVzZXRTZXF1ZW5jZVRpbWVyKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9yZXNldFRpbWVyKTtcbiAgICAgICAgICAgIF9yZXNldFRpbWVyID0gc2V0VGltZW91dChfcmVzZXRTZXF1ZW5jZXMsIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJpbmRzIGEga2V5IHNlcXVlbmNlIHRvIGFuIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21ibyAtIGNvbWJvIHNwZWNpZmllZCBpbiBiaW5kIGNhbGxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0ga2V5c1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfYmluZFNlcXVlbmNlKGNvbWJvLCBrZXlzLCBjYWxsYmFjaywgYWN0aW9uKSB7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IG9mZiBieSBhZGRpbmcgYSBzZXF1ZW5jZSBsZXZlbCByZWNvcmQgZm9yIHRoaXMgY29tYmluYXRpb25cbiAgICAgICAgICAgIC8vIGFuZCBzZXR0aW5nIHRoZSBsZXZlbCB0byAwXG4gICAgICAgICAgICBfc2VxdWVuY2VMZXZlbHNbY29tYm9dID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjYWxsYmFjayB0byBpbmNyZWFzZSB0aGUgc2VxdWVuY2UgbGV2ZWwgZm9yIHRoaXMgc2VxdWVuY2UgYW5kIHJlc2V0XG4gICAgICAgICAgICAgKiBhbGwgb3RoZXIgc2VxdWVuY2VzIHRoYXQgd2VyZSBhY3RpdmVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dEFjdGlvblxuICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfaW5jcmVhc2VTZXF1ZW5jZShuZXh0QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfbmV4dEV4cGVjdGVkQWN0aW9uID0gbmV4dEFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgKytfc2VxdWVuY2VMZXZlbHNbY29tYm9dO1xuICAgICAgICAgICAgICAgICAgICBfcmVzZXRTZXF1ZW5jZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB3cmFwcyB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uIGluIG9yZGVyXG4gICAgICAgICAgICAgKiB0byByZXNldCBhbGwgc2VxdWVuY2UgY291bnRlcnMgYXMgc29vbiBhcyB0aGlzIHNlcXVlbmNlIGlzIGRvbmVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9jYWxsYmFja0FuZFJlc2V0KGUpIHtcbiAgICAgICAgICAgICAgICBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrLCBlLCBjb21ibyk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgaWdub3JlIHRoZSBuZXh0IGtleSB1cCBpZiB0aGUgYWN0aW9uIGlzIGtleSBkb3duXG4gICAgICAgICAgICAgICAgLy8gb3Iga2V5cHJlc3MuICB0aGlzIGlzIHNvIGlmIHlvdSBmaW5pc2ggYSBzZXF1ZW5jZSBhbmRcbiAgICAgICAgICAgICAgICAvLyByZWxlYXNlIHRoZSBrZXkgdGhlIGZpbmFsIGtleSB3aWxsIG5vdCB0cmlnZ2VyIGEga2V5dXBcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pZ25vcmVOZXh0S2V5dXAgPSBfY2hhcmFjdGVyRnJvbUV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdlaXJkIHJhY2UgY29uZGl0aW9uIGlmIGEgc2VxdWVuY2UgZW5kcyB3aXRoIHRoZSBrZXlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIHNlcXVlbmNlIGJlZ2lucyB3aXRoXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChfcmVzZXRTZXF1ZW5jZXMsIDEwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGtleXMgb25lIGF0IGEgdGltZSBhbmQgYmluZCB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uLiAgZm9yIGFueSBrZXkgbGVhZGluZyB1cCB0byB0aGUgZmluYWwgb25lIGl0IHNob3VsZFxuICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIHNlcXVlbmNlLiBhZnRlciB0aGUgZmluYWwsIGl0IHNob3VsZCByZXNldCBhbGwgc2VxdWVuY2VzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaWYgYW4gYWN0aW9uIGlzIHNwZWNpZmllZCBpbiB0aGUgb3JpZ2luYWwgYmluZCBjYWxsIHRoZW4gdGhhdCB3aWxsXG4gICAgICAgICAgICAvLyBiZSB1c2VkIHRocm91Z2hvdXQuICBvdGhlcndpc2Ugd2Ugd2lsbCBwYXNzIHRoZSBhY3Rpb24gdGhhdCB0aGVcbiAgICAgICAgICAgIC8vIG5leHQga2V5IGluIHRoZSBzZXF1ZW5jZSBzaG91bGQgbWF0Y2guICB0aGlzIGFsbG93cyBhIHNlcXVlbmNlXG4gICAgICAgICAgICAvLyB0byBtaXggYW5kIG1hdGNoIGtleXByZXNzIGFuZCBrZXlkb3duIGV2ZW50cyBkZXBlbmRpbmcgb24gd2hpY2hcbiAgICAgICAgICAgIC8vIG9uZXMgYXJlIGJldHRlciBzdWl0ZWQgdG8gdGhlIGtleSBwcm92aWRlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRmluYWwgPSBpICsgMSA9PT0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRDYWxsYmFjayA9IGlzRmluYWwgPyBfY2FsbGJhY2tBbmRSZXNldCA6IF9pbmNyZWFzZVNlcXVlbmNlKGFjdGlvbiB8fCBfZ2V0S2V5SW5mbyhrZXlzW2kgKyAxXSkuYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBfYmluZFNpbmdsZShrZXlzW2ldLCB3cmFwcGVkQ2FsbGJhY2ssIGFjdGlvbiwgY29tYm8sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJpbmRzIGEgc2luZ2xlIGtleWJvYXJkIGNvbWJpbmF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21iaW5hdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNlcXVlbmNlTmFtZSAtIG5hbWUgb2Ygc2VxdWVuY2UgaWYgcGFydCBvZiBzZXF1ZW5jZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGxldmVsIC0gd2hhdCBwYXJ0IG9mIHRoZSBzZXF1ZW5jZSB0aGUgY29tbWFuZCBpc1xuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfYmluZFNpbmdsZShjb21iaW5hdGlvbiwgY2FsbGJhY2ssIGFjdGlvbiwgc2VxdWVuY2VOYW1lLCBsZXZlbCkge1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBhIGRpcmVjdCBtYXBwZWQgcmVmZXJlbmNlIGZvciB1c2Ugd2l0aCBNb3VzZXRyYXAudHJpZ2dlclxuICAgICAgICAgICAgc2VsZi5fZGlyZWN0TWFwW2NvbWJpbmF0aW9uICsgJzonICsgYWN0aW9uXSA9IGNhbGxiYWNrO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgbXVsdGlwbGUgc3BhY2VzIGluIGEgcm93IGJlY29tZSBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgY29tYmluYXRpb24gPSBjb21iaW5hdGlvbi5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG5cbiAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IGNvbWJpbmF0aW9uLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICB2YXIgaW5mbztcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBwYXR0ZXJuIGlzIGEgc2VxdWVuY2Ugb2Yga2V5cyB0aGVuIHJ1biB0aHJvdWdoIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAvLyB0byByZXByb2Nlc3MgZWFjaCBwYXR0ZXJuIG9uZSBrZXkgYXQgYSB0aW1lXG4gICAgICAgICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIF9iaW5kU2VxdWVuY2UoY29tYmluYXRpb24sIHNlcXVlbmNlLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluZm8gPSBfZ2V0S2V5SW5mbyhjb21iaW5hdGlvbiwgYWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGluaXRpYWxpemUgYXJyYXkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgLy8gYSBjYWxsYmFjayBpcyBhZGRlZCBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgIHNlbGYuX2NhbGxiYWNrc1tpbmZvLmtleV0gPSBzZWxmLl9jYWxsYmFja3NbaW5mby5rZXldIHx8IFtdO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgYW4gZXhpc3RpbmcgbWF0Y2ggaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICBfZ2V0TWF0Y2hlcyhpbmZvLmtleSwgaW5mby5tb2RpZmllcnMsIHt0eXBlOiBpbmZvLmFjdGlvbn0sIHNlcXVlbmNlTmFtZSwgY29tYmluYXRpb24sIGxldmVsKTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoaXMgY2FsbCBiYWNrIHRvIHRoZSBhcnJheVxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYSBzZXF1ZW5jZSBwdXQgaXQgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgLy8gaWYgbm90IHB1dCBpdCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgd2F5IHRoZXNlIGFyZSBwcm9jZXNzZWQgZXhwZWN0c1xuICAgICAgICAgICAgLy8gdGhlIHNlcXVlbmNlIG9uZXMgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tzW2luZm8ua2V5XVtzZXF1ZW5jZU5hbWUgPyAndW5zaGlmdCcgOiAncHVzaCddKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBpbmZvLm1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGluZm8uYWN0aW9uLFxuICAgICAgICAgICAgICAgIHNlcTogc2VxdWVuY2VOYW1lLFxuICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICBjb21ibzogY29tYmluYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJpbmRzIG11bHRpcGxlIGNvbWJpbmF0aW9ucyB0byB0aGUgc2FtZSBjYWxsYmFja1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBjb21iaW5hdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBhY3Rpb25cbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5fYmluZE11bHRpcGxlID0gZnVuY3Rpb24oY29tYmluYXRpb25zLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbWJpbmF0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIF9iaW5kU2luZ2xlKGNvbWJpbmF0aW9uc1tpXSwgY2FsbGJhY2ssIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RhcnQhXG4gICAgICAgIF9hZGRFdmVudCh0YXJnZXRFbGVtZW50LCAna2V5cHJlc3MnLCBfaGFuZGxlS2V5RXZlbnQpO1xuICAgICAgICBfYWRkRXZlbnQodGFyZ2V0RWxlbWVudCwgJ2tleWRvd24nLCBfaGFuZGxlS2V5RXZlbnQpO1xuICAgICAgICBfYWRkRXZlbnQodGFyZ2V0RWxlbWVudCwgJ2tleXVwJywgX2hhbmRsZUtleUV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBiaW5kcyBhbiBldmVudCB0byBtb3VzZXRyYXBcbiAgICAgKlxuICAgICAqIGNhbiBiZSBhIHNpbmdsZSBrZXksIGEgY29tYmluYXRpb24gb2Yga2V5cyBzZXBhcmF0ZWQgd2l0aCArLFxuICAgICAqIGFuIGFycmF5IG9mIGtleXMsIG9yIGEgc2VxdWVuY2Ugb2Yga2V5cyBzZXBhcmF0ZWQgYnkgc3BhY2VzXG4gICAgICpcbiAgICAgKiBiZSBzdXJlIHRvIGxpc3QgdGhlIG1vZGlmaWVyIGtleXMgZmlyc3QgdG8gbWFrZSBzdXJlIHRoYXQgdGhlXG4gICAgICogY29ycmVjdCBrZXkgZW5kcyB1cCBnZXR0aW5nIGJvdW5kICh0aGUgbGFzdCBrZXkgaW4gdGhlIHBhdHRlcm4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb24gLSAna2V5cHJlc3MnLCAna2V5ZG93bicsIG9yICdrZXl1cCdcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oa2V5cywgY2FsbGJhY2ssIGFjdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXkgPyBrZXlzIDogW2tleXNdO1xuICAgICAgICBzZWxmLl9iaW5kTXVsdGlwbGUuY2FsbChzZWxmLCBrZXlzLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHVuYmluZHMgYW4gZXZlbnQgdG8gbW91c2V0cmFwXG4gICAgICpcbiAgICAgKiB0aGUgdW5iaW5kaW5nIHNldHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIG9mIHRoZSBzcGVjaWZpZWQga2V5IGNvbWJvXG4gICAgICogdG8gYW4gZW1wdHkgZnVuY3Rpb24gYW5kIGRlbGV0ZXMgdGhlIGNvcnJlc3BvbmRpbmcga2V5IGluIHRoZVxuICAgICAqIF9kaXJlY3RNYXAgZGljdC5cbiAgICAgKlxuICAgICAqIFRPRE86IGFjdHVhbGx5IHJlbW92ZSB0aGlzIGZyb20gdGhlIF9jYWxsYmFja3MgZGljdGlvbmFyeSBpbnN0ZWFkXG4gICAgICogb2YgYmluZGluZyBhbiBlbXB0eSBmdW5jdGlvblxuICAgICAqXG4gICAgICogdGhlIGtleWNvbWJvK2FjdGlvbiBoYXMgdG8gYmUgZXhhY3RseSB0aGUgc2FtZSBhc1xuICAgICAqIGl0IHdhcyBkZWZpbmVkIGluIHRoZSBiaW5kIG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oa2V5cywgYWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYuYmluZC5jYWxsKHNlbGYsIGtleXMsIGZ1bmN0aW9uKCkge30sIGFjdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRyaWdnZXJzIGFuIGV2ZW50IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihrZXlzLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5fZGlyZWN0TWFwW2tleXMgKyAnOicgKyBhY3Rpb25dKSB7XG4gICAgICAgICAgICBzZWxmLl9kaXJlY3RNYXBba2V5cyArICc6JyArIGFjdGlvbl0oe30sIGtleXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXNldHMgdGhlIGxpYnJhcnkgYmFjayB0byBpdHMgaW5pdGlhbCBzdGF0ZS4gIHRoaXMgaXMgdXNlZnVsXG4gICAgICogaWYgeW91IHdhbnQgdG8gY2xlYXIgb3V0IHRoZSBjdXJyZW50IGtleWJvYXJkIHNob3J0Y3V0cyBhbmQgYmluZFxuICAgICAqIG5ldyBvbmVzIC0gZm9yIGV4YW1wbGUgaWYgeW91IHN3aXRjaCB0byBhbm90aGVyIHBhZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5fY2FsbGJhY2tzID0ge307XG4gICAgICAgIHNlbGYuX2RpcmVjdE1hcCA9IHt9O1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIHdlIHN0b3AgdGhpcyBldmVudCBiZWZvcmUgZmlyaW5nIG9mZiBjYWxsYmFja3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oZSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBcIm1vdXNldHJhcFwiIHRoZW4gbm8gbmVlZCB0byBzdG9wXG4gICAgICAgIGlmICgoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyBtb3VzZXRyYXAgJykgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9iZWxvbmdzVG8oZWxlbWVudCwgc2VsZi50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wIGZvciBpbnB1dCwgc2VsZWN0LCBhbmQgdGV4dGFyZWFcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PSAnSU5QVVQnIHx8IGVsZW1lbnQudGFnTmFtZSA9PSAnU0VMRUNUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT0gJ1RFWFRBUkVBJyB8fCBlbGVtZW50LmlzQ29udGVudEVkaXRhYmxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBleHBvc2VzIF9oYW5kbGVLZXkgcHVibGljbHkgc28gaXQgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLmhhbmRsZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZWxmLl9oYW5kbGVLZXkuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYWxsb3cgY3VzdG9tIGtleSBtYXBwaW5nc1xuICAgICAqL1xuICAgIE1vdXNldHJhcC5hZGRLZXljb2RlcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBfTUFQW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfUkVWRVJTRV9NQVAgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0IHRoZSBnbG9iYWwgbW91c2V0cmFwIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbmVlZGVkIHRvIGFsbG93IHRoZSBnbG9iYWwgbW91c2V0cmFwIGZ1bmN0aW9ucyB0byB3b3JrXG4gICAgICogbm93IHRoYXQgbW91c2V0cmFwIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgTW91c2V0cmFwLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50TW91c2V0cmFwID0gTW91c2V0cmFwKGRvY3VtZW50KTtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIGRvY3VtZW50TW91c2V0cmFwKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kLmNoYXJBdCgwKSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgTW91c2V0cmFwW21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudE1vdXNldHJhcFttZXRob2RdLmFwcGx5KGRvY3VtZW50TW91c2V0cmFwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gKG1ldGhvZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1vdXNldHJhcC5pbml0KCk7XG5cbiAgICAvLyBleHBvc2UgbW91c2V0cmFwIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG4gICAgd2luZG93Lk1vdXNldHJhcCA9IE1vdXNldHJhcDtcblxuICAgIC8vIGV4cG9zZSBhcyBhIGNvbW1vbiBqcyBtb2R1bGVcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBNb3VzZXRyYXA7XG4gICAgfVxuXG4gICAgLy8gZXhwb3NlIG1vdXNldHJhcCBhcyBhbiBBTUQgbW9kdWxlXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gTW91c2V0cmFwO1xuICAgICAgICB9KTtcbiAgICB9XG59KSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsLCB0eXBlb2YgIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGwpO1xuXG4vLyBsdWhuIGV4dHJhIHZhbGlkYXRvcnNcbndpbmRvdy5QYXJzbGV5Q29uZmlnID0gd2luZG93LlBhcnNsZXlDb25maWcgfHwge307XG53aW5kb3cuUGFyc2xleUNvbmZpZy52YWxpZGF0b3JzID0gd2luZG93LlBhcnNsZXlDb25maWcudmFsaWRhdG9ycyB8fCB7fTtcblxud2luZG93LlBhcnNsZXlDb25maWcudmFsaWRhdG9ycy5sdWhuID0ge1xuICBmbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIC1dL2csICcnKTtcbiAgICB2YXIgZGlnaXQ7XG4gICAgdmFyIG47XG4gICAgdmFyIF9qO1xuICAgIHZhciBfbGVuMTtcbiAgICB2YXIgX3JlZjI7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgX3JlZjIgPSB2YWx1ZS5zcGxpdCgnJykucmV2ZXJzZSgpO1xuICAgIGZvciAobiA9IF9qID0gMCwgX2xlbjEgPSBfcmVmMi5sZW5ndGg7IF9qIDwgX2xlbjE7IG4gPSArK19qKSB7XG4gICAgICBkaWdpdCA9IF9yZWYyW25dO1xuICAgICAgZGlnaXQgPSArZGlnaXQ7XG4gICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgZGlnaXQgKj0gMjtcbiAgICAgICAgaWYgKGRpZ2l0IDwgMTApIHtcbiAgICAgICAgICBzdW0gKz0gZGlnaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VtICs9IGRpZ2l0IC0gOTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG4gIH0sXG4gIHByaW9yaXR5OiAzMlxufTtcblxuLyohXG4qIFBhcnNsZXkuanNcbiogVmVyc2lvbiAyLjguMSAtIGJ1aWx0IFNhdCwgRmViIDNyZCAyMDE4LCAyOjI3IHBtXG4qIGh0dHA6Ly9wYXJzbGV5anMub3JnXG4qIEd1aWxsYXVtZSBQb3RpZXIgLSA8Z3VpbGxhdW1lQHdpc2VtYmx5LmNvbT5cbiogTWFyYy1BbmRyZSBMYWZvcnR1bmUgLSA8cGV0cm9zZWxpbnVtQG1hcmMtYW5kcmUuY2E+XG4qIE1JVCBMaWNlbnNlZFxuKi9cblxuLy8gVGhlIHNvdXJjZSBjb2RlIGJlbG93IGlzIGdlbmVyYXRlZCBieSBiYWJlbCBhc1xuLy8gUGFyc2xleSBpcyB3cml0dGVuIGluIEVDTUFTY3JpcHQgNlxuLy9cbnZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpIDogZ2xvYmFsLnBhcnNsZXkgPSBmYWN0b3J5KGdsb2JhbC5qUXVlcnkpO1xufSkodGhpcywgZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBnbG9iYWxJRCA9IDE7XG4gIHZhciBwYXN0V2FybmluZ3MgPSB7fTtcblxuICB2YXIgVXRpbHMgPSB7XG4gICAgLy8gUGFyc2xleSBET00tQVBJXG4gICAgLy8gcmV0dXJucyBvYmplY3QgZnJvbSBkb20gYXR0cmlidXRlcyBhbmQgdmFsdWVzXG4gICAgYXR0cjogZnVuY3Rpb24gYXR0cihlbGVtZW50LCBuYW1lc3BhY2UsIG9iaikge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgYXR0cmlidXRlO1xuICAgICAgdmFyIGF0dHJpYnV0ZXM7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZSwgJ2knKTtcblxuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2Ygb2JqKSBvYmogPSB7fTtlbHNlIHtcbiAgICAgICAgLy8gQ2xlYXIgYWxsIG93biBwcm9wZXJ0aWVzLiBUaGlzIHdvbid0IGFmZmVjdCBwcm90b3R5cGUncyB2YWx1ZXNcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIGRlbGV0ZSBvYmpbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm4gb2JqO1xuXG4gICAgICBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChpID0gYXR0cmlidXRlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5zcGVjaWZpZWQgJiYgcmVnZXgudGVzdChhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgICBvYmpbdGhpcy5jYW1lbGl6ZShhdHRyaWJ1dGUubmFtZS5zbGljZShuYW1lc3BhY2UubGVuZ3RoKSldID0gdGhpcy5kZXNlcmlhbGl6ZVZhbHVlKGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgY2hlY2tBdHRyOiBmdW5jdGlvbiBjaGVja0F0dHIoZWxlbWVudCwgbmFtZXNwYWNlLCBfY2hlY2tBdHRyKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZXNwYWNlICsgX2NoZWNrQXR0cik7XG4gICAgfSxcblxuICAgIHNldEF0dHI6IGZ1bmN0aW9uIHNldEF0dHIoZWxlbWVudCwgbmFtZXNwYWNlLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5kYXNoZXJpemUobmFtZXNwYWNlICsgYXR0ciksIFN0cmluZyh2YWx1ZSkpO1xuICAgIH0sXG5cbiAgICBnZXRUeXBlOiBmdW5jdGlvbiBnZXRUeXBlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICd0ZXh0JztcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVJRDogZnVuY3Rpb24gZ2VuZXJhdGVJRCgpIHtcbiAgICAgIHJldHVybiAnJyArIGdsb2JhbElEKys7XG4gICAgfSxcblxuICAgIC8qKiBUaGlyZCBwYXJ0eSBmdW5jdGlvbnMgKiovXG4gICAgZGVzZXJpYWxpemVWYWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgdmFyIG51bTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUgPT0gXCJ0cnVlXCIgfHwgKHZhbHVlID09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWUgPT0gXCJudWxsXCIgPyBudWxsIDogIWlzTmFOKG51bSA9IE51bWJlcih2YWx1ZSkpID8gbnVtIDogL15bXFxbXFx7XS8udGVzdCh2YWx1ZSkgPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlKSA6IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFplcHRvIGNhbWVsaXplIGZ1bmN0aW9uXG4gICAgY2FtZWxpemU6IGZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBjaHIpIHtcbiAgICAgICAgcmV0dXJuIGNociA/IGNoci50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gWmVwdG8gZGFzaGVyaXplIGZ1bmN0aW9uXG4gICAgZGFzaGVyaXplOiBmdW5jdGlvbiBkYXNoZXJpemUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzo6L2csICcvJykucmVwbGFjZSgvKFtBLVpdKykoW0EtWl1bYS16XSkvZywgJyQxXyQyJykucmVwbGFjZSgvKFthLXpcXGRdKShbQS1aXSkvZywgJyQxXyQyJykucmVwbGFjZSgvXy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIHdhcm46IGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgICB2YXIgX3dpbmRvdyRjb25zb2xlO1xuXG4gICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHdpbmRvdy5jb25zb2xlLndhcm4pIChfd2luZG93JGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZSkud2Fybi5hcHBseShfd2luZG93JGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIHdhcm5PbmNlOiBmdW5jdGlvbiB3YXJuT25jZShtc2cpIHtcbiAgICAgIGlmICghcGFzdFdhcm5pbmdzW21zZ10pIHtcbiAgICAgICAgcGFzdFdhcm5pbmdzW21zZ10gPSB0cnVlO1xuICAgICAgICB0aGlzLndhcm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Jlc2V0V2FybmluZ3M6IGZ1bmN0aW9uIF9yZXNldFdhcm5pbmdzKCkge1xuICAgICAgcGFzdFdhcm5pbmdzID0ge307XG4gICAgfSxcblxuICAgIHRyaW1TdHJpbmc6IGZ1bmN0aW9uIHRyaW1TdHJpbmcoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICB9LFxuXG4gICAgcGFyc2U6IHtcbiAgICAgIGRhdGU6IGZ1bmN0aW9uIGRhdGUoc3RyaW5nKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBzdHJpbmcubWF0Y2goL14oXFxkezQsfSktKFxcZFxcZCktKFxcZFxcZCkkLyk7XG4gICAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgX3BhcnNlZCRtYXAgPSBwYXJzZWQubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9wYXJzZWQkbWFwMiA9IF9zbGljZWRUb0FycmF5KF9wYXJzZWQkbWFwLCA0KTtcblxuICAgICAgICB2YXIgXyA9IF9wYXJzZWQkbWFwMlswXTtcbiAgICAgICAgdmFyIHllYXIgPSBfcGFyc2VkJG1hcDJbMV07XG4gICAgICAgIHZhciBtb250aCA9IF9wYXJzZWQkbWFwMlsyXTtcbiAgICAgICAgdmFyIGRheSA9IF9wYXJzZWQkbWFwMlszXTtcblxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICAgICAgaWYgKGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0geWVhciB8fCBkYXRlLmdldE1vbnRoKCkgKyAxICE9PSBtb250aCB8fCBkYXRlLmdldERhdGUoKSAhPT0gZGF5KSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9LFxuICAgICAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcoX3N0cmluZykge1xuICAgICAgICByZXR1cm4gX3N0cmluZztcbiAgICAgIH0sXG4gICAgICBpbnRlZ2VyOiBmdW5jdGlvbiBpbnRlZ2VyKHN0cmluZykge1xuICAgICAgICBpZiAoaXNOYU4oc3RyaW5nKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgICAgIH0sXG4gICAgICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcihzdHJpbmcpIHtcbiAgICAgICAgaWYgKGlzTmFOKHN0cmluZykpIHRocm93IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gICAgICB9LFxuICAgICAgJ2Jvb2xlYW4nOiBmdW5jdGlvbiBfYm9vbGVhbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICEvXlxccypmYWxzZVxccyokL2kudGVzdChzdHJpbmcpO1xuICAgICAgfSxcbiAgICAgIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVXRpbHMuZGVzZXJpYWxpemVWYWx1ZShzdHJpbmcpO1xuICAgICAgfSxcbiAgICAgIHJlZ2V4cDogZnVuY3Rpb24gcmVnZXhwKF9yZWdleHApIHtcbiAgICAgICAgdmFyIGZsYWdzID0gJyc7XG5cbiAgICAgICAgLy8gVGVzdCBpZiBSZWdFeHAgaXMgbGl0ZXJhbCwgaWYgbm90LCBub3RoaW5nIHRvIGJlIGRvbmUsIG90aGVyd2lzZSwgd2UgbmVlZCB0byBpc29sYXRlIGZsYWdzIGFuZCBwYXR0ZXJuXG4gICAgICAgIGlmICgvXlxcLy4qXFwvKD86W2dpbXldKikkLy50ZXN0KF9yZWdleHApKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcmVnZXhwIGxpdGVyYWwgc3RyaW5nIHdpdGggdGhlIGZpcnN0IG1hdGNoIGdyb3VwOiAoW2dpbXldKilcbiAgICAgICAgICAvLyBJZiBubyBmbGFnIGlzIHByZXNlbnQsIHRoaXMgd2lsbCBiZSBhIGJsYW5rIHN0cmluZ1xuICAgICAgICAgIGZsYWdzID0gX3JlZ2V4cC5yZXBsYWNlKC8uKlxcLyhbZ2lteV0qKSQvLCAnJDEnKTtcbiAgICAgICAgICAvLyBBZ2FpbiwgcmVwbGFjZSB0aGUgcmVnZXhwIGxpdGVyYWwgc3RyaW5nIHdpdGggdGhlIGZpcnN0IG1hdGNoIGdyb3VwOlxuICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgZXhjbHVkaW5nIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHNsYXNoZXMgYW5kIHRoZSBmbGFnc1xuICAgICAgICAgIF9yZWdleHAgPSBfcmVnZXhwLnJlcGxhY2UobmV3IFJlZ0V4cCgnXi8oLio/KS8nICsgZmxhZ3MgKyAnJCcpLCAnJDEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbmNob3IgcmVnZXhwOlxuICAgICAgICAgIF9yZWdleHAgPSAnXicgKyBfcmVnZXhwICsgJyQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKF9yZWdleHAsIGZsYWdzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VSZXF1aXJlbWVudDogZnVuY3Rpb24gcGFyc2VSZXF1aXJlbWVudChyZXF1aXJlbWVudFR5cGUsIHN0cmluZykge1xuICAgICAgdmFyIGNvbnZlcnRlciA9IHRoaXMucGFyc2VbcmVxdWlyZW1lbnRUeXBlIHx8ICdzdHJpbmcnXTtcbiAgICAgIGlmICghY29udmVydGVyKSB0aHJvdyAnVW5rbm93biByZXF1aXJlbWVudCBzcGVjaWZpY2F0aW9uOiBcIicgKyByZXF1aXJlbWVudFR5cGUgKyAnXCInO1xuICAgICAgdmFyIGNvbnZlcnRlZCA9IGNvbnZlcnRlcihzdHJpbmcpO1xuICAgICAgaWYgKGNvbnZlcnRlZCA9PT0gbnVsbCkgdGhyb3cgJ1JlcXVpcmVtZW50IGlzIG5vdCBhICcgKyByZXF1aXJlbWVudFR5cGUgKyAnOiBcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgICB9LFxuXG4gICAgbmFtZXNwYWNlRXZlbnRzOiBmdW5jdGlvbiBuYW1lc3BhY2VFdmVudHMoZXZlbnRzLCBuYW1lc3BhY2UpIHtcbiAgICAgIGV2ZW50cyA9IHRoaXMudHJpbVN0cmluZyhldmVudHMgfHwgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgICBpZiAoIWV2ZW50c1swXSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuICQubWFwKGV2ZW50cywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gZXZ0ICsgJy4nICsgbmFtZXNwYWNlO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH0sXG5cbiAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5LCByZW1vdmUpIHtcbiAgICAgIC8vIFRoaXMgaXMgTyhOXjIpLCBzaG91bGQgYmUgb3B0aW1pemVkXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAkLmVhY2goYXJyYXksIGZ1bmN0aW9uIChfLCBlbGVtKSB7XG4gICAgICAgIGlmIChyZW1vdmUuaW5kZXhPZihlbGVtKSA9PSAtMSkgcmVzdWx0LnB1c2goZWxlbSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8vIEFsdGVyLWVnbyB0byBuYXRpdmUgUHJvbWlzZS5hbGwsIGJ1dCBmb3IgalF1ZXJ5XG4gICAgYWxsOiBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICAgIC8vIGpRdWVyeSB0cmVhdHMgJC53aGVuKCkgYW5kICQud2hlbihzaW5nbGVQcm9taXNlKSBkaWZmZXJlbnRseTsgbGV0J3MgYXZvaWQgdGhhdCBhbmQgYWRkIHNwdXJpb3VzIGVsZW1lbnRzXG4gICAgICByZXR1cm4gJC53aGVuLmFwcGx5KCQsIF90b0NvbnN1bWFibGVBcnJheShwcm9taXNlcykuY29uY2F0KFs0MiwgNDJdKSk7XG4gICAgfSxcblxuICAgIC8vIE9iamVjdC5jcmVhdGUgcG9seWZpbGwsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlI1BvbHlmaWxsXG4gICAgb2JqZWN0Q3JlYXRlOiBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgT2JqZWN0ID0gZnVuY3Rpb24gT2JqZWN0KCkge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICBPYmplY3QucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIF9TdWJtaXRTZWxlY3RvcjogJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0sIGJ1dHRvbjpzdWJtaXQnXG4gIH07XG5cbiAgLy8gQWxsIHRoZXNlIG9wdGlvbnMgY291bGQgYmUgb3ZlcnJpZGVuIGFuZCBzcGVjaWZpZWQgZGlyZWN0bHkgaW4gRE9NIHVzaW5nXG4gIC8vIGBkYXRhLXBhcnNsZXktYCBkZWZhdWx0IERPTS1BUElcbiAgLy8gZWc6IGBpbnB1dHNgIGNhbiBiZSBzZXQgaW4gRE9NIHVzaW5nIGBkYXRhLXBhcnNsZXktaW5wdXRzPVwiaW5wdXQsIHRleHRhcmVhXCJgXG4gIC8vIGVnOiBgZGF0YS1wYXJzbGV5LXN0b3Atb24tZmlyc3QtZmFpbGluZy1jb25zdHJhaW50PVwiZmFsc2VcImBcblxuICB2YXIgRGVmYXVsdHMgPSB7XG4gICAgLy8gIyMjIEdlbmVyYWxcblxuICAgIC8vIERlZmF1bHQgZGF0YS1uYW1lc3BhY2UgZm9yIERPTSBBUElcbiAgICBuYW1lc3BhY2U6ICdkYXRhLXBhcnNsZXktJyxcblxuICAgIC8vIFN1cHBvcnRlZCBpbnB1dHMgYnkgZGVmYXVsdFxuICAgIGlucHV0czogJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JyxcblxuICAgIC8vIEV4Y2x1ZGVkIGlucHV0cyBieSBkZWZhdWx0XG4gICAgZXhjbHVkZWQ6ICdpbnB1dFt0eXBlPWJ1dHRvbl0sIGlucHV0W3R5cGU9c3VibWl0XSwgaW5wdXRbdHlwZT1yZXNldF0sIGlucHV0W3R5cGU9aGlkZGVuXScsXG5cbiAgICAvLyBTdG9wIHZhbGlkYXRpbmcgZmllbGQgb24gaGlnaGVzdCBwcmlvcml0eSBmYWlsaW5nIGNvbnN0cmFpbnRcbiAgICBwcmlvcml0eUVuYWJsZWQ6IHRydWUsXG5cbiAgICAvLyAjIyMgRmllbGQgb25seVxuXG4gICAgLy8gaWRlbnRpZmllciB1c2VkIHRvIGdyb3VwIHRvZ2V0aGVyIGlucHV0cyAoZS5nLiByYWRpbyBidXR0b25zLi4uKVxuICAgIG11bHRpcGxlOiBudWxsLFxuXG4gICAgLy8gaWRlbnRpZmllciAob3IgYXJyYXkgb2YgaWRlbnRpZmllcnMpIHVzZWQgdG8gdmFsaWRhdGUgb25seSBhIHNlbGVjdCBncm91cCBvZiBpbnB1dHNcbiAgICBncm91cDogbnVsbCxcblxuICAgIC8vICMjIyBVSVxuICAgIC8vIEVuYWJsZVxcRGlzYWJsZSBlcnJvciBtZXNzYWdlc1xuICAgIHVpRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8vIEtleSBldmVudHMgdGhyZXNob2xkIGJlZm9yZSB2YWxpZGF0aW9uXG4gICAgdmFsaWRhdGlvblRocmVzaG9sZDogMyxcblxuICAgIC8vIEZvY3VzZWQgZmllbGQgb24gZm9ybSB2YWxpZGF0aW9uIGVycm9yLiAnZmlyc3QnfCdsYXN0J3wnbm9uZSdcbiAgICBmb2N1czogJ2ZpcnN0JyxcblxuICAgIC8vIGV2ZW50KHMpIHRoYXQgd2lsbCB0cmlnZ2VyIHZhbGlkYXRpb24gYmVmb3JlIGZpcnN0IGZhaWx1cmUuIGVnOiBgaW5wdXRgLi4uXG4gICAgdHJpZ2dlcjogZmFsc2UsXG5cbiAgICAvLyBldmVudChzKSB0aGF0IHdpbGwgdHJpZ2dlciB2YWxpZGF0aW9uIGFmdGVyIGZpcnN0IGZhaWx1cmUuXG4gICAgdHJpZ2dlckFmdGVyRmFpbHVyZTogJ2lucHV0JyxcblxuICAgIC8vIENsYXNzIHRoYXQgd291bGQgYmUgYWRkZWQgb24gZXZlcnkgZmFpbGluZyB2YWxpZGF0aW9uIFBhcnNsZXkgZmllbGRcbiAgICBlcnJvckNsYXNzOiAncGFyc2xleS1lcnJvcicsXG5cbiAgICAvLyBTYW1lIGZvciBzdWNjZXNzIHZhbGlkYXRpb25cbiAgICBzdWNjZXNzQ2xhc3M6ICdwYXJzbGV5LXN1Y2Nlc3MnLFxuXG4gICAgLy8gUmV0dXJuIHRoZSBgJGVsZW1lbnRgIHRoYXQgd2lsbCByZWNlaXZlIHRoZXNlIGFib3ZlIHN1Y2Nlc3Mgb3IgZXJyb3IgY2xhc3Nlc1xuICAgIC8vIENvdWxkIGFsc28gYmUgKGFuZCBnaXZlbiBkaXJlY3RseSBmcm9tIERPTSkgYSB2YWxpZCBzZWxlY3RvciBsaWtlIGAnI2RpdidgXG4gICAgY2xhc3NIYW5kbGVyOiBmdW5jdGlvbiBjbGFzc0hhbmRsZXIoRmllbGQpIHt9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBgJGVsZW1lbnRgIHdoZXJlIGVycm9ycyB3aWxsIGJlIGFwcGVuZGVkXG4gICAgLy8gQ291bGQgYWxzbyBiZSAoYW5kIGdpdmVuIGRpcmVjdGx5IGZyb20gRE9NKSBhIHZhbGlkIHNlbGVjdG9yIGxpa2UgYCcjZGl2J2BcbiAgICBlcnJvcnNDb250YWluZXI6IGZ1bmN0aW9uIGVycm9yc0NvbnRhaW5lcihGaWVsZCkge30sXG5cbiAgICAvLyB1bCBlbGVtIHRoYXQgd291bGQgcmVjZWl2ZSBlcnJvcnMnIGxpc3RcbiAgICBlcnJvcnNXcmFwcGVyOiAnPHVsIGNsYXNzPVwicGFyc2xleS1lcnJvcnMtbGlzdFwiPjwvdWw+JyxcblxuICAgIC8vIGxpIGVsZW0gdGhhdCB3b3VsZCByZWNlaXZlIGVycm9yIG1lc3NhZ2VcbiAgICBlcnJvclRlbXBsYXRlOiAnPGxpPjwvbGk+J1xuICB9O1xuXG4gIHZhciBCYXNlID0gZnVuY3Rpb24gQmFzZSgpIHtcbiAgICB0aGlzLl9faWRfXyA9IFV0aWxzLmdlbmVyYXRlSUQoKTtcbiAgfTtcblxuICBCYXNlLnByb3RvdHlwZSA9IHtcbiAgICBhc3luY1N1cHBvcnQ6IHRydWUsIC8vIERlcHJlY2F0ZWRcblxuICAgIF9waXBlQWNjb3JkaW5nVG9WYWxpZGF0aW9uUmVzdWx0OiBmdW5jdGlvbiBfcGlwZUFjY29yZGluZ1RvVmFsaWRhdGlvblJlc3VsdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgICAgICAgdmFyIHIgPSAkLkRlZmVycmVkKCk7XG4gICAgICAgIGlmICh0cnVlICE9PSBfdGhpcy52YWxpZGF0aW9uUmVzdWx0KSByLnJlamVjdCgpO1xuICAgICAgICByZXR1cm4gci5yZXNvbHZlKCkucHJvbWlzZSgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBbcGlwZSwgcGlwZV07XG4gICAgfSxcblxuICAgIGFjdHVhbGl6ZU9wdGlvbnM6IGZ1bmN0aW9uIGFjdHVhbGl6ZU9wdGlvbnMoKSB7XG4gICAgICBVdGlscy5hdHRyKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLm5hbWVzcGFjZSwgdGhpcy5kb21PcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5hY3R1YWxpemVPcHRpb25zKSB0aGlzLnBhcmVudC5hY3R1YWxpemVPcHRpb25zKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3Jlc2V0T3B0aW9uczogZnVuY3Rpb24gX3Jlc2V0T3B0aW9ucyhpbml0T3B0aW9ucykge1xuICAgICAgdGhpcy5kb21PcHRpb25zID0gVXRpbHMub2JqZWN0Q3JlYXRlKHRoaXMucGFyZW50Lm9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0gVXRpbHMub2JqZWN0Q3JlYXRlKHRoaXMuZG9tT3B0aW9ucyk7XG4gICAgICAvLyBTaGFsbG93IGNvcHkgb2Ygb3duUHJvcGVydGllcyBvZiBpbml0T3B0aW9uczpcbiAgICAgIGZvciAodmFyIGkgaW4gaW5pdE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGluaXRPcHRpb25zLmhhc093blByb3BlcnR5KGkpKSB0aGlzLm9wdGlvbnNbaV0gPSBpbml0T3B0aW9uc1tpXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0dWFsaXplT3B0aW9ucygpO1xuICAgIH0sXG5cbiAgICBfbGlzdGVuZXJzOiBudWxsLFxuXG4gICAgLy8gUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWVcbiAgICAvLyBDYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBjb250ZXh0IGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIGB0aGlzYFxuICAgIC8vIFRoZSBjb250ZXh0IGlzIHRoZSBjdXJyZW50IHBhcnNsZXkgaW5zdGFuY2UsIG9yIHdpbmRvdy5QYXJzbGV5IGlmIGdsb2JhbFxuICAgIC8vIEEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAgd2lsbCBpbnRlcnJ1cHQgdGhlIGNhbGxzXG4gICAgb246IGZ1bmN0aW9uIG9uKG5hbWUsIGZuKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwge307XG4gICAgICB2YXIgcXVldWUgPSB0aGlzLl9saXN0ZW5lcnNbbmFtZV0gPSB0aGlzLl9saXN0ZW5lcnNbbmFtZV0gfHwgW107XG4gICAgICBxdWV1ZS5wdXNoKGZuKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIERlcHJlY2F0ZWQuIFVzZSBgb25gIGluc3RlYWRcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShuYW1lLCBmbikge1xuICAgICAgJC5saXN0ZW5Ubyh0aGlzLCBuYW1lLnRvTG93ZXJDYXNlKCksIGZuKTtcbiAgICB9LFxuXG4gICAgLy8gVW5yZWdpc3RlciBhIGNhbGxiYWNrIChvciBhbGwgaWYgbm9uZSBpcyBnaXZlbikgZm9yIHRoZSBnaXZlbiBldmVudCBuYW1lXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYobmFtZSwgZm4pIHtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbbmFtZV07XG4gICAgICBpZiAocXVldWUpIHtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHF1ZXVlLmxlbmd0aDsgaS0tOykgaWYgKHF1ZXVlW2ldID09PSBmbikgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRGVwcmVjYXRlZC4gVXNlIGBvZmZgXG4gICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKG5hbWUsIGZuKSB7XG4gICAgICAkLnVuc3Vic2NyaWJlVG8odGhpcywgbmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9LFxuXG4gICAgLy8gVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgZ2l2ZW4gbmFtZVxuICAgIC8vIEEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAgaW50ZXJydXB0cyB0aGUgY2FsbGJhY2sgY2hhaW5cbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIGV4ZWN1dGlvbiB3YXMgaW50ZXJydXB0ZWRcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKG5hbWUsIHRhcmdldCwgZXh0cmFBcmcpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1tuYW1lXTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB2YXIgcGFyZW50UmVzdWx0O1xuICAgICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBxdWV1ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICByZXN1bHQgPSBxdWV1ZVtpXS5jYWxsKHRhcmdldCwgdGFyZ2V0LCBleHRyYUFyZyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQudHJpZ2dlcihuYW1lLCB0YXJnZXQsIGV4dHJhQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBhc3luY0lzVmFsaWQ6IGZ1bmN0aW9uIGFzeW5jSXNWYWxpZChncm91cCwgZm9yY2UpIHtcbiAgICAgIFV0aWxzLndhcm5PbmNlKFwiYXN5bmNJc1ZhbGlkIGlzIGRlcHJlY2F0ZWQ7IHBsZWFzZSB1c2Ugd2hlblZhbGlkIGluc3RlYWRcIik7XG4gICAgICByZXR1cm4gdGhpcy53aGVuVmFsaWQoeyBncm91cDogZ3JvdXAsIGZvcmNlOiBmb3JjZSB9KTtcbiAgICB9LFxuXG4gICAgX2ZpbmRSZWxhdGVkOiBmdW5jdGlvbiBfZmluZFJlbGF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm11bHRpcGxlID8gJCh0aGlzLnBhcmVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgdGhpcy5vcHRpb25zLm5hbWVzcGFjZSArICdtdWx0aXBsZT1cIicgKyB0aGlzLm9wdGlvbnMubXVsdGlwbGUgKyAnXCJdJykpIDogdGhpcy4kZWxlbWVudDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbnZlcnRBcnJheVJlcXVpcmVtZW50ID0gZnVuY3Rpb24gY29udmVydEFycmF5UmVxdWlyZW1lbnQoc3RyaW5nLCBsZW5ndGgpIHtcbiAgICB2YXIgbSA9IHN0cmluZy5tYXRjaCgvXlxccypcXFsoLiopXFxdXFxzKiQvKTtcbiAgICBpZiAoIW0pIHRocm93ICdSZXF1aXJlbWVudCBpcyBub3QgYW4gYXJyYXk6IFwiJyArIHN0cmluZyArICdcIic7XG4gICAgdmFyIHZhbHVlcyA9IG1bMV0uc3BsaXQoJywnKS5tYXAoVXRpbHMudHJpbVN0cmluZyk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGxlbmd0aCkgdGhyb3cgJ1JlcXVpcmVtZW50IGhhcyAnICsgdmFsdWVzLmxlbmd0aCArICcgdmFsdWVzIHdoZW4gJyArIGxlbmd0aCArICcgYXJlIG5lZWRlZCc7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICB2YXIgY29udmVydEV4dHJhT3B0aW9uUmVxdWlyZW1lbnQgPSBmdW5jdGlvbiBjb252ZXJ0RXh0cmFPcHRpb25SZXF1aXJlbWVudChyZXF1aXJlbWVudFNwZWMsIHN0cmluZywgZXh0cmFPcHRpb25SZWFkZXIpIHtcbiAgICB2YXIgbWFpbiA9IG51bGw7XG4gICAgdmFyIGV4dHJhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHJlcXVpcmVtZW50U3BlYykge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBleHRyYU9wdGlvblJlYWRlcihrZXkpO1xuICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSkgdmFsdWUgPSBVdGlscy5wYXJzZVJlcXVpcmVtZW50KHJlcXVpcmVtZW50U3BlY1trZXldLCB2YWx1ZSk7XG4gICAgICAgIGV4dHJhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW4gPSBVdGlscy5wYXJzZVJlcXVpcmVtZW50KHJlcXVpcmVtZW50U3BlY1trZXldLCBzdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21haW4sIGV4dHJhXTtcbiAgfTtcblxuICAvLyBBIFZhbGlkYXRvciBuZWVkcyB0byBpbXBsZW1lbnQgdGhlIG1ldGhvZHMgYHZhbGlkYXRlYCBhbmQgYHBhcnNlUmVxdWlyZW1lbnRzYFxuXG4gIHZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbiBWYWxpZGF0b3Ioc3BlYykge1xuICAgICQuZXh0ZW5kKHRydWUsIHRoaXMsIHNwZWMpO1xuICB9O1xuXG4gIFZhbGlkYXRvci5wcm90b3R5cGUgPSB7XG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWZmIHRoZSBnaXZlbiBgdmFsdWVgIGlzIHZhbGlkIGFjY29yZGluZyB0aGUgZ2l2ZW4gcmVxdWlyZW1lbnRzLlxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgcmVxdWlyZW1lbnRGaXJzdEFyZykge1xuICAgICAgaWYgKHRoaXMuZm4pIHtcbiAgICAgICAgLy8gTGVnYWN5IHN0eWxlIHZhbGlkYXRvclxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgLy8gSWYgbW9yZSBhcmdzIHRoZW4gdmFsdWUsIHJlcXVpcmVtZW50LCBpbnN0YW5jZS4uLlxuICAgICAgICAgIHJlcXVpcmVtZW50Rmlyc3RBcmcgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTEpOyAvLyBTa2lwIGZpcnN0IGFyZyAodmFsdWUpIGFuZCBsYXN0IChpbnN0YW5jZSksIGNvbWJpbmluZyB0aGUgcmVzdFxuICAgICAgICByZXR1cm4gdGhpcy5mbih2YWx1ZSwgcmVxdWlyZW1lbnRGaXJzdEFyZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVNdWx0aXBsZSkgdGhyb3cgJ1ZhbGlkYXRvciBgJyArIHRoaXMubmFtZSArICdgIGRvZXMgbm90IGhhbmRsZSBtdWx0aXBsZSB2YWx1ZXMnO1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU11bHRpcGxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZURhdGUgJiYgaW5zdGFuY2UuX2lzRGF0ZUlucHV0KCkpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBVdGlscy5wYXJzZS5kYXRlKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHBhcnNlRmxvYXQoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU51bWJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAnVmFsaWRhdG9yIGAnICsgdGhpcy5uYW1lICsgJ2Agb25seSBoYW5kbGVzIG11bHRpcGxlIHZhbHVlcyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFBhcnNlcyBgcmVxdWlyZW1lbnRzYCBpbnRvIGFuIGFycmF5IG9mIGFyZ3VtZW50cyxcbiAgICAvLyBhY2NvcmRpbmcgdG8gYHRoaXMucmVxdWlyZW1lbnRUeXBlYFxuICAgIHBhcnNlUmVxdWlyZW1lbnRzOiBmdW5jdGlvbiBwYXJzZVJlcXVpcmVtZW50cyhyZXF1aXJlbWVudHMsIGV4dHJhT3B0aW9uUmVhZGVyKSB7XG4gICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiByZXF1aXJlbWVudHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIHJlcXVpcmVtZW50IGFscmVhZHkgcGFyc2VkXG4gICAgICAgIC8vIGJ1dCBtYWtlIHN1cmUgd2UgcmV0dXJuIGFuIGFycmF5XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVtZW50cykgPyByZXF1aXJlbWVudHMgOiBbcmVxdWlyZW1lbnRzXTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdGhpcy5yZXF1aXJlbWVudFR5cGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gY29udmVydEFycmF5UmVxdWlyZW1lbnQocmVxdWlyZW1lbnRzLCB0eXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB2YWx1ZXNbaV0gPSBVdGlscy5wYXJzZVJlcXVpcmVtZW50KHR5cGVbaV0sIHZhbHVlc1tpXSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9IGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gY29udmVydEV4dHJhT3B0aW9uUmVxdWlyZW1lbnQodHlwZSwgcmVxdWlyZW1lbnRzLCBleHRyYU9wdGlvblJlYWRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1V0aWxzLnBhcnNlUmVxdWlyZW1lbnQodHlwZSwgcmVxdWlyZW1lbnRzKV07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWZhdWx0czpcbiAgICByZXF1aXJlbWVudFR5cGU6ICdzdHJpbmcnLFxuXG4gICAgcHJpb3JpdHk6IDJcblxuICB9O1xuXG4gIHZhciBWYWxpZGF0b3JSZWdpc3RyeSA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlZ2lzdHJ5KHZhbGlkYXRvcnMsIGNhdGFsb2cpIHtcbiAgICB0aGlzLl9fY2xhc3NfXyA9ICdWYWxpZGF0b3JSZWdpc3RyeSc7XG5cbiAgICAvLyBEZWZhdWx0IFBhcnNsZXkgbG9jYWxlIGlzIGVuXG4gICAgdGhpcy5sb2NhbGUgPSAnZW4nO1xuXG4gICAgdGhpcy5pbml0KHZhbGlkYXRvcnMgfHwge30sIGNhdGFsb2cgfHwge30pO1xuICB9O1xuXG4gIHZhciB0eXBlVGVzdGVycyA9IHtcbiAgICBlbWFpbDogL14oKChbYS16QS1aXXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16QS1aXXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvLFxuXG4gICAgLy8gRm9sbG93IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2Zsb2F0aW5nLXBvaW50LW51bWJlcnNcbiAgICBudW1iZXI6IC9eLT8oXFxkKlxcLik/XFxkKyhlWy0rXT9cXGQrKT8kL2ksXG5cbiAgICBpbnRlZ2VyOiAvXi0/XFxkKyQvLFxuXG4gICAgZGlnaXRzOiAvXlxcZCskLyxcblxuICAgIGFscGhhbnVtOiAvXlxcdyskL2ksXG5cbiAgICBkYXRlOiB7XG4gICAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5wYXJzZS5kYXRlKHZhbHVlKSAhPT0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXJsOiBuZXcgUmVnRXhwKFwiXlwiICtcbiAgICAvLyBwcm90b2NvbCBpZGVudGlmaWVyXG4gICAgXCIoPzooPzpodHRwcz98ZnRwKTovLyk/XCIgKyAvLyAqKiBtb2Q6IG1ha2Ugc2NoZW1lIG9wdGlvbmFsXG4gICAgLy8gdXNlcjpwYXNzIGF1dGhlbnRpY2F0aW9uXG4gICAgXCIoPzpcXFxcUysoPzo6XFxcXFMqKT9AKT9cIiArIFwiKD86XCIgK1xuICAgIC8vIElQIGFkZHJlc3MgZXhjbHVzaW9uXG4gICAgLy8gcHJpdmF0ZSAmIGxvY2FsIG5ldHdvcmtzXG4gICAgLy8gXCIoPyEoPzoxMHwxMjcpKD86XFxcXC5cXFxcZHsxLDN9KXszfSlcIiArICAgLy8gKiogbW9kOiBhbGxvdyBsb2NhbCBuZXR3b3Jrc1xuICAgIC8vIFwiKD8hKD86MTY5XFxcXC4yNTR8MTkyXFxcXC4xNjgpKD86XFxcXC5cXFxcZHsxLDN9KXsyfSlcIiArICAvLyAqKiBtb2Q6IGFsbG93IGxvY2FsIG5ldHdvcmtzXG4gICAgLy8gXCIoPyExNzJcXFxcLig/OjFbNi05XXwyXFxcXGR8M1swLTFdKSg/OlxcXFwuXFxcXGR7MSwzfSl7Mn0pXCIgKyAgLy8gKiogbW9kOiBhbGxvdyBsb2NhbCBuZXR3b3Jrc1xuICAgIC8vIElQIGFkZHJlc3MgZG90dGVkIG5vdGF0aW9uIG9jdGV0c1xuICAgIC8vIGV4Y2x1ZGVzIGxvb3BiYWNrIG5ldHdvcmsgMC4wLjAuMFxuICAgIC8vIGV4Y2x1ZGVzIHJlc2VydmVkIHNwYWNlID49IDIyNC4wLjAuMFxuICAgIC8vIGV4Y2x1ZGVzIG5ldHdvcmsgJiBicm9hY2FzdCBhZGRyZXNzZXNcbiAgICAvLyAoZmlyc3QgJiBsYXN0IElQIGFkZHJlc3Mgb2YgZWFjaCBjbGFzcylcbiAgICBcIig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMDFdXFxcXGR8MjJbMC0zXSlcIiArIFwiKD86XFxcXC4oPzoxP1xcXFxkezEsMn18MlswLTRdXFxcXGR8MjVbMC01XSkpezJ9XCIgKyBcIig/OlxcXFwuKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC00XSkpXCIgKyBcInxcIiArXG4gICAgLy8gaG9zdCBuYW1lXG4gICAgJyg/Oig/OlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0qKSpbYS16QS1aXFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rKScgK1xuICAgIC8vIGRvbWFpbiBuYW1lXG4gICAgJyg/OlxcXFwuKD86W2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKicgK1xuICAgIC8vIFRMRCBpZGVudGlmaWVyXG4gICAgJyg/OlxcXFwuKD86W2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpJyArIFwiKVwiICtcbiAgICAvLyBwb3J0IG51bWJlclxuICAgIFwiKD86OlxcXFxkezIsNX0pP1wiICtcbiAgICAvLyByZXNvdXJjZSBwYXRoXG4gICAgXCIoPzovXFxcXFMqKT9cIiArIFwiJFwiKVxuICB9O1xuICB0eXBlVGVzdGVycy5yYW5nZSA9IHR5cGVUZXN0ZXJzLm51bWJlcjtcblxuICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA0NTQ1NjAvODI3OVxuICB2YXIgZGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMobnVtKSB7XG4gICAgdmFyIG1hdGNoID0gKCcnICsgbnVtKS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsXG4gICAgLy8gTnVtYmVyIG9mIGRpZ2l0cyByaWdodCBvZiBkZWNpbWFsIHBvaW50LlxuICAgIChtYXRjaFsxXSA/IG1hdGNoWzFdLmxlbmd0aCA6IDApIC0gKFxuICAgIC8vIEFkanVzdCBmb3Igc2NpZW50aWZpYyBub3RhdGlvbi5cbiAgICBtYXRjaFsyXSA/ICttYXRjaFsyXSA6IDApKTtcbiAgfTtcblxuICAvLyBwYXJzZUFyZ3VtZW50cygnbnVtYmVyJywgWycxJywgJzInXSkgPT4gWzEsIDJdXG4gIHZhciBWYWxpZGF0b3JSZWdpc3RyeV9fcGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbiBWYWxpZGF0b3JSZWdpc3RyeV9fcGFyc2VBcmd1bWVudHModHlwZSwgYXJncykge1xuICAgIHJldHVybiBhcmdzLm1hcChVdGlscy5wYXJzZVt0eXBlXSk7XG4gIH07XG4gIC8vIG9wZXJhdG9yVG9WYWxpZGF0b3IgcmV0dXJucyBhIHZhbGlkYXRpbmcgZnVuY3Rpb24gZm9yIGFuIG9wZXJhdG9yIGZ1bmN0aW9uLCBhcHBsaWVkIHRvIHRoZSBnaXZlbiB0eXBlXG4gIHZhciBWYWxpZGF0b3JSZWdpc3RyeV9fb3BlcmF0b3JUb1ZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlZ2lzdHJ5X19vcGVyYXRvclRvVmFsaWRhdG9yKHR5cGUsIG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlcXVpcmVtZW50c0FuZElucHV0ID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXF1aXJlbWVudHNBbmRJbnB1dFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJlcXVpcmVtZW50c0FuZElucHV0LnBvcCgpOyAvLyBHZXQgcmlkIG9mIGBpbnB1dGAgYXJndW1lbnRcbiAgICAgIHJldHVybiBvcGVyYXRvci5hcHBseSh1bmRlZmluZWQsIFt2YWx1ZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShWYWxpZGF0b3JSZWdpc3RyeV9fcGFyc2VBcmd1bWVudHModHlwZSwgcmVxdWlyZW1lbnRzQW5kSW5wdXQpKSkpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIFZhbGlkYXRvclJlZ2lzdHJ5X19jb21wYXJpc29uT3BlcmF0b3IgPSBmdW5jdGlvbiBWYWxpZGF0b3JSZWdpc3RyeV9fY29tcGFyaXNvbk9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkYXRlRGF0ZTogVmFsaWRhdG9yUmVnaXN0cnlfX29wZXJhdG9yVG9WYWxpZGF0b3IoJ2RhdGUnLCBvcGVyYXRvciksXG4gICAgICB2YWxpZGF0ZU51bWJlcjogVmFsaWRhdG9yUmVnaXN0cnlfX29wZXJhdG9yVG9WYWxpZGF0b3IoJ251bWJlcicsIG9wZXJhdG9yKSxcbiAgICAgIHJlcXVpcmVtZW50VHlwZTogb3BlcmF0b3IubGVuZ3RoIDw9IDIgPyAnc3RyaW5nJyA6IFsnc3RyaW5nJywgJ3N0cmluZyddLCAvLyBTdXBwb3J0IG9wZXJhdG9ycyB3aXRoIGEgMSBvciAyIHJlcXVpcmVtZW50KHMpXG4gICAgICBwcmlvcml0eTogMzBcbiAgICB9O1xuICB9O1xuXG4gIFZhbGlkYXRvclJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHZhbGlkYXRvcnMsIGNhdGFsb2cpIHtcbiAgICAgIHRoaXMuY2F0YWxvZyA9IGNhdGFsb2c7XG4gICAgICAvLyBDb3B5IHByb3RvdHlwZSdzIHZhbGlkYXRvcnM6XG4gICAgICB0aGlzLnZhbGlkYXRvcnMgPSBfZXh0ZW5kcyh7fSwgdGhpcy52YWxpZGF0b3JzKTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiB2YWxpZGF0b3JzKSB0aGlzLmFkZFZhbGlkYXRvcihuYW1lLCB2YWxpZGF0b3JzW25hbWVdLmZuLCB2YWxpZGF0b3JzW25hbWVdLnByaW9yaXR5KTtcblxuICAgICAgd2luZG93LlBhcnNsZXkudHJpZ2dlcigncGFyc2xleTp2YWxpZGF0b3I6aW5pdCcpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgbmV3IG1lc3NhZ2VzIGxvY2FsZSBpZiB3ZSBoYXZlIGRpY3Rpb25hcnkgbG9hZGVkIGluIFBhcnNsZXlDb25maWcuaTE4blxuICAgIHNldExvY2FsZTogZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy5jYXRhbG9nW2xvY2FsZV0pIHRocm93IG5ldyBFcnJvcihsb2NhbGUgKyAnIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGNhdGFsb2cnKTtcblxuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBuZXcgbWVzc2FnZXMgY2F0YWxvZyBmb3IgYSBnaXZlbiBsb2NhbGUuIFNldCBsb2NhbGUgZm9yIHRoaXMgY2F0YWxvZyBpZiBzZXQgPT09IGB0cnVlYFxuICAgIGFkZENhdGFsb2c6IGZ1bmN0aW9uIGFkZENhdGFsb2cobG9jYWxlLCBtZXNzYWdlcywgc2V0KSB7XG4gICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBtZXNzYWdlcykgdGhpcy5jYXRhbG9nW2xvY2FsZV0gPSBtZXNzYWdlcztcblxuICAgICAgaWYgKHRydWUgPT09IHNldCkgcmV0dXJuIHRoaXMuc2V0TG9jYWxlKGxvY2FsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzcGVjaWZpYyBtZXNzYWdlIGZvciBhIGdpdmVuIGNvbnN0cmFpbnQgaW4gYSBnaXZlbiBsb2NhbGVcbiAgICBhZGRNZXNzYWdlOiBmdW5jdGlvbiBhZGRNZXNzYWdlKGxvY2FsZSwgbmFtZSwgbWVzc2FnZSkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy5jYXRhbG9nW2xvY2FsZV0pIHRoaXMuY2F0YWxvZ1tsb2NhbGVdID0ge307XG5cbiAgICAgIHRoaXMuY2F0YWxvZ1tsb2NhbGVdW25hbWVdID0gbWVzc2FnZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBtZXNzYWdlcyBmb3IgYSBnaXZlbiBsb2NhbGVcbiAgICBhZGRNZXNzYWdlczogZnVuY3Rpb24gYWRkTWVzc2FnZXMobG9jYWxlLCBuYW1lTWVzc2FnZU9iamVjdCkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBuYW1lTWVzc2FnZU9iamVjdCkgdGhpcy5hZGRNZXNzYWdlKGxvY2FsZSwgbmFtZSwgbmFtZU1lc3NhZ2VPYmplY3RbbmFtZV0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbmV3IHZhbGlkYXRvclxuICAgIC8vXG4gICAgLy8gICAgYWRkVmFsaWRhdG9yKCdjdXN0b20nLCB7XG4gICAgLy8gICAgICAgIHJlcXVpcmVtZW50VHlwZTogWydpbnRlZ2VyJywgJ2ludGVnZXInXSxcbiAgICAvLyAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uKHZhbHVlLCBmcm9tLCB0bykge30sXG4gICAgLy8gICAgICAgIHByaW9yaXR5OiAyMixcbiAgICAvLyAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAvLyAgICAgICAgICBlbjogXCJIZXksIHRoYXQncyBubyBnb29kXCIsXG4gICAgLy8gICAgICAgICAgZnI6IFwiQXllIGF5ZSwgcGFzIGJvbiBkdSB0b3V0XCIsXG4gICAgLy8gICAgICAgIH1cbiAgICAvLyAgICB9KVxuICAgIC8vXG4gICAgLy8gT2xkIEFQSSB3YXMgYWRkVmFsaWRhdG9yKG5hbWUsIGZ1bmN0aW9uLCBwcmlvcml0eSlcbiAgICAvL1xuICAgIGFkZFZhbGlkYXRvcjogZnVuY3Rpb24gYWRkVmFsaWRhdG9yKG5hbWUsIGFyZzEsIGFyZzIpIHtcbiAgICAgIGlmICh0aGlzLnZhbGlkYXRvcnNbbmFtZV0pIFV0aWxzLndhcm4oJ1ZhbGlkYXRvciBcIicgKyBuYW1lICsgJ1wiIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtlbHNlIGlmIChEZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBVdGlscy53YXJuKCdcIicgKyBuYW1lICsgJ1wiIGlzIGEgcmVzdHJpY3RlZCBrZXl3b3JkIGFuZCBpcyBub3QgYSB2YWxpZCB2YWxpZGF0b3IgbmFtZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3NldFZhbGlkYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBoYXNWYWxpZGF0b3I6IGZ1bmN0aW9uIGhhc1ZhbGlkYXRvcihuYW1lKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnZhbGlkYXRvcnNbbmFtZV07XG4gICAgfSxcblxuICAgIHVwZGF0ZVZhbGlkYXRvcjogZnVuY3Rpb24gdXBkYXRlVmFsaWRhdG9yKG5hbWUsIGFyZzEsIGFyZzIpIHtcbiAgICAgIGlmICghdGhpcy52YWxpZGF0b3JzW25hbWVdKSB7XG4gICAgICAgIFV0aWxzLndhcm4oJ1ZhbGlkYXRvciBcIicgKyBuYW1lICsgJ1wiIGlzIG5vdCBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFZhbGlkYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3NldFZhbGlkYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICByZW1vdmVWYWxpZGF0b3I6IGZ1bmN0aW9uIHJlbW92ZVZhbGlkYXRvcihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMudmFsaWRhdG9yc1tuYW1lXSkgVXRpbHMud2FybignVmFsaWRhdG9yIFwiJyArIG5hbWUgKyAnXCIgaXMgbm90IGRlZmluZWQuJyk7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnZhbGlkYXRvcnNbbmFtZV07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfc2V0VmFsaWRhdG9yOiBmdW5jdGlvbiBfc2V0VmFsaWRhdG9yKG5hbWUsIHZhbGlkYXRvciwgcHJpb3JpdHkpIHtcbiAgICAgIGlmICgnb2JqZWN0JyAhPT0gdHlwZW9mIHZhbGlkYXRvcikge1xuICAgICAgICAvLyBPbGQgc3R5bGUgdmFsaWRhdG9yLCB3aXRoIGBmbmAgYW5kIGBwcmlvcml0eWBcbiAgICAgICAgdmFsaWRhdG9yID0ge1xuICAgICAgICAgIGZuOiB2YWxpZGF0b3IsXG4gICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRvci52YWxpZGF0ZSkge1xuICAgICAgICB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHZhbGlkYXRvcik7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbGlkYXRvcnNbbmFtZV0gPSB2YWxpZGF0b3I7XG5cbiAgICAgIGZvciAodmFyIGxvY2FsZSBpbiB2YWxpZGF0b3IubWVzc2FnZXMgfHwge30pIHRoaXMuYWRkTWVzc2FnZShsb2NhbGUsIG5hbWUsIHZhbGlkYXRvci5tZXNzYWdlc1tsb2NhbGVdKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEVycm9yTWVzc2FnZTogZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciBtZXNzYWdlO1xuXG4gICAgICAvLyBUeXBlIGNvbnN0cmFpbnRzIGFyZSBhIGJpdCBkaWZmZXJlbnQsIHdlIGhhdmUgdG8gbWF0Y2ggdGhlaXIgcmVxdWlyZW1lbnRzIHRvbyB0byBmaW5kIHJpZ2h0IGVycm9yIG1lc3NhZ2VcbiAgICAgIGlmICgndHlwZScgPT09IGNvbnN0cmFpbnQubmFtZSkge1xuICAgICAgICB2YXIgdHlwZU1lc3NhZ2VzID0gdGhpcy5jYXRhbG9nW3RoaXMubG9jYWxlXVtjb25zdHJhaW50Lm5hbWVdIHx8IHt9O1xuICAgICAgICBtZXNzYWdlID0gdHlwZU1lc3NhZ2VzW2NvbnN0cmFpbnQucmVxdWlyZW1lbnRzXTtcbiAgICAgIH0gZWxzZSBtZXNzYWdlID0gdGhpcy5mb3JtYXRNZXNzYWdlKHRoaXMuY2F0YWxvZ1t0aGlzLmxvY2FsZV1bY29uc3RyYWludC5uYW1lXSwgY29uc3RyYWludC5yZXF1aXJlbWVudHMpO1xuXG4gICAgICByZXR1cm4gbWVzc2FnZSB8fCB0aGlzLmNhdGFsb2dbdGhpcy5sb2NhbGVdLmRlZmF1bHRNZXNzYWdlIHx8IHRoaXMuY2F0YWxvZy5lbi5kZWZhdWx0TWVzc2FnZTtcbiAgICB9LFxuXG4gICAgLy8gS2luZCBvZiBsaWdodCBgc3ByaW50ZigpYCBpbXBsZW1lbnRhdGlvblxuICAgIGZvcm1hdE1lc3NhZ2U6IGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uoc3RyaW5nLCBwYXJhbWV0ZXJzKSB7XG4gICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gcGFyYW1ldGVycykgc3RyaW5nID0gdGhpcy5mb3JtYXRNZXNzYWdlKHN0cmluZywgcGFyYW1ldGVyc1tpXSk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdzdHJpbmcnID09PSB0eXBlb2Ygc3RyaW5nID8gc3RyaW5nLnJlcGxhY2UoLyVzL2ksIHBhcmFtZXRlcnMpIDogJyc7XG4gICAgfSxcblxuICAgIC8vIEhlcmUgaXMgdGhlIFBhcnNsZXkgZGVmYXVsdCB2YWxpZGF0b3JzIGxpc3QuXG4gICAgLy8gQSB2YWxpZGF0b3IgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXkgdmFsdWVzOlxuICAgIC8vICAtIHByaW9yaXR5OiBhbiBpbnRlZ2VyXG4gICAgLy8gIC0gcmVxdWlyZW1lbnQ6ICdzdHJpbmcnIChkZWZhdWx0KSwgJ2ludGVnZXInLCAnbnVtYmVyJywgJ3JlZ2V4cCcgb3IgYW4gQXJyYXkgb2YgdGhlc2VcbiAgICAvLyAgLSB2YWxpZGF0ZVN0cmluZywgdmFsaWRhdGVNdWx0aXBsZSwgdmFsaWRhdGVOdW1iZXI6IGZ1bmN0aW9ucyByZXR1cm5pbmcgYHRydWVgLCBgZmFsc2VgIG9yIGEgcHJvbWlzZVxuICAgIC8vIEFsdGVybmF0aXZlbHksIGEgdmFsaWRhdG9yIGNhbiBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBzdWNoIGFuIG9iamVjdFxuICAgIC8vXG4gICAgdmFsaWRhdG9yczoge1xuICAgICAgbm90Ymxhbms6IHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuICgvXFxTLy50ZXN0KHZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiAyXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IHtcbiAgICAgICAgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZSh2YWx1ZXMpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAoL1xcUy8udGVzdCh2YWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBwcmlvcml0eTogNTEyXG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgICAgdmFyIF9yZWYkc3RlcCA9IF9yZWYuc3RlcDtcbiAgICAgICAgICB2YXIgc3RlcCA9IF9yZWYkc3RlcCA9PT0gdW5kZWZpbmVkID8gJ2FueScgOiBfcmVmJHN0ZXA7XG4gICAgICAgICAgdmFyIF9yZWYkYmFzZSA9IF9yZWYuYmFzZTtcbiAgICAgICAgICB2YXIgYmFzZSA9IF9yZWYkYmFzZSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkYmFzZTtcblxuICAgICAgICAgIHZhciB0ZXN0ZXIgPSB0eXBlVGVzdGVyc1t0eXBlXTtcbiAgICAgICAgICBpZiAoIXRlc3Rlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWxpZGF0b3IgdHlwZSBgJyArIHR5cGUgKyAnYCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGVzdGVyLnRlc3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoIS9eYW55JC9pLnRlc3Qoc3RlcCB8fCAnJykpIHtcbiAgICAgICAgICAgICAgdmFyIG5iID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgdmFyIGRlY2ltYWxzID0gTWF0aC5tYXgoZGVjaW1hbFBsYWNlcyhzdGVwKSwgZGVjaW1hbFBsYWNlcyhiYXNlKSk7XG4gICAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2VzKG5iKSA+IGRlY2ltYWxzKSAvLyBWYWx1ZSBjYW4ndCBoYXZlIHRvbyBtYW55IGRlY2ltYWxzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAvLyBCZSBjYXJlZnVsIG9mIHJvdW5kaW5nIGVycm9ycyBieSB1c2luZyBpbnRlZ2Vycy5cbiAgICAgICAgICAgICAgdmFyIHRvSW50ID0gZnVuY3Rpb24gdG9JbnQoZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGYgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCh0b0ludChuYikgLSB0b0ludChiYXNlKSkgJSB0b0ludChzdGVwKSAhPSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlbWVudFR5cGU6IHtcbiAgICAgICAgICAnJzogJ3N0cmluZycsXG4gICAgICAgICAgc3RlcDogJ3N0cmluZycsXG4gICAgICAgICAgYmFzZTogJ251bWJlcidcbiAgICAgICAgfSxcbiAgICAgICAgcHJpb3JpdHk6IDI1NlxuICAgICAgfSxcbiAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCByZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gcmVnZXhwLnRlc3QodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlbWVudFR5cGU6ICdyZWdleHAnLFxuICAgICAgICBwcmlvcml0eTogNjRcbiAgICAgIH0sXG4gICAgICBtaW5sZW5ndGg6IHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCByZXF1aXJlbWVudCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVtZW50VHlwZTogJ2ludGVnZXInLFxuICAgICAgICBwcmlvcml0eTogMzBcbiAgICAgIH0sXG4gICAgICBtYXhsZW5ndGg6IHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCByZXF1aXJlbWVudCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVtZW50VHlwZTogJ2ludGVnZXInLFxuICAgICAgICBwcmlvcml0eTogMzBcbiAgICAgIH0sXG4gICAgICBsZW5ndGg6IHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gbWluICYmIHZhbHVlLmxlbmd0aCA8PSBtYXg7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVtZW50VHlwZTogWydpbnRlZ2VyJywgJ2ludGVnZXInXSxcbiAgICAgICAgcHJpb3JpdHk6IDMwXG4gICAgICB9LFxuICAgICAgbWluY2hlY2s6IHtcbiAgICAgICAgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZSh2YWx1ZXMsIHJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPj0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVtZW50VHlwZTogJ2ludGVnZXInLFxuICAgICAgICBwcmlvcml0eTogMzBcbiAgICAgIH0sXG4gICAgICBtYXhjaGVjazoge1xuICAgICAgICB2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlKHZhbHVlcywgcmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA8PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgIHByaW9yaXR5OiAzMFxuICAgICAgfSxcbiAgICAgIGNoZWNrOiB7XG4gICAgICAgIHZhbGlkYXRlTXVsdGlwbGU6IGZ1bmN0aW9uIHZhbGlkYXRlTXVsdGlwbGUodmFsdWVzLCBtaW4sIG1heCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID49IG1pbiAmJiB2YWx1ZXMubGVuZ3RoIDw9IG1heDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZW1lbnRUeXBlOiBbJ2ludGVnZXInLCAnaW50ZWdlciddLFxuICAgICAgICBwcmlvcml0eTogMzBcbiAgICAgIH0sXG4gICAgICBtaW46IFZhbGlkYXRvclJlZ2lzdHJ5X19jb21wYXJpc29uT3BlcmF0b3IoZnVuY3Rpb24gKHZhbHVlLCByZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gcmVxdWlyZW1lbnQ7XG4gICAgICB9KSxcbiAgICAgIG1heDogVmFsaWRhdG9yUmVnaXN0cnlfX2NvbXBhcmlzb25PcGVyYXRvcihmdW5jdGlvbiAodmFsdWUsIHJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSByZXF1aXJlbWVudDtcbiAgICAgIH0pLFxuICAgICAgcmFuZ2U6IFZhbGlkYXRvclJlZ2lzdHJ5X19jb21wYXJpc29uT3BlcmF0b3IoZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgICAgIH0pLFxuICAgICAgZXF1YWx0bzoge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIHJlZk9yVmFsdWUpIHtcbiAgICAgICAgICB2YXIgJHJlZmVyZW5jZSA9ICQocmVmT3JWYWx1ZSk7XG4gICAgICAgICAgaWYgKCRyZWZlcmVuY2UubGVuZ3RoKSByZXR1cm4gdmFsdWUgPT09ICRyZWZlcmVuY2UudmFsKCk7ZWxzZSByZXR1cm4gdmFsdWUgPT09IHJlZk9yVmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW9yaXR5OiAyNTZcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIFVJID0ge307XG5cbiAgdmFyIGRpZmZSZXN1bHRzID0gZnVuY3Rpb24gZGlmZlJlc3VsdHMobmV3UmVzdWx0LCBvbGRSZXN1bHQsIGRlZXApIHtcbiAgICB2YXIgYWRkZWQgPSBbXTtcbiAgICB2YXIga2VwdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdSZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZFJlc3VsdC5sZW5ndGg7IGorKykgaWYgKG5ld1Jlc3VsdFtpXS5hc3NlcnQubmFtZSA9PT0gb2xkUmVzdWx0W2pdLmFzc2VydC5uYW1lKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkga2VwdC5wdXNoKG5ld1Jlc3VsdFtpXSk7ZWxzZSBhZGRlZC5wdXNoKG5ld1Jlc3VsdFtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcHQ6IGtlcHQsXG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkOiAhZGVlcCA/IGRpZmZSZXN1bHRzKG9sZFJlc3VsdCwgbmV3UmVzdWx0LCB0cnVlKS5hZGRlZCA6IFtdXG4gICAgfTtcbiAgfTtcblxuICBVSS5Gb3JtID0ge1xuXG4gICAgX2FjdHVhbGl6ZVRyaWdnZXJzOiBmdW5jdGlvbiBfYWN0dWFsaXplVHJpZ2dlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignc3VibWl0LlBhcnNsZXknLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIF90aGlzMi5vblN1Ym1pdFZhbGlkYXRlKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLlBhcnNsZXknLCBVdGlscy5fU3VibWl0U2VsZWN0b3IsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgX3RoaXMyLm9uU3VibWl0QnV0dG9uKGV2dCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVUkgY291bGQgYmUgZGlzYWJsZWRcbiAgICAgIGlmIChmYWxzZSA9PT0gdGhpcy5vcHRpb25zLnVpRW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdub3ZhbGlkYXRlJywgJycpO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICB0aGlzLl9mb2N1c2VkRmllbGQgPSBudWxsO1xuXG4gICAgICBpZiAodHJ1ZSA9PT0gdGhpcy52YWxpZGF0aW9uUmVzdWx0IHx8ICdub25lJyA9PT0gdGhpcy5vcHRpb25zLmZvY3VzKSByZXR1cm4gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc1tpXTtcbiAgICAgICAgaWYgKHRydWUgIT09IGZpZWxkLnZhbGlkYXRpb25SZXN1bHQgJiYgZmllbGQudmFsaWRhdGlvblJlc3VsdC5sZW5ndGggPiAwICYmICd1bmRlZmluZWQnID09PSB0eXBlb2YgZmllbGQub3B0aW9ucy5ub0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXNlZEZpZWxkID0gZmllbGQuJGVsZW1lbnQ7XG4gICAgICAgICAgaWYgKCdmaXJzdCcgPT09IHRoaXMub3B0aW9ucy5mb2N1cykgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bGwgPT09IHRoaXMuX2ZvY3VzZWRGaWVsZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHJldHVybiB0aGlzLl9mb2N1c2VkRmllbGQuZm9jdXMoKTtcbiAgICB9LFxuXG4gICAgX2Rlc3Ryb3lVSTogZnVuY3Rpb24gX2Rlc3Ryb3lVSSgpIHtcbiAgICAgIC8vIFJlc2V0IGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuUGFyc2xleScpO1xuICAgIH1cblxuICB9O1xuXG4gIFVJLkZpZWxkID0ge1xuXG4gICAgX3JlZmxvd1VJOiBmdW5jdGlvbiBfcmVmbG93VUkoKSB7XG4gICAgICB0aGlzLl9idWlsZFVJKCk7XG5cbiAgICAgIC8vIElmIHRoaXMgZmllbGQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBVSSBkb24ndCBib3RoZXIgZG9pbmcgc29tZXRoaW5nXG4gICAgICBpZiAoIXRoaXMuX3VpKSByZXR1cm47XG5cbiAgICAgIC8vIERpZmYgYmV0d2VlbiB0d28gdmFsaWRhdGlvbiByZXN1bHRzXG4gICAgICB2YXIgZGlmZiA9IGRpZmZSZXN1bHRzKHRoaXMudmFsaWRhdGlvblJlc3VsdCwgdGhpcy5fdWkubGFzdFZhbGlkYXRpb25SZXN1bHQpO1xuXG4gICAgICAvLyBUaGVuIHN0b3JlIGN1cnJlbnQgdmFsaWRhdGlvbiByZXN1bHQgZm9yIG5leHQgcmVmbG93XG4gICAgICB0aGlzLl91aS5sYXN0VmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGlvblJlc3VsdDtcblxuICAgICAgLy8gSGFuZGxlIHZhbGlkIC8gaW52YWxpZCAvIG5vbmUgZmllbGQgY2xhc3NcbiAgICAgIHRoaXMuX21hbmFnZVN0YXR1c0NsYXNzKCk7XG5cbiAgICAgIC8vIEFkZCwgcmVtb3ZlLCB1cGRhdGVkIGVycm9ycyBtZXNzYWdlc1xuICAgICAgdGhpcy5fbWFuYWdlRXJyb3JzTWVzc2FnZXMoZGlmZik7XG5cbiAgICAgIC8vIFRyaWdnZXJzIGltcGxcbiAgICAgIHRoaXMuX2FjdHVhbGl6ZVRyaWdnZXJzKCk7XG5cbiAgICAgIC8vIElmIGZpZWxkIGlzIG5vdCB2YWxpZCBmb3IgdGhlIGZpcnN0IHRpbWUsIGJpbmQga2V5dXAgdHJpZ2dlciB0byBlYXNlIFVYIGFuZCBxdWlja2x5IGluZm9ybSB1c2VyXG4gICAgICBpZiAoKGRpZmYua2VwdC5sZW5ndGggfHwgZGlmZi5hZGRlZC5sZW5ndGgpICYmICF0aGlzLl9mYWlsZWRPbmNlKSB7XG4gICAgICAgIHRoaXMuX2ZhaWxlZE9uY2UgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hY3R1YWxpemVUcmlnZ2VycygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGZpZWxkJ3MgZXJyb3IgbWVzc2FnZShzKVxuICAgIGdldEVycm9yc01lc3NhZ2VzOiBmdW5jdGlvbiBnZXRFcnJvcnNNZXNzYWdlcygpIHtcbiAgICAgIC8vIE5vIGVycm9yIG1lc3NhZ2UsIGZpZWxkIGlzIHZhbGlkXG4gICAgICBpZiAodHJ1ZSA9PT0gdGhpcy52YWxpZGF0aW9uUmVzdWx0KSByZXR1cm4gW107XG5cbiAgICAgIHZhciBtZXNzYWdlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmFsaWRhdGlvblJlc3VsdC5sZW5ndGg7IGkrKykgbWVzc2FnZXMucHVzaCh0aGlzLnZhbGlkYXRpb25SZXN1bHRbaV0uZXJyb3JNZXNzYWdlIHx8IHRoaXMuX2dldEVycm9yTWVzc2FnZSh0aGlzLnZhbGlkYXRpb25SZXN1bHRbaV0uYXNzZXJ0KSk7XG5cbiAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9LFxuXG4gICAgLy8gSXQncyBhIGdvYWwgb2YgUGFyc2xleSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vIGxvbmdlciByZXF1aXJlZCBbIzEwNzNdXG4gICAgYWRkRXJyb3I6IGZ1bmN0aW9uIGFkZEVycm9yKG5hbWUpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWYyLm1lc3NhZ2U7XG4gICAgICB2YXIgYXNzZXJ0ID0gX3JlZjIuYXNzZXJ0O1xuICAgICAgdmFyIF9yZWYyJHVwZGF0ZUNsYXNzID0gX3JlZjIudXBkYXRlQ2xhc3M7XG4gICAgICB2YXIgdXBkYXRlQ2xhc3MgPSBfcmVmMiR1cGRhdGVDbGFzcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJHVwZGF0ZUNsYXNzO1xuXG4gICAgICB0aGlzLl9idWlsZFVJKCk7XG4gICAgICB0aGlzLl9hZGRFcnJvcihuYW1lLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGFzc2VydDogYXNzZXJ0IH0pO1xuXG4gICAgICBpZiAodXBkYXRlQ2xhc3MpIHRoaXMuX2Vycm9yQ2xhc3MoKTtcbiAgICB9LFxuXG4gICAgLy8gSXQncyBhIGdvYWwgb2YgUGFyc2xleSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vIGxvbmdlciByZXF1aXJlZCBbIzEwNzNdXG4gICAgdXBkYXRlRXJyb3I6IGZ1bmN0aW9uIHVwZGF0ZUVycm9yKG5hbWUpIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWYzLm1lc3NhZ2U7XG4gICAgICB2YXIgYXNzZXJ0ID0gX3JlZjMuYXNzZXJ0O1xuICAgICAgdmFyIF9yZWYzJHVwZGF0ZUNsYXNzID0gX3JlZjMudXBkYXRlQ2xhc3M7XG4gICAgICB2YXIgdXBkYXRlQ2xhc3MgPSBfcmVmMyR1cGRhdGVDbGFzcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYzJHVwZGF0ZUNsYXNzO1xuXG4gICAgICB0aGlzLl9idWlsZFVJKCk7XG4gICAgICB0aGlzLl91cGRhdGVFcnJvcihuYW1lLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGFzc2VydDogYXNzZXJ0IH0pO1xuXG4gICAgICBpZiAodXBkYXRlQ2xhc3MpIHRoaXMuX2Vycm9yQ2xhc3MoKTtcbiAgICB9LFxuXG4gICAgLy8gSXQncyBhIGdvYWwgb2YgUGFyc2xleSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vIGxvbmdlciByZXF1aXJlZCBbIzEwNzNdXG4gICAgcmVtb3ZlRXJyb3I6IGZ1bmN0aW9uIHJlbW92ZUVycm9yKG5hbWUpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB2YXIgX3JlZjQkdXBkYXRlQ2xhc3MgPSBfcmVmNC51cGRhdGVDbGFzcztcbiAgICAgIHZhciB1cGRhdGVDbGFzcyA9IF9yZWY0JHVwZGF0ZUNsYXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjQkdXBkYXRlQ2xhc3M7XG5cbiAgICAgIHRoaXMuX2J1aWxkVUkoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUVycm9yKG5hbWUpO1xuXG4gICAgICAvLyBlZGdlIGNhc2UgcG9zc2libGUgaGVyZTogcmVtb3ZlIGEgc3RhbmRhcmQgUGFyc2xleSBlcnJvciB0aGF0IGlzIHN0aWxsIGZhaWxpbmcgaW4gdGhpcy52YWxpZGF0aW9uUmVzdWx0XG4gICAgICAvLyBidXQgaGlnaGx5IGltcHJvYmFibGUgY3V6JyBtYW51YWxseSByZW1vdmluZyBhIHdlbGwgUGFyc2xleSBoYW5kbGVkIGVycm9yIG1ha2VzIG5vIHNlbnNlLlxuICAgICAgaWYgKHVwZGF0ZUNsYXNzKSB0aGlzLl9tYW5hZ2VTdGF0dXNDbGFzcygpO1xuICAgIH0sXG5cbiAgICBfbWFuYWdlU3RhdHVzQ2xhc3M6IGZ1bmN0aW9uIF9tYW5hZ2VTdGF0dXNDbGFzcygpIHtcbiAgICAgIGlmICh0aGlzLmhhc0NvbnN0cmFpbnRzKCkgJiYgdGhpcy5uZWVkc1ZhbGlkYXRpb24oKSAmJiB0cnVlID09PSB0aGlzLnZhbGlkYXRpb25SZXN1bHQpIHRoaXMuX3N1Y2Nlc3NDbGFzcygpO2Vsc2UgaWYgKHRoaXMudmFsaWRhdGlvblJlc3VsdC5sZW5ndGggPiAwKSB0aGlzLl9lcnJvckNsYXNzKCk7ZWxzZSB0aGlzLl9yZXNldENsYXNzKCk7XG4gICAgfSxcblxuICAgIF9tYW5hZ2VFcnJvcnNNZXNzYWdlczogZnVuY3Rpb24gX21hbmFnZUVycm9yc01lc3NhZ2VzKGRpZmYpIHtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHRoaXMub3B0aW9ucy5lcnJvcnNNZXNzYWdlc0Rpc2FibGVkKSByZXR1cm47XG5cbiAgICAgIC8vIENhc2Ugd2hlcmUgd2UgaGF2ZSBlcnJvck1lc3NhZ2Ugb3B0aW9uIHRoYXQgY29uZmlndXJlIGFuIHVuaXF1ZSBmaWVsZCBlcnJvciBtZXNzYWdlLCByZWdhcmRsZXNzIGZhaWxpbmcgdmFsaWRhdG9yc1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmVycm9yTWVzc2FnZSkge1xuICAgICAgICBpZiAoZGlmZi5hZGRlZC5sZW5ndGggfHwgZGlmZi5rZXB0Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2luc2VydEVycm9yV3JhcHBlcigpO1xuXG4gICAgICAgICAgaWYgKDAgPT09IHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLmZpbmQoJy5wYXJzbGV5LWN1c3RvbS1lcnJvci1tZXNzYWdlJykubGVuZ3RoKSB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hcHBlbmQoJCh0aGlzLm9wdGlvbnMuZXJyb3JUZW1wbGF0ZSkuYWRkQ2xhc3MoJ3BhcnNsZXktY3VzdG9tLWVycm9yLW1lc3NhZ2UnKSk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIuYWRkQ2xhc3MoJ2ZpbGxlZCcpLmZpbmQoJy5wYXJzbGV5LWN1c3RvbS1lcnJvci1tZXNzYWdlJykuaHRtbCh0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5yZW1vdmVDbGFzcygnZmlsbGVkJykuZmluZCgnLnBhcnNsZXktY3VzdG9tLWVycm9yLW1lc3NhZ2UnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdywgaGlkZSwgdXBkYXRlIGZhaWxpbmcgY29uc3RyYWludHMgbWVzc2FnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5yZW1vdmVkLmxlbmd0aDsgaSsrKSB0aGlzLl9yZW1vdmVFcnJvcihkaWZmLnJlbW92ZWRbaV0uYXNzZXJ0Lm5hbWUpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGlmZi5hZGRlZC5sZW5ndGg7IGkrKykgdGhpcy5fYWRkRXJyb3IoZGlmZi5hZGRlZFtpXS5hc3NlcnQubmFtZSwgeyBtZXNzYWdlOiBkaWZmLmFkZGVkW2ldLmVycm9yTWVzc2FnZSwgYXNzZXJ0OiBkaWZmLmFkZGVkW2ldLmFzc2VydCB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRpZmYua2VwdC5sZW5ndGg7IGkrKykgdGhpcy5fdXBkYXRlRXJyb3IoZGlmZi5rZXB0W2ldLmFzc2VydC5uYW1lLCB7IG1lc3NhZ2U6IGRpZmYua2VwdFtpXS5lcnJvck1lc3NhZ2UsIGFzc2VydDogZGlmZi5rZXB0W2ldLmFzc2VydCB9KTtcbiAgICB9LFxuXG4gICAgX2FkZEVycm9yOiBmdW5jdGlvbiBfYWRkRXJyb3IobmFtZSwgX3JlZjUpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjUubWVzc2FnZTtcbiAgICAgIHZhciBhc3NlcnQgPSBfcmVmNS5hc3NlcnQ7XG5cbiAgICAgIHRoaXMuX2luc2VydEVycm9yV3JhcHBlcigpO1xuICAgICAgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl91aS5lcnJvcnNXcmFwcGVySWQpO1xuICAgICAgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIuYWRkQ2xhc3MoJ2ZpbGxlZCcpLmFwcGVuZCgkKHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlKS5hZGRDbGFzcygncGFyc2xleS0nICsgbmFtZSkuaHRtbChtZXNzYWdlIHx8IHRoaXMuX2dldEVycm9yTWVzc2FnZShhc3NlcnQpKSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVFcnJvcjogZnVuY3Rpb24gX3VwZGF0ZUVycm9yKG5hbWUsIF9yZWY2KSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWY2Lm1lc3NhZ2U7XG4gICAgICB2YXIgYXNzZXJ0ID0gX3JlZjYuYXNzZXJ0O1xuXG4gICAgICB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hZGRDbGFzcygnZmlsbGVkJykuZmluZCgnLnBhcnNsZXktJyArIG5hbWUpLmh0bWwobWVzc2FnZSB8fCB0aGlzLl9nZXRFcnJvck1lc3NhZ2UoYXNzZXJ0KSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFcnJvcjogZnVuY3Rpb24gX3JlbW92ZUVycm9yKG5hbWUpIHtcbiAgICAgIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVBdHRyKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5yZW1vdmVDbGFzcygnZmlsbGVkJykuZmluZCgnLnBhcnNsZXktJyArIG5hbWUpLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICBfZ2V0RXJyb3JNZXNzYWdlOiBmdW5jdGlvbiBfZ2V0RXJyb3JNZXNzYWdlKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciBjdXN0b21Db25zdHJhaW50RXJyb3JNZXNzYWdlID0gY29uc3RyYWludC5uYW1lICsgJ01lc3NhZ2UnO1xuXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiB0aGlzLm9wdGlvbnNbY3VzdG9tQ29uc3RyYWludEVycm9yTWVzc2FnZV0pIHJldHVybiB3aW5kb3cuUGFyc2xleS5mb3JtYXRNZXNzYWdlKHRoaXMub3B0aW9uc1tjdXN0b21Db25zdHJhaW50RXJyb3JNZXNzYWdlXSwgY29uc3RyYWludC5yZXF1aXJlbWVudHMpO1xuXG4gICAgICByZXR1cm4gd2luZG93LlBhcnNsZXkuZ2V0RXJyb3JNZXNzYWdlKGNvbnN0cmFpbnQpO1xuICAgIH0sXG5cbiAgICBfYnVpbGRVSTogZnVuY3Rpb24gX2J1aWxkVUkoKSB7XG4gICAgICAvLyBVSSBjb3VsZCBiZSBhbHJlYWR5IGJ1aWx0IG9yIGRpc2FibGVkXG4gICAgICBpZiAodGhpcy5fdWkgfHwgZmFsc2UgPT09IHRoaXMub3B0aW9ucy51aUVuYWJsZWQpIHJldHVybjtcblxuICAgICAgdmFyIF91aSA9IHt9O1xuXG4gICAgICAvLyBHaXZlIGZpZWxkIGl0cyBQYXJzbGV5IGlkIGluIERPTVxuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMubmFtZXNwYWNlICsgJ2lkJywgdGhpcy5fX2lkX18pO1xuXG4gICAgICAvKiogR2VuZXJhdGUgaW1wb3J0YW50IFVJIGVsZW1lbnRzIGFuZCBzdG9yZSB0aGVtIGluIHRoaXMgKiovXG4gICAgICAvLyAkZXJyb3JDbGFzc0hhbmRsZXIgaXMgdGhlICRlbGVtZW50IHRoYXQgd291bCBoYXZlIHBhcnNsZXktZXJyb3IgYW5kIHBhcnNsZXktc3VjY2VzcyBjbGFzc2VzXG4gICAgICBfdWkuJGVycm9yQ2xhc3NIYW5kbGVyID0gdGhpcy5fbWFuYWdlQ2xhc3NIYW5kbGVyKCk7XG5cbiAgICAgIC8vICRlcnJvcnNXcmFwcGVyIGlzIGEgZGl2IHRoYXQgd291bGQgY29udGFpbiB0aGUgdmFyaW91cyBmaWVsZCBlcnJvcnMsIGl0IHdpbGwgYmUgYXBwZW5kZWQgaW50byAkZXJyb3JzQ29udGFpbmVyXG4gICAgICBfdWkuZXJyb3JzV3JhcHBlcklkID0gJ3BhcnNsZXktaWQtJyArICh0aGlzLm9wdGlvbnMubXVsdGlwbGUgPyAnbXVsdGlwbGUtJyArIHRoaXMub3B0aW9ucy5tdWx0aXBsZSA6IHRoaXMuX19pZF9fKTtcbiAgICAgIF91aS4kZXJyb3JzV3JhcHBlciA9ICQodGhpcy5vcHRpb25zLmVycm9yc1dyYXBwZXIpLmF0dHIoJ2lkJywgX3VpLmVycm9yc1dyYXBwZXJJZCk7XG5cbiAgICAgIC8vIFZhbGlkYXRpb25SZXN1bHQgVUkgc3RvcmFnZSB0byBkZXRlY3Qgd2hhdCBoYXZlIGNoYW5nZWQgYnd0IHR3byB2YWxpZGF0aW9ucywgYW5kIHVwZGF0ZSBET00gYWNjb3JkaW5nbHlcbiAgICAgIF91aS5sYXN0VmFsaWRhdGlvblJlc3VsdCA9IFtdO1xuICAgICAgX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSBmYWxzZTtcblxuICAgICAgLy8gU3RvcmUgaXQgaW4gdGhpcyBmb3IgbGF0ZXJcbiAgICAgIHRoaXMuX3VpID0gX3VpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZWxlbWVudCB3aWxsIGhhdmUgYHBhcnNsZXktZXJyb3JgIGFuZCBgcGFyc2xleS1zdWNjZXNzYCBjbGFzc2VzXG4gICAgX21hbmFnZUNsYXNzSGFuZGxlcjogZnVuY3Rpb24gX21hbmFnZUNsYXNzSGFuZGxlcigpIHtcbiAgICAgIC8vIENsYXNzIGhhbmRsZWQgY291bGQgYWxzbyBiZSBkZXRlcm1pbmVkIGJ5IGZ1bmN0aW9uIGdpdmVuIGluIFBhcnNsZXkgb3B0aW9uc1xuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlciAmJiAkKHRoaXMub3B0aW9ucy5jbGFzc0hhbmRsZXIpLmxlbmd0aCkgcmV0dXJuICQodGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcik7XG5cbiAgICAgIC8vIENsYXNzIGhhbmRsZWQgY291bGQgYWxzbyBiZSBkZXRlcm1pbmVkIGJ5IGZ1bmN0aW9uIGdpdmVuIGluIFBhcnNsZXkgb3B0aW9uc1xuICAgICAgdmFyICRoYW5kbGVyRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyO1xuXG4gICAgICAvLyBJdCBtaWdodCBhbHNvIGJlIHRoZSBmdW5jdGlvbiBuYW1lIG9mIGEgZ2xvYmFsIGZ1bmN0aW9uXG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiB3aW5kb3dbdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcl0pICRoYW5kbGVyRnVuY3Rpb24gPSB3aW5kb3dbdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcl07XG5cbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgJGhhbmRsZXJGdW5jdGlvbikge1xuICAgICAgICB2YXIgJGhhbmRsZXIgPSAkaGFuZGxlckZ1bmN0aW9uLmNhbGwodGhpcywgdGhpcyk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5lZCBhIHZhbGlkIGV4aXN0aW5nIERPTSBlbGVtZW50LCBnbyBmb3IgaXRcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgJGhhbmRsZXIgJiYgJGhhbmRsZXIubGVuZ3RoKSByZXR1cm4gJGhhbmRsZXI7XG4gICAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgJGhhbmRsZXJGdW5jdGlvbiAmJiAkaGFuZGxlckZ1bmN0aW9uIGluc3RhbmNlb2YgalF1ZXJ5ICYmICRoYW5kbGVyRnVuY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAkaGFuZGxlckZ1bmN0aW9uO1xuICAgICAgfSBlbHNlIGlmICgkaGFuZGxlckZ1bmN0aW9uKSB7XG4gICAgICAgIFV0aWxzLndhcm4oJ1RoZSBjbGFzcyBoYW5kbGVyIGAnICsgJGhhbmRsZXJGdW5jdGlvbiArICdgIGRvZXMgbm90IGV4aXN0IGluIERPTSBub3IgYXMgYSBnbG9iYWwgSlMgZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2lucHV0SG9sZGVyKCk7XG4gICAgfSxcblxuICAgIF9pbnB1dEhvbGRlcjogZnVuY3Rpb24gX2lucHV0SG9sZGVyKCkge1xuICAgICAgLy8gaWYgc2ltcGxlIGVsZW1lbnQgKGlucHV0LCB0ZXhhdHJlYSwgc2VsZWN0Li4uKSBpdCB3aWxsIHBlcmZlY3RseSBob3N0IHRoZSBjbGFzc2VzIGFuZCBwcmVjZWRlIHRoZSBlcnJvciBjb250YWluZXJcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlIHx8IHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHJldHVybiB0aGlzLiRlbGVtZW50O1xuXG4gICAgICAvLyBCdXQgaWYgbXVsdGlwbGUgZWxlbWVudCAocmFkaW8sIGNoZWNrYm94KSwgdGhhdCB3b3VsZCBiZSB0aGVpciBwYXJlbnRcbiAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50LnBhcmVudCgpO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0RXJyb3JXcmFwcGVyOiBmdW5jdGlvbiBfaW5zZXJ0RXJyb3JXcmFwcGVyKCkge1xuICAgICAgdmFyICRlcnJvcnNDb250YWluZXIgPSB0aGlzLm9wdGlvbnMuZXJyb3JzQ29udGFpbmVyO1xuXG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGlmIGFscmVhZHkgaW5zZXJ0ZWRcbiAgICAgIGlmICgwICE9PSB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5wYXJlbnQoKS5sZW5ndGgpIHJldHVybiB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5wYXJlbnQoKTtcblxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgJGVycm9yc0NvbnRhaW5lcikge1xuICAgICAgICBpZiAoJCgkZXJyb3JzQ29udGFpbmVyKS5sZW5ndGgpIHJldHVybiAkKCRlcnJvcnNDb250YWluZXIpLmFwcGVuZCh0aGlzLl91aS4kZXJyb3JzV3JhcHBlcik7ZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHdpbmRvd1skZXJyb3JzQ29udGFpbmVyXSkgJGVycm9yc0NvbnRhaW5lciA9IHdpbmRvd1skZXJyb3JzQ29udGFpbmVyXTtlbHNlIFV0aWxzLndhcm4oJ1RoZSBlcnJvcnMgY29udGFpbmVyIGAnICsgJGVycm9yc0NvbnRhaW5lciArICdgIGRvZXMgbm90IGV4aXN0IGluIERPTSBub3IgYXMgYSBnbG9iYWwgSlMgZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiAkZXJyb3JzQ29udGFpbmVyKSAkZXJyb3JzQ29udGFpbmVyID0gJGVycm9yc0NvbnRhaW5lci5jYWxsKHRoaXMsIHRoaXMpO1xuXG4gICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiAkZXJyb3JzQ29udGFpbmVyICYmICRlcnJvcnNDb250YWluZXIubGVuZ3RoKSByZXR1cm4gJGVycm9yc0NvbnRhaW5lci5hcHBlbmQodGhpcy5fdWkuJGVycm9yc1dyYXBwZXIpO1xuXG4gICAgICByZXR1cm4gdGhpcy5faW5wdXRIb2xkZXIoKS5hZnRlcih0aGlzLl91aS4kZXJyb3JzV3JhcHBlcik7XG4gICAgfSxcblxuICAgIF9hY3R1YWxpemVUcmlnZ2VyczogZnVuY3Rpb24gX2FjdHVhbGl6ZVRyaWdnZXJzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciAkdG9CaW5kID0gdGhpcy5fZmluZFJlbGF0ZWQoKTtcbiAgICAgIHZhciB0cmlnZ2VyO1xuXG4gICAgICAvLyBSZW1vdmUgUGFyc2xleSBldmVudHMgYWxyZWFkeSBib3VuZCBvbiB0aGlzIGZpZWxkXG4gICAgICAkdG9CaW5kLm9mZignLlBhcnNsZXknKTtcbiAgICAgIGlmICh0aGlzLl9mYWlsZWRPbmNlKSAkdG9CaW5kLm9uKFV0aWxzLm5hbWVzcGFjZUV2ZW50cyh0aGlzLm9wdGlvbnMudHJpZ2dlckFmdGVyRmFpbHVyZSwgJ1BhcnNsZXknKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuX3ZhbGlkYXRlSWZOZWVkZWQoKTtcbiAgICAgIH0pO2Vsc2UgaWYgKHRyaWdnZXIgPSBVdGlscy5uYW1lc3BhY2VFdmVudHModGhpcy5vcHRpb25zLnRyaWdnZXIsICdQYXJzbGV5JykpIHtcbiAgICAgICAgJHRvQmluZC5vbih0cmlnZ2VyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuX3ZhbGlkYXRlSWZOZWVkZWQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlSWZOZWVkZWQ6IGZ1bmN0aW9uIF92YWxpZGF0ZUlmTmVlZGVkKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgLy8gRm9yIGtleXVwLCBrZXlwcmVzcywga2V5ZG93biwgaW5wdXQuLi4gZXZlbnRzIHRoYXQgY291bGQgYmUgYSBsaXR0bGUgYml0IG9ic3RydXNpdmVcbiAgICAgIC8vIGRvIG5vdCB2YWxpZGF0ZSBpZiB2YWwgbGVuZ3RoIDwgbWluIHRocmVzaG9sZCBvbiBmaXJzdCB2YWxpZGF0aW9uLiBPbmNlIGZpZWxkIGhhdmUgYmVlbiB2YWxpZGF0ZWQgb25jZSBhbmQgaW5mb1xuICAgICAgLy8gYWJvdXQgc3VjY2VzcyBvciBmYWlsdXJlIGhhdmUgYmVlbiBkaXNwbGF5ZWQsIGFsd2F5cyB2YWxpZGF0ZSB3aXRoIHRoaXMgdHJpZ2dlciB0byByZWZsZWN0IGV2ZXJ5IHlhbGlkYXRpb24gY2hhbmdlLlxuICAgICAgaWYgKGV2ZW50ICYmIC9rZXl8aW5wdXQvLnRlc3QoZXZlbnQudHlwZSkpIGlmICghKHRoaXMuX3VpICYmIHRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUpICYmIHRoaXMuZ2V0VmFsdWUoKS5sZW5ndGggPD0gdGhpcy5vcHRpb25zLnZhbGlkYXRpb25UaHJlc2hvbGQpIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJvdW5jZSkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2RlYm91bmNlZCk7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnZhbGlkYXRlKCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5kZWJvdW5jZSk7XG4gICAgICB9IGVsc2UgdGhpcy52YWxpZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfcmVzZXRVSTogZnVuY3Rpb24gX3Jlc2V0VUkoKSB7XG4gICAgICAvLyBSZXNldCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB0aGlzLl9mYWlsZWRPbmNlID0gZmFsc2U7XG4gICAgICB0aGlzLl9hY3R1YWxpemVUcmlnZ2VycygpO1xuXG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGlmIFVJIG5ldmVyIGluaXRpYWxpemVkIGZvciB0aGlzIGZpZWxkXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLl91aSkgcmV0dXJuO1xuXG4gICAgICAvLyBSZXNldCBhbGwgZXJyb3JzJyBsaVxuICAgICAgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucmVtb3ZlQ2xhc3MoJ2ZpbGxlZCcpLmNoaWxkcmVuKCkucmVtb3ZlKCk7XG5cbiAgICAgIC8vIFJlc2V0IHZhbGlkYXRpb24gY2xhc3NcbiAgICAgIHRoaXMuX3Jlc2V0Q2xhc3MoKTtcblxuICAgICAgLy8gUmVzZXQgdmFsaWRhdGlvbiBmbGFncyBhbmQgbGFzdCB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAgdGhpcy5fdWkubGFzdFZhbGlkYXRpb25SZXN1bHQgPSBbXTtcbiAgICAgIHRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX2Rlc3Ryb3lVSTogZnVuY3Rpb24gX2Rlc3Ryb3lVSSgpIHtcbiAgICAgIHRoaXMuX3Jlc2V0VUkoKTtcblxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdGhpcy5fdWkpIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnJlbW92ZSgpO1xuXG4gICAgICBkZWxldGUgdGhpcy5fdWk7XG4gICAgfSxcblxuICAgIF9zdWNjZXNzQ2xhc3M6IGZ1bmN0aW9uIF9zdWNjZXNzQ2xhc3MoKSB7XG4gICAgICB0aGlzLl91aS52YWxpZGF0aW9uSW5mb3JtYXRpb25WaXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN1Y2Nlc3NDbGFzcyk7XG4gICAgfSxcbiAgICBfZXJyb3JDbGFzczogZnVuY3Rpb24gX2Vycm9yQ2xhc3MoKSB7XG4gICAgICB0aGlzLl91aS52YWxpZGF0aW9uSW5mb3JtYXRpb25WaXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG4gICAgfSxcbiAgICBfcmVzZXRDbGFzczogZnVuY3Rpb24gX3Jlc2V0Q2xhc3MoKSB7XG4gICAgICB0aGlzLl91aS4kZXJyb3JDbGFzc0hhbmRsZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN1Y2Nlc3NDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgRm9ybSA9IGZ1bmN0aW9uIEZvcm0oZWxlbWVudCwgZG9tT3B0aW9ucywgb3B0aW9ucykge1xuICAgIHRoaXMuX19jbGFzc19fID0gJ0Zvcm0nO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICB0aGlzLmRvbU9wdGlvbnMgPSBkb21PcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5wYXJlbnQgPSB3aW5kb3cuUGFyc2xleTtcblxuICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgdGhpcy52YWxpZGF0aW9uUmVzdWx0ID0gbnVsbDtcbiAgfTtcblxuICB2YXIgRm9ybV9fc3RhdHVzTWFwcGluZyA9IHsgcGVuZGluZzogbnVsbCwgcmVzb2x2ZWQ6IHRydWUsIHJlamVjdGVkOiBmYWxzZSB9O1xuXG4gIEZvcm0ucHJvdG90eXBlID0ge1xuICAgIG9uU3VibWl0VmFsaWRhdGU6IGZ1bmN0aW9uIG9uU3VibWl0VmFsaWRhdGUoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAvLyBUaGlzIGlzIGEgUGFyc2xleSBnZW5lcmF0ZWQgc3VibWl0IGV2ZW50LCBkbyBub3QgdmFsaWRhdGUsIGRvIG5vdCBwcmV2ZW50LCBzaW1wbHkgZXhpdCBhbmQga2VlcCBub3JtYWwgYmVoYXZpb3JcbiAgICAgIGlmICh0cnVlID09PSBldmVudC5wYXJzbGV5KSByZXR1cm47XG5cbiAgICAgIC8vIElmIHdlIGRpZG4ndCBjb21lIGhlcmUgdGhyb3VnaCBhIHN1Ym1pdCBidXR0b24sIHVzZSB0aGUgZmlyc3Qgb25lIGluIHRoZSBmb3JtXG4gICAgICB2YXIgc3VibWl0U291cmNlID0gdGhpcy5fc3VibWl0U291cmNlIHx8IHRoaXMuJGVsZW1lbnQuZmluZChVdGlscy5fU3VibWl0U2VsZWN0b3IpWzBdO1xuICAgICAgdGhpcy5fc3VibWl0U291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLnBhcnNsZXktc3ludGhldGljLXN1Ym1pdC1idXR0b24nKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgaWYgKHN1Ym1pdFNvdXJjZSAmJiBudWxsICE9PSBzdWJtaXRTb3VyY2UuZ2V0QXR0cmlidXRlKCdmb3Jtbm92YWxpZGF0ZScpKSByZXR1cm47XG5cbiAgICAgIHdpbmRvdy5QYXJzbGV5Ll9yZW1vdGVDYWNoZSA9IHt9O1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMud2hlblZhbGlkYXRlKHsgZXZlbnQ6IGV2ZW50IH0pO1xuXG4gICAgICBpZiAoJ3Jlc29sdmVkJyA9PT0gcHJvbWlzZS5zdGF0ZSgpICYmIGZhbHNlICE9PSB0aGlzLl90cmlnZ2VyKCdzdWJtaXQnKSkge1xuICAgICAgICAvLyBBbGwgZ29vZCwgbGV0IGV2ZW50IGdvIHRocm91Z2guIFdlIG1ha2UgdGhpcyBkaXN0aW5jdGlvbiBiZWNhdXNlIGJyb3dzZXJzXG4gICAgICAgIC8vIGRpZmZlciBpbiB0aGVpciBoYW5kbGluZyBvZiBgc3VibWl0YCBiZWluZyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBzdWJtaXQgZXZlbnQgWyMxMDQ3XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWplY3RlZCBvciBwZW5kaW5nOiBjYW5jZWwgdGhpcyBzdWJtaXRcbiAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICgncGVuZGluZycgPT09IHByb21pc2Uuc3RhdGUoKSkgcHJvbWlzZS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNS5fc3VibWl0KHN1Ym1pdFNvdXJjZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25TdWJtaXRCdXR0b246IGZ1bmN0aW9uIG9uU3VibWl0QnV0dG9uKGV2ZW50KSB7XG4gICAgICB0aGlzLl9zdWJtaXRTb3VyY2UgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIH0sXG4gICAgLy8gaW50ZXJuYWxcbiAgICAvLyBfc3VibWl0IHN1Ym1pdHMgdGhlIGZvcm0sIHRoaXMgdGltZSB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIHZhbGlkYXRpb25zLlxuICAgIC8vIENhcmUgbXVzdCBiZSB0YWtlbiB0byBcImZha2VcIiB0aGUgYWN0dWFsIHN1Ym1pdCBidXR0b24gYmVpbmcgY2xpY2tlZC5cbiAgICBfc3VibWl0OiBmdW5jdGlvbiBfc3VibWl0KHN1Ym1pdFNvdXJjZSkge1xuICAgICAgaWYgKGZhbHNlID09PSB0aGlzLl90cmlnZ2VyKCdzdWJtaXQnKSkgcmV0dXJuO1xuICAgICAgLy8gQWRkIHN1Ym1pdCBidXR0b24ncyBkYXRhXG4gICAgICBpZiAoc3VibWl0U291cmNlKSB7XG4gICAgICAgIHZhciAkc3ludGhldGljID0gdGhpcy4kZWxlbWVudC5maW5kKCcucGFyc2xleS1zeW50aGV0aWMtc3VibWl0LWJ1dHRvbicpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICBpZiAoMCA9PT0gJHN5bnRoZXRpYy5sZW5ndGgpICRzeW50aGV0aWMgPSAkKCc8aW5wdXQgY2xhc3M9XCJwYXJzbGV5LXN5bnRoZXRpYy1zdWJtaXQtYnV0dG9uXCIgdHlwZT1cImhpZGRlblwiPicpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICAkc3ludGhldGljLmF0dHIoe1xuICAgICAgICAgIG5hbWU6IHN1Ym1pdFNvdXJjZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcbiAgICAgICAgICB2YWx1ZTogc3VibWl0U291cmNlLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKF9leHRlbmRzKCQuRXZlbnQoJ3N1Ym1pdCcpLCB7IHBhcnNsZXk6IHRydWUgfSkpO1xuICAgIH0sXG5cbiAgICAvLyBQZXJmb3JtcyB2YWxpZGF0aW9uIG9uIGZpZWxkcyB3aGlsZSB0cmlnZ2VyaW5nIGV2ZW50cy5cbiAgICAvLyBAcmV0dXJucyBgdHJ1ZWAgaWYgYWxsIHZhbGlkYXRpb25zIHN1Y2NlZWRzLCBgZmFsc2VgXG4gICAgLy8gaWYgYSBmYWlsdXJlIGlzIGltbWVkaWF0ZWx5IGRldGVjdGVkLCBvciBgbnVsbGBcbiAgICAvLyBpZiBkZXBlbmRhbnQgb24gYSBwcm9taXNlLlxuICAgIC8vIENvbnNpZGVyIHVzaW5nIGB3aGVuVmFsaWRhdGVgIGluc3RlYWQuXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDEgJiYgISQuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICBVdGlscy53YXJuT25jZSgnQ2FsbGluZyB2YWxpZGF0ZSBvbiBhIHBhcnNsZXkgZm9ybSB3aXRob3V0IHBhc3NpbmcgYXJndW1lbnRzIGFzIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLicpO1xuXG4gICAgICAgIHZhciBfYXJndW1lbnRzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICB2YXIgZ3JvdXAgPSBfYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgZm9yY2UgPSBfYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgZXZlbnQgPSBfYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIG9wdGlvbnMgPSB7IGdyb3VwOiBncm91cCwgZm9yY2U6IGZvcmNlLCBldmVudDogZXZlbnQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtX19zdGF0dXNNYXBwaW5nW3RoaXMud2hlblZhbGlkYXRlKG9wdGlvbnMpLnN0YXRlKCldO1xuICAgIH0sXG5cbiAgICB3aGVuVmFsaWRhdGU6IGZ1bmN0aW9uIHdoZW5WYWxpZGF0ZSgpIHtcbiAgICAgIHZhciBfVXRpbHMkYWxsJGRvbmUkZmFpbCRhbHdheXMsXG4gICAgICAgICAgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBncm91cCA9IF9yZWY3Lmdyb3VwO1xuICAgICAgdmFyIGZvcmNlID0gX3JlZjcuZm9yY2U7XG4gICAgICB2YXIgZXZlbnQgPSBfcmVmNy5ldmVudDtcblxuICAgICAgdGhpcy5zdWJtaXRFdmVudCA9IGV2ZW50O1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3VibWl0RXZlbnQgPSBfZXh0ZW5kcyh7fSwgZXZlbnQsIHsgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgVXRpbHMud2Fybk9uY2UoXCJVc2luZyBgdGhpcy5zdWJtaXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpYCBpcyBkZXByZWNhdGVkOyBpbnN0ZWFkLCBjYWxsIGB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPSBmYWxzZWBcIik7XG4gICAgICAgICAgICBfdGhpczYudmFsaWRhdGlvblJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIH0gfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPSB0cnVlO1xuXG4gICAgICAvLyBmaXJlIHZhbGlkYXRlIGV2ZW50IHRvIGV2ZW50dWFsbHkgbW9kaWZ5IHRoaW5ncyBiZWZvcmUgZXZlcnkgdmFsaWRhdGlvblxuICAgICAgdGhpcy5fdHJpZ2dlcigndmFsaWRhdGUnKTtcblxuICAgICAgLy8gUmVmcmVzaCBmb3JtIERPTSBvcHRpb25zIGFuZCBmb3JtJ3MgZmllbGRzIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICB0aGlzLl9yZWZyZXNoRmllbGRzKCk7XG5cbiAgICAgIHZhciBwcm9taXNlcyA9IHRoaXMuX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJC5tYXAoX3RoaXM2LmZpZWxkcywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkLndoZW5WYWxpZGF0ZSh7IGZvcmNlOiBmb3JjZSwgZ3JvdXA6IGdyb3VwIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gKF9VdGlscyRhbGwkZG9uZSRmYWlsJGFsd2F5cyA9IFV0aWxzLmFsbChwcm9taXNlcykuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi5fdHJpZ2dlcignc3VjY2VzcycpO1xuICAgICAgfSkuZmFpbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi52YWxpZGF0aW9uUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzNi5mb2N1cygpO1xuICAgICAgICBfdGhpczYuX3RyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICB9KS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczYuX3RyaWdnZXIoJ3ZhbGlkYXRlZCcpO1xuICAgICAgfSkpLnBpcGUuYXBwbHkoX1V0aWxzJGFsbCRkb25lJGZhaWwkYWx3YXlzLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fcGlwZUFjY29yZGluZ1RvVmFsaWRhdGlvblJlc3VsdCgpKSk7XG4gICAgfSxcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciByZWZyZXNoZWQgZmllbGRzLCBhbmQgc3RvcCBvbiBmaXJzdCBmYWlsdXJlLlxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIGFsbCBmaWVsZHMgYXJlIHZhbGlkLCBgZmFsc2VgIGlmIGEgZmFpbHVyZSBpcyBkZXRlY3RlZFxuICAgIC8vIG9yIGBudWxsYCBpZiB0aGUgcmVzdWx0IGRlcGVuZHMgb24gYW4gdW5yZXNvbHZlZCBwcm9taXNlLlxuICAgIC8vIFByZWZlciB1c2luZyBgd2hlblZhbGlkYCBpbnN0ZWFkLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uIGlzVmFsaWQob3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiAhJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIFV0aWxzLndhcm5PbmNlKCdDYWxsaW5nIGlzVmFsaWQgb24gYSBwYXJzbGV5IGZvcm0gd2l0aG91dCBwYXNzaW5nIGFyZ3VtZW50cyBhcyBhbiBvYmplY3QgaXMgZGVwcmVjYXRlZC4nKTtcblxuICAgICAgICB2YXIgX2FyZ3VtZW50czIgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBncm91cCA9IF9hcmd1bWVudHMyWzBdO1xuICAgICAgICB2YXIgZm9yY2UgPSBfYXJndW1lbnRzMlsxXTtcblxuICAgICAgICBvcHRpb25zID0geyBncm91cDogZ3JvdXAsIGZvcmNlOiBmb3JjZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZvcm1fX3N0YXR1c01hcHBpbmdbdGhpcy53aGVuVmFsaWQob3B0aW9ucykuc3RhdGUoKV07XG4gICAgfSxcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciByZWZyZXNoZWQgZmllbGRzIGFuZCB2YWxpZGF0ZSB0aGVtLlxuICAgIC8vIFJldHVybnMgYSBwcm9taXNlLlxuICAgIC8vIEEgdmFsaWRhdGlvbiB0aGF0IGltbWVkaWF0ZWx5IGZhaWxzIHdpbGwgaW50ZXJydXB0IHRoZSB2YWxpZGF0aW9ucy5cbiAgICB3aGVuVmFsaWQ6IGZ1bmN0aW9uIHdoZW5WYWxpZCgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZjggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIGdyb3VwID0gX3JlZjguZ3JvdXA7XG4gICAgICB2YXIgZm9yY2UgPSBfcmVmOC5mb3JjZTtcblxuICAgICAgdGhpcy5fcmVmcmVzaEZpZWxkcygpO1xuXG4gICAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICQubWFwKF90aGlzNy5maWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmaWVsZC53aGVuVmFsaWQoeyBncm91cDogZ3JvdXAsIGZvcmNlOiBmb3JjZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBVdGlscy5hbGwocHJvbWlzZXMpO1xuICAgIH0sXG5cbiAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdGhpcy5fcmVmcmVzaEZpZWxkcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlc2V0IFVJXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgLy8gRm9ybSBjYXNlOiBlbWl0IGEgcmVzZXQgZXZlbnQgZm9yIGVhY2ggZmllbGRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHRoaXMuZmllbGRzW2ldLnJlc2V0KCk7XG5cbiAgICAgIHRoaXMuX3RyaWdnZXIoJ3Jlc2V0Jyk7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgUGFyc2xleSBpbnN0YW5jZSAoKyBVSSlcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgLy8gRmllbGQgY2FzZTogZW1pdCBkZXN0cm95IGV2ZW50IHRvIGNsZWFuIFVJIGFuZCB0aGVuIGRlc3Ryb3kgc3RvcmVkIGluc3RhbmNlXG4gICAgICB0aGlzLl9kZXN0cm95VUkoKTtcblxuICAgICAgLy8gRm9ybSBjYXNlOiBkZXN0cm95IGFsbCBpdHMgZmllbGRzIGFuZCB0aGVuIGRlc3Ryb3kgc3RvcmVkIGluc3RhbmNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB0aGlzLmZpZWxkc1tpXS5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnUGFyc2xleScpO1xuICAgICAgdGhpcy5fdHJpZ2dlcignZGVzdHJveScpO1xuICAgIH0sXG5cbiAgICBfcmVmcmVzaEZpZWxkczogZnVuY3Rpb24gX3JlZnJlc2hGaWVsZHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3R1YWxpemVPcHRpb25zKCkuX2JpbmRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgX2JpbmRGaWVsZHM6IGZ1bmN0aW9uIF9iaW5kRmllbGRzKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGRGaWVsZHMgPSB0aGlzLmZpZWxkcztcblxuICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgIHRoaXMuZmllbGRzTWFwcGVkQnlJZCA9IHt9O1xuXG4gICAgICB0aGlzLl93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM4LiRlbGVtZW50LmZpbmQoX3RoaXM4Lm9wdGlvbnMuaW5wdXRzKS5ub3QoX3RoaXM4Lm9wdGlvbnMuZXhjbHVkZWQpLmVhY2goZnVuY3Rpb24gKF8sIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgZmllbGRJbnN0YW5jZSA9IG5ldyB3aW5kb3cuUGFyc2xleS5GYWN0b3J5KGVsZW1lbnQsIHt9LCBfdGhpczgpO1xuXG4gICAgICAgICAgLy8gT25seSBhZGQgdmFsaWQgYW5kIG5vdCBleGNsdWRlZCBgRmllbGRgIGFuZCBgRmllbGRNdWx0aXBsZWAgY2hpbGRyZW5cbiAgICAgICAgICBpZiAoKCdGaWVsZCcgPT09IGZpZWxkSW5zdGFuY2UuX19jbGFzc19fIHx8ICdGaWVsZE11bHRpcGxlJyA9PT0gZmllbGRJbnN0YW5jZS5fX2NsYXNzX18pICYmIHRydWUgIT09IGZpZWxkSW5zdGFuY2Uub3B0aW9ucy5leGNsdWRlZCkge1xuICAgICAgICAgICAgdmFyIHVuaXF1ZUlkID0gZmllbGRJbnN0YW5jZS5fX2NsYXNzX18gKyAnLScgKyBmaWVsZEluc3RhbmNlLl9faWRfXztcbiAgICAgICAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIF90aGlzOC5maWVsZHNNYXBwZWRCeUlkW3VuaXF1ZUlkXSkge1xuICAgICAgICAgICAgICBfdGhpczguZmllbGRzTWFwcGVkQnlJZFt1bmlxdWVJZF0gPSBmaWVsZEluc3RhbmNlO1xuICAgICAgICAgICAgICBfdGhpczguZmllbGRzLnB1c2goZmllbGRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkLmVhY2goVXRpbHMuZGlmZmVyZW5jZShvbGRGaWVsZHMsIF90aGlzOC5maWVsZHMpLCBmdW5jdGlvbiAoXywgZmllbGQpIHtcbiAgICAgICAgICBmaWVsZC5yZXNldCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG9ubHkuXG4gICAgLy8gTG9vcGluZyBvbiBhIGZvcm0ncyBmaWVsZHMgdG8gZG8gdmFsaWRhdGlvbiBvciBzaW1pbGFyXG4gICAgLy8gd2lsbCB0cmlnZ2VyIHJlYWN0dWFsaXppbmcgb3B0aW9ucyBvbiBhbGwgb2YgdGhlbSwgd2hpY2hcbiAgICAvLyBpbiB0dXJuIHdpbGwgcmVhY3R1YWxpemUgdGhlIGZvcm0ncyBvcHRpb25zLlxuICAgIC8vIFRvIGF2b2lkIGNhbGxpbmcgYWN0dWFsaXplT3B0aW9ucyBzbyBtYW55IHRpbWVzIG9uIHRoZSBmb3JtXG4gICAgLy8gZm9yIG5vdGhpbmcsIF93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zIHRlbXBvcmFyaWx5IGRpc2FibGVzXG4gICAgLy8gdGhlIG1ldGhvZCBhY3R1YWxpemVPcHRpb25zIG9uIHRoaXMgZm9ybSB3aGlsZSBgZm5gIGlzIGNhbGxlZC5cbiAgICBfd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9uczogZnVuY3Rpb24gX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMoZm4pIHtcbiAgICAgIHZhciBvbGRBY3R1YWxpemVPcHRpb25zID0gdGhpcy5hY3R1YWxpemVPcHRpb25zO1xuICAgICAgdGhpcy5hY3R1YWxpemVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICB2YXIgcmVzdWx0ID0gZm4oKTtcbiAgICAgIHRoaXMuYWN0dWFsaXplT3B0aW9ucyA9IG9sZEFjdHVhbGl6ZU9wdGlvbnM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBvbmx5LlxuICAgIC8vIFNob3J0Y3V0IHRvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAvLyBSZXR1cm5zIHRydWUgaWZmIGV2ZW50IGlzIG5vdCBpbnRlcnJ1cHRlZCBhbmQgZGVmYXVsdCBub3QgcHJldmVudGVkLlxuICAgIF90cmlnZ2VyOiBmdW5jdGlvbiBfdHJpZ2dlcihldmVudE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2Zvcm06JyArIGV2ZW50TmFtZSk7XG4gICAgfVxuXG4gIH07XG5cbiAgdmFyIENvbnN0cmFpbnQgPSBmdW5jdGlvbiBDb25zdHJhaW50KHBhcnNsZXlGaWVsZCwgbmFtZSwgcmVxdWlyZW1lbnRzLCBwcmlvcml0eSwgaXNEb21Db25zdHJhaW50KSB7XG4gICAgdmFyIHZhbGlkYXRvclNwZWMgPSB3aW5kb3cuUGFyc2xleS5fdmFsaWRhdG9yUmVnaXN0cnkudmFsaWRhdG9yc1tuYW1lXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcih2YWxpZGF0b3JTcGVjKTtcbiAgICBwcmlvcml0eSA9IHByaW9yaXR5IHx8IHBhcnNsZXlGaWVsZC5vcHRpb25zW25hbWUgKyAnUHJpb3JpdHknXSB8fCB2YWxpZGF0b3IucHJpb3JpdHk7XG4gICAgaXNEb21Db25zdHJhaW50ID0gdHJ1ZSA9PT0gaXNEb21Db25zdHJhaW50O1xuXG4gICAgX2V4dGVuZHModGhpcywge1xuICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcmVxdWlyZW1lbnRzOiByZXF1aXJlbWVudHMsXG4gICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICBpc0RvbUNvbnN0cmFpbnQ6IGlzRG9tQ29uc3RyYWludFxuICAgIH0pO1xuICAgIHRoaXMuX3BhcnNlUmVxdWlyZW1lbnRzKHBhcnNsZXlGaWVsZC5vcHRpb25zKTtcbiAgfTtcblxuICB2YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gICAgdmFyIGNhcCA9IHN0clswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBjYXAgKyBzdHIuc2xpY2UoMSk7XG4gIH07XG5cbiAgQ29uc3RyYWludC5wcm90b3R5cGUgPSB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBpbnN0YW5jZSkge1xuICAgICAgdmFyIF92YWxpZGF0b3I7XG5cbiAgICAgIHJldHVybiAoX3ZhbGlkYXRvciA9IHRoaXMudmFsaWRhdG9yKS52YWxpZGF0ZS5hcHBseShfdmFsaWRhdG9yLCBbdmFsdWVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5yZXF1aXJlbWVudExpc3QpLCBbaW5zdGFuY2VdKSk7XG4gICAgfSxcblxuICAgIF9wYXJzZVJlcXVpcmVtZW50czogZnVuY3Rpb24gX3BhcnNlUmVxdWlyZW1lbnRzKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJlcXVpcmVtZW50TGlzdCA9IHRoaXMudmFsaWRhdG9yLnBhcnNlUmVxdWlyZW1lbnRzKHRoaXMucmVxdWlyZW1lbnRzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW190aGlzOS5uYW1lICsgY2FwaXRhbGl6ZShrZXkpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgRmllbGQgPSBmdW5jdGlvbiBGaWVsZChmaWVsZCwgZG9tT3B0aW9ucywgb3B0aW9ucywgcGFyc2xleUZvcm1JbnN0YW5jZSkge1xuICAgIHRoaXMuX19jbGFzc19fID0gJ0ZpZWxkJztcblxuICAgIHRoaXMuZWxlbWVudCA9IGZpZWxkO1xuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGZpZWxkKTtcblxuICAgIC8vIFNldCBwYXJlbnQgaWYgd2UgaGF2ZSBvbmVcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJzbGV5Rm9ybUluc3RhbmNlKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcnNsZXlGb3JtSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRvbU9wdGlvbnMgPSBkb21PcHRpb25zO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzb21lIHByb3BlcnRpZXNcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG4gICAgdGhpcy5jb25zdHJhaW50c0J5TmFtZSA9IHt9O1xuICAgIHRoaXMudmFsaWRhdGlvblJlc3VsdCA9IHRydWU7XG5cbiAgICAvLyBCaW5kIGNvbnN0cmFpbnRzXG4gICAgdGhpcy5fYmluZENvbnN0cmFpbnRzKCk7XG4gIH07XG5cbiAgdmFyIHBhcnNsZXlfZmllbGRfX3N0YXR1c01hcHBpbmcgPSB7IHBlbmRpbmc6IG51bGwsIHJlc29sdmVkOiB0cnVlLCByZWplY3RlZDogZmFsc2UgfTtcblxuICBGaWVsZC5wcm90b3R5cGUgPSB7XG4gICAgLy8gIyBQdWJsaWMgQVBJXG4gICAgLy8gVmFsaWRhdGUgZmllbGQgYW5kIHRyaWdnZXIgc29tZSBldmVudHMgZm9yIG1haW5seSBgVUlgXG4gICAgLy8gQHJldHVybnMgYHRydWVgLCBhbiBhcnJheSBvZiB0aGUgdmFsaWRhdG9ycyB0aGF0IGZhaWxlZCwgb3JcbiAgICAvLyBgbnVsbGAgaWYgdmFsaWRhdGlvbiBpcyBub3QgZmluaXNoZWQuIFByZWZlciB1c2luZyB3aGVuVmFsaWRhdGVcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiAhJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIFV0aWxzLndhcm5PbmNlKCdDYWxsaW5nIHZhbGlkYXRlIG9uIGEgcGFyc2xleSBmaWVsZCB3aXRob3V0IHBhc3NpbmcgYXJndW1lbnRzIGFzIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLicpO1xuICAgICAgICBvcHRpb25zID0geyBvcHRpb25zOiBvcHRpb25zIH07XG4gICAgICB9XG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMud2hlblZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgaWYgKCFwcm9taXNlKSAvLyBJZiBleGNsdWRlZCB3aXRoIGBncm91cGAgb3B0aW9uXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgc3dpdGNoIChwcm9taXNlLnN0YXRlKCkpIHtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ3Jlc29sdmVkJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb25SZXN1bHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFZhbGlkYXRlIGZpZWxkIGFuZCB0cmlnZ2VyIHNvbWUgZXZlbnRzIGZvciBtYWlubHkgYFVJYFxuICAgIC8vIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHN1Y2NlZWRzIG9ubHkgd2hlbiBhbGwgdmFsaWRhdGlvbnMgZG9cbiAgICAvLyBvciBgdW5kZWZpbmVkYCBpZiBmaWVsZCBpcyBub3QgaW4gdGhlIGdpdmVuIGBncm91cGAuXG4gICAgd2hlblZhbGlkYXRlOiBmdW5jdGlvbiB3aGVuVmFsaWRhdGUoKSB7XG4gICAgICB2YXIgX3doZW5WYWxpZCRhbHdheXMkZG9uZSRmYWlsJGFsd2F5cyxcbiAgICAgICAgICBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIF9yZWY5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBmb3JjZSA9IF9yZWY5LmZvcmNlO1xuICAgICAgdmFyIGdyb3VwID0gX3JlZjkuZ3JvdXA7XG5cbiAgICAgIC8vIGRvIG5vdCB2YWxpZGF0ZSBhIGZpZWxkIGlmIG5vdCB0aGUgc2FtZSBhcyBnaXZlbiB2YWxpZGF0aW9uIGdyb3VwXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIGlmIChncm91cCAmJiAhdGhpcy5faXNJbkdyb3VwKGdyb3VwKSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gICAgICAvLyBGaWVsZCBWYWxpZGF0ZSBldmVudC4gYHRoaXMudmFsdWVgIGNvdWxkIGJlIGFsdGVyZWQgZm9yIGN1c3RvbSBuZWVkc1xuICAgICAgdGhpcy5fdHJpZ2dlcigndmFsaWRhdGUnKTtcblxuICAgICAgcmV0dXJuIChfd2hlblZhbGlkJGFsd2F5cyRkb25lJGZhaWwkYWx3YXlzID0gdGhpcy53aGVuVmFsaWQoeyBmb3JjZTogZm9yY2UsIHZhbHVlOiB0aGlzLnZhbHVlLCBfcmVmcmVzaGVkOiB0cnVlIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAuX3JlZmxvd1VJKCk7XG4gICAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5fdHJpZ2dlcignc3VjY2VzcycpO1xuICAgICAgfSkuZmFpbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAuX3RyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICB9KS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEwLl90cmlnZ2VyKCd2YWxpZGF0ZWQnKTtcbiAgICAgIH0pKS5waXBlLmFwcGx5KF93aGVuVmFsaWQkYWx3YXlzJGRvbmUkZmFpbCRhbHdheXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9waXBlQWNjb3JkaW5nVG9WYWxpZGF0aW9uUmVzdWx0KCkpKTtcbiAgICB9LFxuXG4gICAgaGFzQ29uc3RyYWludHM6IGZ1bmN0aW9uIGhhc0NvbnN0cmFpbnRzKCkge1xuICAgICAgcmV0dXJuIDAgIT09IHRoaXMuY29uc3RyYWludHMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBBbiBlbXB0eSBvcHRpb25hbCBmaWVsZCBkb2VzIG5vdCBuZWVkIHZhbGlkYXRpb25cbiAgICBuZWVkc1ZhbGlkYXRpb246IGZ1bmN0aW9uIG5lZWRzVmFsaWRhdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdmFsdWUpIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gICAgICAvLyBJZiBhIGZpZWxkIGlzIGVtcHR5IGFuZCBub3QgcmVxdWlyZWQsIGl0IGlzIHZhbGlkXG4gICAgICAvLyBFeGNlcHQgaWYgYGRhdGEtcGFyc2xleS12YWxpZGF0ZS1pZi1lbXB0eWAgZXhwbGljaXRlbHkgYWRkZWQsIHVzZWZ1bCBmb3Igc29tZSBjdXN0b20gdmFsaWRhdG9yc1xuICAgICAgaWYgKCF2YWx1ZS5sZW5ndGggJiYgIXRoaXMuX2lzUmVxdWlyZWQoKSAmJiAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMub3B0aW9ucy52YWxpZGF0ZUlmRW1wdHkpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIF9pc0luR3JvdXA6IGZ1bmN0aW9uIF9pc0luR3JvdXAoZ3JvdXApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5ncm91cCkpIHJldHVybiAtMSAhPT0gJC5pbkFycmF5KGdyb3VwLCB0aGlzLm9wdGlvbnMuZ3JvdXApO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ncm91cCA9PT0gZ3JvdXA7XG4gICAgfSxcblxuICAgIC8vIEp1c3QgdmFsaWRhdGUgZmllbGQuIERvIG5vdCB0cmlnZ2VyIGFueSBldmVudC5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZmYgYWxsIGNvbnN0cmFpbnRzIHBhc3MsIGBmYWxzZWAgaWYgdGhlcmUgYXJlIGZhaWx1cmVzLFxuICAgIC8vIG9yIGBudWxsYCBpZiB0aGUgcmVzdWx0IGNhbiBub3QgYmUgZGV0ZXJtaW5lZCB5ZXQgKGRlcGVuZHMgb24gYSBwcm9taXNlKVxuICAgIC8vIFNlZSBhbHNvIGB3aGVuVmFsaWRgLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uIGlzVmFsaWQob3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiAhJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIFV0aWxzLndhcm5PbmNlKCdDYWxsaW5nIGlzVmFsaWQgb24gYSBwYXJzbGV5IGZpZWxkIHdpdGhvdXQgcGFzc2luZyBhcmd1bWVudHMgYXMgYW4gb2JqZWN0IGlzIGRlcHJlY2F0ZWQuJyk7XG5cbiAgICAgICAgdmFyIF9hcmd1bWVudHMzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICB2YXIgZm9yY2UgPSBfYXJndW1lbnRzM1swXTtcbiAgICAgICAgdmFyIHZhbHVlID0gX2FyZ3VtZW50czNbMV07XG5cbiAgICAgICAgb3B0aW9ucyA9IHsgZm9yY2U6IGZvcmNlLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy53aGVuVmFsaWQob3B0aW9ucyk7XG4gICAgICBpZiAoIXByb21pc2UpIC8vIEV4Y2x1ZGVkIHZpYSBgZ3JvdXBgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIHBhcnNsZXlfZmllbGRfX3N0YXR1c01hcHBpbmdbcHJvbWlzZS5zdGF0ZSgpXTtcbiAgICB9LFxuXG4gICAgLy8gSnVzdCB2YWxpZGF0ZSBmaWVsZC4gRG8gbm90IHRyaWdnZXIgYW55IGV2ZW50LlxuICAgIC8vIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHN1Y2NlZWRzIG9ubHkgd2hlbiBhbGwgdmFsaWRhdGlvbnMgZG9cbiAgICAvLyBvciBgdW5kZWZpbmVkYCBpZiB0aGUgZmllbGQgaXMgbm90IGluIHRoZSBnaXZlbiBgZ3JvdXBgLlxuICAgIC8vIFRoZSBhcmd1bWVudCBgZm9yY2VgIHdpbGwgZm9yY2UgdmFsaWRhdGlvbiBvZiBlbXB0eSBmaWVsZHMuXG4gICAgLy8gSWYgYSBgdmFsdWVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHZhbGlkYXRlZCBpbnN0ZWFkIG9mIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXG4gICAgd2hlblZhbGlkOiBmdW5jdGlvbiB3aGVuVmFsaWQoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmMTAgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIF9yZWYxMCRmb3JjZSA9IF9yZWYxMC5mb3JjZTtcbiAgICAgIHZhciBmb3JjZSA9IF9yZWYxMCRmb3JjZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmMTAkZm9yY2U7XG4gICAgICB2YXIgdmFsdWUgPSBfcmVmMTAudmFsdWU7XG4gICAgICB2YXIgZ3JvdXAgPSBfcmVmMTAuZ3JvdXA7XG4gICAgICB2YXIgX3JlZnJlc2hlZCA9IF9yZWYxMC5fcmVmcmVzaGVkO1xuXG4gICAgICAvLyBSZWNvbXB1dGUgb3B0aW9ucyBhbmQgcmViaW5kIGNvbnN0cmFpbnRzIHRvIGhhdmUgbGF0ZXN0IGNoYW5nZXNcbiAgICAgIGlmICghX3JlZnJlc2hlZCkgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAvLyBkbyBub3QgdmFsaWRhdGUgYSBmaWVsZCBpZiBub3QgdGhlIHNhbWUgYXMgZ2l2ZW4gdmFsaWRhdGlvbiBncm91cFxuICAgICAgaWYgKGdyb3VwICYmICF0aGlzLl9pc0luR3JvdXAoZ3JvdXApKSByZXR1cm47XG5cbiAgICAgIHRoaXMudmFsaWRhdGlvblJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIEEgZmllbGQgd2l0aG91dCBjb25zdHJhaW50IGlzIHZhbGlkXG4gICAgICBpZiAoIXRoaXMuaGFzQ29uc3RyYWludHMoKSkgcmV0dXJuICQud2hlbigpO1xuXG4gICAgICAvLyBWYWx1ZSBjb3VsZCBiZSBwYXNzZWQgYXMgYXJndW1lbnQsIG5lZWRlZCB0byBhZGQgbW9yZSBwb3dlciB0byAnZmllbGQ6dmFsaWRhdGUnXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB2YWx1ZSB8fCBudWxsID09PSB2YWx1ZSkgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgICAgIGlmICghdGhpcy5uZWVkc1ZhbGlkYXRpb24odmFsdWUpICYmIHRydWUgIT09IGZvcmNlKSByZXR1cm4gJC53aGVuKCk7XG5cbiAgICAgIHZhciBncm91cGVkQ29uc3RyYWludHMgPSB0aGlzLl9nZXRHcm91cGVkQ29uc3RyYWludHMoKTtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgJC5lYWNoKGdyb3VwZWRDb25zdHJhaW50cywgZnVuY3Rpb24gKF8sIGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIC8vIFByb2Nlc3Mgb25lIGdyb3VwIG9mIGNvbnN0cmFpbnRzIGF0IGEgdGltZSwgd2UgdmFsaWRhdGUgdGhlIGNvbnN0cmFpbnRzXG4gICAgICAgIC8vIGFuZCBjb21iaW5lIHRoZSBwcm9taXNlcyB0b2dldGhlci5cbiAgICAgICAgdmFyIHByb21pc2UgPSBVdGlscy5hbGwoJC5tYXAoY29uc3RyYWludHMsIGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTEuX3ZhbGlkYXRlQ29uc3RyYWludCh2YWx1ZSwgY29uc3RyYWludCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgaWYgKHByb21pc2Uuc3RhdGUoKSA9PT0gJ3JlamVjdGVkJykgcmV0dXJuIGZhbHNlOyAvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBpZiBhIGdyb3VwIGhhcyBhbHJlYWR5IGZhaWxlZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gVXRpbHMuYWxsKHByb21pc2VzKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybnMgYSBwcm9taXNlXG4gICAgX3ZhbGlkYXRlQ29uc3RyYWludDogZnVuY3Rpb24gX3ZhbGlkYXRlQ29uc3RyYWludCh2YWx1ZSwgY29uc3RyYWludCkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3RyYWludC52YWxpZGF0ZSh2YWx1ZSwgdGhpcyk7XG4gICAgICAvLyBNYXAgZmFsc2UgdG8gYSBmYWlsZWQgcHJvbWlzZVxuICAgICAgaWYgKGZhbHNlID09PSByZXN1bHQpIHJlc3VsdCA9ICQuRGVmZXJyZWQoKS5yZWplY3QoKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXR1cm4gYSBwcm9taXNlIGFuZCB0aGF0IHdlIHJlY29yZCBmYWlsdXJlc1xuICAgICAgcmV0dXJuIFV0aWxzLmFsbChbcmVzdWx0XSkuZmFpbChmdW5jdGlvbiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGlmICghKF90aGlzMTIudmFsaWRhdGlvblJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KSkgX3RoaXMxMi52YWxpZGF0aW9uUmVzdWx0ID0gW107XG4gICAgICAgIF90aGlzMTIudmFsaWRhdGlvblJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBhc3NlcnQ6IGNvbnN0cmFpbnQsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiAnc3RyaW5nJyA9PT0gdHlwZW9mIGVycm9yTWVzc2FnZSAmJiBlcnJvck1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybnMgUGFyc2xleSBmaWVsZCBjb21wdXRlZCB2YWx1ZSB0aGF0IGNvdWxkIGJlIG92ZXJyaWRlZCBvciBjb25maWd1cmVkIGluIERPTVxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgLy8gVmFsdWUgY291bGQgYmUgb3ZlcnJpZGVuIGluIERPTSBvciB3aXRoIGV4cGxpY2l0IG9wdGlvbnNcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbHVlKSB2YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZSh0aGlzKTtlbHNlIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSkgdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWU7ZWxzZSB2YWx1ZSA9IHRoaXMuJGVsZW1lbnQudmFsKCk7XG5cbiAgICAgIC8vIEhhbmRsZSB3cm9uZyBET00gb3IgY29uZmlndXJhdGlvbnNcbiAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHZhbHVlIHx8IG51bGwgPT09IHZhbHVlKSByZXR1cm4gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVXaGl0ZXNwYWNlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gUmVzZXQgVUlcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLl9yZXNldFVJKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcigncmVzZXQnKTtcbiAgICB9LFxuXG4gICAgLy8gRGVzdHJveSBQYXJzbGV5IGluc3RhbmNlICgrIFVJKVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAvLyBGaWVsZCBjYXNlOiBlbWl0IGRlc3Ryb3kgZXZlbnQgdG8gY2xlYW4gVUkgYW5kIHRoZW4gZGVzdHJveSBzdG9yZWQgaW5zdGFuY2VcbiAgICAgIHRoaXMuX2Rlc3Ryb3lVSSgpO1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCdQYXJzbGV5Jyk7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ0ZpZWxkTXVsdGlwbGUnKTtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICB9LFxuXG4gICAgLy8gQWN0dWFsaXplIG9wdGlvbnMgYW5kIHJlYmluZCBjb25zdHJhaW50c1xuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB0aGlzLl9yZWZyZXNoQ29uc3RyYWludHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVmcmVzaENvbnN0cmFpbnRzOiBmdW5jdGlvbiBfcmVmcmVzaENvbnN0cmFpbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsaXplT3B0aW9ucygpLl9iaW5kQ29uc3RyYWludHMoKTtcbiAgICB9LFxuXG4gICAgcmVmcmVzaENvbnN0cmFpbnRzOiBmdW5jdGlvbiByZWZyZXNoQ29uc3RyYWludHMoKSB7XG4gICAgICBVdGlscy53YXJuT25jZShcIlBhcnNsZXkncyByZWZyZXNoQ29uc3RyYWludHMgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSByZWZyZXNoXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEFkZCBhIG5ldyBjb25zdHJhaW50IHRvIGEgZmllbGRcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gICBuYW1lXG4gICAgKiBAcGFyYW0ge01peGVkfSAgICByZXF1aXJlbWVudHMgICAgICBvcHRpb25hbFxuICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgcHJpb3JpdHkgICAgICAgICAgb3B0aW9uYWxcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gIGlzRG9tQ29uc3RyYWludCAgIG9wdGlvbmFsXG4gICAgKi9cbiAgICBhZGRDb25zdHJhaW50OiBmdW5jdGlvbiBhZGRDb25zdHJhaW50KG5hbWUsIHJlcXVpcmVtZW50cywgcHJpb3JpdHksIGlzRG9tQ29uc3RyYWludCkge1xuXG4gICAgICBpZiAod2luZG93LlBhcnNsZXkuX3ZhbGlkYXRvclJlZ2lzdHJ5LnZhbGlkYXRvcnNbbmFtZV0pIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgQ29uc3RyYWludCh0aGlzLCBuYW1lLCByZXF1aXJlbWVudHMsIHByaW9yaXR5LCBpc0RvbUNvbnN0cmFpbnQpO1xuXG4gICAgICAgIC8vIGlmIGNvbnN0cmFpbnQgYWxyZWFkeSBleGlzdCwgZGVsZXRlIGl0IGFuZCBwdXNoIG5ldyB2ZXJzaW9uXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdGhpcy5jb25zdHJhaW50c0J5TmFtZVtjb25zdHJhaW50Lm5hbWVdKSB0aGlzLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludC5uYW1lKTtcblxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHNCeU5hbWVbY29uc3RyYWludC5uYW1lXSA9IGNvbnN0cmFpbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBjb25zdHJhaW50XG4gICAgcmVtb3ZlQ29uc3RyYWludDogZnVuY3Rpb24gcmVtb3ZlQ29uc3RyYWludChuYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uc3RyYWludHMubGVuZ3RoOyBpKyspIGlmIChuYW1lID09PSB0aGlzLmNvbnN0cmFpbnRzW2ldLm5hbWUpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuY29uc3RyYWludHNCeU5hbWVbbmFtZV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29uc3RyYWludCAoUmVtb3ZlICsgcmUtYWRkKVxuICAgIHVwZGF0ZUNvbnN0cmFpbnQ6IGZ1bmN0aW9uIHVwZGF0ZUNvbnN0cmFpbnQobmFtZSwgcGFyYW1ldGVycywgcHJpb3JpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbnN0cmFpbnQobmFtZSkuYWRkQ29uc3RyYWludChuYW1lLCBwYXJhbWV0ZXJzLCBwcmlvcml0eSk7XG4gICAgfSxcblxuICAgIC8vICMgSW50ZXJuYWxzXG5cbiAgICAvLyBJbnRlcm5hbCBvbmx5LlxuICAgIC8vIEJpbmQgY29uc3RyYWludHMgZnJvbSBjb25maWcgKyBvcHRpb25zICsgRE9NXG4gICAgX2JpbmRDb25zdHJhaW50czogZnVuY3Rpb24gX2JpbmRDb25zdHJhaW50cygpIHtcbiAgICAgIHZhciBjb25zdHJhaW50cyA9IFtdO1xuICAgICAgdmFyIGNvbnN0cmFpbnRzQnlOYW1lID0ge307XG5cbiAgICAgIC8vIGNsZWFuIGFsbCBleGlzdGluZyBET00gY29uc3RyYWludHMgdG8gb25seSBrZWVwIGphdmFzY3JpcHQgdXNlciBjb25zdHJhaW50c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSBpZiAoZmFsc2UgPT09IHRoaXMuY29uc3RyYWludHNbaV0uaXNEb21Db25zdHJhaW50KSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnB1c2godGhpcy5jb25zdHJhaW50c1tpXSk7XG4gICAgICAgIGNvbnN0cmFpbnRzQnlOYW1lW3RoaXMuY29uc3RyYWludHNbaV0ubmFtZV0gPSB0aGlzLmNvbnN0cmFpbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lID0gY29uc3RyYWludHNCeU5hbWU7XG5cbiAgICAgIC8vIHRoZW4gcmUtYWRkIFBhcnNsZXkgRE9NLUFQSSBjb25zdHJhaW50c1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm9wdGlvbnMpIHRoaXMuYWRkQ29uc3RyYWludChuYW1lLCB0aGlzLm9wdGlvbnNbbmFtZV0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIC8vIGZpbmFsbHksIGJpbmQgc3BlY2lhbCBIVE1MNSBjb25zdHJhaW50c1xuICAgICAgcmV0dXJuIHRoaXMuX2JpbmRIdG1sNUNvbnN0cmFpbnRzKCk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG9ubHkuXG4gICAgLy8gQmluZCBzcGVjaWZpYyBIVE1MNSBjb25zdHJhaW50cyB0byBiZSBIVE1MNSBjb21wbGlhbnRcbiAgICBfYmluZEh0bWw1Q29uc3RyYWludHM6IGZ1bmN0aW9uIF9iaW5kSHRtbDVDb25zdHJhaW50cygpIHtcbiAgICAgIC8vIGh0bWw1IHJlcXVpcmVkXG4gICAgICBpZiAobnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgncmVxdWlyZWQnKSkgdGhpcy5hZGRDb25zdHJhaW50KCdyZXF1aXJlZCcsIHRydWUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIC8vIGh0bWw1IHBhdHRlcm5cbiAgICAgIGlmIChudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuJykpIHRoaXMuYWRkQ29uc3RyYWludCgncGF0dGVybicsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm4nKSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgLy8gcmFuZ2VcbiAgICAgIHZhciBtaW4gPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW4nKTtcbiAgICAgIHZhciBtYXggPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXgnKTtcbiAgICAgIGlmIChudWxsICE9PSBtaW4gJiYgbnVsbCAhPT0gbWF4KSB0aGlzLmFkZENvbnN0cmFpbnQoJ3JhbmdlJywgW21pbiwgbWF4XSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgLy8gSFRNTDUgbWluXG4gICAgICBlbHNlIGlmIChudWxsICE9PSBtaW4pIHRoaXMuYWRkQ29uc3RyYWludCgnbWluJywgbWluLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAgIC8vIEhUTUw1IG1heFxuICAgICAgICBlbHNlIGlmIChudWxsICE9PSBtYXgpIHRoaXMuYWRkQ29uc3RyYWludCgnbWF4JywgbWF4LCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAvLyBsZW5ndGhcbiAgICAgIGlmIChudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5sZW5ndGgnKSAmJiBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnKSkgdGhpcy5hZGRDb25zdHJhaW50KCdsZW5ndGgnLCBbdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWlubGVuZ3RoJyksIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGxlbmd0aCcpXSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgLy8gSFRNTDUgbWlubGVuZ3RoXG4gICAgICBlbHNlIGlmIChudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5sZW5ndGgnKSkgdGhpcy5hZGRDb25zdHJhaW50KCdtaW5sZW5ndGgnLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5sZW5ndGgnKSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgICAvLyBIVE1MNSBtYXhsZW5ndGhcbiAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4bGVuZ3RoJykpIHRoaXMuYWRkQ29uc3RyYWludCgnbWF4bGVuZ3RoJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4bGVuZ3RoJyksIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIC8vIGh0bWw1IHR5cGVzXG4gICAgICB2YXIgdHlwZSA9IFV0aWxzLmdldFR5cGUodGhpcy5lbGVtZW50KTtcblxuICAgICAgLy8gU21hbGwgc3BlY2lhbCBjYXNlIGhlcmUgZm9yIEhUTUw1IG51bWJlcjogaW50ZWdlciB2YWxpZGF0b3IgaWYgc3RlcCBhdHRyaWJ1dGUgaXMgdW5kZWZpbmVkIG9yIGFuIGludGVnZXIgdmFsdWUsIG51bWJlciBvdGhlcndpc2VcbiAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRDb25zdHJhaW50KCd0eXBlJywgWydudW1iZXInLCB7XG4gICAgICAgICAgc3RlcDogdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RlcCcpIHx8ICcxJyxcbiAgICAgICAgICBiYXNlOiBtaW4gfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgICB9XSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgLy8gUmVndWxhciBvdGhlciBIVE1MNSBzdXBwb3J0ZWQgdHlwZXNcbiAgICAgIH0gZWxzZSBpZiAoL14oZW1haWx8dXJsfHJhbmdlfGRhdGUpJC9pLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDb25zdHJhaW50KCd0eXBlJywgdHlwZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG9ubHkuXG4gICAgLy8gRmllbGQgaXMgcmVxdWlyZWQgaWYgaGF2ZSByZXF1aXJlZCBjb25zdHJhaW50IHdpdGhvdXQgYGZhbHNlYCB2YWx1ZVxuICAgIF9pc1JlcXVpcmVkOiBmdW5jdGlvbiBfaXNSZXF1aXJlZCgpIHtcbiAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMuY29uc3RyYWludHNCeU5hbWUucmVxdWlyZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIGZhbHNlICE9PSB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lLnJlcXVpcmVkLnJlcXVpcmVtZW50cztcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgb25seS5cbiAgICAvLyBTaG9ydGN1dCB0byB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgX3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignZmllbGQ6JyArIGV2ZW50TmFtZSk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG9ubHlcbiAgICAvLyBIYW5kbGVzIHdoaXRlc3BhY2UgaW4gYSB2YWx1ZVxuICAgIC8vIFVzZSBgZGF0YS1wYXJzbGV5LXdoaXRlc3BhY2U9XCJzcXVpc2hcImAgdG8gYXV0byBzcXVpc2ggaW5wdXQgdmFsdWVcbiAgICAvLyBVc2UgYGRhdGEtcGFyc2xleS13aGl0ZXNwYWNlPVwidHJpbVwiYCB0byBhdXRvIHRyaW0gaW5wdXQgdmFsdWVcbiAgICBfaGFuZGxlV2hpdGVzcGFjZTogZnVuY3Rpb24gX2hhbmRsZVdoaXRlc3BhY2UodmFsdWUpIHtcbiAgICAgIGlmICh0cnVlID09PSB0aGlzLm9wdGlvbnMudHJpbVZhbHVlKSBVdGlscy53YXJuT25jZSgnZGF0YS1wYXJzbGV5LXRyaW0tdmFsdWU9XCJ0cnVlXCIgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBkYXRhLXBhcnNsZXktd2hpdGVzcGFjZT1cInRyaW1cIicpO1xuXG4gICAgICBpZiAoJ3NxdWlzaCcgPT09IHRoaXMub3B0aW9ucy53aGl0ZXNwYWNlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcblxuICAgICAgaWYgKCd0cmltJyA9PT0gdGhpcy5vcHRpb25zLndoaXRlc3BhY2UgfHwgJ3NxdWlzaCcgPT09IHRoaXMub3B0aW9ucy53aGl0ZXNwYWNlIHx8IHRydWUgPT09IHRoaXMub3B0aW9ucy50cmltVmFsdWUpIHZhbHVlID0gVXRpbHMudHJpbVN0cmluZyh2YWx1ZSk7XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgX2lzRGF0ZUlucHV0OiBmdW5jdGlvbiBfaXNEYXRlSW5wdXQoKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuY29uc3RyYWludHNCeU5hbWUudHlwZTtcbiAgICAgIHJldHVybiBjICYmIGMucmVxdWlyZW1lbnRzID09PSAnZGF0ZSc7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG9ubHkuXG4gICAgLy8gUmV0dXJucyB0aGUgY29uc3RyYWludHMsIGdyb3VwZWQgYnkgZGVzY2VuZGluZyBwcmlvcml0eS5cbiAgICAvLyBUaGUgcmVzdWx0IGlzIHRodXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGNvbnN0cmFpbnRzLlxuICAgIF9nZXRHcm91cGVkQ29uc3RyYWludHM6IGZ1bmN0aW9uIF9nZXRHcm91cGVkQ29uc3RyYWludHMoKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMub3B0aW9ucy5wcmlvcml0eUVuYWJsZWQpIHJldHVybiBbdGhpcy5jb25zdHJhaW50c107XG5cbiAgICAgIHZhciBncm91cGVkQ29uc3RyYWludHMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IHt9O1xuXG4gICAgICAvLyBDcmVhdGUgYXJyYXkgdW5pcXVlIG9mIHByaW9yaXRpZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHRoaXMuY29uc3RyYWludHNbaV0ucHJpb3JpdHk7XG4gICAgICAgIGlmICghaW5kZXhbcF0pIGdyb3VwZWRDb25zdHJhaW50cy5wdXNoKGluZGV4W3BdID0gW10pO1xuICAgICAgICBpbmRleFtwXS5wdXNoKHRoaXMuY29uc3RyYWludHNbaV0pO1xuICAgICAgfVxuICAgICAgLy8gU29ydCB0aGVtIGJ5IHByaW9yaXR5IERFU0NcbiAgICAgIGdyb3VwZWRDb25zdHJhaW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiWzBdLnByaW9yaXR5IC0gYVswXS5wcmlvcml0eTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ3JvdXBlZENvbnN0cmFpbnRzO1xuICAgIH1cblxuICB9O1xuXG4gIHZhciBwYXJzbGV5X2ZpZWxkID0gRmllbGQ7XG5cbiAgdmFyIE11bHRpcGxlID0gZnVuY3Rpb24gTXVsdGlwbGUoKSB7XG4gICAgdGhpcy5fX2NsYXNzX18gPSAnRmllbGRNdWx0aXBsZSc7XG4gIH07XG5cbiAgTXVsdGlwbGUucHJvdG90eXBlID0ge1xuICAgIC8vIEFkZCBuZXcgYCRlbGVtZW50YCBzaWJsaW5nIGZvciBtdWx0aXBsZSBmaWVsZFxuICAgIGFkZEVsZW1lbnQ6IGZ1bmN0aW9uIGFkZEVsZW1lbnQoJGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRzLnB1c2goJGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2VlIGBGaWVsZC5fcmVmcmVzaENvbnN0cmFpbnRzKClgXG4gICAgX3JlZnJlc2hDb25zdHJhaW50czogZnVuY3Rpb24gX3JlZnJlc2hDb25zdHJhaW50cygpIHtcbiAgICAgIHZhciBmaWVsZENvbnN0cmFpbnRzO1xuXG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG5cbiAgICAgIC8vIFNlbGVjdCBtdWx0aXBsZSBzcGVjaWFsIHRyZWF0bWVudFxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgdGhpcy5hY3R1YWxpemVPcHRpb25zKCkuX2JpbmRDb25zdHJhaW50cygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBHYXRoZXIgYWxsIGNvbnN0cmFpbnRzIGZvciBlYWNoIGlucHV0IGluIHRoZSBtdWx0aXBsZSBncm91cFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgaGF2ZSBub3QgYmVlbiBkeW5hbWljYWxseSByZW1vdmVkIHNpbmNlIGxhc3QgYmluZGluZ1xuICAgICAgICBpZiAoISQoJ2h0bWwnKS5oYXModGhpcy4kZWxlbWVudHNbaV0pLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkQ29uc3RyYWludHMgPSB0aGlzLiRlbGVtZW50c1tpXS5kYXRhKCdGaWVsZE11bHRpcGxlJykuX3JlZnJlc2hDb25zdHJhaW50cygpLmNvbnN0cmFpbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRDb25zdHJhaW50cy5sZW5ndGg7IGorKykgdGhpcy5hZGRDb25zdHJhaW50KGZpZWxkQ29uc3RyYWludHNbal0ubmFtZSwgZmllbGRDb25zdHJhaW50c1tqXS5yZXF1aXJlbWVudHMsIGZpZWxkQ29uc3RyYWludHNbal0ucHJpb3JpdHksIGZpZWxkQ29uc3RyYWludHNbal0uaXNEb21Db25zdHJhaW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNlZSBgRmllbGQuZ2V0VmFsdWUoKWBcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAvLyBWYWx1ZSBjb3VsZCBiZSBvdmVycmlkZW4gaW4gRE9NXG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSkgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZSh0aGlzKTtlbHNlIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSkgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcblxuICAgICAgLy8gUmFkaW8gaW5wdXQgY2FzZVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICB2YXIgdHlwZSA9IFV0aWxzLmdldFR5cGUodGhpcy5lbGVtZW50KTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycpIHJldHVybiB0aGlzLl9maW5kUmVsYXRlZCgpLmZpbHRlcignOmNoZWNrZWQnKS52YWwoKSB8fCAnJztcblxuICAgICAgICAvLyBjaGVja2JveCBpbnB1dCBjYXNlXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgdGhpcy5fZmluZFJlbGF0ZWQoKS5maWx0ZXIoJzpjaGVja2VkJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCgkKHRoaXMpLnZhbCgpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IG11bHRpcGxlIGNhc2VcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQubm9kZU5hbWUgPT09ICdTRUxFQ1QnICYmIG51bGwgPT09IHRoaXMuJGVsZW1lbnQudmFsKCkpIHJldHVybiBbXTtcblxuICAgICAgLy8gRGVmYXVsdCBjYXNlIHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQudmFsKCk7XG4gICAgfSxcblxuICAgIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRzID0gW3RoaXMuJGVsZW1lbnRdO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgdmFyIEZhY3RvcnkgPSBmdW5jdGlvbiBGYWN0b3J5KGVsZW1lbnQsIG9wdGlvbnMsIHBhcnNsZXlGb3JtSW5zdGFuY2UpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiBib3VuZCwgcmV0dXJucyBpdHMgc2F2ZWQgUGFyc2xleSBpbnN0YW5jZVxuICAgIHZhciBzYXZlZHBhcnNsZXlGb3JtSW5zdGFuY2UgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ1BhcnNsZXknKTtcbiAgICBpZiAoc2F2ZWRwYXJzbGV5Rm9ybUluc3RhbmNlKSB7XG5cbiAgICAgIC8vIElmIHRoZSBzYXZlZCBpbnN0YW5jZSBoYXMgYmVlbiBib3VuZCB3aXRob3V0IGEgRm9ybSBwYXJlbnQgYW5kIHRoZXJlIGlzIG9uZSBnaXZlbiBpbiB0aGlzIGNhbGwsIGFkZCBpdFxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFyc2xleUZvcm1JbnN0YW5jZSAmJiBzYXZlZHBhcnNsZXlGb3JtSW5zdGFuY2UucGFyZW50ID09PSB3aW5kb3cuUGFyc2xleSkge1xuICAgICAgICBzYXZlZHBhcnNsZXlGb3JtSW5zdGFuY2UucGFyZW50ID0gcGFyc2xleUZvcm1JbnN0YW5jZTtcbiAgICAgICAgc2F2ZWRwYXJzbGV5Rm9ybUluc3RhbmNlLl9yZXNldE9wdGlvbnMoc2F2ZWRwYXJzbGV5Rm9ybUluc3RhbmNlLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgIF9leHRlbmRzKHNhdmVkcGFyc2xleUZvcm1JbnN0YW5jZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhdmVkcGFyc2xleUZvcm1JbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBQYXJzbGV5IG11c3QgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBET00gZWxlbWVudCBvciBqUXVlcnkgJGVsZW1lbnRcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGJpbmQgUGFyc2xleSBvbiBhbiBleGlzdGluZyBlbGVtZW50LicpO1xuXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFyc2xleUZvcm1JbnN0YW5jZSAmJiAnRm9ybScgIT09IHBhcnNsZXlGb3JtSW5zdGFuY2UuX19jbGFzc19fKSB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBpbnN0YW5jZSBtdXN0IGJlIGEgRm9ybSBpbnN0YW5jZScpO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJzbGV5Rm9ybUluc3RhbmNlIHx8IHdpbmRvdy5QYXJzbGV5O1xuICAgIHJldHVybiB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgRmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9fY2xhc3NfXyA9ICdQYXJzbGV5JztcbiAgICAgIHRoaXMuX192ZXJzaW9uX18gPSAnMi44LjEnO1xuICAgICAgdGhpcy5fX2lkX18gPSBVdGlscy5nZW5lcmF0ZUlEKCk7XG5cbiAgICAgIC8vIFByZS1jb21wdXRlIG9wdGlvbnNcbiAgICAgIHRoaXMuX3Jlc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgLy8gQSBGb3JtIGluc3RhbmNlIGlzIG9idmlvdXNseSBhIGA8Zm9ybT5gIGVsZW1lbnQgYnV0IGFsc28gZXZlcnkgbm9kZSB0aGF0IGlzIG5vdCBhbiBpbnB1dCBhbmQgaGFzIHRoZSBgZGF0YS1wYXJzbGV5LXZhbGlkYXRlYCBhdHRyaWJ1dGVcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQubm9kZU5hbWUgPT09ICdGT1JNJyB8fCBVdGlscy5jaGVja0F0dHIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMubmFtZXNwYWNlLCAndmFsaWRhdGUnKSAmJiAhdGhpcy4kZWxlbWVudC5pcyh0aGlzLm9wdGlvbnMuaW5wdXRzKSkgcmV0dXJuIHRoaXMuYmluZCgncGFyc2xleUZvcm0nKTtcblxuICAgICAgLy8gRXZlcnkgb3RoZXIgZWxlbWVudCBpcyBib3VuZCBhcyBhIGBGaWVsZGAgb3IgYEZpZWxkTXVsdGlwbGVgXG4gICAgICByZXR1cm4gdGhpcy5pc011bHRpcGxlKCkgPyB0aGlzLmhhbmRsZU11bHRpcGxlKCkgOiB0aGlzLmJpbmQoJ3BhcnNsZXlGaWVsZCcpO1xuICAgIH0sXG5cbiAgICBpc011bHRpcGxlOiBmdW5jdGlvbiBpc011bHRpcGxlKCkge1xuICAgICAgdmFyIHR5cGUgPSBVdGlscy5nZXRUeXBlKHRoaXMuZWxlbWVudCk7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnIHx8IHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcgJiYgbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcbiAgICB9LFxuXG4gICAgLy8gTXVsdGlwbGVzIGZpZWxkcyBhcmUgYSByZWFsIG5pZ2h0bWFyZSA6KFxuICAgIC8vIE1heWJlIHNvbWUgcmVmYWN0b3Jpbmcgd291bGQgYmUgYXBwcmVjaWF0ZWQgaGVyZS4uLlxuICAgIGhhbmRsZU11bHRpcGxlOiBmdW5jdGlvbiBoYW5kbGVNdWx0aXBsZSgpIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgdmFyIG5hbWU7XG4gICAgICB2YXIgbXVsdGlwbGU7XG4gICAgICB2YXIgcGFyc2xleU11bHRpcGxlSW5zdGFuY2U7XG5cbiAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBuYW1lXG4gICAgICB0aGlzLm9wdGlvbnMubXVsdGlwbGUgPSB0aGlzLm9wdGlvbnMubXVsdGlwbGUgfHwgKG5hbWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJykpIHx8IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgIC8vIFNwZWNpYWwgc2VsZWN0IG11bHRpcGxlIGlucHV0XG4gICAgICBpZiAodGhpcy5lbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJyAmJiBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5tdWx0aXBsZSB8fCB0aGlzLl9faWRfXztcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZCgncGFyc2xleUZpZWxkTXVsdGlwbGUnKTtcblxuICAgICAgICAvLyBFbHNlIGZvciByYWRpbyAvIGNoZWNrYm94ZXMsIHdlIG5lZWQgYSBgbmFtZWAgb3IgYGRhdGEtcGFyc2xleS1tdWx0aXBsZWAgdG8gcHJvcGVybHkgYmluZCBpdFxuICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgICAgVXRpbHMud2FybignVG8gYmUgYm91bmQgYnkgUGFyc2xleSwgYSByYWRpbywgYSBjaGVja2JveCBhbmQgYSBtdWx0aXBsZSBzZWxlY3QgaW5wdXQgbXVzdCBoYXZlIGVpdGhlciBhIG5hbWUgb3IgYSBtdWx0aXBsZSBvcHRpb24uJywgdGhpcy4kZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHNwZWNpYWwgY2hhcnNcbiAgICAgIHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5tdWx0aXBsZS5yZXBsYWNlKC8oOnxcXC58XFxbfFxcXXxcXHt8XFx9fFxcJCkvZywgJycpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVyIGBkYXRhLXBhcnNsZXktbXVsdGlwbGVgIHRvIHNpYmxpbmdzIGlmIHdlIGhhdmUgYSB2YWxpZCBtdWx0aXBsZSBuYW1lXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICAkKCdpbnB1dFtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJykuZWFjaChmdW5jdGlvbiAoaSwgaW5wdXQpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IFV0aWxzLmdldFR5cGUoaW5wdXQpO1xuICAgICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIGlucHV0LnNldEF0dHJpYnV0ZShfdGhpczEzLm9wdGlvbnMubmFtZXNwYWNlICsgJ211bHRpcGxlJywgX3RoaXMxMy5vcHRpb25zLm11bHRpcGxlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGhlcmUgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgcmVsYXRlZCBtdWx0aXBsZSBpbnN0YW5jZSBzYXZlZFxuICAgICAgdmFyICRwcmV2aW91c2x5UmVsYXRlZCA9IHRoaXMuX2ZpbmRSZWxhdGVkKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRwcmV2aW91c2x5UmVsYXRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzbGV5TXVsdGlwbGVJbnN0YW5jZSA9ICQoJHByZXZpb3VzbHlSZWxhdGVkLmdldChpKSkuZGF0YSgnUGFyc2xleScpO1xuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJzbGV5TXVsdGlwbGVJbnN0YW5jZSkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLiRlbGVtZW50LmRhdGEoJ0ZpZWxkTXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgcGFyc2xleU11bHRpcGxlSW5zdGFuY2UuYWRkRWxlbWVudCh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBzZWNyZXQgRmllbGQgaW5zdGFuY2UgZm9yIGV2ZXJ5IG11bHRpcGxlIGZpZWxkLiBJdCB3aWxsIGJlIHN0b3JlZCBpbiBgZGF0YSgnRmllbGRNdWx0aXBsZScpYFxuICAgICAgLy8gQW5kIHdpbGwgYmUgdXNlZnVsIGxhdGVyIHRvIGFjY2VzcyBjbGFzc2ljIGBGaWVsZGAgc3R1ZmYgd2hpbGUgYmVpbmcgaW4gYSBgRmllbGRNdWx0aXBsZWAgaW5zdGFuY2VcbiAgICAgIHRoaXMuYmluZCgncGFyc2xleUZpZWxkJywgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBwYXJzbGV5TXVsdGlwbGVJbnN0YW5jZSB8fCB0aGlzLmJpbmQoJ3BhcnNsZXlGaWVsZE11bHRpcGxlJyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBwcm9wZXIgYEZvcm1gLCBgRmllbGRgIG9yIGBGaWVsZE11bHRpcGxlYFxuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodHlwZSwgZG9Ob3RTdG9yZSkge1xuICAgICAgdmFyIHBhcnNsZXlJbnN0YW5jZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BhcnNsZXlGb3JtJzpcbiAgICAgICAgICBwYXJzbGV5SW5zdGFuY2UgPSAkLmV4dGVuZChuZXcgRm9ybSh0aGlzLmVsZW1lbnQsIHRoaXMuZG9tT3B0aW9ucywgdGhpcy5vcHRpb25zKSwgbmV3IEJhc2UoKSwgd2luZG93LlBhcnNsZXlFeHRlbmQpLl9iaW5kRmllbGRzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BhcnNsZXlGaWVsZCc6XG4gICAgICAgICAgcGFyc2xleUluc3RhbmNlID0gJC5leHRlbmQobmV3IHBhcnNsZXlfZmllbGQodGhpcy5lbGVtZW50LCB0aGlzLmRvbU9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5wYXJlbnQpLCBuZXcgQmFzZSgpLCB3aW5kb3cuUGFyc2xleUV4dGVuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BhcnNsZXlGaWVsZE11bHRpcGxlJzpcbiAgICAgICAgICBwYXJzbGV5SW5zdGFuY2UgPSAkLmV4dGVuZChuZXcgcGFyc2xleV9maWVsZCh0aGlzLmVsZW1lbnQsIHRoaXMuZG9tT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLnBhcmVudCksIG5ldyBNdWx0aXBsZSgpLCBuZXcgQmFzZSgpLCB3aW5kb3cuUGFyc2xleUV4dGVuZCkuX2luaXQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArICdpcyBub3QgYSBzdXBwb3J0ZWQgUGFyc2xleSB0eXBlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlwbGUpIFV0aWxzLnNldEF0dHIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMubmFtZXNwYWNlLCAnbXVsdGlwbGUnLCB0aGlzLm9wdGlvbnMubXVsdGlwbGUpO1xuXG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBkb05vdFN0b3JlKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZGF0YSgnRmllbGRNdWx0aXBsZScsIHBhcnNsZXlJbnN0YW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNsZXlJbnN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgdGhlIGZyZXNobHkgYm91bmQgaW5zdGFuY2UgaW4gYSBET00gZWxlbWVudCBmb3IgbGF0ZXIgYWNjZXNzIHVzaW5nIGpRdWVyeSBgZGF0YSgpYFxuICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCdQYXJzbGV5JywgcGFyc2xleUluc3RhbmNlKTtcblxuICAgICAgLy8gVGVsbCB0aGUgd29ybGQgd2UgaGF2ZSBhIG5ldyBGb3JtIG9yIEZpZWxkIGluc3RhbmNlIVxuICAgICAgcGFyc2xleUluc3RhbmNlLl9hY3R1YWxpemVUcmlnZ2VycygpO1xuICAgICAgcGFyc2xleUluc3RhbmNlLl90cmlnZ2VyKCdpbml0Jyk7XG5cbiAgICAgIHJldHVybiBwYXJzbGV5SW5zdGFuY2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciB2ZXJudW1zID0gJC5mbi5qcXVlcnkuc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnNlSW50KHZlcm51bXNbMF0pIDw9IDEgJiYgcGFyc2VJbnQodmVybnVtc1sxXSkgPCA4KSB7XG4gICAgdGhyb3cgXCJUaGUgbG9hZGVkIHZlcnNpb24gb2YgalF1ZXJ5IGlzIHRvbyBvbGQuIFBsZWFzZSB1cGdyYWRlIHRvIDEuOC54IG9yIGJldHRlci5cIjtcbiAgfVxuICBpZiAoIXZlcm51bXMuZm9yRWFjaCkge1xuICAgIFV0aWxzLndhcm4oJ1BhcnNsZXkgcmVxdWlyZXMgRVM1IHRvIHJ1biBwcm9wZXJseS4gUGxlYXNlIGluY2x1ZGUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltJyk7XG4gIH1cbiAgLy8gSW5oZXJpdCBgb25gLCBgb2ZmYCAmIGB0cmlnZ2VyYCB0byBQYXJzbGV5OlxuICB2YXIgUGFyc2xleSA9IF9leHRlbmRzKG5ldyBCYXNlKCksIHtcbiAgICBlbGVtZW50OiBkb2N1bWVudCxcbiAgICAkZWxlbWVudDogJChkb2N1bWVudCksXG4gICAgYWN0dWFsaXplT3B0aW9uczogbnVsbCxcbiAgICBfcmVzZXRPcHRpb25zOiBudWxsLFxuICAgIEZhY3Rvcnk6IEZhY3RvcnksXG4gICAgdmVyc2lvbjogJzIuOC4xJ1xuICB9KTtcblxuICAvLyBTdXBwbGVtZW50IEZpZWxkIGFuZCBGb3JtIHdpdGggQmFzZVxuICAvLyBUaGlzIHdheSwgdGhlIGNvbnN0cnVjdG9ycyB3aWxsIGhhdmUgYWNjZXNzIHRvIHRob3NlIG1ldGhvZHNcbiAgX2V4dGVuZHMocGFyc2xleV9maWVsZC5wcm90b3R5cGUsIFVJLkZpZWxkLCBCYXNlLnByb3RvdHlwZSk7XG4gIF9leHRlbmRzKEZvcm0ucHJvdG90eXBlLCBVSS5Gb3JtLCBCYXNlLnByb3RvdHlwZSk7XG4gIC8vIEluaGVyaXQgYWN0dWFsaXplT3B0aW9ucyBhbmQgX3Jlc2V0T3B0aW9uczpcbiAgX2V4dGVuZHMoRmFjdG9yeS5wcm90b3R5cGUsIEJhc2UucHJvdG90eXBlKTtcblxuICAvLyAjIyMgalF1ZXJ5IEFQSVxuICAvLyBgJCgnLmVsZW0nKS5wYXJzbGV5KG9wdGlvbnMpYCBvciBgJCgnLmVsZW0nKS5wc2x5KG9wdGlvbnMpYFxuICAkLmZuLnBhcnNsZXkgPSAkLmZuLnBzbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcblxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goJCh0aGlzKS5wYXJzbGV5KG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgYXBwbGllZCB0byBub24gZXhpc3RpbmcgRE9NIGVsZW1lbnRcbiAgICBpZiAodGhpcy5sZW5ndGggPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRmFjdG9yeSh0aGlzWzBdLCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyAjIyMgRmllbGQgYW5kIEZvcm0gZXh0ZW5zaW9uXG4gIC8vIEVuc3VyZSB0aGUgZXh0ZW5zaW9uIGlzIG5vdyBkZWZpbmVkIGlmIGl0IHdhc24ndCBwcmV2aW91c2x5XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdpbmRvdy5QYXJzbGV5RXh0ZW5kKSB3aW5kb3cuUGFyc2xleUV4dGVuZCA9IHt9O1xuXG4gIC8vICMjIyBQYXJzbGV5IGNvbmZpZ1xuICAvLyBJbmhlcml0IGZyb20gUGFyc2xleURlZmF1bHQsIGFuZCBjb3B5IG92ZXIgYW55IGV4aXN0aW5nIHZhbHVlc1xuICBQYXJzbGV5Lm9wdGlvbnMgPSBfZXh0ZW5kcyhVdGlscy5vYmplY3RDcmVhdGUoRGVmYXVsdHMpLCB3aW5kb3cuUGFyc2xleUNvbmZpZyk7XG4gIHdpbmRvdy5QYXJzbGV5Q29uZmlnID0gUGFyc2xleS5vcHRpb25zOyAvLyBPbGQgd2F5IG9mIGFjY2Vzc2luZyBnbG9iYWwgb3B0aW9uc1xuXG4gIC8vICMjIyBHbG9iYWxzXG4gIHdpbmRvdy5QYXJzbGV5ID0gd2luZG93LnBzbHkgPSBQYXJzbGV5O1xuICBQYXJzbGV5LlV0aWxzID0gVXRpbHM7XG4gIHdpbmRvdy5QYXJzbGV5VXRpbHMgPSB7fTtcbiAgJC5lYWNoKFV0aWxzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgIHdpbmRvdy5QYXJzbGV5VXRpbHNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVXRpbHMud2Fybk9uY2UoJ0FjY2Vzc2luZyBgd2luZG93LlBhcnNsZXlVdGlsc2AgaXMgZGVwcmVjYXRlZC4gVXNlIGB3aW5kb3cuUGFyc2xleS5VdGlsc2AgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIFV0aWxzW2tleV0uYXBwbHkoVXRpbHMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gIyMjIERlZmluZSBtZXRob2RzIHRoYXQgZm9yd2FyZCB0byB0aGUgcmVnaXN0cnksIGFuZCBkZXByZWNhdGUgYWxsIGFjY2VzcyBleGNlcHQgdGhyb3VnaCB3aW5kb3cuUGFyc2xleVxuICB2YXIgcmVnaXN0cnkgPSB3aW5kb3cuUGFyc2xleS5fdmFsaWRhdG9yUmVnaXN0cnkgPSBuZXcgVmFsaWRhdG9yUmVnaXN0cnkod2luZG93LlBhcnNsZXlDb25maWcudmFsaWRhdG9ycywgd2luZG93LlBhcnNsZXlDb25maWcuaTE4bik7XG4gIHdpbmRvdy5QYXJzbGV5VmFsaWRhdG9yID0ge307XG4gICQuZWFjaCgnc2V0TG9jYWxlIGFkZENhdGFsb2cgYWRkTWVzc2FnZSBhZGRNZXNzYWdlcyBnZXRFcnJvck1lc3NhZ2UgZm9ybWF0TWVzc2FnZSBhZGRWYWxpZGF0b3IgdXBkYXRlVmFsaWRhdG9yIHJlbW92ZVZhbGlkYXRvciBoYXNWYWxpZGF0b3InLnNwbGl0KCcgJyksIGZ1bmN0aW9uIChpLCBtZXRob2QpIHtcbiAgICB3aW5kb3cuUGFyc2xleVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZ2lzdHJ5W21ldGhvZF0uYXBwbHkocmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB3aW5kb3cuUGFyc2xleVZhbGlkYXRvclttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF93aW5kb3ckUGFyc2xleTtcblxuICAgICAgVXRpbHMud2Fybk9uY2UoJ0FjY2Vzc2luZyB0aGUgbWV0aG9kIFxcJycgKyBtZXRob2QgKyAnXFwnIHRocm91Z2ggVmFsaWRhdG9yIGlzIGRlcHJlY2F0ZWQuIFNpbXBseSBjYWxsIFxcJ3dpbmRvdy5QYXJzbGV5LicgKyBtZXRob2QgKyAnKC4uLilcXCcnKTtcbiAgICAgIHJldHVybiAoX3dpbmRvdyRQYXJzbGV5ID0gd2luZG93LlBhcnNsZXkpW21ldGhvZF0uYXBwbHkoX3dpbmRvdyRQYXJzbGV5LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vICMjIyBVSVxuICAvLyBEZXByZWNhdGVkIGdsb2JhbCBvYmplY3RcbiAgd2luZG93LlBhcnNsZXkuVUkgPSBVSTtcbiAgd2luZG93LlBhcnNsZXlVSSA9IHtcbiAgICByZW1vdmVFcnJvcjogZnVuY3Rpb24gcmVtb3ZlRXJyb3IoaW5zdGFuY2UsIG5hbWUsIGRvTm90VXBkYXRlQ2xhc3MpIHtcbiAgICAgIHZhciB1cGRhdGVDbGFzcyA9IHRydWUgIT09IGRvTm90VXBkYXRlQ2xhc3M7XG4gICAgICBVdGlscy53YXJuT25jZSgnQWNjZXNzaW5nIFVJIGlzIGRlcHJlY2F0ZWQuIENhbGwgXFwncmVtb3ZlRXJyb3JcXCcgb24gdGhlIGluc3RhbmNlIGRpcmVjdGx5LiBQbGVhc2UgY29tbWVudCBpbiBpc3N1ZSAxMDczIGFzIHRvIHlvdXIgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kLicpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbW92ZUVycm9yKG5hbWUsIHsgdXBkYXRlQ2xhc3M6IHVwZGF0ZUNsYXNzIH0pO1xuICAgIH0sXG4gICAgZ2V0RXJyb3JzTWVzc2FnZXM6IGZ1bmN0aW9uIGdldEVycm9yc01lc3NhZ2VzKGluc3RhbmNlKSB7XG4gICAgICBVdGlscy53YXJuT25jZSgnQWNjZXNzaW5nIFVJIGlzIGRlcHJlY2F0ZWQuIENhbGwgXFwnZ2V0RXJyb3JzTWVzc2FnZXNcXCcgb24gdGhlIGluc3RhbmNlIGRpcmVjdGx5LicpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlLmdldEVycm9yc01lc3NhZ2VzKCk7XG4gICAgfVxuICB9O1xuICAkLmVhY2goJ2FkZEVycm9yIHVwZGF0ZUVycm9yJy5zcGxpdCgnICcpLCBmdW5jdGlvbiAoaSwgbWV0aG9kKSB7XG4gICAgd2luZG93LlBhcnNsZXlVSVttZXRob2RdID0gZnVuY3Rpb24gKGluc3RhbmNlLCBuYW1lLCBtZXNzYWdlLCBhc3NlcnQsIGRvTm90VXBkYXRlQ2xhc3MpIHtcbiAgICAgIHZhciB1cGRhdGVDbGFzcyA9IHRydWUgIT09IGRvTm90VXBkYXRlQ2xhc3M7XG4gICAgICBVdGlscy53YXJuT25jZSgnQWNjZXNzaW5nIFVJIGlzIGRlcHJlY2F0ZWQuIENhbGwgXFwnJyArIG1ldGhvZCArICdcXCcgb24gdGhlIGluc3RhbmNlIGRpcmVjdGx5LiBQbGVhc2UgY29tbWVudCBpbiBpc3N1ZSAxMDczIGFzIHRvIHlvdXIgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kLicpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlW21ldGhvZF0obmFtZSwgeyBtZXNzYWdlOiBtZXNzYWdlLCBhc3NlcnQ6IGFzc2VydCwgdXBkYXRlQ2xhc3M6IHVwZGF0ZUNsYXNzIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vICMjIyBQQVJTTEVZIGF1dG8tYmluZGluZ1xuICAvLyBQcmV2ZW50IGl0IGJ5IHNldHRpbmcgYFBhcnNsZXlDb25maWcuYXV0b0JpbmRgIHRvIGBmYWxzZWBcbiAgaWYgKGZhbHNlICE9PSB3aW5kb3cuUGFyc2xleUNvbmZpZy5hdXRvQmluZCkge1xuICAgICQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV29ya3Mgb25seSBvbiBgZGF0YS1wYXJzbGV5LXZhbGlkYXRlYC5cbiAgICAgIGlmICgkKCdbZGF0YS1wYXJzbGV5LXZhbGlkYXRlXScpLmxlbmd0aCkgJCgnW2RhdGEtcGFyc2xleS12YWxpZGF0ZV0nKS5wYXJzbGV5KCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbyA9ICQoe30pO1xuICB2YXIgZGVwcmVjYXRlZCA9IGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgVXRpbHMud2Fybk9uY2UoXCJQYXJzbGV5J3MgcHVic3ViIG1vZHVsZSBpcyBkZXByZWNhdGVkOyB1c2UgdGhlICdvbicgYW5kICdvZmYnIG1ldGhvZHMgb24gcGFyc2xleSBpbnN0YW5jZXMgb3Igd2luZG93LlBhcnNsZXlcIik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBldmVudCBoYW5kbGVyIHRoYXQgY2FsbHMgYGZuYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgZXhwZWN0c1xuICBmdW5jdGlvbiBhZGFwdChmbiwgY29udGV4dCkge1xuICAgIC8vIFN0b3JlIHRvIGFsbG93IHVuYmluZGluZ1xuICAgIGlmICghZm4ucGFyc2xleUFkYXB0ZWRDYWxsYmFjaykge1xuICAgICAgZm4ucGFyc2xleUFkYXB0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgIGZuLmFwcGx5KGNvbnRleHQgfHwgbywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZm4ucGFyc2xleUFkYXB0ZWRDYWxsYmFjaztcbiAgfVxuXG4gIHZhciBldmVudFByZWZpeCA9ICdwYXJzbGV5Oic7XG4gIC8vIENvbnZlcnRzICdwYXJzbGV5OmZvcm06dmFsaWRhdGUnIGludG8gJ2Zvcm06dmFsaWRhdGUnXG4gIGZ1bmN0aW9uIGV2ZW50TmFtZShuYW1lKSB7XG4gICAgaWYgKG5hbWUubGFzdEluZGV4T2YoZXZlbnRQcmVmaXgsIDApID09PSAwKSByZXR1cm4gbmFtZS5zdWJzdHIoZXZlbnRQcmVmaXgubGVuZ3RoKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8vICQubGlzdGVuIGlzIGRlcHJlY2F0ZWQuIFVzZSBQYXJzbGV5Lm9uIGluc3RlYWQuXG4gICQubGlzdGVuID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbnRleHQ7XG4gICAgZGVwcmVjYXRlZCgpO1xuICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGFyZ3VtZW50c1sxXSAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzJdKSB7XG4gICAgICBjb250ZXh0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBwYXJhbWV0ZXJzJyk7XG5cbiAgICB3aW5kb3cuUGFyc2xleS5vbihldmVudE5hbWUobmFtZSksIGFkYXB0KGNhbGxiYWNrLCBjb250ZXh0KSk7XG4gIH07XG5cbiAgJC5saXN0ZW5UbyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgbmFtZSwgZm4pIHtcbiAgICBkZXByZWNhdGVkKCk7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBwYXJzbGV5X2ZpZWxkKSAmJiAhKGluc3RhbmNlIGluc3RhbmNlb2YgRm9ybSkpIHRocm93IG5ldyBFcnJvcignTXVzdCBnaXZlIFBhcnNsZXkgaW5zdGFuY2UnKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG5hbWUgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHBhcmFtZXRlcnMnKTtcblxuICAgIGluc3RhbmNlLm9uKGV2ZW50TmFtZShuYW1lKSwgYWRhcHQoZm4pKTtcbiAgfTtcblxuICAkLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgZGVwcmVjYXRlZCgpO1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIG5hbWUgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGFyZ3VtZW50cycpO1xuICAgIHdpbmRvdy5QYXJzbGV5Lm9mZihldmVudE5hbWUobmFtZSksIGZuLnBhcnNsZXlBZGFwdGVkQ2FsbGJhY2spO1xuICB9O1xuXG4gICQudW5zdWJzY3JpYmVUbyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgbmFtZSkge1xuICAgIGRlcHJlY2F0ZWQoKTtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIHBhcnNsZXlfZmllbGQpICYmICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBGb3JtKSkgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGdpdmUgUGFyc2xleSBpbnN0YW5jZScpO1xuICAgIGluc3RhbmNlLm9mZihldmVudE5hbWUobmFtZSkpO1xuICB9O1xuXG4gICQudW5zdWJzY3JpYmVBbGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGRlcHJlY2F0ZWQoKTtcbiAgICB3aW5kb3cuUGFyc2xleS5vZmYoZXZlbnROYW1lKG5hbWUpKTtcbiAgICAkKCdmb3JtLGlucHV0LHRleHRhcmVhLHNlbGVjdCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gJCh0aGlzKS5kYXRhKCdQYXJzbGV5Jyk7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2Uub2ZmKGV2ZW50TmFtZShuYW1lKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gJC5lbWl0IGlzIGRlcHJlY2F0ZWQuIFVzZSBqUXVlcnkgZXZlbnRzIGluc3RlYWQuXG4gICQuZW1pdCA9IGZ1bmN0aW9uIChuYW1lLCBpbnN0YW5jZSkge1xuICAgIHZhciBfaW5zdGFuY2U7XG5cbiAgICBkZXByZWNhdGVkKCk7XG4gICAgdmFyIGluc3RhbmNlR2l2ZW4gPSBpbnN0YW5jZSBpbnN0YW5jZW9mIHBhcnNsZXlfZmllbGQgfHwgaW5zdGFuY2UgaW5zdGFuY2VvZiBGb3JtO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBpbnN0YW5jZUdpdmVuID8gMiA6IDEpO1xuICAgIGFyZ3MudW5zaGlmdChldmVudE5hbWUobmFtZSkpO1xuICAgIGlmICghaW5zdGFuY2VHaXZlbikge1xuICAgICAgaW5zdGFuY2UgPSB3aW5kb3cuUGFyc2xleTtcbiAgICB9XG4gICAgKF9pbnN0YW5jZSA9IGluc3RhbmNlKS50cmlnZ2VyLmFwcGx5KF9pbnN0YW5jZSwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgfTtcblxuICB2YXIgcHVic3ViID0ge307XG5cbiAgJC5leHRlbmQodHJ1ZSwgUGFyc2xleSwge1xuICAgIGFzeW5jVmFsaWRhdG9yczoge1xuICAgICAgJ2RlZmF1bHQnOiB7XG4gICAgICAgIGZuOiBmdW5jdGlvbiBmbih4aHIpIHtcbiAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBvbmx5IHN0YXR1cyAyeHggYXJlIGRlZW1lZCBzdWNjZXNzZnVsLlxuICAgICAgICAgIC8vIE5vdGU6IHdlIHVzZSBzdGF0dXMgaW5zdGVhZCBvZiBzdGF0ZSgpIGJlY2F1c2UgcmVzcG9uc2VzIHdpdGggc3RhdHVzIDIwMFxuICAgICAgICAgIC8vIGJ1dCBpbnZhbGlkIG1lc3NhZ2VzIChlLmcuIGFuIGVtcHR5IGJvZHkgZm9yIGNvbnRlbnQgdHlwZSBzZXQgdG8gSlNPTikgd2lsbFxuICAgICAgICAgIC8vIHJlc3VsdCBpbiBzdGF0ZSgpID09PSAncmVqZWN0ZWQnLlxuICAgICAgICAgIHJldHVybiB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwO1xuICAgICAgICB9LFxuICAgICAgICB1cmw6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZToge1xuICAgICAgICBmbjogZnVuY3Rpb24gZm4oeGhyKSB7XG4gICAgICAgICAgLy8gSWYgcmV2ZXJzZSBvcHRpb24gaXMgc2V0LCBhIGZhaWxpbmcgYWpheCByZXF1ZXN0IGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bFxuICAgICAgICAgIHJldHVybiB4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPj0gMzAwO1xuICAgICAgICB9LFxuICAgICAgICB1cmw6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkZEFzeW5jVmFsaWRhdG9yOiBmdW5jdGlvbiBhZGRBc3luY1ZhbGlkYXRvcihuYW1lLCBmbiwgdXJsLCBvcHRpb25zKSB7XG4gICAgICBQYXJzbGV5LmFzeW5jVmFsaWRhdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgZm46IGZuLFxuICAgICAgICB1cmw6IHVybCB8fCBmYWxzZSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH0pO1xuXG4gIFBhcnNsZXkuYWRkVmFsaWRhdG9yKCdyZW1vdGUnLCB7XG4gICAgcmVxdWlyZW1lbnRUeXBlOiB7XG4gICAgICAnJzogJ3N0cmluZycsXG4gICAgICAndmFsaWRhdG9yJzogJ3N0cmluZycsXG4gICAgICAncmV2ZXJzZSc6ICdib29sZWFuJyxcbiAgICAgICdvcHRpb25zJzogJ29iamVjdCdcbiAgICB9LFxuXG4gICAgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKHZhbHVlLCB1cmwsIG9wdGlvbnMsIGluc3RhbmNlKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgdmFyIGFqYXhPcHRpb25zO1xuICAgICAgdmFyIGNzcjtcbiAgICAgIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvciB8fCAodHJ1ZSA9PT0gb3B0aW9ucy5yZXZlcnNlID8gJ3JldmVyc2UnIDogJ2RlZmF1bHQnKTtcblxuICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgUGFyc2xleS5hc3luY1ZhbGlkYXRvcnNbdmFsaWRhdG9yXSkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIGFuIHVuZGVmaW5lZCBhc3luYyB2YWxpZGF0b3I6IGAnICsgdmFsaWRhdG9yICsgJ2AnKTtcblxuICAgICAgdXJsID0gUGFyc2xleS5hc3luY1ZhbGlkYXRvcnNbdmFsaWRhdG9yXS51cmwgfHwgdXJsO1xuXG4gICAgICAvLyBGaWxsIGN1cnJlbnQgdmFsdWVcbiAgICAgIGlmICh1cmwuaW5kZXhPZigne3ZhbHVlfScpID4gLTEpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3t2YWx1ZX0nLCBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5zdGFuY2UuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCBpbnN0YW5jZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2Ugb3B0aW9ucyBwYXNzZWQgaW4gZnJvbSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgb25lcyBpbiB0aGUgYXR0cmlidXRlXG4gICAgICB2YXIgcmVtb3RlT3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMub3B0aW9ucyB8fCB7fSwgUGFyc2xleS5hc3luY1ZhbGlkYXRvcnNbdmFsaWRhdG9yXS5vcHRpb25zKTtcblxuICAgICAgLy8gQWxsIGAkLmFqYXgob3B0aW9ucylgIGNvdWxkIGJlIG92ZXJyaWRkZW4gb3IgZXh0ZW5kZWQgZGlyZWN0bHkgZnJvbSBET00gaW4gYGRhdGEtcGFyc2xleS1yZW1vdGUtb3B0aW9uc2BcbiAgICAgIGFqYXhPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHR5cGU6ICdHRVQnXG4gICAgICB9LCByZW1vdGVPcHRpb25zKTtcblxuICAgICAgLy8gR2VuZXJhdGUgc3RvcmUga2V5IGJhc2VkIG9uIGFqYXggb3B0aW9uc1xuICAgICAgaW5zdGFuY2UudHJpZ2dlcignZmllbGQ6YWpheG9wdGlvbnMnLCBpbnN0YW5jZSwgYWpheE9wdGlvbnMpO1xuXG4gICAgICBjc3IgPSAkLnBhcmFtKGFqYXhPcHRpb25zKTtcblxuICAgICAgLy8gSW5pdGlhbGlzZSBxdWVycnkgY2FjaGVcbiAgICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIFBhcnNsZXkuX3JlbW90ZUNhY2hlKSBQYXJzbGV5Ll9yZW1vdGVDYWNoZSA9IHt9O1xuXG4gICAgICAvLyBUcnkgdG8gcmV0cmlldmUgc3RvcmVkIHhoclxuICAgICAgdmFyIHhociA9IFBhcnNsZXkuX3JlbW90ZUNhY2hlW2Nzcl0gPSBQYXJzbGV5Ll9yZW1vdGVDYWNoZVtjc3JdIHx8ICQuYWpheChhamF4T3B0aW9ucyk7XG5cbiAgICAgIHZhciBoYW5kbGVYaHIgPSBmdW5jdGlvbiBoYW5kbGVYaHIoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBQYXJzbGV5LmFzeW5jVmFsaWRhdG9yc1t2YWxpZGF0b3JdLmZuLmNhbGwoaW5zdGFuY2UsIHhociwgdXJsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIC8vIE1hcCBmYWxzeSByZXN1bHRzIHRvIHJlamVjdGVkIHByb21pc2VcbiAgICAgICAgICByZXN1bHQgPSAkLkRlZmVycmVkKCkucmVqZWN0KCk7XG4gICAgICAgIHJldHVybiAkLndoZW4ocmVzdWx0KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB4aHIudGhlbihoYW5kbGVYaHIsIGhhbmRsZVhocik7XG4gICAgfSxcblxuICAgIHByaW9yaXR5OiAtMVxuICB9KTtcblxuICBQYXJzbGV5Lm9uKCdmb3JtOnN1Ym1pdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBQYXJzbGV5Ll9yZW1vdGVDYWNoZSA9IHt9O1xuICB9KTtcblxuICBCYXNlLnByb3RvdHlwZS5hZGRBc3luY1ZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBVdGlscy53YXJuT25jZSgnQWNjZXNzaW5nIHRoZSBtZXRob2QgYGFkZEFzeW5jVmFsaWRhdG9yYCB0aHJvdWdoIGFuIGluc3RhbmNlIGlzIGRlcHJlY2F0ZWQuIFNpbXBseSBjYWxsIGBQYXJzbGV5LmFkZEFzeW5jVmFsaWRhdG9yKC4uLilgJyk7XG4gICAgcmV0dXJuIFBhcnNsZXkuYWRkQXN5bmNWYWxpZGF0b3IuYXBwbHkoUGFyc2xleSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGluY2x1ZGVkIHdpdGggdGhlIFBhcnNsZXkgbGlicmFyeSBpdHNlbGYsXG4gIC8vIHRodXMgdGhlcmUgaXMgbm8gdXNlIGluIGFkZGluZyBpdCB0byB5b3VyIHByb2plY3QuXG4gIFBhcnNsZXkuYWRkTWVzc2FnZXMoJ2VuJywge1xuICAgIGRlZmF1bHRNZXNzYWdlOiBcIlRoaXMgdmFsdWUgc2VlbXMgdG8gYmUgaW52YWxpZC5cIixcbiAgICB0eXBlOiB7XG4gICAgICBlbWFpbDogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIGVtYWlsLlwiLFxuICAgICAgdXJsOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgdXJsLlwiLFxuICAgICAgbnVtYmVyOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgbnVtYmVyLlwiLFxuICAgICAgaW50ZWdlcjogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIGludGVnZXIuXCIsXG4gICAgICBkaWdpdHM6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgZGlnaXRzLlwiLFxuICAgICAgYWxwaGFudW06IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYWxwaGFudW1lcmljLlwiXG4gICAgfSxcbiAgICBub3RibGFuazogXCJUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgYmxhbmsuXCIsXG4gICAgcmVxdWlyZWQ6IFwiVGhpcyB2YWx1ZSBpcyByZXF1aXJlZC5cIixcbiAgICBwYXR0ZXJuOiBcIlRoaXMgdmFsdWUgc2VlbXMgdG8gYmUgaW52YWxpZC5cIixcbiAgICBtaW46IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzLlwiLFxuICAgIG1heDogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBsb3dlciB0aGFuIG9yIGVxdWFsIHRvICVzLlwiLFxuICAgIHJhbmdlOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGJldHdlZW4gJXMgYW5kICVzLlwiLFxuICAgIG1pbmxlbmd0aDogXCJUaGlzIHZhbHVlIGlzIHRvbyBzaG9ydC4gSXQgc2hvdWxkIGhhdmUgJXMgY2hhcmFjdGVycyBvciBtb3JlLlwiLFxuICAgIG1heGxlbmd0aDogXCJUaGlzIHZhbHVlIGlzIHRvbyBsb25nLiBJdCBzaG91bGQgaGF2ZSAlcyBjaGFyYWN0ZXJzIG9yIGZld2VyLlwiLFxuICAgIGxlbmd0aDogXCJUaGlzIHZhbHVlIGxlbmd0aCBpcyBpbnZhbGlkLiBJdCBzaG91bGQgYmUgYmV0d2VlbiAlcyBhbmQgJXMgY2hhcmFjdGVycyBsb25nLlwiLFxuICAgIG1pbmNoZWNrOiBcIllvdSBtdXN0IHNlbGVjdCBhdCBsZWFzdCAlcyBjaG9pY2VzLlwiLFxuICAgIG1heGNoZWNrOiBcIllvdSBtdXN0IHNlbGVjdCAlcyBjaG9pY2VzIG9yIGZld2VyLlwiLFxuICAgIGNoZWNrOiBcIllvdSBtdXN0IHNlbGVjdCBiZXR3ZWVuICVzIGFuZCAlcyBjaG9pY2VzLlwiLFxuICAgIGVxdWFsdG86IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgdGhlIHNhbWUuXCJcbiAgfSk7XG5cbiAgUGFyc2xleS5zZXRMb2NhbGUoJ2VuJyk7XG5cbiAgLyoqXG4gICAqIGlucHV0ZXZlbnQgLSBBbGxldmlhdGUgYnJvd3NlciBidWdzIGZvciBpbnB1dCBldmVudHNcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNhbmRyZS9pbnB1dGV2ZW50XG4gICAqIEB2ZXJzaW9uIHYwLjAuMyAtIChidWlsdCBUaHUsIEFwciAxNHRoIDIwMTYsIDU6NTggcG0pXG4gICAqIEBhdXRob3IgTWFyYy1BbmRyZSBMYWZvcnR1bmUgPGdpdGh1YkBtYXJjLWFuZHJlLmNhPlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5cbiAgZnVuY3Rpb24gSW5wdXRFdmVudCgpIHtcbiAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICB2YXIgZ2xvYmFscyA9IHdpbmRvdyB8fCBnbG9iYWw7XG5cbiAgICAvLyBTbGlnaHRseSBvZGQgd2F5IGNvbnN0cnVjdCBvdXIgb2JqZWN0LiBUaGlzIHdheSBtZXRob2RzIGFyZSBmb3JjZSBib3VuZC5cbiAgICAvLyBVc2VkIHRvIHRlc3QgZm9yIGR1cGxpY2F0ZSBsaWJyYXJ5LlxuICAgIF9leHRlbmRzKHRoaXMsIHtcblxuICAgICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXNUcnVzdGVkLCBhc3N1bWVzIGV2ZW50IGlzIG5hdGl2ZS5cbiAgICAgIGlzTmF0aXZlRXZlbnQ6IGZ1bmN0aW9uIGlzTmF0aXZlRXZlbnQoZXZ0KSB7XG4gICAgICAgIHJldHVybiBldnQub3JpZ2luYWxFdmVudCAmJiBldnQub3JpZ2luYWxFdmVudC5pc1RydXN0ZWQgIT09IGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgZmFrZUlucHV0RXZlbnQ6IGZ1bmN0aW9uIGZha2VJbnB1dEV2ZW50KGV2dCkge1xuICAgICAgICBpZiAoX3RoaXMxNC5pc05hdGl2ZUV2ZW50KGV2dCkpIHtcbiAgICAgICAgICAkKGV2dC50YXJnZXQpLnRyaWdnZXIoJ2lucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG1pc2JlaGF2ZXM6IGZ1bmN0aW9uIG1pc2JlaGF2ZXMoZXZ0KSB7XG4gICAgICAgIGlmIChfdGhpczE0LmlzTmF0aXZlRXZlbnQoZXZ0KSkge1xuICAgICAgICAgIF90aGlzMTQuYmVoYXZlc09rKGV2dCk7XG4gICAgICAgICAgJChkb2N1bWVudCkub24oJ2NoYW5nZS5pbnB1dGV2ZW50JywgZXZ0LmRhdGEuc2VsZWN0b3IsIF90aGlzMTQuZmFrZUlucHV0RXZlbnQpO1xuICAgICAgICAgIF90aGlzMTQuZmFrZUlucHV0RXZlbnQoZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYmVoYXZlc09rOiBmdW5jdGlvbiBiZWhhdmVzT2soZXZ0KSB7XG4gICAgICAgIGlmIChfdGhpczE0LmlzTmF0aXZlRXZlbnQoZXZ0KSkge1xuICAgICAgICAgICQoZG9jdW1lbnQpIC8vIFNpbXBseSB1bmJpbmRzIHRoZSB0ZXN0aW5nIGhhbmRsZXJcbiAgICAgICAgICAub2ZmKCdpbnB1dC5pbnB1dGV2ZW50JywgZXZ0LmRhdGEuc2VsZWN0b3IsIF90aGlzMTQuYmVoYXZlc09rKS5vZmYoJ2NoYW5nZS5pbnB1dGV2ZW50JywgZXZ0LmRhdGEuc2VsZWN0b3IsIF90aGlzMTQubWlzYmVoYXZlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIEJpbmQgdGhlIHRlc3RpbmcgaGFuZGxlcnNcbiAgICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICAgIGlmIChnbG9iYWxzLmlucHV0RXZlbnRQYXRjaGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbHMuaW5wdXRFdmVudFBhdGNoZWQgPSAnMC4wLjMnO1xuICAgICAgICB2YXIgX2FyciA9IFsnc2VsZWN0JywgJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScsICdpbnB1dFt0eXBlPVwicmFkaW9cIl0nLCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gX2FycltfaV07XG4gICAgICAgICAgJChkb2N1bWVudCkub24oJ2lucHV0LmlucHV0ZXZlbnQnLCBzZWxlY3RvciwgeyBzZWxlY3Rvcjogc2VsZWN0b3IgfSwgX3RoaXMxNC5iZWhhdmVzT2spLm9uKCdjaGFuZ2UuaW5wdXRldmVudCcsIHNlbGVjdG9yLCB7IHNlbGVjdG9yOiBzZWxlY3RvciB9LCBfdGhpczE0Lm1pc2JlaGF2ZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICAgICAgZGVsZXRlIGdsb2JhbHMuaW5wdXRFdmVudFBhdGNoZWQ7XG4gICAgICAgICQoZG9jdW1lbnQpLm9mZignLmlucHV0ZXZlbnQnKTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBpbnB1dGV2ZW50ID0gbmV3IElucHV0RXZlbnQoKTtcblxuICBpbnB1dGV2ZW50Lmluc3RhbGwoKTtcblxuICB2YXIgcGFyc2xleSA9IFBhcnNsZXk7XG5cbiAgcmV0dXJuIHBhcnNsZXk7XG59KTtcblxuXG4oZnVuY3Rpb24od2luZG93LCBmYWN0b3J5KSB7XG4gIHZhciBsYXp5U2l6ZXMgPSBmYWN0b3J5KHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcbiAgd2luZG93LmxhenlTaXplcyA9IGxhenlTaXplcztcbiAgaWYodHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyl7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsYXp5U2l6ZXM7XG4gIH1cbn0od2luZG93LCBmdW5jdGlvbiBsKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICBpZighZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSl7cmV0dXJuO31cblxuICB2YXIgbGF6eXNpemVzLCBsYXp5U2l6ZXNDb25maWc7XG5cbiAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgdmFyIERhdGUgPSB3aW5kb3cuRGF0ZTtcblxuICB2YXIgc3VwcG9ydFBpY3R1cmUgPSB3aW5kb3cuSFRNTFBpY3R1cmVFbGVtZW50O1xuXG4gIHZhciBfYWRkRXZlbnRMaXN0ZW5lciA9ICdhZGRFdmVudExpc3RlbmVyJztcblxuICB2YXIgX2dldEF0dHJpYnV0ZSA9ICdnZXRBdHRyaWJ1dGUnO1xuXG4gIHZhciBhZGRFdmVudExpc3RlbmVyID0gd2luZG93W19hZGRFdmVudExpc3RlbmVyXTtcblxuICB2YXIgc2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQ7XG5cbiAgdmFyIHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcblxuICB2YXIgcmVnUGljdHVyZSA9IC9ecGljdHVyZSQvaTtcblxuICB2YXIgbG9hZEV2ZW50cyA9IFsnbG9hZCcsICdlcnJvcicsICdsYXp5aW5jbHVkZWQnLCAnX2xhenlsb2FkZWQnXTtcblxuICB2YXIgcmVnQ2xhc3NDYWNoZSA9IHt9O1xuXG4gIHZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG5cbiAgdmFyIGhhc0NsYXNzID0gZnVuY3Rpb24oZWxlLCBjbHMpIHtcbiAgICBpZighcmVnQ2xhc3NDYWNoZVtjbHNdKXtcbiAgICAgIHJlZ0NsYXNzQ2FjaGVbY2xzXSA9IG5ldyBSZWdFeHAoJyhcXFxcc3xeKScrY2xzKycoXFxcXHN8JCknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ0NsYXNzQ2FjaGVbY2xzXS50ZXN0KGVsZVtfZ2V0QXR0cmlidXRlXSgnY2xhc3MnKSB8fCAnJykgJiYgcmVnQ2xhc3NDYWNoZVtjbHNdO1xuICB9O1xuXG4gIHZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uKGVsZSwgY2xzKSB7XG4gICAgaWYgKCFoYXNDbGFzcyhlbGUsIGNscykpe1xuICAgICAgZWxlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlW19nZXRBdHRyaWJ1dGVdKCdjbGFzcycpIHx8ICcnKS50cmltKCkgKyAnICcgKyBjbHMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbGUsIGNscykge1xuICAgIHZhciByZWc7XG4gICAgaWYgKChyZWcgPSBoYXNDbGFzcyhlbGUsY2xzKSkpIHtcbiAgICAgIGVsZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGVsZVtfZ2V0QXR0cmlidXRlXSgnY2xhc3MnKSB8fCAnJykucmVwbGFjZShyZWcsICcgJykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYWRkUmVtb3ZlTG9hZEV2ZW50cyA9IGZ1bmN0aW9uKGRvbSwgZm4sIGFkZCl7XG4gICAgdmFyIGFjdGlvbiA9IGFkZCA/IF9hZGRFdmVudExpc3RlbmVyIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGlmKGFkZCl7XG4gICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGRvbSwgZm4pO1xuICAgIH1cbiAgICBsb2FkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZ0KXtcbiAgICAgIGRvbVthY3Rpb25dKGV2dCwgZm4pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB0cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbihlbGVtLCBuYW1lLCBkZXRhaWwsIG5vQnViYmxlcywgbm9DYW5jZWxhYmxlKXtcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblxuICAgIGlmKCFkZXRhaWwpe1xuICAgICAgZGV0YWlsID0ge307XG4gICAgfVxuXG4gICAgZGV0YWlsLmluc3RhbmNlID0gbGF6eXNpemVzO1xuXG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsICFub0J1YmJsZXMsICFub0NhbmNlbGFibGUpO1xuXG4gICAgZXZlbnQuZGV0YWlsID0gZGV0YWlsO1xuXG4gICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBvbHlmaWxsID0gZnVuY3Rpb24gKGVsLCBmdWxsKXtcbiAgICB2YXIgcG9seWZpbGw7XG4gICAgaWYoICFzdXBwb3J0UGljdHVyZSAmJiAoIHBvbHlmaWxsID0gKHdpbmRvdy5waWN0dXJlZmlsbCB8fCBsYXp5U2l6ZXNDb25maWcucGYpICkgKXtcbiAgICAgIGlmKGZ1bGwgJiYgZnVsbC5zcmMgJiYgIWVsW19nZXRBdHRyaWJ1dGVdKCdzcmNzZXQnKSl7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3Jjc2V0JywgZnVsbC5zcmMpO1xuICAgICAgfVxuICAgICAgcG9seWZpbGwoe3JlZXZhbHVhdGU6IHRydWUsIGVsZW1lbnRzOiBbZWxdfSk7XG4gICAgfSBlbHNlIGlmKGZ1bGwgJiYgZnVsbC5zcmMpe1xuICAgICAgZWwuc3JjID0gZnVsbC5zcmM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRDU1MgPSBmdW5jdGlvbiAoZWxlbSwgc3R5bGUpe1xuICAgIHJldHVybiAoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSB8fCB7fSlbc3R5bGVdO1xuICB9O1xuXG4gIHZhciBnZXRXaWR0aCA9IGZ1bmN0aW9uKGVsZW0sIHBhcmVudCwgd2lkdGgpe1xuICAgIHdpZHRoID0gd2lkdGggfHwgZWxlbS5vZmZzZXRXaWR0aDtcblxuICAgIHdoaWxlKHdpZHRoIDwgbGF6eVNpemVzQ29uZmlnLm1pblNpemUgJiYgcGFyZW50ICYmICFlbGVtLl9sYXp5c2l6ZXNXaWR0aCl7XG4gICAgICB3aWR0aCA9ICBwYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH07XG5cbiAgdmFyIHJBRiA9IChmdW5jdGlvbigpe1xuICAgIHZhciBydW5uaW5nLCB3YWl0aW5nO1xuICAgIHZhciBmaXJzdEZucyA9IFtdO1xuICAgIHZhciBzZWNvbmRGbnMgPSBbXTtcbiAgICB2YXIgZm5zID0gZmlyc3RGbnM7XG5cbiAgICB2YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBydW5GbnMgPSBmbnM7XG5cbiAgICAgIGZucyA9IGZpcnN0Rm5zLmxlbmd0aCA/IHNlY29uZEZucyA6IGZpcnN0Rm5zO1xuXG4gICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcblxuICAgICAgd2hpbGUocnVuRm5zLmxlbmd0aCl7XG4gICAgICAgIHJ1bkZucy5zaGlmdCgpKCk7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHJhZkJhdGNoID0gZnVuY3Rpb24oZm4sIHF1ZXVlKXtcbiAgICAgIGlmKHJ1bm5pbmcgJiYgIXF1ZXVlKXtcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZucy5wdXNoKGZuKTtcblxuICAgICAgICBpZighd2FpdGluZyl7XG4gICAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgKGRvY3VtZW50LmhpZGRlbiA/IHNldFRpbWVvdXQgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHJ1bik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmFmQmF0Y2guX2xzRmx1c2ggPSBydW47XG5cbiAgICByZXR1cm4gcmFmQmF0Y2g7XG4gIH0pKCk7XG5cbiAgdmFyIHJBRkl0ID0gZnVuY3Rpb24oZm4sIHNpbXBsZSl7XG4gICAgcmV0dXJuIHNpbXBsZSA/XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgckFGKGZuKTtcbiAgICAgIH0gOlxuICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgckFGKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIDtcbiAgfTtcblxuICB2YXIgdGhyb3R0bGUgPSBmdW5jdGlvbihmbil7XG4gICAgdmFyIHJ1bm5pbmc7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgZ0RlbGF5ID0gbGF6eVNpemVzQ29uZmlnLnRocm90dGxlRGVsYXk7XG4gICAgdmFyIHJJQ1RpbWVvdXQgPSBsYXp5U2l6ZXNDb25maWcucmljVGltZW91dDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGZuKCk7XG4gICAgfTtcbiAgICB2YXIgaWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFjayAmJiBySUNUaW1lb3V0ID4gNDkgP1xuICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFjayhydW4sIHt0aW1lb3V0OiBySUNUaW1lb3V0fSk7XG5cbiAgICAgICAgaWYocklDVGltZW91dCAhPT0gbGF6eVNpemVzQ29uZmlnLnJpY1RpbWVvdXQpe1xuICAgICAgICAgIHJJQ1RpbWVvdXQgPSBsYXp5U2l6ZXNDb25maWcucmljVGltZW91dDtcbiAgICAgICAgfVxuICAgICAgfSA6XG4gICAgICByQUZJdChmdW5jdGlvbigpe1xuICAgICAgICBzZXRUaW1lb3V0KHJ1bik7XG4gICAgICB9LCB0cnVlKVxuICAgIDtcblxuICAgIHJldHVybiBmdW5jdGlvbihpc1ByaW9yaXR5KXtcbiAgICAgIHZhciBkZWxheTtcblxuICAgICAgaWYoKGlzUHJpb3JpdHkgPSBpc1ByaW9yaXR5ID09PSB0cnVlKSl7XG4gICAgICAgIHJJQ1RpbWVvdXQgPSAzMztcbiAgICAgIH1cblxuICAgICAgaWYocnVubmluZyl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcnVubmluZyA9ICB0cnVlO1xuXG4gICAgICBkZWxheSA9IGdEZWxheSAtIChEYXRlLm5vdygpIC0gbGFzdFRpbWUpO1xuXG4gICAgICBpZihkZWxheSA8IDApe1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmKGlzUHJpb3JpdHkgfHwgZGVsYXkgPCA5KXtcbiAgICAgICAgaWRsZUNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGlkbGVDYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy9iYXNlZCBvbiBodHRwOi8vbW9kZXJuamF2YXNjcmlwdC5ibG9nc3BvdC5kZS8yMDEzLzA4L2J1aWxkaW5nLWJldHRlci1kZWJvdW5jZS5odG1sXG4gIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgdGltZW91dCwgdGltZXN0YW1wO1xuICAgIHZhciB3YWl0ID0gOTk7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGZ1bmMoKTtcbiAgICB9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgcnVuKShydW4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb3A7XG5cbiAgICB2YXIgbGF6eVNpemVzRGVmYXVsdHMgPSB7XG4gICAgICBsYXp5Q2xhc3M6ICdsYXp5bG9hZCcsXG4gICAgICBsb2FkZWRDbGFzczogJ2xhenlsb2FkZWQnLFxuICAgICAgbG9hZGluZ0NsYXNzOiAnbGF6eWxvYWRpbmcnLFxuICAgICAgcHJlbG9hZENsYXNzOiAnbGF6eXByZWxvYWQnLFxuICAgICAgZXJyb3JDbGFzczogJ2xhenllcnJvcicsXG4gICAgICAvL3N0cmljdENsYXNzOiAnbGF6eXN0cmljdCcsXG4gICAgICBhdXRvc2l6ZXNDbGFzczogJ2xhenlhdXRvc2l6ZXMnLFxuICAgICAgc3JjQXR0cjogJ2RhdGEtc3JjJyxcbiAgICAgIHNyY3NldEF0dHI6ICdkYXRhLXNyY3NldCcsXG4gICAgICBzaXplc0F0dHI6ICdkYXRhLXNpemVzJyxcbiAgICAgIC8vcHJlbG9hZEFmdGVyTG9hZDogZmFsc2UsXG4gICAgICBtaW5TaXplOiA0MCxcbiAgICAgIGN1c3RvbU1lZGlhOiB7fSxcbiAgICAgIGluaXQ6IHRydWUsXG4gICAgICBleHBGYWN0b3I6IDEuNSxcbiAgICAgIGhGYWM6IDAuOCxcbiAgICAgIGxvYWRNb2RlOiAyLFxuICAgICAgbG9hZEhpZGRlbjogdHJ1ZSxcbiAgICAgIHJpY1RpbWVvdXQ6IDAsXG4gICAgICB0aHJvdHRsZURlbGF5OiAxMjUsXG4gICAgfTtcblxuICAgIGxhenlTaXplc0NvbmZpZyA9IHdpbmRvdy5sYXp5U2l6ZXNDb25maWcgfHwgd2luZG93LmxhenlzaXplc0NvbmZpZyB8fCB7fTtcblxuICAgIGZvcihwcm9wIGluIGxhenlTaXplc0RlZmF1bHRzKXtcbiAgICAgIGlmKCEocHJvcCBpbiBsYXp5U2l6ZXNDb25maWcpKXtcbiAgICAgICAgbGF6eVNpemVzQ29uZmlnW3Byb3BdID0gbGF6eVNpemVzRGVmYXVsdHNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmxhenlTaXplc0NvbmZpZyA9IGxhenlTaXplc0NvbmZpZztcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmKGxhenlTaXplc0NvbmZpZy5pbml0KXtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xuXG4gIHZhciBsb2FkZXIgPSAoZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJlbG9hZEVsZW1zLCBpc0NvbXBsZXRlZCwgcmVzZXRQcmVsb2FkaW5nVGltZXIsIGxvYWRNb2RlLCBzdGFydGVkO1xuXG4gICAgdmFyIGVMdlcsIGVsdkgsIGVMdG9wLCBlTGxlZnQsIGVMcmlnaHQsIGVMYm90dG9tO1xuXG4gICAgdmFyIGRlZmF1bHRFeHBhbmQsIHByZWxvYWRFeHBhbmQsIGhGYWM7XG5cbiAgICB2YXIgcmVnSW1nID0gL15pbWckL2k7XG4gICAgdmFyIHJlZ0lmcmFtZSA9IC9eaWZyYW1lJC9pO1xuXG4gICAgdmFyIHN1cHBvcnRTY3JvbGwgPSAoJ29uc2Nyb2xsJyBpbiB3aW5kb3cpICYmICEoLyhnbGV8aW5nKWJvdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG5cbiAgICB2YXIgc2hyaW5rRXhwYW5kID0gMDtcbiAgICB2YXIgY3VycmVudEV4cGFuZCA9IDA7XG5cbiAgICB2YXIgaXNMb2FkaW5nID0gMDtcbiAgICB2YXIgbG93UnVucyA9IC0xO1xuXG4gICAgdmFyIHJlc2V0UHJlbG9hZGluZyA9IGZ1bmN0aW9uKGUpe1xuICAgICAgaXNMb2FkaW5nLS07XG4gICAgICBpZihlICYmIGUudGFyZ2V0KXtcbiAgICAgICAgYWRkUmVtb3ZlTG9hZEV2ZW50cyhlLnRhcmdldCwgcmVzZXRQcmVsb2FkaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYoIWUgfHwgaXNMb2FkaW5nIDwgMCB8fCAhZS50YXJnZXQpe1xuICAgICAgICBpc0xvYWRpbmcgPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaXNOZXN0ZWRWaXNpYmxlID0gZnVuY3Rpb24oZWxlbSwgZWxlbUV4cGFuZCl7XG4gICAgICB2YXIgb3V0ZXJSZWN0O1xuICAgICAgdmFyIHBhcmVudCA9IGVsZW07XG4gICAgICB2YXIgdmlzaWJsZSA9IGdldENTUyhkb2N1bWVudC5ib2R5LCAndmlzaWJpbGl0eScpID09ICdoaWRkZW4nIHx8IChnZXRDU1MoZWxlbS5wYXJlbnROb2RlLCAndmlzaWJpbGl0eScpICE9ICdoaWRkZW4nICYmIGdldENTUyhlbGVtLCAndmlzaWJpbGl0eScpICE9ICdoaWRkZW4nKTtcblxuICAgICAgZUx0b3AgLT0gZWxlbUV4cGFuZDtcbiAgICAgIGVMYm90dG9tICs9IGVsZW1FeHBhbmQ7XG4gICAgICBlTGxlZnQgLT0gZWxlbUV4cGFuZDtcbiAgICAgIGVMcmlnaHQgKz0gZWxlbUV4cGFuZDtcblxuICAgICAgd2hpbGUodmlzaWJsZSAmJiAocGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudCkgJiYgcGFyZW50ICE9IGRvY3VtZW50LmJvZHkgJiYgcGFyZW50ICE9IGRvY0VsZW0pe1xuICAgICAgICB2aXNpYmxlID0gKChnZXRDU1MocGFyZW50LCAnb3BhY2l0eScpIHx8IDEpID4gMCk7XG5cbiAgICAgICAgaWYodmlzaWJsZSAmJiBnZXRDU1MocGFyZW50LCAnb3ZlcmZsb3cnKSAhPSAndmlzaWJsZScpe1xuICAgICAgICAgIG91dGVyUmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2aXNpYmxlID0gZUxyaWdodCA+IG91dGVyUmVjdC5sZWZ0ICYmXG4gICAgICAgICAgICBlTGxlZnQgPCBvdXRlclJlY3QucmlnaHQgJiZcbiAgICAgICAgICAgIGVMYm90dG9tID4gb3V0ZXJSZWN0LnRvcCAtIDEgJiZcbiAgICAgICAgICAgIGVMdG9wIDwgb3V0ZXJSZWN0LmJvdHRvbSArIDFcbiAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgfTtcblxuICAgIHZhciBjaGVja0VsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZUxsZW4sIGksIHJlY3QsIGF1dG9Mb2FkRWxlbSwgbG9hZGVkU29tZXRoaW5nLCBlbGVtRXhwYW5kLCBlbGVtTmVnYXRpdmVFeHBhbmQsIGVsZW1FeHBhbmRWYWwsIGJlZm9yZUV4cGFuZFZhbDtcblxuICAgICAgdmFyIGxhenlsb2FkRWxlbXMgPSBsYXp5c2l6ZXMuZWxlbWVudHM7XG5cbiAgICAgIGlmKChsb2FkTW9kZSA9IGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSkgJiYgaXNMb2FkaW5nIDwgOCAmJiAoZUxsZW4gPSBsYXp5bG9hZEVsZW1zLmxlbmd0aCkpe1xuXG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGxvd1J1bnMrKztcblxuICAgICAgICBpZihwcmVsb2FkRXhwYW5kID09IG51bGwpe1xuICAgICAgICAgIGlmKCEoJ2V4cGFuZCcgaW4gbGF6eVNpemVzQ29uZmlnKSl7XG4gICAgICAgICAgICBsYXp5U2l6ZXNDb25maWcuZXhwYW5kID0gZG9jRWxlbS5jbGllbnRIZWlnaHQgPiA1MDAgJiYgZG9jRWxlbS5jbGllbnRXaWR0aCA+IDUwMCA/IDUwMCA6IDM3MDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0RXhwYW5kID0gbGF6eVNpemVzQ29uZmlnLmV4cGFuZDtcbiAgICAgICAgICBwcmVsb2FkRXhwYW5kID0gZGVmYXVsdEV4cGFuZCAqIGxhenlTaXplc0NvbmZpZy5leHBGYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdXJyZW50RXhwYW5kIDwgcHJlbG9hZEV4cGFuZCAmJiBpc0xvYWRpbmcgPCAxICYmIGxvd1J1bnMgPiAyICYmIGxvYWRNb2RlID4gMiAmJiAhZG9jdW1lbnQuaGlkZGVuKXtcbiAgICAgICAgICBjdXJyZW50RXhwYW5kID0gcHJlbG9hZEV4cGFuZDtcbiAgICAgICAgICBsb3dSdW5zID0gMDtcbiAgICAgICAgfSBlbHNlIGlmKGxvYWRNb2RlID4gMSAmJiBsb3dSdW5zID4gMSAmJiBpc0xvYWRpbmcgPCA2KXtcbiAgICAgICAgICBjdXJyZW50RXhwYW5kID0gZGVmYXVsdEV4cGFuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50RXhwYW5kID0gc2hyaW5rRXhwYW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKDsgaSA8IGVMbGVuOyBpKyspe1xuXG4gICAgICAgICAgaWYoIWxhenlsb2FkRWxlbXNbaV0gfHwgbGF6eWxvYWRFbGVtc1tpXS5fbGF6eVJhY2Upe2NvbnRpbnVlO31cblxuICAgICAgICAgIGlmKCFzdXBwb3J0U2Nyb2xsKXt1bnZlaWxFbGVtZW50KGxhenlsb2FkRWxlbXNbaV0pO2NvbnRpbnVlO31cblxuICAgICAgICAgIGlmKCEoZWxlbUV4cGFuZFZhbCA9IGxhenlsb2FkRWxlbXNbaV1bX2dldEF0dHJpYnV0ZV0oJ2RhdGEtZXhwYW5kJykpIHx8ICEoZWxlbUV4cGFuZCA9IGVsZW1FeHBhbmRWYWwgKiAxKSl7XG4gICAgICAgICAgICBlbGVtRXhwYW5kID0gY3VycmVudEV4cGFuZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihiZWZvcmVFeHBhbmRWYWwgIT09IGVsZW1FeHBhbmQpe1xuICAgICAgICAgICAgZUx2VyA9IGlubmVyV2lkdGggKyAoZWxlbUV4cGFuZCAqIGhGYWMpO1xuICAgICAgICAgICAgZWx2SCA9IGlubmVySGVpZ2h0ICsgZWxlbUV4cGFuZDtcbiAgICAgICAgICAgIGVsZW1OZWdhdGl2ZUV4cGFuZCA9IGVsZW1FeHBhbmQgKiAtMTtcbiAgICAgICAgICAgIGJlZm9yZUV4cGFuZFZhbCA9IGVsZW1FeHBhbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVjdCA9IGxhenlsb2FkRWxlbXNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAoKGVMYm90dG9tID0gcmVjdC5ib3R0b20pID49IGVsZW1OZWdhdGl2ZUV4cGFuZCAmJlxuICAgICAgICAgICAgKGVMdG9wID0gcmVjdC50b3ApIDw9IGVsdkggJiZcbiAgICAgICAgICAgIChlTHJpZ2h0ID0gcmVjdC5yaWdodCkgPj0gZWxlbU5lZ2F0aXZlRXhwYW5kICogaEZhYyAmJlxuICAgICAgICAgICAgKGVMbGVmdCA9IHJlY3QubGVmdCkgPD0gZUx2VyAmJlxuICAgICAgICAgICAgKGVMYm90dG9tIHx8IGVMcmlnaHQgfHwgZUxsZWZ0IHx8IGVMdG9wKSAmJlxuICAgICAgICAgICAgKGxhenlTaXplc0NvbmZpZy5sb2FkSGlkZGVuIHx8IGdldENTUyhsYXp5bG9hZEVsZW1zW2ldLCAndmlzaWJpbGl0eScpICE9ICdoaWRkZW4nKSAmJlxuICAgICAgICAgICAgKChpc0NvbXBsZXRlZCAmJiBpc0xvYWRpbmcgPCAzICYmICFlbGVtRXhwYW5kVmFsICYmIChsb2FkTW9kZSA8IDMgfHwgbG93UnVucyA8IDQpKSB8fCBpc05lc3RlZFZpc2libGUobGF6eWxvYWRFbGVtc1tpXSwgZWxlbUV4cGFuZCkpKXtcbiAgICAgICAgICAgIHVudmVpbEVsZW1lbnQobGF6eWxvYWRFbGVtc1tpXSk7XG4gICAgICAgICAgICBsb2FkZWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYoaXNMb2FkaW5nID4gOSl7YnJlYWs7fVxuICAgICAgICAgIH0gZWxzZSBpZighbG9hZGVkU29tZXRoaW5nICYmIGlzQ29tcGxldGVkICYmICFhdXRvTG9hZEVsZW0gJiZcbiAgICAgICAgICAgIGlzTG9hZGluZyA8IDQgJiYgbG93UnVucyA8IDQgJiYgbG9hZE1vZGUgPiAyICYmXG4gICAgICAgICAgICAocHJlbG9hZEVsZW1zWzBdIHx8IGxhenlTaXplc0NvbmZpZy5wcmVsb2FkQWZ0ZXJMb2FkKSAmJlxuICAgICAgICAgICAgKHByZWxvYWRFbGVtc1swXSB8fCAoIWVsZW1FeHBhbmRWYWwgJiYgKChlTGJvdHRvbSB8fCBlTHJpZ2h0IHx8IGVMbGVmdCB8fCBlTHRvcCkgfHwgbGF6eWxvYWRFbGVtc1tpXVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc2l6ZXNBdHRyKSAhPSAnYXV0bycpKSkpe1xuICAgICAgICAgICAgYXV0b0xvYWRFbGVtID0gcHJlbG9hZEVsZW1zWzBdIHx8IGxhenlsb2FkRWxlbXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXV0b0xvYWRFbGVtICYmICFsb2FkZWRTb21ldGhpbmcpe1xuICAgICAgICAgIHVudmVpbEVsZW1lbnQoYXV0b0xvYWRFbGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cyA9IHRocm90dGxlKGNoZWNrRWxlbWVudHMpO1xuXG4gICAgdmFyIHN3aXRjaExvYWRpbmdDbGFzcyA9IGZ1bmN0aW9uKGUpe1xuICAgICAgYWRkQ2xhc3MoZS50YXJnZXQsIGxhenlTaXplc0NvbmZpZy5sb2FkZWRDbGFzcyk7XG4gICAgICByZW1vdmVDbGFzcyhlLnRhcmdldCwgbGF6eVNpemVzQ29uZmlnLmxvYWRpbmdDbGFzcyk7XG4gICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGUudGFyZ2V0LCByYWZTd2l0Y2hMb2FkaW5nQ2xhc3MpO1xuICAgICAgdHJpZ2dlckV2ZW50KGUudGFyZ2V0LCAnbGF6eWxvYWRlZCcpO1xuICAgIH07XG4gICAgdmFyIHJhZmVkU3dpdGNoTG9hZGluZ0NsYXNzID0gckFGSXQoc3dpdGNoTG9hZGluZ0NsYXNzKTtcbiAgICB2YXIgcmFmU3dpdGNoTG9hZGluZ0NsYXNzID0gZnVuY3Rpb24oZSl7XG4gICAgICByYWZlZFN3aXRjaExvYWRpbmdDbGFzcyh7dGFyZ2V0OiBlLnRhcmdldH0pO1xuICAgIH07XG5cbiAgICB2YXIgY2hhbmdlSWZyYW1lU3JjID0gZnVuY3Rpb24oZWxlbSwgc3JjKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsZW0uY29udGVudFdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHNyYyk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICBlbGVtLnNyYyA9IHNyYztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZVNvdXJjZXMgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgICAgdmFyIGN1c3RvbU1lZGlhO1xuXG4gICAgICB2YXIgc291cmNlU3Jjc2V0ID0gc291cmNlW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NvbmZpZy5zcmNzZXRBdHRyKTtcblxuICAgICAgaWYoIChjdXN0b21NZWRpYSA9IGxhenlTaXplc0NvbmZpZy5jdXN0b21NZWRpYVtzb3VyY2VbX2dldEF0dHJpYnV0ZV0oJ2RhdGEtbWVkaWEnKSB8fCBzb3VyY2VbX2dldEF0dHJpYnV0ZV0oJ21lZGlhJyldKSApe1xuICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKCdtZWRpYScsIGN1c3RvbU1lZGlhKTtcbiAgICAgIH1cblxuICAgICAgaWYoc291cmNlU3Jjc2V0KXtcbiAgICAgICAgc291cmNlLnNldEF0dHJpYnV0ZSgnc3Jjc2V0Jywgc291cmNlU3Jjc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhenlVbnZlaWwgPSByQUZJdChmdW5jdGlvbiAoZWxlbSwgZGV0YWlsLCBpc0F1dG8sIHNpemVzLCBpc0ltZyl7XG4gICAgICB2YXIgc3JjLCBzcmNzZXQsIHBhcmVudCwgaXNQaWN0dXJlLCBldmVudCwgZmlyZXNMb2FkO1xuXG4gICAgICBpZighKGV2ZW50ID0gdHJpZ2dlckV2ZW50KGVsZW0sICdsYXp5YmVmb3JldW52ZWlsJywgZGV0YWlsKSkuZGVmYXVsdFByZXZlbnRlZCl7XG5cbiAgICAgICAgaWYoc2l6ZXMpe1xuICAgICAgICAgIGlmKGlzQXV0byl7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcuYXV0b3NpemVzQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnc2l6ZXMnLCBzaXplcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3Jjc2V0ID0gZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc3Jjc2V0QXR0cik7XG4gICAgICAgIHNyYyA9IGVsZW1bX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNyY0F0dHIpO1xuXG4gICAgICAgIGlmKGlzSW1nKSB7XG4gICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgIGlzUGljdHVyZSA9IHBhcmVudCAmJiByZWdQaWN0dXJlLnRlc3QocGFyZW50Lm5vZGVOYW1lIHx8ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcmVzTG9hZCA9IGRldGFpbC5maXJlc0xvYWQgfHwgKCgnc3JjJyBpbiBlbGVtKSAmJiAoc3Jjc2V0IHx8IHNyYyB8fCBpc1BpY3R1cmUpKTtcblxuICAgICAgICBldmVudCA9IHt0YXJnZXQ6IGVsZW19O1xuXG4gICAgICAgIGlmKGZpcmVzTG9hZCl7XG4gICAgICAgICAgYWRkUmVtb3ZlTG9hZEV2ZW50cyhlbGVtLCByZXNldFByZWxvYWRpbmcsIHRydWUpO1xuICAgICAgICAgIGNsZWFyVGltZW91dChyZXNldFByZWxvYWRpbmdUaW1lcik7XG4gICAgICAgICAgcmVzZXRQcmVsb2FkaW5nVGltZXIgPSBzZXRUaW1lb3V0KHJlc2V0UHJlbG9hZGluZywgMjUwMCk7XG5cbiAgICAgICAgICBhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGVsZW0sIHJhZlN3aXRjaExvYWRpbmdDbGFzcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpc1BpY3R1cmUpe1xuICAgICAgICAgIGZvckVhY2guY2FsbChwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpLCBoYW5kbGVTb3VyY2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNyY3NldCl7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3NyY3NldCcsIHNyY3NldCk7XG4gICAgICAgIH0gZWxzZSBpZihzcmMgJiYgIWlzUGljdHVyZSl7XG4gICAgICAgICAgaWYocmVnSWZyYW1lLnRlc3QoZWxlbS5ub2RlTmFtZSkpe1xuICAgICAgICAgICAgY2hhbmdlSWZyYW1lU3JjKGVsZW0sIHNyYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc3JjID0gc3JjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzSW1nICYmIChzcmNzZXQgfHwgaXNQaWN0dXJlKSl7XG4gICAgICAgICAgdXBkYXRlUG9seWZpbGwoZWxlbSwge3NyYzogc3JjfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoZWxlbS5fbGF6eVJhY2Upe1xuICAgICAgICBkZWxldGUgZWxlbS5fbGF6eVJhY2U7XG4gICAgICB9XG4gICAgICByZW1vdmVDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKTtcblxuICAgICAgckFGKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhZmlyZXNMb2FkIHx8IChlbGVtLmNvbXBsZXRlICYmIGVsZW0ubmF0dXJhbFdpZHRoID4gMSkpe1xuICAgICAgICAgIGlmKGZpcmVzTG9hZCl7XG4gICAgICAgICAgICByZXNldFByZWxvYWRpbmcoZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0xvYWRpbmctLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoTG9hZGluZ0NsYXNzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgdW52ZWlsRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtKXtcbiAgICAgIHZhciBkZXRhaWw7XG5cbiAgICAgIHZhciBpc0ltZyA9IHJlZ0ltZy50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuXG4gICAgICAvL2FsbG93IHVzaW5nIHNpemVzPVwiYXV0b1wiLCBidXQgZG9uJ3QgdXNlLiBpdCdzIGludmFsaWQuIFVzZSBkYXRhLXNpemVzPVwiYXV0b1wiIG9yIGEgdmFsaWQgdmFsdWUgZm9yIHNpemVzIGluc3RlYWQgKGkuZS46IHNpemVzPVwiODB2d1wiKVxuICAgICAgdmFyIHNpemVzID0gaXNJbWcgJiYgKGVsZW1bX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNpemVzQXR0cikgfHwgZWxlbVtfZ2V0QXR0cmlidXRlXSgnc2l6ZXMnKSk7XG4gICAgICB2YXIgaXNBdXRvID0gc2l6ZXMgPT0gJ2F1dG8nO1xuXG4gICAgICBpZiggKGlzQXV0byB8fCAhaXNDb21wbGV0ZWQpICYmIGlzSW1nICYmIChlbGVtW19nZXRBdHRyaWJ1dGVdKCdzcmMnKSB8fCBlbGVtLnNyY3NldCkgJiYgIWVsZW0uY29tcGxldGUgJiYgIWhhc0NsYXNzKGVsZW0sIGxhenlTaXplc0NvbmZpZy5lcnJvckNsYXNzKSAmJiBoYXNDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKSl7cmV0dXJuO31cblxuICAgICAgZGV0YWlsID0gdHJpZ2dlckV2ZW50KGVsZW0sICdsYXp5dW52ZWlscmVhZCcpLmRldGFpbDtcblxuICAgICAgaWYoaXNBdXRvKXtcbiAgICAgICAgIGF1dG9TaXplci51cGRhdGVFbGVtKGVsZW0sIHRydWUsIGVsZW0ub2Zmc2V0V2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBlbGVtLl9sYXp5UmFjZSA9IHRydWU7XG4gICAgICBpc0xvYWRpbmcrKztcblxuICAgICAgbGF6eVVudmVpbChlbGVtLCBkZXRhaWwsIGlzQXV0bywgc2l6ZXMsIGlzSW1nKTtcbiAgICB9O1xuXG4gICAgdmFyIG9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZihpc0NvbXBsZXRlZCl7cmV0dXJuO31cbiAgICAgIGlmKERhdGUubm93KCkgLSBzdGFydGVkIDwgOTk5KXtcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWQsIDk5OSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhZnRlclNjcm9sbCA9IGRlYm91bmNlKGZ1bmN0aW9uKCl7XG4gICAgICAgIGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSA9IDM7XG4gICAgICAgIHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpc0NvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgIGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSA9IDM7XG5cbiAgICAgIHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcblxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYobGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlID09IDMpe1xuICAgICAgICAgIGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgYWZ0ZXJTY3JvbGwoKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgXzogZnVuY3Rpb24oKXtcbiAgICAgICAgc3RhcnRlZCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgbGF6eXNpemVzLmVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKTtcbiAgICAgICAgcHJlbG9hZEVsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzICsgJyAnICsgbGF6eVNpemVzQ29uZmlnLnByZWxvYWRDbGFzcyk7XG4gICAgICAgIGhGYWMgPSBsYXp5U2l6ZXNDb25maWcuaEZhYztcblxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuICAgICAgICBpZih3aW5kb3cuTXV0YXRpb25PYnNlcnZlcil7XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoIHRocm90dGxlZENoZWNrRWxlbWVudHMgKS5vYnNlcnZlKCBkb2NFbGVtLCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY0VsZW1bX2FkZEV2ZW50TGlzdGVuZXJdKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgICBkb2NFbGVtW19hZGRFdmVudExpc3RlbmVyXSgnRE9NQXR0ck1vZGlmaWVkJywgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgdHJ1ZSk7XG4gICAgICAgICAgc2V0SW50ZXJ2YWwodGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgOTk5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuICAgICAgICAvLywgJ2Z1bGxzY3JlZW5jaGFuZ2UnXG4gICAgICAgIFsnZm9jdXMnLCAnbW91c2VvdmVyJywgJ2NsaWNrJywgJ2xvYWQnLCAndHJhbnNpdGlvbmVuZCcsICdhbmltYXRpb25lbmQnLCAnd2Via2l0QW5pbWF0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgICBkb2N1bWVudFtfYWRkRXZlbnRMaXN0ZW5lcl0obmFtZSwgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCgvZCR8XmMvLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkpKXtcbiAgICAgICAgICBvbmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25sb2FkKTtcbiAgICAgICAgICBkb2N1bWVudFtfYWRkRXZlbnRMaXN0ZW5lcl0oJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZCwgMjAwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobGF6eXNpemVzLmVsZW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgY2hlY2tFbGVtZW50cygpO1xuICAgICAgICAgIHJBRi5fbHNGbHVzaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNoZWNrRWxlbXM6IHRocm90dGxlZENoZWNrRWxlbWVudHMsXG4gICAgICB1bnZlaWw6IHVudmVpbEVsZW1lbnRcbiAgICB9O1xuICB9KSgpO1xuXG5cbiAgdmFyIGF1dG9TaXplciA9IChmdW5jdGlvbigpe1xuICAgIHZhciBhdXRvc2l6ZXNFbGVtcztcblxuICAgIHZhciBzaXplRWxlbWVudCA9IHJBRkl0KGZ1bmN0aW9uKGVsZW0sIHBhcmVudCwgZXZlbnQsIHdpZHRoKXtcbiAgICAgIHZhciBzb3VyY2VzLCBpLCBsZW47XG4gICAgICBlbGVtLl9sYXp5c2l6ZXNXaWR0aCA9IHdpZHRoO1xuICAgICAgd2lkdGggKz0gJ3B4JztcblxuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3NpemVzJywgd2lkdGgpO1xuXG4gICAgICBpZihyZWdQaWN0dXJlLnRlc3QocGFyZW50Lm5vZGVOYW1lIHx8ICcnKSl7XG4gICAgICAgIHNvdXJjZXMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xuICAgICAgICBmb3IoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgIHNvdXJjZXNbaV0uc2V0QXR0cmlidXRlKCdzaXplcycsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZighZXZlbnQuZGV0YWlsLmRhdGFBdHRyKXtcbiAgICAgICAgdXBkYXRlUG9seWZpbGwoZWxlbSwgZXZlbnQuZGV0YWlsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZ2V0U2l6ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YUF0dHIsIHdpZHRoKXtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgICAgIGlmKHBhcmVudCl7XG4gICAgICAgIHdpZHRoID0gZ2V0V2lkdGgoZWxlbSwgcGFyZW50LCB3aWR0aCk7XG4gICAgICAgIGV2ZW50ID0gdHJpZ2dlckV2ZW50KGVsZW0sICdsYXp5YmVmb3Jlc2l6ZXMnLCB7d2lkdGg6IHdpZHRoLCBkYXRhQXR0cjogISFkYXRhQXR0cn0pO1xuXG4gICAgICAgIGlmKCFldmVudC5kZWZhdWx0UHJldmVudGVkKXtcbiAgICAgICAgICB3aWR0aCA9IGV2ZW50LmRldGFpbC53aWR0aDtcblxuICAgICAgICAgIGlmKHdpZHRoICYmIHdpZHRoICE9PSBlbGVtLl9sYXp5c2l6ZXNXaWR0aCl7XG4gICAgICAgICAgICBzaXplRWxlbWVudChlbGVtLCBwYXJlbnQsIGV2ZW50LCB3aWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVFbGVtZW50c1NpemVzID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGF1dG9zaXplc0VsZW1zLmxlbmd0aDtcbiAgICAgIGlmKGxlbil7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvcig7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgZ2V0U2l6ZUVsZW1lbnQoYXV0b3NpemVzRWxlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZWJvdW5jZWRVcGRhdGVFbGVtZW50c1NpemVzID0gZGVib3VuY2UodXBkYXRlRWxlbWVudHNTaXplcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgXzogZnVuY3Rpb24oKXtcbiAgICAgICAgYXV0b3NpemVzRWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGxhenlTaXplc0NvbmZpZy5hdXRvc2l6ZXNDbGFzcyk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrRWxlbXM6IGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMsXG4gICAgICB1cGRhdGVFbGVtOiBnZXRTaXplRWxlbWVudFxuICAgIH07XG4gIH0pKCk7XG5cbiAgdmFyIGluaXQgPSBmdW5jdGlvbigpe1xuICAgIGlmKCFpbml0Lmkpe1xuICAgICAgaW5pdC5pID0gdHJ1ZTtcbiAgICAgIGF1dG9TaXplci5fKCk7XG4gICAgICBsb2FkZXIuXygpO1xuICAgIH1cbiAgfTtcblxuICBsYXp5c2l6ZXMgPSB7XG4gICAgY2ZnOiBsYXp5U2l6ZXNDb25maWcsXG4gICAgYXV0b1NpemVyOiBhdXRvU2l6ZXIsXG4gICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgaW5pdDogaW5pdCxcbiAgICB1UDogdXBkYXRlUG9seWZpbGwsXG4gICAgYUM6IGFkZENsYXNzLFxuICAgIHJDOiByZW1vdmVDbGFzcyxcbiAgICBoQzogaGFzQ2xhc3MsXG4gICAgZmlyZTogdHJpZ2dlckV2ZW50LFxuICAgIGdXOiBnZXRXaWR0aCxcbiAgICByQUY6IHJBRixcbiAgfTtcblxuICByZXR1cm4gbGF6eXNpemVzO1xufVxuKSk7XG5cbi8vXG4vLyBQYXNzaXZlIG9wdGlvbiBmb3IgZXZlbnQgbGlzdGVuZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRmVhdHVyZSBkZXRlY3Rpb24gZm9yIGFkZEV2ZW50TGlzdGVuZXIncyAncGFzc2l2ZScgb3B0aW9uLlxuLy8gQWxsb3dzIGZvciBjb25kaXRpb25hbCBzZXR0aW5nIG9mIHRoZSB0aGlyZCBhcmd1bWVudCBpbiBhbiBldmVudCBsaXN0ZW5lci5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeGFtcGxlIHVzYWdlOlxuLy8gZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpey4uLn0sIHBhc3NpdmVFdmVudExpc3RlbmVyT3B0aW9uU3VwcG9ydGVkID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHBhc3NpdmVFdmVudExpc3RlbmVyT3B0aW9uU3VwcG9ydGVkID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBwYXNzaXZlRXZlbnRMaXN0ZW5lck9wdGlvblN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZU9wdGlvblwiLCBudWxsLCBvcHRzKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZU9wdGlvblwiLCBudWxsLCBvcHRzKTtcbn0gY2F0Y2goZXJyKSB7fVxuXG4vL1xuLy8gUmVtb3ZlIHRoZSBzY3JvbGxpbmcgaW5jcmVtZW50L2RlY3JlbWVudCBiZWhhdmlvciBmcm9tIG51bWJlciBpbnB1dCBlbGVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBmdW5jdGlvbihldmVudCkge1xuICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgPT09IFwibnVtYmVyXCIpe1xuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICB9XG59LCBwYXNzaXZlRXZlbnRMaXN0ZW5lck9wdGlvblN1cHBvcnRlZCA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2UpO1xuXG4vL1xuLy8gRXhjbHVkZSBoaWRkZW4gZWxlbWVudHMgZnJvbSBQYXJzbGV5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaWYgKHR5cGVvZiBQYXJzbGV5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgUGFyc2xleS5vcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICBQYXJzbGV5Lm9wdGlvbnMuZXhjbHVkZWQgPSAnaW5wdXRbdHlwZT1idXR0b25dLCBpbnB1dFt0eXBlPXN1Ym1pdF0sIGlucHV0W3R5cGU9cmVzZXRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIFtkaXNhYmxlZF0sIDpoaWRkZW4nO1xufVxuXG4vL1xuLy8gRE9NIGxvYWRlZCBib2R5IGNsYXNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gV2hlbiB0aGUgcGFnZSBpcyBsb2FkZWQsIGFkZCAmIHJlbW92ZSBjbGFzc2VzIGZyb20gdGhlIGJvZHkgZWxlbWVudFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEgvdCB0byBodHRwczovL3d3dy5zaXRlcG9pbnQuY29tL2pxdWVyeS1kb2N1bWVudC1yZWFkeS1wbGFpbi1qYXZhc2NyaXB0L1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBkb21Mb2FkZWRDYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZG9tLWhhcy1sb2FkZWQnKTtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdkb20tbm90LXlldC1sb2FkZWQnKTtcbn07XG5cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8IChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKSApIHtcbiAgZG9tTG9hZGVkQ2FsbGJhY2soKTtcbn0gZWxzZSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGRvbUxvYWRlZENhbGxiYWNrKTtcbn1cblxuLy9cbi8vIERpc3BhdGNoZXIuanNcbi8vIHYwLjQuNFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ3JlYXRlIGFjdGlvbnMgJiByZWFjdGlvbnMgaW4gbWFya3VwXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUT0RPXG4vLyAtIENoYW5nZSBkYXRhLWRpc3BhdGNoZXItbm90aWZ5IHRvIGFjY2VwdCBhbiBhcnJheSBvZiBJRHMgdG8gbm90aWZ5XG4vLyAtIEFsbG93IGN1c3RvbWl6YXRpb24gb2YgLmlzLWRpc3BhdGNoZXItbm90aWZpZWQgY2xhc3MgbmFtZSAoZm9yIG11bHRpcGxlIHVzZXMgb2YgZGlzcGF0Y2hlcilcbi8vIC0gU2VwYXJhdGUgdHJpZ2dlciwgdGFyZ2V0LCBhbmQgbm90aWZpZWQgZGlzcGF0Y2ggaW50byAzIGZ1bmN0aW9ucz9cbi8vIC0gQWRkIGEgY2FsbGJhY2sgd2hlbiBkaXNwYXRjaCBpcyBjb21wbGV0ZWQ/XG4vLyAtIFJld3JpdGUgaW4gVmFuaWxsYSBKUyAoZm9yIGV2ZW50IGRlbGVnYXRpb24sIHNlZSBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vY2hlY2tpbmctZXZlbnQtdGFyZ2V0LXNlbGVjdG9ycy13aXRoLWV2ZW50LWJ1YmJsaW5nLWluLXZhbmlsbGEtamF2YXNjcmlwdC8pXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2xpY2tEaXNwYXRjaCAodHJpZ2dlcikge1xuICAvLyBGZWVkYmFjayB0byB0aGUgdHJpZ2dlciBlbGVtZW50XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBpZiBhbiBhdHRyaWJ1dGUgZGF0YS1kaXNwYXRjaGVyLXRyaWdnZXItYWN0aXZlLWNsYXNzIF9fZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZV9fXG4gIGlmICggdHJpZ2dlci5hdHRyKFwiZGF0YS1kaXNwYXRjaGVyLXRyaWdnZXItYWN0aXZlLWNsYXNzXCIpICkge1xuICAgIHZhciAkY3VzdG9tX3RyaWdnZXJfY2xhc3MgPSB0cmlnZ2VyLmRhdGEoXCJkaXNwYXRjaGVyLXRyaWdnZXItYWN0aXZlLWNsYXNzXCIpO1xuICAgIHRyaWdnZXIudG9nZ2xlQ2xhc3MoJGN1c3RvbV90cmlnZ2VyX2NsYXNzKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBUb2dnbGUgYWN0aXZlIGNsYXNzXG4gICAgdHJpZ2dlci50b2dnbGVDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgfVxuXG4gIC8vIFRvZ2dsZSBzZWxlY3RlZCBBUklBIGF0dHJpYnV0ZXMgaWYgdGhleSBleGlzdFxuICBpZiAoIHRyaWdnZXIuYXR0cihcImFyaWEtcHJlc3NlZFwiKSApICB7IHZhciBoYXNBcmlhUHJlc3NlZEF0dHIgID0gdHJ1ZTsgfVxuICBpZiAoIHRyaWdnZXIuYXR0cihcImFyaWEtZXhwYW5kZWRcIikgKSB7IHZhciBoYXNBcmlhRXhwYW5kZWRBdHRyID0gdHJ1ZTsgfVxuXG4gIGlmIChoYXNBcmlhUHJlc3NlZEF0dHIpIHtcbiAgICB0cmlnZ2VyLmF0dHIoXCJhcmlhLXByZXNzZWRcIiwgICh0cmlnZ2VyLmF0dHIoXCJhcmlhLXByZXNzZWRcIikgID09IFwiZmFsc2VcIiA/IHRydWUgOiBmYWxzZSkpO1xuICB9XG4gIGlmIChoYXNBcmlhRXhwYW5kZWRBdHRyKSB7XG4gICAgdHJpZ2dlci5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCAodHJpZ2dlci5hdHRyKFwiYXJpYS1leHBhbmRlZFwiKSA9PSBcImZhbHNlXCIgPyB0cnVlIDogZmFsc2UpKTtcbiAgfVxuXG5cbiAgLy8gTm90aWZpZWQgZWxlbWVudCBkaXNwYXRjaFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIGFuIGVsZW1lbnQgaXMgdG8gYmUgbm90aWZpZWQgKGEgdmFsdWUgaXMgZ2l2ZW4gaW4gdGhlIGF0dHJpYnV0ZSksXG4gIC8vIG5vdGlmeSBpdC90aGVtIHdpdGggdG9nZ2xlZCBjbGFzcyBcImlzLWRpc3BhdGNoaW5nXCJcbiAgaWYgKCB0cmlnZ2VyLmF0dHIoXCJkYXRhLWRpc3BhdGNoZXItbm90aWZ5XCIpICkge1xuICAgIHZhciAkbm90aWZ5X2NsYXNzID0gXCIuXCIgKyB0cmlnZ2VyLmRhdGEoXCJkaXNwYXRjaGVyLW5vdGlmeVwiKTtcbiAgICAkKCRub3RpZnlfY2xhc3MpLnRvZ2dsZUNsYXNzKFwiaXMtZGlzcGF0Y2hlci1ub3RpZmllZFwiKTtcbiAgfVxuXG5cbiAgLy8gVGFyZ2V0IGVsZW1lbnQgZGlzcGF0Y2hcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIHRhcmdldGVkIGVsZW1lbnQgdmlhIGRhdGEtYXR0cmlidXRlXG4gIHZhciB0YXJnZXQgPSBcIiNcIiArIHRyaWdnZXIuZGF0YShcImRpc3BhdGNoZXItdGFyZ2V0XCIpO1xuICB0YXJnZXQgPSAkKHRhcmdldCk7XG5cbiAgLy8gaWYgYW4gYXR0cmlidXRlIGRhdGEtZGlzcGF0Y2hlci10YXJnZXQtYWN0aXZlLWNsYXNzIF9fZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZV9fXG4gIGlmICggdHJpZ2dlci5hdHRyKFwiZGF0YS1kaXNwYXRjaGVyLXRhcmdldC1hY3RpdmUtY2xhc3NcIikgKSB7XG4gICAgdmFyICRjdXN0b21fdGFyZ2V0X2NsYXNzID0gdHJpZ2dlci5kYXRhKFwiZGlzcGF0Y2hlci10YXJnZXQtYWN0aXZlLWNsYXNzXCIpO1xuICAgIHRhcmdldC50b2dnbGVDbGFzcygkY3VzdG9tX3RhcmdldF9jbGFzcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGFyZ2V0LnRvZ2dsZUNsYXNzKFwiaXMtYWN0aXZlXCIpO1xuICB9XG5cbiAgLy8gQVJJQSBhdHRyaWJ1dGVzIHRvIGZsaXBcbiAgdGFyZ2V0LmF0dHIoXCJhcmlhLWhpZGRlblwiLCAodGFyZ2V0LmF0dHIoXCJhcmlhLWhpZGRlblwiKSA9PSBcImZhbHNlXCIgPyB0cnVlIDogZmFsc2UpKTtcblxuXG4gIC8vIFwiT25lIGF0IGEgdGltZSwgc2libGluZ3NcIiBkaXNwYXRjaFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBGb3Igd2hlbiBvbmx5IG9uZSBjaGlsZCBtYXkgYmUgYWN0aXZlIGF0IGEgdGltZS4gKExpa2UgYW4gYWNjb3JkaW9uISlcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKCB0cmlnZ2VyLmF0dHIoXCJkYXRhLWRpc3BhdGNoZXItcGFyZW50XCIpICkge1xuICAgIC8vIEdldCB0aGUgdGFyZ2V0ZWQgZWxlbWVudCB2aWEgZGF0YS1hdHRyaWJ1dGVcbiAgICB2YXIgJHBhcmVudCA9IFwiI1wiICsgdHJpZ2dlci5kYXRhKFwiZGlzcGF0Y2hlci1wYXJlbnRcIik7XG5cbiAgICAvLyBUaGVzZSBtYXkgX3NlZW1fIHJldmVyc2VkLCBidXQgbm90ZSB0aGF0IGF0IHRoZSB0b3Agb2YgdGhpcyBmdW5jdGlvbiwgdGhlIGlzLWFjdGl2ZSBjbGFzcyBpcyB0b2dnbGVkLiBTbyBhdCB0aGlzIHBvaW50LCB3ZSdyZSBub3QgY2hlY2tpbmcgXCJpZiB0aGUgdHJpZ2dlciBoYWQgaXMtYWN0aXZlIGJlZm9yZSBjbGlja1wiLCBidXQgXCJpZiB0aGUgdHJpZ2dlciBoYXMgaXMtYWN0aXZlIG5vdyB0aGF0IGl0IGhhcyBiZWVuIGNsaWNrZWRcIi5cbiAgICBpZiAoIHRyaWdnZXIuaGFzQ2xhc3MoXCJpcy1hY3RpdmVcIikgKSB7XG4gICAgICAkKCRwYXJlbnQpLmFkZENsYXNzKFwiaGFzLWRpc3BhdGNoZWQtYWN0aXZlLWNoaWxkXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICQoJHBhcmVudCkucmVtb3ZlQ2xhc3MoXCJoYXMtZGlzcGF0Y2hlZC1hY3RpdmUtY2hpbGRcIik7XG4gICAgfVxuXG4gICAgdHJpZ2dlci5zaWJsaW5ncyhcIi5kaXNwYXRjaGVyLXRyaWdnZXJcIikucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG4gIH1cbn1cblxuXG4vLyBMb2dpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAvLyBsaXN0ZW4gZm9yIGEgY2xpY2sgb3Iga2V5ZG93biBldmVudCBvbiBlbGVtZW50cyB3aXRoIC5kaXNwYXRjaC10cmlnZ2VyLiBrZXlkb3duIGlzIG5lZWRlZCBiZWNhdXNlIHNvbWUgZWxlbWVudHMgdGhhdCBhcmUgbm90IG5hdGl2ZSA8YnV0dG9uPiBvciA8YT4gZWxlbWVudHMg4oCUIHlldCBoYXZlIHRhYmluZGV4PVwiMFwiIGFkZGVkIGFsbG93aW5nIGZvciBrZXlib2FyZCBhY2Nlc3Mg4oCUIG5lZWQgdG8gcmVjZWl2ZSBhIHNwYWNlYmFyIGtleSBwcmVzcyBvciByZXR1cm4ga2V5IHByZXNzXG4gICQoXCJib2R5XCIpLm9uKFwiY2xpY2sga2V5ZG93blwiLCBcIi5kaXNwYXRjaGVyLXRyaWdnZXJcIiwgZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCBpcyBlaXRoZXIgYSBjbGljaywgYSBzcGFjZWJhciBwcmVzcywgb3IgYSByZXR1cm4gcHJlc3NcbiAgICBpZiAoIChldmVudC50eXBlID09PSBcImNsaWNrXCIpIHx8IChldmVudC53aGljaCA9PSAxMyB8fCBldmVudC53aGljaCA9PSAzMikpIHtcblxuICAgICAgLy8gcmVzdHJpY3RzIHRoZSBcIm92ZXJwb3dlcmVkXCIgcHJldmVudERlZmF1bHQgYWN0aW9uIE9OTFkgdG8gYSBkaXJlY3QgY2xpY2sva2V5ZG93biBvbiAuZGlzcGF0Y2gtdHJpZ2VyIGVsZW1lbnRcbiAgICAgIC8vICAgLSB0aGlzIHJldGFpbnMgYmxvY2tpbmcgb2YgZGVmYXVsdCBhY3Rpb25zIHdoZW4gdGhlIHRyaWdnZXIgaXMgYW4gYW5jaG9yIGl0c2VsZlxuICAgICAgLy8gICAtIGJ1dCBhbGxvd3MgY2hpbGQgYSwgaW5wdXQsIGJ1dHRvbiwgbGFiZWwsIGV0Yy4gdG8gcmV0YWluIHRoZWlyIGZ1bmN0aW9uYWxpdHlcbiAgICAgIGlmKGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgY2xpY2sgYWN0aW9uc1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaXJlIHRoZSBtYWluIGZ1bmN0aW9uXG4gICAgICBjbGlja0Rpc3BhdGNoKCAkKHRoaXMpICk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vL1xuLy8gUGVyY2ggTmF2aWdhdGlvbiAvIE1lbnUgU3lzdGVtXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVmFyaWFibGVzIGRlZmluZWQgaW4gcGVyY2gtY29yZS1zY3JpcHRzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8vIFZhcmlhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgJGdsb2JhbF9oZWFkZXIgICAgICA9ICQoJyNnbG9iYWwtaGVhZGVyJyksXG5cbiAgJG5hdl9vdXRlcl93cmFwcGVyICAgID0gJCgnI2dsb2JhbC1vdXRlci1uYXZpZ2F0aW9uLXdyYXBwZXInKSxcblxuICAvLyAkbmF2X3BhcmVudCAgICAgID0gJCgnLmdsb2JhbC1uYXYtaXRlbS0taGFzLWNoaWxkcmVuJyksXG4gICRuYXZfYWN0aXZlX3BhcmVudCAgICA9ICQoJy5nbG9iYWwtbmF2LWl0ZW0tLWhhcy1jaGlsZHJlbi5hY3RpdmUtcGFyZW50JyksXG4gIC8vICRuYXZfcGFyZW50X2xpbmsgICAgID0gJCgnLmdsb2JhbC1uYXYtaXRlbS0taGFzLWNoaWxkcmVuID4gLmdsb2JhbC1uYXYtbGluaycpLFxuICAkbmF2X2NoaWxkICAgICAgICA9ICQoJy5nbG9iYWwtbmF2LWNoaWxkLWxpc3QnKSxcblxuICAkbmF2X3JldmVhbF9idXR0b24gICAgPSAkKCcuaGFtYnVyZ2VyLW1lbnUtYnV0dG9uJyk7XG5cblxuLy8gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBNb2JpbGUgbmF2IG9wZW5pbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBvcGVuTW9iaWxlTmF2ICgpIHtcbiAgJCgnaHRtbCcpLmFkZENsYXNzKCdtb2JpbGUtbmF2LWlzLW9wZW4gaXMtbW9iaWxlLXNjcm9sbC1sb2NrZWQnKTtcbiAgJG5hdl9yZXZlYWxfYnV0dG9uLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKS5hdHRyKCdhcmlhLXByZXNzZWQnLCAndHJ1ZScpO1xuICAkbmF2X291dGVyX3dyYXBwZXIuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAkZ2xvYmFsX2hlYWRlci5hZGRDbGFzcygnbW9iaWxlLW5hdi1pcy1vcGVuJyk7XG59XG5cblxuLy8gTmF2aWdhdGlvbiBvcGVuaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlbnMgdGhlIG1lbnUgZm9yIGJvdGggbW9iaWxlIGFuZCBkZXNrdG9wLlxuLy8gQWxzbyBjYW4gYWNjZXB0IGFuIGFyZ3VtZW50IHRvIG9wZW4gYSBzcGVjaWZpYyBjaGlsZCBtZW51LlxuLy8gID4gQ291bGQgYmUgdXNlZCB0byBvcGVuIHRoZSBuYXZpZ2F0aW9uIGJ5IGNsaWNraW5nIGEgbGluayBvciBidXR0b24gb24gdGhlIHBhZ2UuXG4vLyAgPiBXYXMgb25jZSB1c2VkIG9uIFdNVS9Xb3JkbENyYWZ0cyBzaWRlYmFyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gb3Blbk5hdiAodGhlX21lbnUpIHtcblxuICAvLyBVc2UgaW50ZXJwb2xhdGlvbiB0byB0YWtlIHRoZSBwYXNzZWQgY2hpbGQgbWVudSBuYW1lIGFuZCB0aGVuIHNlbGVjdCBpdCBiZWxvd1xuICB2YXIgaW50ZXJwb2xhdGVkX3NlbGVjdG9yID0gXCIubWVudS1cIiArIHRoZV9tZW51O1xuICAkKGludGVycG9sYXRlZF9zZWxlY3RvcilcbiAgICAuZm9jdXMoKVxuICAgIC5hZGRDbGFzcygnaXMtb3BlbiBzdWJtZW51LWlzLW9wZW4nKTtcbiAgJChpbnRlcnBvbGF0ZWRfc2VsZWN0b3IpLmNoaWxkcmVuKCRuYXZfY2hpbGQpLmFkZENsYXNzKCdpcy1vcGVuJyk7XG4gICQoaW50ZXJwb2xhdGVkX3NlbGVjdG9yKS5jaGlsZHJlbignLmNoaWxkLW5hdi1vcGVuZXInKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgLy8gRmVlZGJhY2sgdG8gdGhlIGJvZHk6IGEgY2hpbGQgbWVudSBpcyBvcGVuLiBBbGxvd3MgZm9yIG1ha2luZyBhIGJhY2tkcm9wIHNob3cgdXAgb3ZlciB0aGUgY29udGVudC9iZW5lYXRoIHRoZSBtZW51LlxuICAvLyAkKCdib2R5JykuYWRkQ2xhc3MoJ2NoaWxkLW1lbnUtaXMtb3BlbicpO1xuXG4gIG9wZW5Nb2JpbGVOYXYoKTtcblxuICBpZigkbmF2X291dGVyX3dyYXBwZXIuaGFzQ2xhc3MoJ25hdmlnYXRpb24tZHJhd2VyLXdyYXBwZXInKSkge1xuICAgIGRyYXdlckxpc3RlbkZvckNsb3NpbmdTd2lwZSgpO1xuICB9XG59XG5cblxuLy8gTmF2aWdhdGlvbiBjbG9zaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2xvc2VOYXYgKGNsb3NlTmF2TWlsbGlzZWNvbmRzKSB7XG4gICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnbW9iaWxlLW5hdi1pcy1vcGVuIGlzLW1vYmlsZS1zY3JvbGwtbG9ja2VkJyk7XG4gICRuYXZfb3V0ZXJfd3JhcHBlci5hZGRDbGFzcygnYW5pbWF0aW5nLW91dCcpO1xuICAkbmF2X3JldmVhbF9idXR0b24ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKS5hdHRyKCdhcmlhLXByZXNzZWQnLCAnZmFsc2UnKTtcbiAgJGdsb2JhbF9oZWFkZXIucmVtb3ZlQ2xhc3MoJ21vYmlsZS1uYXYtaXMtb3BlbicpO1xuXG4gIC8vIENsb3NlIG1lZ2FtZW51cyBmb3IgbW9iaWxlLi4uYmVmb3JlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxuICAkKCcuZ2xvYmFsLW5hdi1pdGVtJykucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4gc3VibWVudS1pcy1vcGVuIHN1Ym1lbnUtaXMtbW9iaWxlLW9wZW4nKTtcbiAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdjaGlsZC1tZW51LWlzLW9wZW4nKTtcblxuICAvLyBpZiBhIGN1c3RvbSB0aW1lb3V0IGlzIHBhc3NlZCwgXG4gIG1pbGxpc2Vjb25kcyA9IChjbG9zZU5hdk1pbGxpc2Vjb25kcyA+PSAwKSA/IGNsb3NlTmF2TWlsbGlzZWNvbmRzIDogMjUwO1xuXG4gIHZhciBuYXZfY2xvc2VfdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIC8vIENsb3NlIG1lZ2FtZW51cyBmb3IgbW9iaWxlLi4uYWZ0ZXIgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICAgJCgnLmNoaWxkLW5hdi1vcGVuZXInKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgJG5hdl9jaGlsZC5yZW1vdmVDbGFzcygnaXMtb3BlbicpO1xuXG4gICAgJG5hdl9vdXRlcl93cmFwcGVyLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAkbmF2X291dGVyX3dyYXBwZXIucmVtb3ZlQ2xhc3MoJ2FuaW1hdGluZy1vdXQnKTtcbiAgfSwgbWlsbGlzZWNvbmRzKTtcblxuICAvLyBhbHNvIGNsb3NlIHRoZSBzZWFyY2hcbiAgaWYgKHR5cGVvZiBjbG9zZVNlYXJjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNsb3NlU2VhcmNoKCk7XG4gIH1cblxuICAvLyBpZiBhIGRyYXdlciwgcGFzcyB0aGUgZmFsc2UgdmFsdWUgdG8gcmVtb3ZlIHRoZSBzd2lwZSBldmVudCBsaXN0ZW5lcnNcbiAgaWYoJG5hdl9vdXRlcl93cmFwcGVyLmhhc0NsYXNzKCduYXZpZ2F0aW9uLWRyYXdlci13cmFwcGVyJykpIHtcbiAgICBkcmF3ZXJMaXN0ZW5Gb3JDbG9zaW5nU3dpcGUoZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIExvZ2ljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gTmF2aWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQ2xvc2UgdGhlIG1lbnUgaWYgaXQncyBjdXJyZW50bHkgYWN0aXZlLiBPdGhlcndpc2U6IHJ1biBvcGVuTmF2IGZ1bmN0aW9uLlxuJG5hdl9yZXZlYWxfYnV0dG9uLm9uKCdjbGljayBrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICBpZiAoKGUudHlwZSA9PSAnY2xpY2snKSB8fCAoZS5rZXlDb2RlID09IDMyKSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgY2xvc2VOYXYoKTtcbiAgICAgIHRoaXMuYmx1cigpOyAvLyBSZW1vdmUgdGhlIGZvY3VzIGZyb20gdGhlIGJ1dHRvbiBzbyA6Zm9jdXMgc3R5bGVzIGRvbid0IHNob3cgb24gdG91Y2ggc2NyZWVuc1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW5OYXYoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vL1xuLy8gQ2hpbGQgTmF2IE9wZW4gV2l0aCBQYXJlbnQgQ2xpY2tcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJZiBhIG5hdiBsaW5rIHNldCB0byBvcGVuIGl0cyBjaGlsZCBpcyBjbGlja2VkLFxuLy8gb3BlbiB0aGUgY2hpbGQgbWVudS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBc3N1bWVzIGFuIGludGVncmF0aW9uIHdpdGg6XG4vLyAtIG5hdmlnYXRpb24tc3lzdGVtLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRG8gbm90IHVzZSBhbG9uZ3NpZGUgY2hpbGQtbmF2LW9wZW4td2l0aC1nZW5lcmF0ZWQtYnV0dG9uLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8vIFZhcmlhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgJG5hdl9saW5rX29wZW5zX2NoaWxkICAgICA9ICQoJy5nbG9iYWwtbmF2LWl0ZW0tLW9wZW5zLWNoaWxkID4gLmdsb2JhbC1uYXYtbGluaycpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gTG9naWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuJG5hdl9saW5rX29wZW5zX2NoaWxkLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCBsaW5rIGZyb20gYmVpbmcgZm9sbG93ZWRcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIC8vIHNldCB0aGUgcGFyZW50XG4gIHZhciAkdGhlX3BhcmVudCA9ICQodGhpcykucGFyZW50KCk7XG5cbiAgLy8gcmVtb3ZlIGlzLW9wZW4gY2xhc3MgaWYgaXQncyBhbHJlYWR5IHRoZXJlXG4gIGlmICggJHRoZV9wYXJlbnQuaGFzQ2xhc3MoJ3N1Ym1lbnUtaXMtb3BlbicpIHx8ICR0aGVfcGFyZW50Lmhhc0NsYXNzKCdzdWJtZW51LWlzLW1vYmlsZS1vcGVuJykgKSB7XG4gICAgJHRoZV9wYXJlbnQucmVtb3ZlQ2xhc3MoJ3N1Ym1lbnUtaXMtb3BlbiBzdWJtZW51LWlzLW1vYmlsZS1vcGVuJylcbiAgICAgIC5jaGlsZHJlbignLmdsb2JhbC1uYXYtY2hpbGQtbGlzdCcpLnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG4gICAgJCh0aGlzKS5ibHVyKCk7XG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCBhZGQgaXRcbiAgZWxzZSB7XG4gICAgJHRoZV9wYXJlbnQuYWRkQ2xhc3MoJ3N1Ym1lbnUtaXMtb3BlbicpXG4gICAgICAuY2hpbGRyZW4oJy5nbG9iYWwtbmF2LWNoaWxkLWxpc3QnKS5hZGRDbGFzcygnaXMtb3BlbicpO1xuICB9XG59KTtcblxuLy9cbi8vIE1vZGFsIFNlYXJjaCBTeXN0ZW1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBWYXJpYWJsZXMgZGVmaW5lZCBpbiBwZXJjaC1jb3JlLXNjcmlwdHMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gVmFyaWFibGVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciAkc2VhcmNoX3JldmVhbF9idXR0b24gPSAkKCcuZ2xvYmFsLXNlYXJjaC1yZXZlYWwtYnV0dG9uJyksXG4gICRzZWFyY2hfbWVudSAgICAgID0gJCgnI2dsb2JhbC1zZWFyY2gtb3ZlcmxheScpLFxuICAkc2VhcmNoX2lucHV0ICAgICAgID0gJCgnI2dsb2JhbC1zZWFyY2gtb3ZlcmxheV9faW5wdXQnKSxcbiAgJHNlYXJjaF9zdWJtaXQgICAgICA9ICQoJyNnbG9iYWwtc2VhcmNoLW92ZXJsYXlfX3N1Ym1pdCcpLFxuICAkc2VhcmNoX2Nsb3NlX2J0biAgICAgPSAkKCcjZ2xvYmFsLXNlYXJjaC1vdmVybGF5X19jbG9zZS1idXR0b24nKSxcblxuICAvLyBHbG9iYWwgc3RhbmRhcmQgZm9yIHRyaWdnZXJpbmcgc2VhcmNoLlxuICAvLyBFeGFtcGxlIHVzYWdlOiByYXRoZXIgdGhhbiBlbWJlZCBhbiBhZGRpdGlvbmFsIHNlYXJjaCBmb3JtIGlucHV0IGFuZCBzdWJtaXQgb24gYSA0MDQgcGFnZSwgYWRkIGEgbGluayBvciBidXR0b24gd2l0aCB0aGlzIGNsYXNzIHRoYXQgc3VtbW9ucyB0aGUgc2l0ZSBzZWFyY2guXG4gIC8vIElmIG5vdCB1c2luZyBmdW5jdGlvbmFsaXR5IGluIHRoZSBtb2RhbCBzZWFyY2ggc3lzdGVtLCB3cml0ZSBzb21ldGhpbmcgc2ltaWxhciB1c2luZyB0aGlzIGNsYXNzIG5hbWUgYW5kIHZhcmlhYmxlLlxuICAkc2VhcmNoX3RyaWdnZXIgICAgID0gJCgnLmdsb2JhbC1zZWFyY2gtdHJpZ2dlcicpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gU2VhcmNoIG9wZW5pbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBvcGVuU2VhcmNoICgpIHtcbiAgLy8gRmlyc3QsIG1ha2UgdGhlIGxpbmsgaGlnaGxpZ2h0ZWQgJiBzaG93IHRoZSBtZW51XG4gICRzZWFyY2hfcmV2ZWFsX2J1dHRvbi5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJykuYXR0cignYXJpYS1wcmVzc2VkJywgJ3RydWUnKTtcbiAgJHNlYXJjaF9tZW51LmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgLy8gVGhlbiwgc2VsZWN0IHRoZSBpbnB1dCBmaWVsZFxuICAkc2VhcmNoX2lucHV0LnNlbGVjdCgpO1xufVxuXG5cbi8vIFNlYXJjaCBjbG9zaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2xvc2VTZWFyY2ggKCkge1xuICAvLyBSZW1vdmUgY2xhc3NlcyB0byB0aGUgbWVudSBhbmQgdGhlIGxpbmtcbiAgLy8gJCh0aGlzKS5vZmZzZXRXaWR0aCA9ICQodGhpcykub2Zmc2V0V2lkdGg7XG4gICRzZWFyY2hfbWVudS5hZGRDbGFzcygnYW5pbWF0aW5nLW91dCcpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICRzZWFyY2hfcmV2ZWFsX2J1dHRvbi5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtcHJlc3NlZCcsICdmYWxzZScpO1xuICAgICRzZWFyY2hfbWVudS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgJHNlYXJjaF9tZW51LnJlbW92ZUNsYXNzKCdhbmltYXRpbmctb3V0Jyk7XG4gIH0sIDI1MCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLy8gTG9naWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDbG9zZSB0aGUgbWVudSBpZiBpdCdzIGN1cnJlbnRseSBhY3RpdmUuIE90aGVyd2lzZTogcnVuIG9wZW5TZWFyY2ggZnVuY3Rpb24uXG4kc2VhcmNoX3JldmVhbF9idXR0b24uY2xpY2soZnVuY3Rpb24oKSB7XG4gIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgIGNsb3NlU2VhcmNoKCk7XG4gIH1cblxuICBlbHNlIHtcbiAgICBvcGVuU2VhcmNoKCk7XG4gIH1cbn0pO1xuXG5cbi8vIE9wZW4gdGhlIHNlYXJjaCBtZW51IGlmIGFueSBhbmNob3Igd2l0aCBhIGNlcnRhaW4gY2xhc3MgaXMgY2xpY2tlZFxuJHNlYXJjaF90cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAvLyBpZiB0aGUgc2VsZWN0ZWQgc2VhcmNoIHRyaWdnZXIgaXMgYWxzbyBhIHNlYXJjaCByZXZlYWwgYnV0dG9uLCBhYm9ydCB0aGlzIGZ1bmN0aW9uXG4gIGlmKCQodGhpcykuaXMoJHNlYXJjaF9yZXZlYWxfYnV0dG9uKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBBZGQgY2xhc3NlcyB0byB0aGUgbWVudSBhbmQgdGhlIGxpbmtcbiAgJHNlYXJjaF9yZXZlYWxfYnV0dG9uLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgJHNlYXJjaF9tZW51LmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAvLyBGb2N1cyB0aGUgc2VhcmNoIGlucHV0XG4gICQodGhpcykuYmx1cigpO1xuICAkc2VhcmNoX2lucHV0LnNlbGVjdCgpO1xuXG4gIHJldHVybiBmYWxzZTtcbn0pO1xuXG5cbi8vIENsaWNraW5nIGFueXdoZXJlIGluIHRoZSBzZWFyY2gncyBiYWNrZ3JvdW5kIG92ZXJsYXkg4oCUIGV4Y2VwdCB3aXRoaW4gdGhlIGFjdHVhbCBmb3JtIOKAlCBjbG9zZXMgdGhlIG92ZXJsYXlcbiRzZWFyY2hfbWVudS5jbGljayhjbG9zZVNlYXJjaCk7XG4gIC8vIC4uLkRvIG5vdCBjbG9zZSBpZiB0aGUgY2xpY2sgaXMgaW5zaWRlIHRoZSBpbm5lciBjb250YWluZXIuXG4gICQoJy5nbG9iYWwtc2VhcmNoLW92ZXJsYXlfX2lubmVyJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG4kc2VhcmNoX2Nsb3NlX2J0bi5jbGljayhjbG9zZVNlYXJjaCk7XG5cblxuLy8gU2VhcmNoIGtleWJvYXJkIGFzc2lzdDogd2hlbiBzZWFyY2ggbWVudSBpcyBvcGVuLCBrZWVwIGZvY3VzIHdpdGhpbiB0aGUgc2VhcmNoIG1lbnVcbi8vIGJ5IGZvY3VzaW5nIFwiYmFjayB0b1wiIHRoZSBjb3JuZXIgY2xvc2VyIGJ1dHRvbiwgd2hpY2ggYWxsb3dzIHRoZSB1c2VyIHRvIGNsb3NlIGlmIGRlc2lyZWQsXG4vLyBvciBjb250aW51ZSB0byB0aGUgbmV4dCBmb2N1c2FibGUgZmllbGQsIHRoZSBpbnB1dCBpdHNlbGZcbiRzZWFyY2hfY2xvc2VfYnRuLm9uKCdmb2N1c291dCcsIGZ1bmN0aW9uKCkge1xuICAkc2VhcmNoX2lucHV0LmZvY3VzKCk7XG59KTtcblxuLy9cbi8vIEtleWJvYXJkIHNob3J0Y3V0cyB3aXRoIE1vdXNlVHJhcC5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFzc3VtZXMgYW4gaW50ZWdyYXRpb24gd2l0aDpcbi8vIC0gbmF2aWdhdGlvbi1zeXN0ZW0uanNcbi8vIC0gbW9kYWwtc2VhcmNoLXN5c3RlbS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gb3BlbiBzZWFyY2hcbk1vdXNldHJhcC5iaW5kKCcvJywgZnVuY3Rpb24oZSkge1xuXG4gIGlmICh0eXBlb2Ygb3BlblNlYXJjaCA9PSAnZnVuY3Rpb24nICYmICRzZWFyY2hfbWVudS5sZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgc2VhcmNoIG1lbnUgaXMgYWxyZWFkeSBvcGVuLCBuZXZlcm1pbmQsIGxldCB0aGUgYC9gIHRocm91Z2guLi5cbiAgICBpZiAoJHNlYXJjaF9tZW51Lmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQnV0IGlmIGl0J3Mgbm90IGFscmVhZHkgb3BlbiwgY2FwdHVyZSB0aGUgYC9gIGFuZCBvcGVuIHRoZSBtZW51XG4gICAgZWxzZSB7XG4gICAgICAvLyBQcmV2ZW50ICcvJyBjaGFyIGZyb20gYmVpbmcgdHlwZWQgaW50byB0aGUgbmV3bHktZm9jdXNlZCBzZWFyY2ggZmllbGRcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgb3BlblNlYXJjaCgpO1xuICAgIH1cbiAgfVxuICAvLyBlbHNlIHtcbiAgLy8gIGNvbnNvbGUubG9nKFwiRWl0aGVyIG9wZW5TZWFyY2ggaXMgbm90IGEgZnVuY3Rpb24gb3IgJHNlYXJjaF9tZW51IGhhcyBub3QgYmVlbiBhc3NpZ25lZC5cIik7XG4gIC8vIH1cblxufSk7XG5cbi8vIHByZXNzIGVzY2FwZSAoRVNDKSB0byBjbG9zZSBtZW51c1xuTW91c2V0cmFwLmJpbmQoJ2VzYycsIGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIGNsb3NlTmF2ID09ICdmdW5jdGlvbicpIHtcbiAgICBjbG9zZU5hdigpO1xuICB9XG4gIGlmICh0eXBlb2YgY2xvc2VTZWFyY2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNsb3NlU2VhcmNoKCk7XG4gIH1cbn0pO1xuXG4vLyBvcGVuIHRoZSBtZW51L25hdlxuTW91c2V0cmFwLmJpbmQoJ3UnLCBmdW5jdGlvbigpIHtcbiAgLy8gU2luY2Ugc2VhcmNoIGlucHV0IGlzIGFsbG93ZWQgdG8gbGlzdGVuIHRvIE1vdXNldHJhcCAobm9ybWFsbHkgaXQncyBkaXNhYmxlZCDigJQgYnV0IHdlIHdhbnQgaXQgZW5hYmxlZCBmb3IgRVNDIGtleSBjbG9zZSksIGlnbm9yZSB0aGUgXCJ1XCIgY2hhcmFjdGVyIGlmIGl0IGlzIG9wZW5cbiAgaWYoICghdHlwZW9mKCRzZWFyY2hfbWVudSkgPT09ICd1bmRlZmluZWQnKSAmJiAoJHNlYXJjaF9tZW51Lmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGlmIHRoZSBtb2JpbGUgbmF2aWdhdGlvbiBpcyBvcGVuLCBjbG9zZSBpdFxuICBlbHNlIGlmICgkZ2xvYmFsX2hlYWRlci5oYXNDbGFzcygnbW9iaWxlLW5hdi1pcy1vcGVuJykpIHtcbiAgICBpZiAodHlwZW9mIGNsb3NlTmF2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNsb3NlTmF2KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gLi4uYW5kIGlmIGl0J3Mgbm90IG9wZW4sIG9wZW4gaXRcbiAgZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcGVuTmF2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wZW5OYXYoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAvLyBrb25hbWkgY29kZSFcbi8vIE1vdXNldHJhcC5iaW5kKCd1cCB1cCBkb3duIGRvd24gbGVmdCByaWdodCBsZWZ0IHJpZ2h0IGIgYScsIGZ1bmN0aW9uKCkgeyAvL2VudGVyXG4vLyAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdrb25hbWktY29kZS1pcy1hY3RpdmUnKTtcbi8vIH0pO1xuXG4vKiFcblxuSG9sZGVyIC0gY2xpZW50IHNpZGUgaW1hZ2UgcGxhY2Vob2xkZXJzXG5WZXJzaW9uIDIuOS42K2ZibHl5XG7CqSAyMDE4IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jb1xuXG5TaXRlOiAgICAgaHR0cDovL2hvbGRlcmpzLmNvbVxuSXNzdWVzOiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9pbXNreS9ob2xkZXIvaXNzdWVzXG5MaWNlbnNlOiAgTUlUXG5cbiovXG4oZnVuY3Rpb24gKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5kb2N1bWVudCkgcmV0dXJuO1xuICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgLy9odHRwczovL2dpdGh1Yi5jb20vaW5leG9yYWJsZXRhc2gvcG9seWZpbGwvYmxvYi9tYXN0ZXIvd2ViLmpzXG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLCBlbGVtZW50cyA9IFtdLCBlbGVtZW50O1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIGRvY3VtZW50Ll9xc2EgPSBbXTtcblxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBzZWxlY3RvcnMgKyAne3gtcXNhOmV4cHJlc3Npb24oZG9jdW1lbnQuX3FzYSAmJiBkb2N1bWVudC5fcXNhLnB1c2godGhpcykpfSc7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCAwKTtcbiAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cbiAgICAgICAgd2hpbGUgKGRvY3VtZW50Ll9xc2EubGVuZ3RoKSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50Ll9xc2Euc2hpZnQoKTtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgneC1xc2EnKTtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50Ll9xc2EgPSBudWxsO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMpO1xuICAgICAgICByZXR1cm4gKGVsZW1lbnRzLmxlbmd0aCkgPyBlbGVtZW50c1swXSA6IG51bGw7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChjbGFzc05hbWVzKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgPSBTdHJpbmcoY2xhc3NOYW1lcykucmVwbGFjZSgvXnxcXHMrL2csICcuJyk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNsYXNzTmFtZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgLy9odHRwczovL2dpdGh1Yi5jb20vaW5leG9yYWJsZXRhc2gvcG9seWZpbGxcbiAgLy8gRVM1IDE1LjIuMy4xNCBPYmplY3Qua2V5cyAoIE8gKVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1xuICBpZiAoIU9iamVjdC5rZXlzKSB7XG4gICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkgeyB0aHJvdyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7IH1cbiAgICAgIHZhciByZXQgPSBbXSwgcDtcbiAgICAgIGZvciAocCBpbiBvKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIHtcbiAgICAgICAgICByZXQucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG5cbiAgLy8gRVM1IDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAoIGNhbGxiYWNrZm4gWyAsIHRoaXNBcmcgXSApXG4gIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzcCAqLykge1xuICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XG5cbiAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBUeXBlRXJyb3IoKTsgfVxuXG4gICAgICB2YXIgdGhpc3AgPSBhcmd1bWVudHNbMV0sIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdCkge1xuICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCB0W2ldLCBpLCB0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbC9ibG9iL21hc3Rlci93ZWIuanNcbiAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICB2YXIgQjY0X0FMUEhBQkVUID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICBnbG9iYWwuYXRvYiA9IGdsb2JhbC5hdG9iIHx8IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCxcbiAgICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgICBidWZmZXIgPSAwLCBiaXRzID0gMCwgbjtcblxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgaWYgKChpbnB1dC5sZW5ndGggJSA0KSA9PT0gMCkgeyBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTsgfVxuICAgICAgaWYgKChpbnB1dC5sZW5ndGggJSA0KSA9PT0gMSkgeyB0aHJvdyBFcnJvcignSW52YWxpZENoYXJhY3RlckVycm9yJyk7IH1cbiAgICAgIGlmICgvW14rLzAtOUEtWmEtel0vLnRlc3QoaW5wdXQpKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbiA9IEI2NF9BTFBIQUJFVC5pbmRleE9mKGlucHV0LmNoYXJBdChwb3NpdGlvbikpO1xuICAgICAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDYpIHwgbjtcbiAgICAgICAgYml0cyArPSA2O1xuXG4gICAgICAgIGlmIChiaXRzID09PSAyNCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKGJ1ZmZlciA+PiAxNikgJiAweEZGKSk7XG4gICAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoYnVmZmVyID4+ICA4KSAmIDB4RkYpKTtcbiAgICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlciAmIDB4RkYpKTtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICBidWZmZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRzID09PSAxMikge1xuICAgICAgICBidWZmZXIgPSBidWZmZXIgPj4gNDtcbiAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIgJiAweEZGKSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHMgPT09IDE4KSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciA+PiAyO1xuICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChidWZmZXIgPj4gOCkgJiAweEZGKSk7XG4gICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyICYgMHhGRikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBnbG9iYWwuYnRvYSA9IGdsb2JhbC5idG9hIHx8IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCxcbiAgICAgICAgICBvdXQgPSBbXSxcbiAgICAgICAgICBvMSwgbzIsIG8zLFxuICAgICAgICAgIGUxLCBlMiwgZTMsIGU0O1xuXG4gICAgICBpZiAoL1teXFx4MDAtXFx4RkZdLy50ZXN0KGlucHV0KSkgeyB0aHJvdyBFcnJvcignSW52YWxpZENoYXJhY3RlckVycm9yJyk7IH1cblxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIG8xID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbisrKTtcbiAgICAgICAgbzIgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKyspO1xuICAgICAgICBvMyA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24rKyk7XG5cbiAgICAgICAgLy8gMTExMTExIDExMjIyMiAyMjIyMzMgMzMzMzMzXG4gICAgICAgIGUxID0gbzEgPj4gMjtcbiAgICAgICAgZTIgPSAoKG8xICYgMHgzKSA8PCA0KSB8IChvMiA+PiA0KTtcbiAgICAgICAgZTMgPSAoKG8yICYgMHhmKSA8PCAyKSB8IChvMyA+PiA2KTtcbiAgICAgICAgZTQgPSBvMyAmIDB4M2Y7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggKyAyKSB7XG4gICAgICAgICAgZTMgPSA2NDsgZTQgPSA2NDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA9PT0gaW5wdXQubGVuZ3RoICsgMSkge1xuICAgICAgICAgIGU0ID0gNjQ7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQucHVzaChCNjRfQUxQSEFCRVQuY2hhckF0KGUxKSxcbiAgICAgICAgICAgICAgICAgQjY0X0FMUEhBQkVULmNoYXJBdChlMiksXG4gICAgICAgICAgICAgICAgIEI2NF9BTFBIQUJFVC5jaGFyQXQoZTMpLFxuICAgICAgICAgICAgICAgICBCNjRfQUxQSEFCRVQuY2hhckF0KGU0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gICAgfTtcbiAgfSh3aW5kb3cpKTtcblxuICAvL2h0dHBzOi8vZ2lzdC5naXRodWIuY29tL2ppbWVoLzMzMjM1N1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpe1xuICAgICAgLypqc2hpbnQgLVcwMDEsIC1XMTAzICovXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdmFyIHByb3RvID0gdGhpcy5fX3Byb3RvX18gfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gKHByb3AgaW4gdGhpcykgJiYgKCEocHJvcCBpbiBwcm90bykgfHwgcHJvdG9bcHJvcF0gIT09IHRoaXNbcHJvcF0pO1xuICAgIH07XG4gICAgICAvKmpzaGludCArVzAwMSwgK1cxMDMgKi9cbiAgfVxuXG4gIC8vIEBsaWNlbnNlIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAgLy8gY29weXJpZ2h0IFBhdWwgSXJpc2ggMjAxNVxuXG5cbiAgLy8gRGF0ZS5ub3coKSBpcyBzdXBwb3J0ZWQgZXZlcnl3aGVyZSBleGNlcHQgSUU4LiBGb3IgSUU4IHdlIHVzZSB0aGUgRGF0ZS5ub3cgcG9seWZpbGxcbiAgLy8gICBnaXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL2Jsb2IvbWFzdGVyL3BvbHlmaWxscy9EYXRlLm5vdy9wb2x5ZmlsbC5qc1xuICAvLyBhcyBTYWZhcmkgNiBkb2Vzbid0IGhhdmUgc3VwcG9ydCBmb3IgTmF2aWdhdGlvblRpbWluZywgd2UgdXNlIGEgRGF0ZS5ub3coKSB0aW1lc3RhbXAgZm9yIHJlbGF0aXZlIHZhbHVlc1xuXG4gIC8vIGlmIHlvdSB3YW50IHZhbHVlcyBzaW1pbGFyIHRvIHdoYXQgeW91J2QgZ2V0IHdpdGggcmVhbCBwZXJmLm5vdywgcGxhY2UgdGhpcyB0b3dhcmRzIHRoZSBoZWFkIG9mIHRoZSBwYWdlXG4gIC8vIGJ1dCBpbiByZWFsaXR5LCB5b3UncmUganVzdCBnZXR0aW5nIHRoZSBkZWx0YSBiZXR3ZWVuIG5vdygpIGNhbGxzLCBzbyBpdCdzIG5vdCB0ZXJyaWJseSBpbXBvcnRhbnQgd2hlcmUgaXQncyBwbGFjZWRcblxuXG4gIChmdW5jdGlvbigpe1xuXG4gICAgaWYgKCdwZXJmb3JtYW5jZScgaW4gd2luZG93ID09PSBmYWxzZSkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgRGF0ZS5ub3cgPSAoRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyAgLy8gdGhhbmtzIElFOFxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCdub3cnIGluIHdpbmRvdy5wZXJmb3JtYW5jZSA9PT0gZmFsc2Upe1xuICAgICAgXG4gICAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdygpe1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICAgIH07XG4gICAgfVxuXG4gIH0pKCk7XG5cbiAgLy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgZm9yIG9sZGVyIEZpcmVmb3gvQ2hyb21lIHZlcnNpb25zXG4gIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIGlmICh3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL2Jsb2IvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUvcG9seWZpbGwtd2Via2l0LmpzXG4gICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHdlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfSh3aW5kb3cpKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtc2VydmljZS9ibG9iL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lL3BvbHlmaWxsLW1vei5qc1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKGdsb2JhbC5wZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsLm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgIH0od2luZG93KSk7XG4gICAgfSBlbHNlIHtcbiAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsLnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xuICAgIH0pKHdpbmRvdyk7XG4gICAgfVxuICB9XG59KSh0aGlzKTtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICBlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICBlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgICBleHBvcnRzW1wiSG9sZGVyXCJdID0gZmFjdG9yeSgpO1xuICBlbHNlXG4gICAgcm9vdFtcIkhvbGRlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovICAvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyAgICAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovICAgIGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gICAgICByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovICAgICAgZXhwb3J0czoge30sXG4vKioqKioqLyAgICAgIGlkOiBtb2R1bGVJZCxcbi8qKioqKiovICAgICAgbG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gICAgfTtcblxuLyoqKioqKi8gICAgLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gICAgLy8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gICAgbW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyAgfVxuXG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovICAvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAvKlxuICBIb2xkZXIuanMgLSBjbGllbnQgc2lkZSBpbWFnZSBwbGFjZWhvbGRlcnNcbiAgKGMpIDIwMTItMjAxNSBJdmFuIE1hbG9waW5za3kgLSBodHRwOi8vaW1za3kuY29cbiAgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qXG4gIEhvbGRlci5qcyAtIGNsaWVudCBzaWRlIGltYWdlIHBsYWNlaG9sZGVyc1xuICAoYykgMjAxMi0yMDE2IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jb1xuICAqL1xuXG4gIC8vTGlicmFyaWVzIGFuZCBmdW5jdGlvbnNcbiAgdmFyIG9uRG9tUmVhZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuICB2YXIgcXVlcnlzdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4gIHZhciBTY2VuZUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbiAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbiAgdmFyIFNWRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gIHZhciBET00gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgQ29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbiAgdmFyIGNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4gIHZhciBzdmdSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuICB2YXIgc2dDYW52YXNSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG4gIHZhciBleHRlbmQgPSB1dGlscy5leHRlbmQ7XG4gIHZhciBkaW1lbnNpb25DaGVjayA9IHV0aWxzLmRpbWVuc2lvbkNoZWNrO1xuXG4gIC8vQ29uc3RhbnRzIGFuZCBkZWZpbml0aW9uc1xuICB2YXIgU1ZHX05TID0gY29uc3RhbnRzLnN2Z19ucztcblxuICB2YXIgSG9sZGVyID0ge1xuICAgICAgdmVyc2lvbjogY29uc3RhbnRzLnZlcnNpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhIHRoZW1lIHRvIGRlZmF1bHQgc2V0dGluZ3NcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGVtZSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhlbWUgVGhlbWUgb2JqZWN0LCB3aXRoIGZvcmVncm91bmQsIGJhY2tncm91bmQsIHNpemUsIGZvbnQsIGFuZCBmb250d2VpZ2h0IHByb3BlcnRpZXMuXG4gICAgICAgKi9cbiAgICAgIGFkZFRoZW1lOiBmdW5jdGlvbihuYW1lLCB0aGVtZSkge1xuICAgICAgICAgIG5hbWUgIT0gbnVsbCAmJiB0aGVtZSAhPSBudWxsICYmIChBcHAuc2V0dGluZ3MudGhlbWVzW25hbWVdID0gdGhlbWUpO1xuICAgICAgICAgIGRlbGV0ZSBBcHAudmFycy5jYWNoZS50aGVtZUtleXM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGVuZHMgYSBwbGFjZWhvbGRlciB0byBhbiBlbGVtZW50XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBQbGFjZWhvbGRlciBVUkwgc3RyaW5nXG4gICAgICAgKiBAcGFyYW0gZWwgQSBzZWxlY3RvciBvciBhIHJlZmVyZW5jZSB0byBhIERPTSBub2RlXG4gICAgICAgKi9cbiAgICAgIGFkZEltYWdlOiBmdW5jdGlvbihzcmMsIGVsKSB7XG4gICAgICAgICAgLy90b2RvOiB1c2UganF1ZXJ5IGZhbGxiYWNrIGlmIGF2YWlsYWJsZSBmb3IgYWxsIFFTQSByZWZlcmVuY2VzXG4gICAgICAgICAgdmFyIG5vZGVzID0gRE9NLmdldE5vZGVBcnJheShlbCk7XG4gICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB2YXIgaW1nID0gRE9NLm5ld0VsKCdpbWcnKTtcbiAgICAgICAgICAgICAgdmFyIGRvbVByb3BzID0ge307XG4gICAgICAgICAgICAgIGRvbVByb3BzW0FwcC5zZXR1cC5kYXRhQXR0cl0gPSBzcmM7XG4gICAgICAgICAgICAgIERPTS5zZXRBdHRyKGltZywgZG9tUHJvcHMpO1xuICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgd2hldGhlciBvciBub3QgYW4gaW1hZ2UgaXMgdXBkYXRlZCBvbiByZXNpemUuXG4gICAgICAgKiBJZiBhbiBpbWFnZSBpcyBzZXQgdG8gYmUgdXBkYXRlZCwgaXQgaXMgaW1tZWRpYXRlbHkgcmVuZGVyZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsIEltYWdlIERPTSBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFJlc2l6YWJsZSB1cGRhdGUgZmxhZyB2YWx1ZVxuICAgICAgICovXG4gICAgICBzZXRSZXNpemVVcGRhdGU6IGZ1bmN0aW9uKGVsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChlbC5ob2xkZXJEYXRhKSB7XG4gICAgICAgICAgICAgIGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlID0gISF2YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVSZXNpemFibGVFbGVtZW50cyhlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJ1bnMgSG9sZGVyIHdpdGggb3B0aW9ucy4gQnkgZGVmYXVsdCBydW5zIEhvbGRlciBvbiBhbGwgaW1hZ2VzIHdpdGggXCJob2xkZXIuanNcIiBpbiB0aGVpciBzb3VyY2UgYXR0cmlidXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlck9wdGlvbnMgT3B0aW9ucyBvYmplY3QsIGNhbiBjb250YWluIGRvbWFpbiwgdGhlbWVzLCBpbWFnZXMsIGFuZCBiZ25vZGVzIHByb3BlcnRpZXNcbiAgICAgICAqL1xuICAgICAgcnVuOiBmdW5jdGlvbih1c2VyT3B0aW9ucykge1xuICAgICAgICAgIC8vdG9kbzogc3BsaXQgcHJvY2Vzc2luZyBpbnRvIHNlcGFyYXRlIHF1ZXVlc1xuICAgICAgICAgIHVzZXJPcHRpb25zID0gdXNlck9wdGlvbnMgfHwge307XG4gICAgICAgICAgdmFyIGVuZ2luZVNldHRpbmdzID0ge307XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQoQXBwLnNldHRpbmdzLCB1c2VyT3B0aW9ucyk7XG5cbiAgICAgICAgICBBcHAudmFycy5wcmVlbXB0ZWQgPSB0cnVlO1xuICAgICAgICAgIEFwcC52YXJzLmRhdGFBdHRyID0gb3B0aW9ucy5kYXRhQXR0ciB8fCBBcHAuc2V0dXAuZGF0YUF0dHI7XG5cbiAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXIgPyBvcHRpb25zLnJlbmRlcmVyIDogQXBwLnNldHVwLnJlbmRlcmVyO1xuICAgICAgICAgIGlmIChBcHAuc2V0dXAucmVuZGVyZXJzLmpvaW4oJywnKS5pbmRleE9mKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPSBBcHAuc2V0dXAuc3VwcG9ydHNTVkcgPyAnc3ZnJyA6IChBcHAuc2V0dXAuc3VwcG9ydHNDYW52YXMgPyAnY2FudmFzJyA6ICdodG1sJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGltYWdlcyA9IERPTS5nZXROb2RlQXJyYXkob3B0aW9ucy5pbWFnZXMpO1xuICAgICAgICAgIHZhciBiZ25vZGVzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLmJnbm9kZXMpO1xuICAgICAgICAgIHZhciBzdHlsZW5vZGVzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLnN0eWxlbm9kZXMpO1xuICAgICAgICAgIHZhciBvYmplY3RzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLm9iamVjdHMpO1xuXG4gICAgICAgICAgZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHMgPSBbXTtcbiAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5zdmdYTUxTdHlsZXNoZWV0ID0gdHJ1ZTtcbiAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5ub0ZvbnRGYWxsYmFjayA9ICEhb3B0aW9ucy5ub0ZvbnRGYWxsYmFjaztcbiAgICAgICAgICBlbmdpbmVTZXR0aW5ncy5ub0JhY2tncm91bmRTaXplID0gISFvcHRpb25zLm5vQmFja2dyb3VuZFNpemU7XG5cbiAgICAgICAgICBzdHlsZW5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoc3R5bGVOb2RlLmF0dHJpYnV0ZXMucmVsICYmIHN0eWxlTm9kZS5hdHRyaWJ1dGVzLmhyZWYgJiYgc3R5bGVOb2RlLmF0dHJpYnV0ZXMucmVsLnZhbHVlID09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBzdHlsZU5vZGUuYXR0cmlidXRlcy5ocmVmLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgLy90b2RvOiB3cml0ZSBpc29tb3JwaGljIHJlbGF0aXZlLXRvLWFic29sdXRlIFVSTCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgdmFyIHByb3h5TGluayA9IERPTS5uZXdFbCgnYScpO1xuICAgICAgICAgICAgICAgICAgcHJveHlMaW5rLmhyZWYgPSBocmVmO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXRVUkwgPSBwcm94eUxpbmsucHJvdG9jb2wgKyAnLy8nICsgcHJveHlMaW5rLmhvc3QgKyBwcm94eUxpbmsucGF0aG5hbWUgKyBwcm94eUxpbmsuc2VhcmNoO1xuICAgICAgICAgICAgICAgICAgZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHMucHVzaChzdHlsZXNoZWV0VVJMKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYmdub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChiZ05vZGUpIHtcbiAgICAgICAgICAgICAgLy9Ta2lwIHByb2Nlc3NpbmcgYmFja2dyb3VuZCBub2RlcyBpZiBnZXRDb21wdXRlZFN0eWxlIGlzIHVuYXZhaWxhYmxlLCBzaW5jZSBvbmx5IG1vZGVybiBicm93c2VycyB3b3VsZCBiZSBhYmxlIHRvIHVzZSBjYW52YXMgb3IgU1ZHIHRvIHJlbmRlciB0byBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgIGlmICghZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUpIHJldHVybjtcbiAgICAgICAgICAgICAgdmFyIGJhY2tncm91bmRJbWFnZSA9IGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKGJnTm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICAgICAgICAgICAgICB2YXIgZGF0YUJhY2tncm91bmRJbWFnZSA9IGJnTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmFja2dyb3VuZC1zcmMnKTtcbiAgICAgICAgICAgICAgdmFyIHJhd1VSTCA9IGRhdGFCYWNrZ3JvdW5kSW1hZ2UgfHwgYmFja2dyb3VuZEltYWdlO1xuXG4gICAgICAgICAgICAgIHZhciBob2xkZXJVUkwgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgaG9sZGVyU3RyaW5nID0gb3B0aW9ucy5kb21haW4gKyAnLyc7XG4gICAgICAgICAgICAgIHZhciBob2xkZXJTdHJpbmdJbmRleCA9IHJhd1VSTC5pbmRleE9mKGhvbGRlclN0cmluZyk7XG5cbiAgICAgICAgICAgICAgaWYgKGhvbGRlclN0cmluZ0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBob2xkZXJVUkwgPSByYXdVUkw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9sZGVyU3RyaW5nSW5kZXggPT09IDEgJiYgcmF3VVJMWzBdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgIGhvbGRlclVSTCA9IHJhd1VSTC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHJhd1VSTC5zdWJzdHIoaG9sZGVyU3RyaW5nSW5kZXgpLm1hdGNoKC8oW15cXFwiXSopXCI/XFwpLyk7XG4gICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBob2xkZXJVUkwgPSBmcmFnbWVudFsxXTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmF3VVJMLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdIb2xkZXI6IHVuYWJsZSB0byBwYXJzZSBiYWNrZ3JvdW5kIFVSTDogJyArIHJhd1VSTDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChob2xkZXJVUkwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBob2xkZXJGbGFncyA9IHBhcnNlVVJMKGhvbGRlclVSTCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyRmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlRE9NRWxlbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGJnTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGhvbGRlckZsYWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5nczogZW5naW5lU2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgdmFyIG9iamVjdEF0dHIgPSB7fTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgb2JqZWN0QXR0ci5kYXRhID0gb2JqZWN0LmdldEF0dHJpYnV0ZSgnZGF0YScpO1xuICAgICAgICAgICAgICAgICAgb2JqZWN0QXR0ci5kYXRhU3JjID0gb2JqZWN0LmdldEF0dHJpYnV0ZShBcHAudmFycy5kYXRhQXR0cik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgICAgdmFyIG9iamVjdEhhc1NyY1VSTCA9IG9iamVjdEF0dHIuZGF0YSAhPSBudWxsICYmIG9iamVjdEF0dHIuZGF0YS5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcbiAgICAgICAgICAgICAgdmFyIG9iamVjdEhhc0RhdGFTcmNVUkwgPSBvYmplY3RBdHRyLmRhdGFTcmMgIT0gbnVsbCAmJiBvYmplY3RBdHRyLmRhdGFTcmMuaW5kZXhPZihvcHRpb25zLmRvbWFpbikgPT09IDA7XG5cbiAgICAgICAgICAgICAgaWYgKG9iamVjdEhhc1NyY1VSTCkge1xuICAgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgb2JqZWN0QXR0ci5kYXRhLCBvYmplY3QpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdEhhc0RhdGFTcmNVUkwpIHtcbiAgICAgICAgICAgICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIG9iamVjdEF0dHIuZGF0YVNyYywgb2JqZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgIHZhciBpbWFnZUF0dHIgPSB7fTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaW1hZ2VBdHRyLnNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAgICAgICBpbWFnZUF0dHIuZGF0YVNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZShBcHAudmFycy5kYXRhQXR0cik7XG4gICAgICAgICAgICAgICAgICBpbWFnZUF0dHIucmVuZGVyZWQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaG9sZGVyLXJlbmRlcmVkJyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgICAgdmFyIGltYWdlSGFzU3JjID0gaW1hZ2VBdHRyLnNyYyAhPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgaW1hZ2VIYXNEYXRhU3JjVVJMID0gaW1hZ2VBdHRyLmRhdGFTcmMgIT0gbnVsbCAmJiBpbWFnZUF0dHIuZGF0YVNyYy5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcbiAgICAgICAgICAgICAgdmFyIGltYWdlUmVuZGVyZWQgPSBpbWFnZUF0dHIucmVuZGVyZWQgIT0gbnVsbCAmJiBpbWFnZUF0dHIucmVuZGVyZWQgPT0gJ3RydWUnO1xuXG4gICAgICAgICAgICAgIGlmIChpbWFnZUhhc1NyYykge1xuICAgICAgICAgICAgICAgICAgaWYgKGltYWdlQXR0ci5zcmMuaW5kZXhPZihvcHRpb25zLmRvbWFpbikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuc3JjLCBpbWFnZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGltYWdlSGFzRGF0YVNyY1VSTCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vSW1hZ2UgaGFzIGEgdmFsaWQgZGF0YS1zcmMgYW5kIGFuIGludmFsaWQgc3JjXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlUmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgcGxhY2Vob2xkZXIgaGFzIGFscmVhZHkgYmVlbiByZW5kZXIsIHJlLXJlbmRlciBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIHBsYWNlaG9sZGVyIGhhcyBub3QgYmVlbiByZW5kZXJlZCwgY2hlY2sgaWYgdGhlIGltYWdlIGV4aXN0cyBhbmQgcmVuZGVyIGEgZmFsbGJhY2sgaWYgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oc3JjLCBvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgZGF0YVNyYywgaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmltYWdlRXhpc3RzKHNyYywgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgZGF0YVNyYywgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KShpbWFnZUF0dHIuc3JjLCBvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgaW1hZ2VBdHRyLmRhdGFTcmMsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VIYXNEYXRhU3JjVVJMKSB7XG4gICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgfTtcblxuICB2YXIgQXBwID0ge1xuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBkb21haW46ICdob2xkZXIuanMnLFxuICAgICAgICAgIGltYWdlczogJ2ltZycsXG4gICAgICAgICAgb2JqZWN0czogJ29iamVjdCcsXG4gICAgICAgICAgYmdub2RlczogJ2JvZHkgLmhvbGRlcmpzJyxcbiAgICAgICAgICBzdHlsZW5vZGVzOiAnaGVhZCBsaW5rLmhvbGRlcmpzJyxcbiAgICAgICAgICB0aGVtZXM6IHtcbiAgICAgICAgICAgICAgJ2dyYXknOiB7XG4gICAgICAgICAgICAgICAgICBiZzogJyNFRUVFRUUnLFxuICAgICAgICAgICAgICAgICAgZmc6ICcjQUFBQUFBJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnc29jaWFsJzoge1xuICAgICAgICAgICAgICAgICAgYmc6ICcjM2E1YTk3JyxcbiAgICAgICAgICAgICAgICAgIGZnOiAnI0ZGRkZGRidcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2luZHVzdHJpYWwnOiB7XG4gICAgICAgICAgICAgICAgICBiZzogJyM0MzRBNTInLFxuICAgICAgICAgICAgICAgICAgZmc6ICcjQzJGMjAwJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnc2t5Jzoge1xuICAgICAgICAgICAgICAgICAgYmc6ICcjMEQ4RkRCJyxcbiAgICAgICAgICAgICAgICAgIGZnOiAnI0ZGRkZGRidcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ3ZpbmUnOiB7XG4gICAgICAgICAgICAgICAgICBiZzogJyMzOURCQUMnLFxuICAgICAgICAgICAgICAgICAgZmc6ICcjMUUyOTJDJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnbGF2YSc6IHtcbiAgICAgICAgICAgICAgICAgIGJnOiAnI0Y4NTkxQScsXG4gICAgICAgICAgICAgICAgICBmZzogJyMxQzI4NDYnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgICB1bml0czogJ3B0JyxcbiAgICAgICAgICBzY2FsZTogMSAvIDE2XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBwcm92aWRlZCBzb3VyY2UgYXR0cmlidXRlIGFuZCBzZXRzIHVwIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJpbmcgd29ya2Zsb3dcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgSW5zdGFuY2Ugb3B0aW9ucyBmcm9tIEhvbGRlci5ydW5cbiAgICogQHBhcmFtIHJlbmRlclNldHRpbmdzIEluc3RhbmNlIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHNyYyBJbWFnZSBVUkxcbiAgICogQHBhcmFtIGVsIEltYWdlIERPTSBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBzcmMsIGVsKSB7XG4gICAgICB2YXIgaG9sZGVyRmxhZ3MgPSBwYXJzZVVSTChzcmMuc3Vic3RyKHNyYy5sYXN0SW5kZXhPZihvcHRpb25zLmRvbWFpbikpLCBvcHRpb25zKTtcbiAgICAgIGlmIChob2xkZXJGbGFncykge1xuICAgICAgICAgIHByZXBhcmVET01FbGVtZW50KHtcbiAgICAgICAgICAgICAgbW9kZTogbnVsbCxcbiAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICBmbGFnczogaG9sZGVyRmxhZ3MsXG4gICAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbmdpbmVTZXR0aW5nc1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIEhvbGRlciBVUkwgYW5kIGV4dHJhY3RzIGNvbmZpZ3VyYXRpb24gZnJvbSBxdWVyeSBzdHJpbmdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHVybCBVUkxcbiAgICogQHBhcmFtIGluc3RhbmNlT3B0aW9ucyBJbnN0YW5jZSBvcHRpb25zIGZyb20gSG9sZGVyLnJ1blxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VVUkwodXJsLCBpbnN0YW5jZU9wdGlvbnMpIHtcbiAgICAgIHZhciBob2xkZXIgPSB7XG4gICAgICAgICAgdGhlbWU6IGV4dGVuZChBcHAuc2V0dGluZ3MudGhlbWVzLmdyYXksIG51bGwpLFxuICAgICAgICAgIHN0eWxlc2hlZXRzOiBpbnN0YW5jZU9wdGlvbnMuc3R5bGVzaGVldHMsXG4gICAgICAgICAgaW5zdGFuY2VPcHRpb25zOiBpbnN0YW5jZU9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHZhciBmaXJzdFF1ZXN0aW9uTWFyayA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICB2YXIgcGFydHMgPSBbdXJsXTtcblxuICAgICAgaWYgKGZpcnN0UXVlc3Rpb25NYXJrICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzID0gW3VybC5zbGljZSgwLCBmaXJzdFF1ZXN0aW9uTWFyayksIHVybC5zbGljZShmaXJzdFF1ZXN0aW9uTWFyayArIDEpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhc2ljcyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cbiAgICAgIGhvbGRlci5ob2xkZXJVUkwgPSB1cmw7XG5cbiAgICAgIHZhciBkaW1lbnNpb25zID0gYmFzaWNzWzFdO1xuICAgICAgdmFyIGRpbWVuc2lvbkRhdGEgPSBkaW1lbnNpb25zLm1hdGNoKC8oW1xcZF0rcD8peChbXFxkXStwPykvKTtcblxuICAgICAgaWYgKCFkaW1lbnNpb25EYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGhvbGRlci5mbHVpZCA9IGRpbWVuc2lvbnMuaW5kZXhPZigncCcpICE9PSAtMTtcblxuICAgICAgaG9sZGVyLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgd2lkdGg6IGRpbWVuc2lvbkRhdGFbMV0ucmVwbGFjZSgncCcsICclJyksXG4gICAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb25EYXRhWzJdLnJlcGxhY2UoJ3AnLCAnJScpXG4gICAgICB9O1xuXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBxdWVyeXN0cmluZy5wYXJzZShwYXJ0c1sxXSk7XG5cbiAgICAgICAgICAvLyBEaW1lbnNpb25zXG5cbiAgICAgICAgICBpZiAodXRpbHMudHJ1dGh5KG9wdGlvbnMucmF0aW8pKSB7XG4gICAgICAgICAgICAgIGhvbGRlci5mbHVpZCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciByYXRpb1dpZHRoID0gcGFyc2VGbG9hdChob2xkZXIuZGltZW5zaW9ucy53aWR0aC5yZXBsYWNlKCclJywgJycpKTtcbiAgICAgICAgICAgICAgdmFyIHJhdGlvSGVpZ2h0ID0gcGFyc2VGbG9hdChob2xkZXIuZGltZW5zaW9ucy5oZWlnaHQucmVwbGFjZSgnJScsICcnKSk7XG5cbiAgICAgICAgICAgICAgcmF0aW9IZWlnaHQgPSBNYXRoLmZsb29yKDEwMCAqIChyYXRpb0hlaWdodCAvIHJhdGlvV2lkdGgpKTtcbiAgICAgICAgICAgICAgcmF0aW9XaWR0aCA9IDEwMDtcblxuICAgICAgICAgICAgICBob2xkZXIuZGltZW5zaW9ucy53aWR0aCA9IHJhdGlvV2lkdGggKyAnJSc7XG4gICAgICAgICAgICAgIGhvbGRlci5kaW1lbnNpb25zLmhlaWdodCA9IHJhdGlvSGVpZ2h0ICsgJyUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhvbGRlci5hdXRvID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMuYXV0byk7XG5cbiAgICAgICAgICAvLyBDb2xvcnNcblxuICAgICAgICAgIGlmIChvcHRpb25zLmJnKSB7XG4gICAgICAgICAgICAgIGhvbGRlci50aGVtZS5iZyA9IHV0aWxzLnBhcnNlQ29sb3Iob3B0aW9ucy5iZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZmcpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLnRoZW1lLmZnID0gdXRpbHMucGFyc2VDb2xvcihvcHRpb25zLmZnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL3RvZG86IGFkZCBhdXRvbWF0aWMgZm9yZWdyb3VuZCB0byB0aGVtZXMgd2l0aG91dCBmb3JlZ3JvdW5kXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYmcgJiYgIW9wdGlvbnMuZmcpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLmF1dG9GZyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudGhlbWUgJiYgaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucy50aGVtZSkpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLnRoZW1lID0gZXh0ZW5kKGhvbGRlci5pbnN0YW5jZU9wdGlvbnMudGhlbWVzW29wdGlvbnMudGhlbWVdLCBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUZXh0XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICAgICAgICAgIGhvbGRlci50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnRleHRtb2RlKSB7XG4gICAgICAgICAgICAgIGhvbGRlci50ZXh0bW9kZSA9IG9wdGlvbnMudGV4dG1vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAmJiBwYXJzZUZsb2F0KG9wdGlvbnMuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgaG9sZGVyLnNpemUgPSBwYXJzZUZsb2F0KG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZm9udCkge1xuICAgICAgICAgICAgICBob2xkZXIuZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgICAgICBob2xkZXIuYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmxpbmVXcmFwKSB7XG4gICAgICAgICAgICAgIGhvbGRlci5saW5lV3JhcCA9IG9wdGlvbnMubGluZVdyYXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaG9sZGVyLm5vd3JhcCA9IHV0aWxzLnRydXRoeShvcHRpb25zLm5vd3JhcCk7XG5cbiAgICAgICAgICAvLyBNaXNjZWxsYW5lb3VzXG5cbiAgICAgICAgICBob2xkZXIub3V0bGluZSA9IHV0aWxzLnRydXRoeShvcHRpb25zLm91dGxpbmUpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLnRydXRoeShvcHRpb25zLnJhbmRvbSkpIHtcbiAgICAgICAgICAgICAgQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzID0gQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzIHx8IE9iamVjdC5rZXlzKGhvbGRlci5pbnN0YW5jZU9wdGlvbnMudGhlbWVzKTtcbiAgICAgICAgICAgICAgdmFyIF90aGVtZSA9IEFwcC52YXJzLmNhY2hlLnRoZW1lS2V5c1swIHwgTWF0aC5yYW5kb20oKSAqIEFwcC52YXJzLmNhY2hlLnRoZW1lS2V5cy5sZW5ndGhdO1xuICAgICAgICAgICAgICBob2xkZXIudGhlbWUgPSBleHRlbmQoaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXNbX3RoZW1lXSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG9sZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIHRoZSBET00gdG8gZml0IHBsYWNlaG9sZGVycyBhbmQgc2V0cyB1cCByZXNpemFibGUgaW1hZ2UgY2FsbGJhY2tzIChmb3IgZmx1aWQgYW5kIGF1dG9tYXRpY2FsbHkgc2l6ZWQgcGxhY2Vob2xkZXJzKVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gc2V0dGluZ3MgRE9NIHByZXAgc2V0dGluZ3NcbiAgICovXG4gIGZ1bmN0aW9uIHByZXBhcmVET01FbGVtZW50KHByZXBTZXR0aW5ncykge1xuICAgICAgdmFyIG1vZGUgPSBwcmVwU2V0dGluZ3MubW9kZTtcbiAgICAgIHZhciBlbCA9IHByZXBTZXR0aW5ncy5lbDtcbiAgICAgIHZhciBmbGFncyA9IHByZXBTZXR0aW5ncy5mbGFncztcbiAgICAgIHZhciBfZW5naW5lU2V0dGluZ3MgPSBwcmVwU2V0dGluZ3MuZW5naW5lU2V0dGluZ3M7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IGZsYWdzLmRpbWVuc2lvbnMsXG4gICAgICAgICAgdGhlbWUgPSBmbGFncy50aGVtZTtcbiAgICAgIHZhciBkaW1lbnNpb25zQ2FwdGlvbiA9IGRpbWVuc2lvbnMud2lkdGggKyAneCcgKyBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIG1vZGUgPSBtb2RlID09IG51bGwgPyAoZmxhZ3MuZmx1aWQgPyAnZmx1aWQnIDogJ2ltYWdlJykgOiBtb2RlO1xuICAgICAgdmFyIGhvbGRlclRlbXBsYXRlUmUgPSAvaG9sZGVyXyhbYS16XSspL2c7XG4gICAgICB2YXIgZGltZW5zaW9uc0luVGV4dCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZmxhZ3MudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhlbWUudGV4dCA9IGZsYWdzLnRleHQ7XG5cbiAgICAgICAgICAvLzxvYmplY3Q+IFNWRyBlbWJlZGRpbmcgZG9lc24ndCBwYXJzZSBVbmljb2RlIHByb3Blcmx5XG4gICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0aGVtZS50ZXh0LnNwbGl0KCdcXFxcbicpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRleHRMaW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgdGV4dExpbmVzW2tdID0gdXRpbHMuZW5jb2RlSHRtbEVudGl0eSh0ZXh0TGluZXNba10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoZW1lLnRleHQgPSB0ZXh0TGluZXMuam9pbignXFxcXG4nKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGVtZS50ZXh0KSB7XG4gICAgICAgICAgdmFyIGhvbGRlclRlbXBsYXRlTWF0Y2hlcyA9IHRoZW1lLnRleHQubWF0Y2goaG9sZGVyVGVtcGxhdGVSZSk7XG5cbiAgICAgICAgICBpZiAoaG9sZGVyVGVtcGxhdGVNYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vdG9kbzogb3B0aW1pemUgdGVtcGxhdGUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgaG9sZGVyVGVtcGxhdGVNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT09ICdob2xkZXJfZGltZW5zaW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGVtZS50ZXh0ID0gdGhlbWUudGV4dC5yZXBsYWNlKG1hdGNoLCBkaW1lbnNpb25zQ2FwdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGhvbGRlclVSTCA9IGZsYWdzLmhvbGRlclVSTDtcbiAgICAgIHZhciBlbmdpbmVTZXR0aW5ncyA9IGV4dGVuZChfZW5naW5lU2V0dGluZ3MsIG51bGwpO1xuXG4gICAgICBpZiAoZmxhZ3MuZm9udCkge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgSWYgZXh0ZXJuYWwgZm9udHMgYXJlIHVzZWQgaW4gYSA8aW1nPiBwbGFjZWhvbGRlciByZW5kZXJlZCB3aXRoIFNWRywgSG9sZGVyIGZhbGxzIGJhY2sgdG8gY2FudmFzLlxuXG4gICAgICAgICAgVGhpcyBpcyBkb25lIGJlY2F1c2UgRmlyZWZveCBhbmQgQ2hyb21lIGRpc2FsbG93IGVtYmVkZGVkIFNWR3MgZnJvbSByZWZlcmVuY2luZyBleHRlcm5hbCBhc3NldHMuXG4gICAgICAgICAgVGhlIHdvcmthcm91bmQgaXMgZWl0aGVyIHRvIGNoYW5nZSB0aGUgcGxhY2Vob2xkZXIgdGFnIGZyb20gPGltZz4gdG8gPG9iamVjdD4gb3IgdG8gdXNlIHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICAgICAgKi9cbiAgICAgICAgICB0aGVtZS5mb250ID0gZmxhZ3MuZm9udDtcbiAgICAgICAgICBpZiAoIWVuZ2luZVNldHRpbmdzLm5vRm9udEZhbGxiYWNrICYmIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnICYmIEFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcyAmJiBlbmdpbmVTZXR0aW5ncy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgZW5naW5lU2V0dGluZ3MgPSBleHRlbmQoZW5naW5lU2V0dGluZ3MsIHtcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiAnY2FudmFzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vQ2hyb21lIGFuZCBPcGVyYSByZXF1aXJlIGEgcXVpY2sgMTBtcyByZS1yZW5kZXIgaWYgd2ViIGZvbnRzIGFyZSB1c2VkIHdpdGggY2FudmFzXG4gICAgICBpZiAoZmxhZ3MuZm9udCAmJiBlbmdpbmVTZXR0aW5ncy5yZW5kZXJlciA9PSAnY2FudmFzJykge1xuICAgICAgICAgIGVuZ2luZVNldHRpbmdzLnJlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT0gJ2JhY2tncm91bmQnKSB7XG4gICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrZ3JvdW5kLXNyYycpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgRE9NLnNldEF0dHIoZWwsIHtcbiAgICAgICAgICAgICAgICAgICdkYXRhLWJhY2tncm91bmQtc3JjJzogaG9sZGVyVVJMXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRvbVByb3BzID0ge307XG4gICAgICAgICAgZG9tUHJvcHNbQXBwLnZhcnMuZGF0YUF0dHJdID0gaG9sZGVyVVJMO1xuICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCBkb21Qcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGZsYWdzLnRoZW1lID0gdGhlbWU7XG5cbiAgICAgIC8vdG9kbyBjb25zaWRlciB1c2luZyBhbGwgcmVuZGVyU2V0dGluZ3MgaW4gaG9sZGVyRGF0YVxuICAgICAgZWwuaG9sZGVyRGF0YSA9IHtcbiAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgZW5naW5lU2V0dGluZ3M6IGVuZ2luZVNldHRpbmdzXG4gICAgICB9O1xuXG4gICAgICBpZiAobW9kZSA9PSAnaW1hZ2UnIHx8IG1vZGUgPT0gJ2ZsdWlkJykge1xuICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG4gICAgICAgICAgICAgICdhbHQnOiB0aGVtZS50ZXh0ID8gKGRpbWVuc2lvbnNJblRleHQgPyB0aGVtZS50ZXh0IDogdGhlbWUudGV4dCArICcgWycgKyBkaW1lbnNpb25zQ2FwdGlvbiArICddJykgOiBkaW1lbnNpb25zQ2FwdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyU2V0dGluZ3MgPSB7XG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgaG9sZGVyU2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgICBmbGFnczogZmxhZ3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbmdpbmVTZXR0aW5nc1xuICAgICAgfTtcblxuICAgICAgaWYgKG1vZGUgPT0gJ2ltYWdlJykge1xuICAgICAgICAgIGlmICghZmxhZ3MuYXV0bykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCArICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09ICdodG1sJykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGVtZS5iZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW5kZXIocmVuZGVyU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgIGlmIChmbGFncy50ZXh0bW9kZSA9PSAnZXhhY3QnKSB7XG4gICAgICAgICAgICAgICAgICBlbC5ob2xkZXJEYXRhLnJlc2l6ZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBBcHAudmFycy5yZXNpemFibGVJbWFnZXMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVSZXNpemFibGVFbGVtZW50cyhlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ2JhY2tncm91bmQnICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyICE9ICdodG1sJykge1xuICAgICAgICAgIHJlbmRlcihyZW5kZXJTZXR0aW5ncyk7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ2ZsdWlkJykge1xuICAgICAgICAgIGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodC5zbGljZSgtMSkgPT0gJyUnKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MuYXV0byA9PSBudWxsIHx8ICFmbGFncy5hdXRvKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGguc2xpY2UoLTEpID09ICclJykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChmbGFncy5hdXRvID09IG51bGwgfHwgIWZsYWdzLmF1dG8pIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT0gJ2lubGluZScgfHwgZWwuc3R5bGUuZGlzcGxheSA9PT0gJycgfHwgZWwuc3R5bGUuZGlzcGxheSA9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0SW5pdGlhbERpbWVuc2lvbnMoZWwpO1xuXG4gICAgICAgICAgaWYgKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09ICdodG1sJykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGVtZS5iZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBBcHAudmFycy5yZXNpemFibGVJbWFnZXMucHVzaChlbCk7XG4gICAgICAgICAgICAgIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBmdW5jdGlvbiB0aGF0IHRha2VzIG91dHB1dCBmcm9tIHJlbmRlcmVycyBhbmQgc2V0cyBpdCBhcyB0aGUgc291cmNlIG9yIGJhY2tncm91bmQtaW1hZ2Ugb2YgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSByZW5kZXJTZXR0aW5ncyBSZW5kZXJlciBzZXR0aW5nc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyKHJlbmRlclNldHRpbmdzKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBudWxsO1xuICAgICAgdmFyIG1vZGUgPSByZW5kZXJTZXR0aW5ncy5tb2RlO1xuICAgICAgdmFyIGVsID0gcmVuZGVyU2V0dGluZ3MuZWw7XG4gICAgICB2YXIgaG9sZGVyU2V0dGluZ3MgPSByZW5kZXJTZXR0aW5ncy5ob2xkZXJTZXR0aW5ncztcbiAgICAgIHZhciBlbmdpbmVTZXR0aW5ncyA9IHJlbmRlclNldHRpbmdzLmVuZ2luZVNldHRpbmdzO1xuXG4gICAgICBzd2l0Y2ggKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgICAgaWYgKCFBcHAuc2V0dXAuc3VwcG9ydHNTVkcpIHJldHVybjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgICAgICAgaWYgKCFBcHAuc2V0dXAuc3VwcG9ydHNDYW52YXMpIHJldHVybjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL3RvZG86IG1vdmUgZ2VuZXJhdGlvbiBvZiBzY2VuZSB1cCB0byBmbGFnIGdlbmVyYXRpb24gdG8gcmVkdWNlIGV4dHJhIG9iamVjdCBjcmVhdGlvblxuICAgICAgdmFyIHNjZW5lID0ge1xuICAgICAgICAgIHdpZHRoOiBob2xkZXJTZXR0aW5ncy5kaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaG9sZGVyU2V0dGluZ3MuZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgdGhlbWU6IGhvbGRlclNldHRpbmdzLnRoZW1lLFxuICAgICAgICAgIGZsYWdzOiBob2xkZXJTZXR0aW5ncy5mbGFnc1xuICAgICAgfTtcblxuICAgICAgdmFyIHNjZW5lR3JhcGggPSBidWlsZFNjZW5lR3JhcGgoc2NlbmUpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRSZW5kZXJlZEltYWdlKCkge1xuICAgICAgICAgIHZhciBpbWFnZSA9IG51bGw7XG4gICAgICAgICAgc3dpdGNoIChlbmdpbmVTZXR0aW5ncy5yZW5kZXJlcikge1xuICAgICAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBzZ0NhbnZhc1JlbmRlcmVyKHNjZW5lR3JhcGgsIHJlbmRlclNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBzdmdSZW5kZXJlcihzY2VuZUdyYXBoLCByZW5kZXJTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93ICdIb2xkZXI6IGludmFsaWQgcmVuZGVyZXI6ICcgKyBlbmdpbmVTZXR0aW5ncy5yZW5kZXJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgICB9XG5cbiAgICAgIGltYWdlID0gZ2V0UmVuZGVyZWRJbWFnZSgpO1xuXG4gICAgICBpZiAoaW1hZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93ICdIb2xkZXI6IGNvdWxkblxcJ3QgcmVuZGVyIHBsYWNlaG9sZGVyJztcbiAgICAgIH1cblxuICAgICAgLy90b2RvOiBhZGQgPG9iamVjdD4gY2FudmFzIHJlbmRlcmluZ1xuICAgICAgaWYgKG1vZGUgPT0gJ2JhY2tncm91bmQnKSB7XG4gICAgICAgICAgZWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgaW1hZ2UgKyAnKSc7XG5cbiAgICAgICAgICBpZiAoIWVuZ2luZVNldHRpbmdzLm5vQmFja2dyb3VuZFNpemUpIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBzY2VuZS53aWR0aCArICdweCAnICsgc2NlbmUuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuICAgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuICAgICAgICAgICAgICAgICAgJ3NyYyc6IGltYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgRE9NLnNldEF0dHIoZWwsIHtcbiAgICAgICAgICAgICAgICAgICdkYXRhJzogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAndHlwZSc6ICdpbWFnZS9zdmcreG1sJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZ2luZVNldHRpbmdzLnJlUmVuZGVyKSB7XG4gICAgICAgICAgICAgIGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IGdldFJlbmRlcmVkSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbWFnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0hvbGRlcjogY291bGRuXFwndCByZW5kZXIgcGxhY2Vob2xkZXInO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy90b2RvOiByZWZhY3RvciB0aGlzIGNvZGUgaW50byBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnc3JjJzogaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpbWFnZS9zdmcreG1sJ1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vdG9kbzogYWNjb3VudCBmb3IgcmUtcmVuZGVyaW5nXG4gICAgICBET00uc2V0QXR0cihlbCwge1xuICAgICAgICAgICdkYXRhLWhvbGRlci1yZW5kZXJlZCc6IHRydWVcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcmUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIEhvbGRlciBzY2VuZSBkZXNjcmlwdGlvbiBhbmQgYnVpbGRzIGEgc2NlbmUgZ3JhcGhcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHNjZW5lIEhvbGRlciBzY2VuZSBvYmplY3RcbiAgICovXG4gIC8vdG9kbzogbWFrZSB0aGlzIGZ1bmN0aW9uIHJldXNhYmxlXG4gIC8vdG9kbzogbWVyZ2UgYXBwIGRlZmF1bHRzIGFuZCBzZXR1cCBwcm9wZXJ0aWVzIGludG8gdGhlIHNjZW5lIGFyZ3VtZW50XG4gIGZ1bmN0aW9uIGJ1aWxkU2NlbmVHcmFwaChzY2VuZSkge1xuICAgICAgdmFyIGZvbnRTaXplID0gQXBwLmRlZmF1bHRzLnNpemU7XG4gICAgICBpZiAocGFyc2VGbG9hdChzY2VuZS50aGVtZS5zaXplKSkge1xuICAgICAgICAgIGZvbnRTaXplID0gc2NlbmUudGhlbWUuc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VGbG9hdChzY2VuZS5mbGFncy5zaXplKSkge1xuICAgICAgICAgIGZvbnRTaXplID0gc2NlbmUuZmxhZ3Muc2l6ZTtcbiAgICAgIH1cblxuICAgICAgc2NlbmUuZm9udCA9IHtcbiAgICAgICAgICBmYW1pbHk6IHNjZW5lLnRoZW1lLmZvbnQgPyBzY2VuZS50aGVtZS5mb250IDogJ0FyaWFsLCBIZWx2ZXRpY2EsIE9wZW4gU2Fucywgc2Fucy1zZXJpZicsXG4gICAgICAgICAgc2l6ZTogdGV4dFNpemUoc2NlbmUud2lkdGgsIHNjZW5lLmhlaWdodCwgZm9udFNpemUsIEFwcC5kZWZhdWx0cy5zY2FsZSksXG4gICAgICAgICAgdW5pdHM6IHNjZW5lLnRoZW1lLnVuaXRzID8gc2NlbmUudGhlbWUudW5pdHMgOiBBcHAuZGVmYXVsdHMudW5pdHMsXG4gICAgICAgICAgd2VpZ2h0OiBzY2VuZS50aGVtZS5mb250d2VpZ2h0ID8gc2NlbmUudGhlbWUuZm9udHdlaWdodCA6ICdib2xkJ1xuICAgICAgfTtcblxuICAgICAgc2NlbmUudGV4dCA9IHNjZW5lLnRoZW1lLnRleHQgfHwgTWF0aC5mbG9vcihzY2VuZS53aWR0aCkgKyAneCcgKyBNYXRoLmZsb29yKHNjZW5lLmhlaWdodCk7XG5cbiAgICAgIHNjZW5lLm5vV3JhcCA9IHNjZW5lLnRoZW1lLm5vd3JhcCB8fCBzY2VuZS5mbGFncy5ub3dyYXA7XG5cbiAgICAgIHNjZW5lLmFsaWduID0gc2NlbmUudGhlbWUuYWxpZ24gfHwgc2NlbmUuZmxhZ3MuYWxpZ24gfHwgJ2NlbnRlcic7XG5cbiAgICAgIHN3aXRjaCAoc2NlbmUuZmxhZ3MudGV4dG1vZGUpIHtcbiAgICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgICAgc2NlbmUudGV4dCA9IHNjZW5lLmZsYWdzLmRpbWVuc2lvbnMud2lkdGggKyAneCcgKyBzY2VuZS5mbGFncy5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZXhhY3QnOlxuICAgICAgICAgICAgICBpZiAoIXNjZW5lLmZsYWdzLmV4YWN0RGltZW5zaW9ucykgYnJlYWs7XG4gICAgICAgICAgICAgIHNjZW5lLnRleHQgPSBNYXRoLmZsb29yKHNjZW5lLmZsYWdzLmV4YWN0RGltZW5zaW9ucy53aWR0aCkgKyAneCcgKyBNYXRoLmZsb29yKHNjZW5lLmZsYWdzLmV4YWN0RGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVXcmFwID0gc2NlbmUuZmxhZ3MubGluZVdyYXAgfHwgQXBwLnNldHVwLmxpbmVXcmFwUmF0aW87XG4gICAgICB2YXIgc2NlbmVNYXJnaW4gPSBzY2VuZS53aWR0aCAqIGxpbmVXcmFwO1xuICAgICAgdmFyIG1heExpbmVXaWR0aCA9IHNjZW5lTWFyZ2luO1xuXG4gICAgICB2YXIgc2NlbmVHcmFwaCA9IG5ldyBTY2VuZUdyYXBoKHtcbiAgICAgICAgICB3aWR0aDogc2NlbmUud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzY2VuZS5oZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgU2hhcGUgPSBzY2VuZUdyYXBoLlNoYXBlO1xuXG4gICAgICB2YXIgaG9sZGVyQmcgPSBuZXcgU2hhcGUuUmVjdCgnaG9sZGVyQmcnLCB7XG4gICAgICAgICAgZmlsbDogc2NlbmUudGhlbWUuYmdcbiAgICAgIH0pO1xuXG4gICAgICBob2xkZXJCZy5yZXNpemUoc2NlbmUud2lkdGgsIHNjZW5lLmhlaWdodCk7XG4gICAgICBzY2VuZUdyYXBoLnJvb3QuYWRkKGhvbGRlckJnKTtcblxuICAgICAgaWYgKHNjZW5lLmZsYWdzLm91dGxpbmUpIHtcbiAgICAgICAgICB2YXIgb3V0bGluZUNvbG9yID0gbmV3IENvbG9yKGhvbGRlckJnLnByb3BlcnRpZXMuZmlsbCk7XG4gICAgICAgICAgb3V0bGluZUNvbG9yID0gb3V0bGluZUNvbG9yLmxpZ2h0ZW4ob3V0bGluZUNvbG9yLmxpZ2h0ZXJUaGFuKCc3ZjdmN2YnKSA/IC0wLjEgOiAwLjEpO1xuICAgICAgICAgIGhvbGRlckJnLnByb3BlcnRpZXMub3V0bGluZSA9IHtcbiAgICAgICAgICAgICAgZmlsbDogb3V0bGluZUNvbG9yLnRvSGV4KHRydWUpLFxuICAgICAgICAgICAgICB3aWR0aDogMlxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBob2xkZXJUZXh0Q29sb3IgPSBzY2VuZS50aGVtZS5mZztcblxuICAgICAgaWYgKHNjZW5lLmZsYWdzLmF1dG9GZykge1xuICAgICAgICAgIHZhciBob2xkZXJCZ0NvbG9yID0gbmV3IENvbG9yKGhvbGRlckJnLnByb3BlcnRpZXMuZmlsbCk7XG4gICAgICAgICAgdmFyIGxpZ2h0Q29sb3IgPSBuZXcgQ29sb3IoJ2ZmZicpO1xuICAgICAgICAgIHZhciBkYXJrQ29sb3IgPSBuZXcgQ29sb3IoJzAwMCcsIHtcbiAgICAgICAgICAgICAgJ2FscGhhJzogMC4yODU3MTRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGhvbGRlclRleHRDb2xvciA9IGhvbGRlckJnQ29sb3IuYmxlbmRBbHBoYShob2xkZXJCZ0NvbG9yLmxpZ2h0ZXJUaGFuKCc3ZjdmN2YnKSA/IGRhcmtDb2xvciA6IGxpZ2h0Q29sb3IpLnRvSGV4KHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9sZGVyVGV4dEdyb3VwID0gbmV3IFNoYXBlLkdyb3VwKCdob2xkZXJUZXh0R3JvdXAnLCB7XG4gICAgICAgICAgdGV4dDogc2NlbmUudGV4dCxcbiAgICAgICAgICBhbGlnbjogc2NlbmUuYWxpZ24sXG4gICAgICAgICAgZm9udDogc2NlbmUuZm9udCxcbiAgICAgICAgICBmaWxsOiBob2xkZXJUZXh0Q29sb3JcbiAgICAgIH0pO1xuXG4gICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKG51bGwsIG51bGwsIDEpO1xuICAgICAgc2NlbmVHcmFwaC5yb290LmFkZChob2xkZXJUZXh0R3JvdXApO1xuXG4gICAgICB2YXIgdHBkYXRhID0gaG9sZGVyVGV4dEdyb3VwLnRleHRQb3NpdGlvbkRhdGEgPSBzdGFnaW5nUmVuZGVyZXIoc2NlbmVHcmFwaCk7XG4gICAgICBpZiAoIXRwZGF0YSkge1xuICAgICAgICAgIHRocm93ICdIb2xkZXI6IHN0YWdpbmcgZmFsbGJhY2sgbm90IHN1cHBvcnRlZCB5ZXQuJztcbiAgICAgIH1cbiAgICAgIGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzLmxlYWRpbmcgPSB0cGRhdGEuYm91bmRpbmdCb3guaGVpZ2h0O1xuXG4gICAgICB2YXIgdGV4dE5vZGUgPSBudWxsO1xuICAgICAgdmFyIGxpbmUgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBmaW5hbGl6ZUxpbmUocGFyZW50LCBsaW5lLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgbGluZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIGxpbmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIHBhcmVudC53aWR0aCA9IE1hdGgubWF4KHBhcmVudC53aWR0aCwgbGluZS53aWR0aCk7XG4gICAgICAgICAgcGFyZW50LmhlaWdodCArPSBsaW5lLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRwZGF0YS5saW5lQ291bnQgPiAxKSB7XG4gICAgICAgICAgdmFyIG9mZnNldFggPSAwO1xuICAgICAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgICAgICB2YXIgbGluZUluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgbGluZUtleTtcbiAgICAgICAgICBsaW5lID0gbmV3IFNoYXBlLkdyb3VwKCdsaW5lJyArIGxpbmVJbmRleCk7XG5cbiAgICAgICAgICAvL0RvdWJsZSBtYXJnaW4gc28gdGhhdCBsZWZ0L3JpZ2h0LWFsaWduZWQgbmV4dCBpcyBub3QgZmx1c2ggd2l0aCBlZGdlIG9mIGltYWdlXG4gICAgICAgICAgaWYgKHNjZW5lLmFsaWduID09PSAnbGVmdCcgfHwgc2NlbmUuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gc2NlbmUud2lkdGggKiAoMSAtICgxIC0gbGluZVdyYXApICogMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cGRhdGEud29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHdvcmQgPSB0cGRhdGEud29yZHNbaV07XG4gICAgICAgICAgICAgIHRleHROb2RlID0gbmV3IFNoYXBlLlRleHQod29yZC50ZXh0KTtcbiAgICAgICAgICAgICAgdmFyIG5ld2xpbmUgPSB3b3JkLnRleHQgPT0gJ1xcXFxuJztcbiAgICAgICAgICAgICAgaWYgKCFzY2VuZS5ub1dyYXAgJiYgKG9mZnNldFggKyB3b3JkLndpZHRoID49IG1heExpbmVXaWR0aCB8fCBuZXdsaW5lID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgZmluYWxpemVMaW5lKGhvbGRlclRleHRHcm91cCwgbGluZSwgb2Zmc2V0WCwgaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXMubGVhZGluZyk7XG4gICAgICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAuYWRkKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICAgICAgICBvZmZzZXRZICs9IGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzLmxlYWRpbmc7XG4gICAgICAgICAgICAgICAgICBsaW5lSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXcgU2hhcGUuR3JvdXAoJ2xpbmUnICsgbGluZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGxpbmUueSA9IG9mZnNldFk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5ld2xpbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHROb2RlLm1vdmVUbyhvZmZzZXRYLCAwKTtcbiAgICAgICAgICAgICAgb2Zmc2V0WCArPSB0cGRhdGEuc3BhY2VXaWR0aCArIHdvcmQud2lkdGg7XG4gICAgICAgICAgICAgIGxpbmUuYWRkKHRleHROb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaW5hbGl6ZUxpbmUoaG9sZGVyVGV4dEdyb3VwLCBsaW5lLCBvZmZzZXRYLCBob2xkZXJUZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nKTtcbiAgICAgICAgICBob2xkZXJUZXh0R3JvdXAuYWRkKGxpbmUpO1xuXG4gICAgICAgICAgaWYgKHNjZW5lLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbyhzY2VuZS53aWR0aCAtIHNjZW5lTWFyZ2luLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjZW5lLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIGZvciAobGluZUtleSBpbiBob2xkZXJUZXh0R3JvdXAuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBob2xkZXJUZXh0R3JvdXAuY2hpbGRyZW5bbGluZUtleV07XG4gICAgICAgICAgICAgICAgICBsaW5lLm1vdmVUbyhzY2VuZS53aWR0aCAtIGxpbmUud2lkdGgsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbygwIC0gKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4pLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGxpbmVLZXkgaW4gaG9sZGVyVGV4dEdyb3VwLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICBsaW5lID0gaG9sZGVyVGV4dEdyb3VwLmNoaWxkcmVuW2xpbmVLZXldO1xuICAgICAgICAgICAgICAgICAgbGluZS5tb3ZlVG8oKGhvbGRlclRleHRHcm91cC53aWR0aCAtIGxpbmUud2lkdGgpIC8gMiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKChzY2VuZS53aWR0aCAtIGhvbGRlclRleHRHcm91cC53aWR0aCkgLyAyLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKG51bGwsIChzY2VuZS5oZWlnaHQgLSBob2xkZXJUZXh0R3JvdXAuaGVpZ2h0KSAvIDIsIG51bGwpO1xuXG4gICAgICAgICAgLy9JZiB0aGUgdGV4dCBleGNlZWRzIHZlcnRpY2FsIHNwYWNlLCBtb3ZlIGl0IGRvd24gc28gdGhlIGZpcnN0IGxpbmUgaXMgdmlzaWJsZVxuICAgICAgICAgIGlmICgoc2NlbmUuaGVpZ2h0IC0gaG9sZGVyVGV4dEdyb3VwLmhlaWdodCkgLyAyIDwgMCkge1xuICAgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKG51bGwsIDAsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBuZXcgU2hhcGUuVGV4dChzY2VuZS50ZXh0KTtcbiAgICAgICAgICBsaW5lID0gbmV3IFNoYXBlLkdyb3VwKCdsaW5lMCcpO1xuICAgICAgICAgIGxpbmUuYWRkKHRleHROb2RlKTtcbiAgICAgICAgICBob2xkZXJUZXh0R3JvdXAuYWRkKGxpbmUpO1xuXG4gICAgICAgICAgaWYgKHNjZW5lLmFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbyhzY2VuZS53aWR0aCAtIHNjZW5lTWFyZ2luLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjZW5lLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oMCAtIChzY2VuZS53aWR0aCAtIHNjZW5lTWFyZ2luKSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbygoc2NlbmUud2lkdGggLSB0cGRhdGEuYm91bmRpbmdCb3gud2lkdGgpIC8gMiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbyhudWxsLCAoc2NlbmUuaGVpZ2h0IC0gdHBkYXRhLmJvdW5kaW5nQm94LmhlaWdodCkgLyAyLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy90b2RvOiByZW5kZXJsaXN0XG4gICAgICByZXR1cm4gc2NlbmVHcmFwaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGFwdGl2ZSB0ZXh0IHNpemluZyBmdW5jdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gd2lkdGggUGFyZW50IHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHQgUGFyZW50IGhlaWdodFxuICAgKiBAcGFyYW0gZm9udFNpemUgUmVxdWVzdGVkIHRleHQgc2l6ZVxuICAgKiBAcGFyYW0gc2NhbGUgUHJvcG9ydGlvbmFsIHNjYWxlIG9mIHRleHRcbiAgICovXG4gIGZ1bmN0aW9uIHRleHRTaXplKHdpZHRoLCBoZWlnaHQsIGZvbnRTaXplLCBzY2FsZSkge1xuICAgICAgdmFyIHN0YWdlV2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuICAgICAgdmFyIHN0YWdlSGVpZ2h0ID0gcGFyc2VJbnQoaGVpZ2h0LCAxMCk7XG5cbiAgICAgIHZhciBiaWdTaWRlID0gTWF0aC5tYXgoc3RhZ2VXaWR0aCwgc3RhZ2VIZWlnaHQpO1xuICAgICAgdmFyIHNtYWxsU2lkZSA9IE1hdGgubWluKHN0YWdlV2lkdGgsIHN0YWdlSGVpZ2h0KTtcblxuICAgICAgdmFyIG5ld0hlaWdodCA9IDAuOCAqIE1hdGgubWluKHNtYWxsU2lkZSwgYmlnU2lkZSAqIHNjYWxlKTtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWF4KGZvbnRTaXplLCBuZXdIZWlnaHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIHJlc2l6YWJsZSAoZmx1aWQgb3IgYXV0bykgcGxhY2Vob2xkZXJzIGFuZCByZW5kZXJzIHRoZW1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGVsZW1lbnQgT3B0aW9uYWwgZWxlbWVudCBzZWxlY3Rvciwgc3BlY2lmaWVkIG9ubHkgaWYgYSBzcGVjaWZpYyBlbGVtZW50IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVSZXNpemFibGVFbGVtZW50cyhlbGVtZW50KSB7XG4gICAgICB2YXIgaW1hZ2VzO1xuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCBlbGVtZW50Lm5vZGVUeXBlID09IG51bGwpIHtcbiAgICAgICAgICBpbWFnZXMgPSBBcHAudmFycy5yZXNpemFibGVJbWFnZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlcyA9IFtlbGVtZW50XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW1hZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBlbCA9IGltYWdlc1tpXTtcbiAgICAgICAgICBpZiAoZWwuaG9sZGVyRGF0YSkge1xuICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBlbC5ob2xkZXJEYXRhLmZsYWdzO1xuICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGRpbWVuc2lvbkNoZWNrKGVsKTtcbiAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZWwuaG9sZGVyRGF0YS5yZXNpemVVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzLmZsdWlkICYmIGZsYWdzLmF1dG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZmx1aWRDb25maWcgPSBlbC5ob2xkZXJEYXRhLmZsdWlkQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmx1aWRDb25maWcubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCA9IGRpbWVuc2lvbnMud2lkdGggLyBmbHVpZENvbmZpZy5yYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogZmx1aWRDb25maWcucmF0aW87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgIGhvbGRlclNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lOiBmbGFncy50aGVtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgICAgZW5naW5lU2V0dGluZ3M6IGVsLmhvbGRlckRhdGEuZW5naW5lU2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncy50ZXh0bW9kZSA9PSAnZXhhY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuZXhhY3REaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ob2xkZXJTZXR0aW5ncy5kaW1lbnNpb25zID0gZmxhZ3MuZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVuZGVyKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNldEludmlzaWJsZShlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCBhc3BlY3QgcmF0aW8gbWV0YWRhdGEgZm9yIGZsdWlkIHBsYWNlaG9sZGVycywgaW4gb3JkZXIgdG8gcHJlc2VydmUgcHJvcG9ydGlvbnMgd2hlbiByZXNpemluZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZWwgSW1hZ2UgRE9NIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHNldEluaXRpYWxEaW1lbnNpb25zKGVsKSB7XG4gICAgICBpZiAoZWwuaG9sZGVyRGF0YSkge1xuICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gZGltZW5zaW9uQ2hlY2soZWwpO1xuICAgICAgICAgIGlmIChkaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgIHZhciBmbGFncyA9IGVsLmhvbGRlckRhdGEuZmxhZ3M7XG5cbiAgICAgICAgICAgICAgdmFyIGZsdWlkQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgZmx1aWRIZWlnaHQ6IGZsYWdzLmRpbWVuc2lvbnMuaGVpZ2h0LnNsaWNlKC0xKSA9PSAnJScsXG4gICAgICAgICAgICAgICAgICBmbHVpZFdpZHRoOiBmbGFncy5kaW1lbnNpb25zLndpZHRoLnNsaWNlKC0xKSA9PSAnJScsXG4gICAgICAgICAgICAgICAgICBtb2RlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgaW5pdGlhbERpbWVuc2lvbnM6IGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoZmx1aWRDb25maWcuZmx1aWRXaWR0aCAmJiAhZmx1aWRDb25maWcuZmx1aWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGZsdWlkQ29uZmlnLm1vZGUgPSAnd2lkdGgnO1xuICAgICAgICAgICAgICAgICAgZmx1aWRDb25maWcucmF0aW8gPSBmbHVpZENvbmZpZy5pbml0aWFsRGltZW5zaW9ucy53aWR0aCAvIHBhcnNlRmxvYXQoZmxhZ3MuZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmbHVpZENvbmZpZy5mbHVpZFdpZHRoICYmIGZsdWlkQ29uZmlnLmZsdWlkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBmbHVpZENvbmZpZy5tb2RlID0gJ2hlaWdodCc7XG4gICAgICAgICAgICAgICAgICBmbHVpZENvbmZpZy5yYXRpbyA9IHBhcnNlRmxvYXQoZmxhZ3MuZGltZW5zaW9ucy53aWR0aCkgLyBmbHVpZENvbmZpZy5pbml0aWFsRGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlbC5ob2xkZXJEYXRhLmZsdWlkQ29uZmlnID0gZmx1aWRDb25maWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0SW52aXNpYmxlKGVsKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCBhbGwgY3VycmVudCBpbnZpc2libGUgaW1hZ2VzLCBhbmQgaWYgdGhleSdyZSB2aXNpYmxlLCByZW5kZXJzIHRoZW0gYW5kIHJlbW92ZXMgdGhlbSBmcm9tIGZ1cnRoZXIgY2hlY2tzLiBSdW5zIGV2ZXJ5IGFuaW1hdGlvbiBmcmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHZpc2liaWxpdHlDaGVjaygpIHtcbiAgICAgIHZhciByZW5kZXJhYmxlSW1hZ2VzID0gW107XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEFwcC52YXJzLmludmlzaWJsZUltYWdlcyk7XG4gICAgICB2YXIgZWw7XG5cbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgZWwgPSBBcHAudmFycy5pbnZpc2libGVJbWFnZXNba2V5XTtcbiAgICAgICAgICBpZiAoZGltZW5zaW9uQ2hlY2soZWwpICYmIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2ltZycpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZUltYWdlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgZGVsZXRlIEFwcC52YXJzLmludmlzaWJsZUltYWdlc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVuZGVyYWJsZUltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBIb2xkZXIucnVuKHtcbiAgICAgICAgICAgICAgaW1hZ2VzOiByZW5kZXJhYmxlSW1hZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbmUgdG8gcHJldmVudCAxMDAlIENQVSB1c2FnZSB2aWEgYWdncmVzc2l2ZSBjYWxsaW5nIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSh2aXNpYmlsaXR5Q2hlY2spO1xuICAgICAgfSwgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBjaGVja2luZyBmb3IgaW52aXNpYmxlIHBsYWNlaG9sZGVycyBpZiBub3QgZG9pbmcgc28geWV0LiBEb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnRWaXNpYmlsaXR5Q2hlY2soKSB7XG4gICAgICBpZiAoIUFwcC52YXJzLnZpc2liaWxpdHlDaGVja1N0YXJ0ZWQpIHtcbiAgICAgICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHZpc2liaWxpdHlDaGVjayk7XG4gICAgICAgICAgQXBwLnZhcnMudmlzaWJpbGl0eUNoZWNrU3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gaW1hZ2UgZGV0ZWN0ZWQgdG8gYmUgaW52aXNpYmxlIGFuZCBhZGRzIGl0IHRvIHRoZSBtYXAgb2YgaW52aXNpYmxlIGltYWdlcyBjaGVja2VkIGJ5IHZpc2liaWxpdHlDaGVja1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZWwgSW52aXNpYmxlIERPTSBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRJbnZpc2libGUoZWwpIHtcbiAgICAgIGlmICghZWwuaG9sZGVyRGF0YS5pbnZpc2libGVJZCkge1xuICAgICAgICAgIEFwcC52YXJzLmludmlzaWJsZUlkICs9IDE7XG4gICAgICAgICAgQXBwLnZhcnMuaW52aXNpYmxlSW1hZ2VzWydpJyArIEFwcC52YXJzLmludmlzaWJsZUlkXSA9IGVsO1xuICAgICAgICAgIGVsLmhvbGRlckRhdGEuaW52aXNpYmxlSWQgPSBBcHAudmFycy5pbnZpc2libGVJZDtcbiAgICAgIH1cbiAgfVxuXG4gIC8vdG9kbzogc2VlIGlmIHBvc3NpYmxlIHRvIGNvbnZlcnQgc3RhZ2luZ1JlbmRlcmVyIHRvIHVzZSBIVE1MIG9ubHlcbiAgdmFyIHN0YWdpbmdSZW5kZXJlciA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmcgPSBudWxsLFxuICAgICAgICAgIHN0YWdpbmdUZXh0ID0gbnVsbCxcbiAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgICAgdmFyIHJvb3ROb2RlID0gZ3JhcGgucm9vdDtcbiAgICAgICAgICBpZiAoQXBwLnNldHVwLnN1cHBvcnRzU1ZHKSB7XG4gICAgICAgICAgICAgIHZhciBmaXJzdFRpbWVTZXR1cCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgdG5vZGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChzdmcgPT0gbnVsbCB8fCBzdmcucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgZmlyc3RUaW1lU2V0dXAgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3ZnID0gU1ZHLmluaXRTVkcoc3ZnLCByb290Tm9kZS5wcm9wZXJ0aWVzLndpZHRoLCByb290Tm9kZS5wcm9wZXJ0aWVzLmhlaWdodCk7XG4gICAgICAgICAgICAgIC8vU2hvdyBzdGFnaW5nIGVsZW1lbnQgYmVmb3JlIHN0YWdpbmdcbiAgICAgICAgICAgICAgc3ZnLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgICAgIGlmIChmaXJzdFRpbWVTZXR1cCkge1xuICAgICAgICAgICAgICAgICAgc3RhZ2luZ1RleHQgPSBET00ubmV3RWwoJ3RleHQnLCBTVkdfTlMpO1xuICAgICAgICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlID0gdG5vZGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICBET00uc2V0QXR0cihzdGFnaW5nVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHg6IDBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc3RhZ2luZ1RleHQuYXBwZW5kQ2hpbGQoc3RhZ2luZ1RleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmRDaGlsZChzdGFnaW5nVGV4dCk7XG4gICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgICAgICAgICAgICAgICBzdmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICAgIHN2Zy5zdHlsZS50b3AgPSAnLTEwMCUnO1xuICAgICAgICAgICAgICAgICAgc3ZnLnN0eWxlLmxlZnQgPSAnLTEwMCUnO1xuICAgICAgICAgICAgICAgICAgLy90b2RvOiB3b3JrYXJvdW5kIGZvciB6ZXJvLWRpbWVuc2lvbiA8c3ZnPiB0YWcgaW4gT3BlcmEgMTJcbiAgICAgICAgICAgICAgICAgIC8vc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAwKTtcbiAgICAgICAgICAgICAgICAgIC8vc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaG9sZGVyVGV4dEdyb3VwID0gcm9vdE5vZGUuY2hpbGRyZW4uaG9sZGVyVGV4dEdyb3VwO1xuICAgICAgICAgICAgICB2YXIgaHRnUHJvcHMgPSBob2xkZXJUZXh0R3JvdXAucHJvcGVydGllcztcbiAgICAgICAgICAgICAgRE9NLnNldEF0dHIoc3RhZ2luZ1RleHQsIHtcbiAgICAgICAgICAgICAgICAgICd5JzogaHRnUHJvcHMuZm9udC5zaXplLFxuICAgICAgICAgICAgICAgICAgJ3N0eWxlJzogdXRpbHMuY3NzUHJvcHMoe1xuICAgICAgICAgICAgICAgICAgICAgICdmb250LXdlaWdodCc6IGh0Z1Byb3BzLmZvbnQud2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBodGdQcm9wcy5mb250LnNpemUgKyBodGdQcm9wcy5mb250LnVuaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IGh0Z1Byb3BzLmZvbnQuZmFtaWx5XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvL1VuZXNjYXBlIEhUTUwgZW50aXRpZXMgdG8gZ2V0IGFwcHJveGltYXRlbHkgdGhlIHJpZ2h0IHdpZHRoXG4gICAgICAgICAgICAgIHZhciB0eHQgPSBET00ubmV3RWwoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAgIHR4dC5pbm5lckhUTUwgPSBodGdQcm9wcy50ZXh0O1xuICAgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUubm9kZVZhbHVlID0gdHh0LnZhbHVlO1xuXG4gICAgICAgICAgICAgIC8vR2V0IGJvdW5kaW5nIGJveCBmb3IgdGhlIHdob2xlIHN0cmluZyAodG90YWwgd2lkdGggYW5kIGhlaWdodClcbiAgICAgICAgICAgICAgdmFyIHN0YWdpbmdUZXh0QkJveCA9IHN0YWdpbmdUZXh0LmdldEJCb3goKTtcblxuICAgICAgICAgICAgICAvL0dldCBsaW5lIGNvdW50IGFuZCBzcGxpdCB0aGUgc3RyaW5nIGludG8gd29yZHNcbiAgICAgICAgICAgICAgdmFyIGxpbmVDb3VudCA9IE1hdGguY2VpbChzdGFnaW5nVGV4dEJCb3gud2lkdGggLyByb290Tm9kZS5wcm9wZXJ0aWVzLndpZHRoKTtcbiAgICAgICAgICAgICAgdmFyIHdvcmRzID0gaHRnUHJvcHMudGV4dC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICB2YXIgbmV3bGluZXMgPSBodGdQcm9wcy50ZXh0Lm1hdGNoKC9cXFxcbi9nKTtcbiAgICAgICAgICAgICAgbGluZUNvdW50ICs9IG5ld2xpbmVzID09IG51bGwgPyAwIDogbmV3bGluZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIC8vR2V0IGJvdW5kaW5nIGJveCBmb3IgdGhlIHN0cmluZyB3aXRoIHNwYWNlcyByZW1vdmVkXG4gICAgICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZS5ub2RlVmFsdWUgPSBodGdQcm9wcy50ZXh0LnJlcGxhY2UoL1sgXSsvZywgJycpO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWROb1NwYWNlTGVuZ3RoID0gc3RhZ2luZ1RleHQuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG5cbiAgICAgICAgICAgICAgLy9Db21wdXRlIGF2ZXJhZ2Ugc3BhY2Ugd2lkdGhcbiAgICAgICAgICAgICAgdmFyIGRpZmZMZW5ndGggPSBzdGFnaW5nVGV4dEJCb3gud2lkdGggLSBjb21wdXRlZE5vU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBzcGFjZVdpZHRoID0gTWF0aC5yb3VuZChkaWZmTGVuZ3RoIC8gTWF0aC5tYXgoMSwgd29yZHMubGVuZ3RoIC0gMSkpO1xuXG4gICAgICAgICAgICAgIC8vR2V0IHdpZHRocyBmb3IgZXZlcnkgd29yZCB3aXRoIHNwYWNlIG9ubHkgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lXG4gICAgICAgICAgICAgIHZhciB3b3JkV2lkdGhzID0gW107XG4gICAgICAgICAgICAgIGlmIChsaW5lQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUubm9kZVZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmRzW2ldLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlLm5vZGVWYWx1ZSA9IHV0aWxzLmRlY29kZUh0bWxFbnRpdHkod29yZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBiYm94ID0gc3RhZ2luZ1RleHQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmRXaWR0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHdvcmRzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmJveC53aWR0aFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9IaWRlIHN0YWdpbmcgZWxlbWVudCBhZnRlciBzdGFnaW5nXG4gICAgICAgICAgICAgIHN2Zy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzcGFjZVdpZHRoOiBzcGFjZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgbGluZUNvdW50OiBsaW5lQ291bnQsXG4gICAgICAgICAgICAgICAgICBib3VuZGluZ0JveDogc3RhZ2luZ1RleHRCQm94LFxuICAgICAgICAgICAgICAgICAgd29yZHM6IHdvcmRXaWR0aHNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvL3RvZG86IGNhbnZhcyBmYWxsYmFjayBmb3IgbWVhc3VyaW5nIHRleHQgb24gYW5kcm9pZCAyLjNcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gIH0pKCk7XG5cbiAgLy9IZWxwZXJzXG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIGEgZnVuY3Rpb24gZnJvbSBiZWluZyBjYWxsZWQgdG9vIG9mdGVuLCB3YWl0cyB1bnRpbCBhIHRpbWVyIGVsYXBzZXMgdG8gY2FsbCBpdCBhZ2FpblxuICAgKlxuICAgKiBAcGFyYW0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICAgKi9cbiAgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgICAgIGlmICghQXBwLnZhcnMuZGVib3VuY2VUaW1lcikgZm4uY2FsbCh0aGlzKTtcbiAgICAgIGlmIChBcHAudmFycy5kZWJvdW5jZVRpbWVyKSBnbG9iYWwuY2xlYXJUaW1lb3V0KEFwcC52YXJzLmRlYm91bmNlVGltZXIpO1xuICAgICAgQXBwLnZhcnMuZGVib3VuY2VUaW1lciA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEFwcC52YXJzLmRlYm91bmNlVGltZXIgPSBudWxsO1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICB9LCBBcHAuc2V0dXAuZGVib3VuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvbGRlci1zcGVjaWZpYyByZXNpemUvb3JpZW50YXRpb24gY2hhbmdlIGNhbGxiYWNrLCBkZWJvdW5jZWQgdG8gcHJldmVudCBleGNlc3NpdmUgZXhlY3V0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZXNpemVFdmVudCgpIHtcbiAgICAgIGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKG51bGwpO1xuICAgICAgfSk7XG4gIH1cblxuICAvL1NldCB1cCBmbGFnc1xuXG4gIGZvciAodmFyIGZsYWcgaW4gQXBwLmZsYWdzKSB7XG4gICAgICBpZiAoIUFwcC5mbGFncy5oYXNPd25Qcm9wZXJ0eShmbGFnKSkgY29udGludWU7XG4gICAgICBBcHAuZmxhZ3NbZmxhZ10ubWF0Y2ggPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsLm1hdGNoKHRoaXMucmVnZXgpO1xuICAgICAgfTtcbiAgfVxuXG4gIC8vUHJvcGVydGllcyBzZXQgb25jZSBvbiBzZXR1cFxuXG4gIEFwcC5zZXR1cCA9IHtcbiAgICAgIHJlbmRlcmVyOiAnaHRtbCcsXG4gICAgICBkZWJvdW5jZTogMTAwLFxuICAgICAgcmF0aW86IDEsXG4gICAgICBzdXBwb3J0c0NhbnZhczogZmFsc2UsXG4gICAgICBzdXBwb3J0c1NWRzogZmFsc2UsXG4gICAgICBsaW5lV3JhcFJhdGlvOiAwLjksXG4gICAgICBkYXRhQXR0cjogJ2RhdGEtc3JjJyxcbiAgICAgIHJlbmRlcmVyczogWydodG1sJywgJ2NhbnZhcycsICdzdmcnXVxuICB9O1xuXG4gIC8vUHJvcGVydGllcyBtb2RpZmllZCBkdXJpbmcgcnVudGltZVxuXG4gIEFwcC52YXJzID0ge1xuICAgICAgcHJlZW1wdGVkOiBmYWxzZSxcbiAgICAgIHJlc2l6YWJsZUltYWdlczogW10sXG4gICAgICBpbnZpc2libGVJbWFnZXM6IHt9LFxuICAgICAgaW52aXNpYmxlSWQ6IDAsXG4gICAgICB2aXNpYmlsaXR5Q2hlY2tTdGFydGVkOiBmYWxzZSxcbiAgICAgIGRlYm91bmNlVGltZXI6IG51bGwsXG4gICAgICBjYWNoZToge31cbiAgfTtcblxuICAvL1ByZS1mbGlnaHRcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FudmFzID0gRE9NLm5ld0VsKCdjYW52YXMnKTtcblxuICAgICAgaWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpLmluZGV4T2YoJ2RhdGE6aW1hZ2UvcG5nJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgQXBwLnNldHVwLnJlbmRlcmVyID0gJ2NhbnZhcyc7XG4gICAgICAgICAgICAgIEFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdCkge1xuICAgICAgICAgIEFwcC5zZXR1cC5yZW5kZXJlciA9ICdzdmcnO1xuICAgICAgICAgIEFwcC5zZXR1cC5zdXBwb3J0c1NWRyA9IHRydWU7XG4gICAgICB9XG4gIH0pKCk7XG5cbiAgLy9TdGFydHMgY2hlY2tpbmcgZm9yIGludmlzaWJsZSBwbGFjZWhvbGRlcnNcbiAgc3RhcnRWaXNpYmlsaXR5Q2hlY2soKTtcblxuICBpZiAob25Eb21SZWFkeSkge1xuICAgICAgb25Eb21SZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIUFwcC52YXJzLnByZWVtcHRlZCkge1xuICAgICAgICAgICAgICBIb2xkZXIucnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgcmVzaXplRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgcmVzaXplRXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsLlR1cmJvbGlua3MgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2U6Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBIb2xkZXIucnVuKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBIb2xkZXI7XG5cbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAvKiFcbiAgICogb25Eb21SZWFkeS5qcyAxLjQuMCAoYykgMjAxMyBUdWJhbCBNYXJ0aW4gLSBNSVQgbGljZW5zZVxuICAgKlxuICAgKiBTcGVjaWFsbHkgbW9kaWZpZWQgdG8gd29yayB3aXRoIEhvbGRlci5qc1xuICAgKi9cblxuICBmdW5jdGlvbiBfb25Eb21SZWFkeSh3aW4pIHtcbiAgICAgIC8vTGF6eSBsb2FkaW5nIGZpeCBmb3IgRmlyZWZveCA8IDMuNlxuICAgICAgLy9odHRwOi8vd2VicmVmbGVjdGlvbi5ibG9nc3BvdC5jb20vMjAwOS8xMS8xOTUtY2hhcnMtdG8taGVscC1sYXp5LWxvYWRpbmcuaHRtbFxuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gbnVsbCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gRE9NQ29udGVudExvYWRlZCgpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID0gXCJjb21wbGV0ZVwiO1xuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID0gXCJsb2FkaW5nXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQsXG4gICAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBcbiAgICAgICAgICBMT0FEID0gXCJsb2FkXCIsXG4gICAgICAgICAgRkFMU0UgPSBmYWxzZSxcbiAgICAgICAgICBPTkxPQUQgPSBcIm9uXCIrTE9BRCxcbiAgICAgICAgICBDT01QTEVURSA9IFwiY29tcGxldGVcIixcbiAgICAgICAgICBSRUFEWVNUQVRFID0gXCJyZWFkeVN0YXRlXCIsXG4gICAgICAgICAgQVRUQUNIRVZFTlQgPSBcImF0dGFjaEV2ZW50XCIsXG4gICAgICAgICAgREVUQUNIRVZFTlQgPSBcImRldGFjaEV2ZW50XCIsXG4gICAgICAgICAgQURERVZFTlRMSVNURU5FUiA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICAgIERPTUNPTlRFTlRMT0FERUQgPSBcIkRPTUNvbnRlbnRMb2FkZWRcIixcbiAgICAgICAgICBPTlJFQURZU1RBVEVDSEFOR0UgPSBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLFxuICAgICAgICAgIFJFTU9WRUVWRU5UTElTVEVORVIgPSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICAgIFxuICAgICAgICAgIC8vIFczQyBFdmVudCBtb2RlbFxuICAgICAgICAgIHczYyA9IEFEREVWRU5UTElTVEVORVIgaW4gZG9jLFxuICAgICAgICAgIF90b3AgPSBGQUxTRSxcbiAgICAgIFxuICAgICAgICAgIC8vIGlzUmVhZHk6IElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG4gICAgICAgICAgaXNSZWFkeSA9IEZBTFNFLFxuICAgICAgXG4gICAgICAgICAgLy8gQ2FsbGJhY2tzIHBlbmRpbmcgZXhlY3V0aW9uIHVudGlsIERPTSBpcyByZWFkeVxuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICBmdW5jdGlvbiByZWFkeSggZm4gKSB7XG4gICAgICAgICAgaWYgKCAhaXNSZWFkeSApIHtcbiAgICAgIFxuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG4gICAgICAgICAgICAgIGlmICggIWRvYy5ib2R5ICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyKCByZWFkeSApO1xuICAgICAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgICAgIGlzUmVhZHkgPSB0cnVlO1xuICAgICAgXG4gICAgICAgICAgICAgIC8vIEV4ZWN1dGUgYWxsIGNhbGxiYWNrc1xuICAgICAgICAgICAgICB3aGlsZSAoIGZuID0gY2FsbGJhY2tzLnNoaWZ0KCkgKSB7XG4gICAgICAgICAgICAgICAgICBkZWZlciggZm4gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXJcbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCggZXZlbnQgKSB7XG4gICAgICAgICAgLy8gcmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIGlzIGdvb2QgZW5vdWdoIGZvciB1cyB0byBjYWxsIHRoZSBkb20gcmVhZHkgaW4gb2xkSUVcbiAgICAgICAgICBpZiAoIHczYyB8fCBldmVudC50eXBlID09PSBMT0FEIHx8IGRvY1tSRUFEWVNUQVRFXSA9PT0gQ09NUExFVEUgKSB7XG4gICAgICAgICAgICAgIGRldGFjaCgpO1xuICAgICAgICAgICAgICByZWFkeSgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYW4tdXAgbWV0aG9kIGZvciBkb20gcmVhZHkgZXZlbnRzXG4gICAgICBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICAgICAgaWYgKCB3M2MgKSB7XG4gICAgICAgICAgICAgIGRvY1tSRU1PVkVFVkVOVExJU1RFTkVSXSggRE9NQ09OVEVOVExPQURFRCwgY29tcGxldGVkLCBGQUxTRSApO1xuICAgICAgICAgICAgICB3aW5bUkVNT1ZFRVZFTlRMSVNURU5FUl0oIExPQUQsIGNvbXBsZXRlZCwgRkFMU0UgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb2NbREVUQUNIRVZFTlRdKCBPTlJFQURZU1RBVEVDSEFOR0UsIGNvbXBsZXRlZCApO1xuICAgICAgICAgICAgICB3aW5bREVUQUNIRVZFTlRdKCBPTkxPQUQsIGNvbXBsZXRlZCApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICBmdW5jdGlvbiBkZWZlciggZm4sIHdhaXQgKSB7XG4gICAgICAgICAgLy8gQWxsb3cgMCB0byBiZSBwYXNzZWRcbiAgICAgICAgICBzZXRUaW1lb3V0KCBmbiwgK3dhaXQgPj0gMCA/IHdhaXQgOiAxICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEF0dGFjaCB0aGUgbGlzdGVuZXJzOlxuICAgICAgXG4gICAgICAvLyBDYXRjaCBjYXNlcyB3aGVyZSBvbkRvbVJlYWR5IGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgICAgIC8vIHdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgXCJpbnRlcmFjdGl2ZVwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxuICAgICAgLy8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuICAgICAgaWYgKCBkb2NbUkVBRFlTVEFURV0gPT09IENPTVBMRVRFICkge1xuICAgICAgICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuICAgICAgICAgIGRlZmVyKCByZWFkeSApO1xuICAgICAgXG4gICAgICAvLyBTdGFuZGFyZHMtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydCBET01Db250ZW50TG9hZGVkXG4gICAgICB9IGVsc2UgaWYgKCB3M2MgKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuICAgICAgICAgIGRvY1tBRERFVkVOVExJU1RFTkVSXSggRE9NQ09OVEVOVExPQURFRCwgY29tcGxldGVkLCBGQUxTRSApO1xuICAgICAgXG4gICAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcbiAgICAgICAgICB3aW5bQURERVZFTlRMSVNURU5FUl0oIExPQUQsIGNvbXBsZXRlZCwgRkFMU0UgKTtcbiAgICAgIFxuICAgICAgLy8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFbnN1cmUgZmlyaW5nIGJlZm9yZSBvbmxvYWQsIG1heWJlIGxhdGUgYnV0IHNhZmUgYWxzbyBmb3IgaWZyYW1lc1xuICAgICAgICAgIGRvY1tBVFRBQ0hFVkVOVF0oIE9OUkVBRFlTVEFURUNIQU5HRSwgY29tcGxldGVkICk7XG4gICAgICBcbiAgICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICAgIHdpbltBVFRBQ0hFVkVOVF0oIE9OTE9BRCwgY29tcGxldGVkICk7XG4gICAgICBcbiAgICAgICAgICAvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcbiAgICAgICAgICAvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgX3RvcCA9IHdpbi5mcmFtZUVsZW1lbnQgPT0gbnVsbCAmJiBkb2NFbGVtO1xuICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIFxuICAgICAgICAgIGlmICggX3RvcCAmJiBfdG9wLmRvU2Nyb2xsICkge1xuICAgICAgICAgICAgICAoZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcbiAgICAgICAgICAgICAgICAgIGlmICggIWlzUmVhZHkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RvcC5kb1Njcm9sbChcImxlZnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlciggZG9TY3JvbGxDaGVjaywgNTAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZXRhY2ggYWxsIGRvbSByZWFkeSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICBkZXRhY2goKTtcbiAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBleGVjdXRlIGFueSB3YWl0aW5nIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgIHJlYWR5KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBvbkRvbVJlYWR5KCBmbiApIHtcbiAgICAgICAgICAvLyBJZiBET00gaXMgcmVhZHksIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIChhc3luYyksIG90aGVyd2lzZSB3YWl0XG4gICAgICAgICAgaXNSZWFkeSA/IGRlZmVyKCBmbiApIDogY2FsbGJhY2tzLnB1c2goIGZuICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCB2ZXJzaW9uXG4gICAgICBvbkRvbVJlYWR5LnZlcnNpb24gPSBcIjEuNC4wXCI7XG4gICAgICAvLyBBZGQgbWV0aG9kIHRvIGNoZWNrIGlmIERPTSBpcyByZWFkeVxuICAgICAgb25Eb21SZWFkeS5pc1JlYWR5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gaXNSZWFkeTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvbkRvbVJlYWR5O1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIF9vbkRvbVJlYWR5KHdpbmRvdyk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIC8vTW9kaWZpZWQgdmVyc2lvbiBvZiBjb21wb25lbnQvcXVlcnlzdHJpbmdcbiAgLy9DaGFuZ2VzOiB1cGRhdGVkIGRlcGVuZGVuY2llcywgZG90IG5vdGF0aW9uIHBhcnNpbmcsIEpTSGludCBmaXhlc1xuICAvL0ZvcmsgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ltc2t5L3F1ZXJ5c3RyaW5nXG5cbiAgLyoqXG4gICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gIHZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG4gIHZhciB0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgdmFyIHR5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4gIHZhciBhcnJheVJlZ2V4ID0gLyhcXHcrKVxcWyhcXGQrKVxcXS87XG4gIHZhciBvYmplY3RSZWdleCA9IC9cXHcrXFwuXFx3Ky87XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHN0cikgcmV0dXJuIHt9O1xuXG4gICAgc3RyID0gdHJpbShzdHIpO1xuICAgIGlmICgnJyA9PT0gc3RyKSByZXR1cm4ge307XG4gICAgaWYgKCc/JyA9PT0gc3RyLmNoYXJBdCgwKSkgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0cyA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzWzBdKTtcbiAgICAgIHZhciBtLCBjdHgsIHByb3A7XG5cbiAgICAgIGlmIChtID0gYXJyYXlSZWdleC5leGVjKGtleSkpIHtcbiAgICAgICAgb2JqW21bMV1dID0gb2JqW21bMV1dIHx8IFtdO1xuICAgICAgICBvYmpbbVsxXV1bbVsyXV0gPSBkZWNvZGUocGFydHNbMV0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG0gPSBvYmplY3RSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgbSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICBjdHggPSBvYmo7XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAobS5sZW5ndGgpIHtcbiAgICAgICAgICBwcm9wID0gbS5zaGlmdCgpO1xuXG4gICAgICAgICAgaWYgKCFwcm9wLmxlbmd0aCkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoIWN0eFtwcm9wXSkge1xuICAgICAgICAgICAgY3R4W3Byb3BdID0ge307XG4gICAgICAgICAgfSBlbHNlIGlmIChjdHhbcHJvcF0gJiYgdHlwZW9mIGN0eFtwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN0eFtwcm9wXSA9IGRlY29kZShwYXJ0c1sxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4ID0gY3R4W3Byb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG9ialtwYXJ0c1swXV0gPSBudWxsID09IHBhcnRzWzFdID8gJycgOiBkZWNvZGUocGFydHNbMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYG9iamAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iail7XG4gICAgaWYgKCFvYmopIHJldHVybiAnJztcbiAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKHZhbHVlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChlbmNvZGUoa2V5ICsgJ1snICsgaSArICddJykgKyAnPScgKyBlbmNvZGUodmFsdWVbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFpcnMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZShvYmpba2V5XSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG4gIH07XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgXG4gIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbiAgZnVuY3Rpb24gdHJpbShzdHIpe1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xuICB9XG5cbiAgZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xuICB9O1xuXG4gIGV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG4gIH07XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgLyoqXG4gICAqIHRvU3RyaW5nIHJlZi5cbiAgICovXG5cbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzogcmV0dXJuICdyZWdleHAnO1xuICAgICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzogcmV0dXJuICdhcmd1bWVudHMnO1xuICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzogcmV0dXJuICdlcnJvcic7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBpZiAodmFsICE9PSB2YWwpIHJldHVybiAnbmFuJztcbiAgICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztcblxuICAgIGlmIChpc0J1ZmZlcih2YWwpKSByZXR1cm4gJ2J1ZmZlcic7XG5cbiAgICB2YWwgPSB2YWwudmFsdWVPZlxuICAgICAgPyB2YWwudmFsdWVPZigpXG4gICAgICA6IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZi5hcHBseSh2YWwpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gIH07XG5cbiAgLy8gY29kZSBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaXMtYnVmZmVyL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgIHJldHVybiAhIShvYmogIT0gbnVsbCAmJlxuICAgICAgKG9iai5faXNCdWZmZXIgfHwgLy8gRm9yIFNhZmFyaSA1LTcgKG1pc3NpbmcgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKVxuICAgICAgKSlcbiAgfVxuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIHZhciBTY2VuZUdyYXBoID0gZnVuY3Rpb24oc2NlbmVQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZUNvdW50ID0gMTtcblxuICAgICAgLy90b2RvOiBtb3ZlIG1lcmdlIHRvIGhlbHBlcnMgc2VjdGlvblxuICAgICAgZnVuY3Rpb24gbWVyZ2UocGFyZW50LCBjaGlsZCkge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgcGFyZW50W3Byb3BdID0gY2hpbGRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBTY2VuZU5vZGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgbm9kZUNvdW50Kys7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgICB0aGlzLmlkID0gbm9kZUNvdW50O1xuICAgICAgICAgIHRoaXMubmFtZSA9ICduJyArIG5vZGVDb3VudDtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIH07XG5cbiAgICAgIFNjZW5lTm9kZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNjZW5lTm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgICAgICAgIHRoaXMueCA9IHggIT0gbnVsbCA/IHggOiB0aGlzLng7XG4gICAgICAgICAgdGhpcy55ID0geSAhPSBudWxsID8geSA6IHRoaXMueTtcbiAgICAgICAgICB0aGlzLnogPSB6ICE9IG51bGwgPyB6IDogdGhpcy56O1xuICAgICAgfTtcblxuICAgICAgU2NlbmVOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hpbGRyZW5bbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bbmFtZV0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyAnU2NlbmVHcmFwaDogY2hpbGQgYWxyZWFkeSBleGlzdHM6ICcgKyBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBSb290Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFNjZW5lTm9kZS5jYWxsKHRoaXMsICdyb290Jyk7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gc2NlbmVQcm9wZXJ0aWVzO1xuICAgICAgfTtcblxuICAgICAgUm9vdE5vZGUucHJvdG90eXBlID0gbmV3IFNjZW5lTm9kZSgpO1xuXG4gICAgICB2YXIgU2hhcGUgPSBmdW5jdGlvbihuYW1lLCBwcm9wcykge1xuICAgICAgICAgIFNjZW5lTm9kZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgJ2ZpbGwnOiAnIzAwMDAwMCdcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIG1lcmdlKHRoaXMucHJvcGVydGllcywgcHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aHJvdyAnU2NlbmVHcmFwaDogaW52YWxpZCBub2RlIG5hbWUnO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNoYXBlLnByb3RvdHlwZSA9IG5ldyBTY2VuZU5vZGUoKTtcblxuICAgICAgdmFyIEdyb3VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAnZ3JvdXAnO1xuICAgICAgfTtcblxuICAgICAgR3JvdXAucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5cbiAgICAgIHZhciBSZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG4gICAgICB9O1xuXG4gICAgICBSZWN0LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG4gICAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudGV4dCA9IHRleHQ7XG4gICAgICB9O1xuXG4gICAgICBUZXh0LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG4gICAgICB2YXIgcm9vdCA9IG5ldyBSb290Tm9kZSgpO1xuXG4gICAgICB0aGlzLlNoYXBlID0ge1xuICAgICAgICAgICdSZWN0JzogUmVjdCxcbiAgICAgICAgICAnVGV4dCc6IFRleHQsXG4gICAgICAgICAgJ0dyb3VwJzogR3JvdXBcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFNjZW5lR3JhcGg7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuICAgKiBTaGFsbG93IG9iamVjdCBjbG9uZSBhbmQgbWVyZ2VcbiAgICpcbiAgICogQHBhcmFtIGEgT2JqZWN0IEFcbiAgICogQHBhcmFtIGIgT2JqZWN0IEJcbiAgICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCB3aXRoIGFsbCBvZiBBJ3MgcHJvcGVydGllcywgYW5kIGFsbCBvZiBCJ3MgcHJvcGVydGllcywgb3ZlcndyaXRpbmcgQSdzIHByb3BlcnRpZXNcbiAgICovXG4gIGV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIGMgPSB7fTtcbiAgICAgIGZvciAodmFyIHggaW4gYSkge1xuICAgICAgICAgIGlmIChhLmhhc093blByb3BlcnR5KHgpKSB7XG4gICAgICAgICAgICAgIGNbeF0gPSBhW3hdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciB5IGluIGIpIHtcbiAgICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoeSkpIHtcbiAgICAgICAgICAgICAgICAgIGNbeV0gPSBiW3ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgay92IGxpc3Qgb2YgQ1NTIHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBydWxlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wcyBDU1MgcHJvcGVydGllcyBvYmplY3RcbiAgICovXG4gIGV4cG9ydHMuY3NzUHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgZm9yICh2YXIgcCBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICByZXQucHVzaChwICsgJzonICsgcHJvcHNbcF0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQuam9pbignOycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIEhUTUwgZW50aXRpZXMgaW4gYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlSHRtbEVudGl0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgdmFyIGNoYXJDb2RlID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGlmIChjaGFyQ29kZSA+IDEyOCkge1xuICAgICAgICAgICAgICBidWYudW5zaGlmdChbJyYjJywgY2hhckNvZGUsICc7J10uam9pbignJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJ1Zi51bnNoaWZ0KHN0cltpXSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGltYWdlIGV4aXN0c1xuICAgKlxuICAgKiBAcGFyYW0gc3JjIFVSTCBvZiBpbWFnZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gY2FsbCBvbmNlIGltYWdlIHN0YXR1cyBoYXMgYmVlbiBmb3VuZFxuICAgKi9cbiAgZXhwb3J0cy5pbWFnZUV4aXN0cyA9IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICB9O1xuICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIEhUTUwgZW50aXRpZXMgaW4gYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlSHRtbEVudGl0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24obWF0Y2gsIGRlYykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyk7XG4gICAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVsZW1lbnQncyBkaW1lbnNpb25zIGlmIGl0J3MgdmlzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSBlbCBET00gZWxlbWVudFxuICAgKi9cbiAgZXhwb3J0cy5kaW1lbnNpb25DaGVjayA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGhcbiAgICAgIH07XG5cbiAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCAmJiBkaW1lbnNpb25zLndpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgdHJ1dGh5IG9yIGlmIGl0IGlzIFwic2VtYW50aWNhbGx5IHRydXRoeVwiXG4gICAqIEBwYXJhbSB2YWxcbiAgICovXG4gIGV4cG9ydHMudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAneWVzJyB8fCB2YWwgPT09ICcxJyB8fCB2YWwgPT09ICdvbicgfHwgdmFsID09PSAn4pyTJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGlucHV0IGludG8gYSB3ZWxsLWZvcm1lZCBDU1MgY29sb3JcbiAgICogQHBhcmFtIHZhbFxuICAgKi9cbiAgZXhwb3J0cy5wYXJzZUNvbG9yID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgaGV4cmUgPSAvKF4oPzojPylbMC05YS1mXXs2fSQpfCheKD86Iz8pWzAtOWEtZl17M30kKS9pO1xuICAgICAgdmFyIHJnYnJlID0gL15yZ2JcXCgoXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqXFwpJC87XG4gICAgICB2YXIgcmdiYXJlID0gL15yZ2JhXFwoKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKDBcXC5cXGR7MSx9fDEpXFwpJC87XG5cbiAgICAgIHZhciBtYXRjaCA9IHZhbC5tYXRjaChoZXhyZSk7XG4gICAgICB2YXIgcmV0dmFsO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXTtcbiAgICAgICAgICBpZiAocmV0dmFsWzBdICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcjJyArIHJldHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB2YWwubWF0Y2gocmdicmUpO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSAncmdiKCcgKyBtYXRjaC5zbGljZSgxKS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB2YWwubWF0Y2gocmdiYXJlKTtcblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dmFsID0gJ3JnYmEoJyArIG1hdGNoLnNsaWNlKDEpLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZXMgdGhlIGNvcnJlY3Qgc2NhbGluZyByYXRpbyBmb3IgY2FudmFzIGRyYXdpbmcgb3BlcmF0aW9ucyBvbiBIaURQSSBzY3JlZW5zIChlLmcuIFJldGluYSBkaXNwbGF5cylcbiAgICovXG4gIGV4cG9ydHMuY2FudmFzUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IDE7XG4gICAgICB2YXIgYmFja2luZ1N0b3JlUmF0aW8gPSAxO1xuXG4gICAgICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICAgICAgdmFyIGNhbnZhcyA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBpZiAoY2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvID0gZ2xvYmFsLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgfTtcbiAgLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIERPTSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbiAgdmFyIFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBOT0RFX1RZUEVfQ09NTUVOVCA9IDg7XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgU1ZHIGVsZW1lbnQgY3JlYXRpb24gZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHN2ZyBTVkcgY29udGV4dCwgc2V0IHRvIG51bGwgaWYgbmV3XG4gICAqIEBwYXJhbSB3aWR0aCBEb2N1bWVudCB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0IERvY3VtZW50IGhlaWdodFxuICAgKi9cbiAgZXhwb3J0cy5pbml0U1ZHID0gZnVuY3Rpb24oc3ZnLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgZGVmcywgc3R5bGUsIGluaXRpYWxpemUgPSBmYWxzZTtcblxuICAgICAgaWYgKHN2ZyAmJiBzdmcucXVlcnlTZWxlY3Rvcikge1xuICAgICAgICAgIHN0eWxlID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJyk7XG4gICAgICAgICAgaWYgKHN0eWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGluaXRpYWxpemUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ZnID0gRE9NLm5ld0VsKCdzdmcnLCBTVkdfTlMpO1xuICAgICAgICAgIGluaXRpYWxpemUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdGlhbGl6ZSkge1xuICAgICAgICAgIGRlZnMgPSBET00ubmV3RWwoJ2RlZnMnLCBTVkdfTlMpO1xuICAgICAgICAgIHN0eWxlID0gRE9NLm5ld0VsKCdzdHlsZScsIFNWR19OUyk7XG4gICAgICAgICAgRE9NLnNldEF0dHIoc3R5bGUsIHtcbiAgICAgICAgICAgICAgJ3R5cGUnOiAndGV4dC9jc3MnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGRlZnMpO1xuICAgICAgfVxuXG4gICAgICAvL0lFIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhpcyBpcyBzZXQgYW5kIENocm9tZSByZXF1aXJlcyBpdCB0byBiZSBzZXRcbiAgICAgIGlmIChzdmcud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCBTVkdfTlMpO1xuICAgICAgfVxuXG4gICAgICAvL1JlbW92ZSBjb21tZW50IG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN2Zy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHN2Zy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfQ09NTUVOVCkge1xuICAgICAgICAgICAgICBzdmcucmVtb3ZlQ2hpbGQoc3ZnLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9SZW1vdmUgQ1NTXG4gICAgICB3aGlsZSAoc3R5bGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgRE9NLnNldEF0dHIoc3ZnLCB7XG4gICAgICAgICAgJ3dpZHRoJzogd2lkdGgsXG4gICAgICAgICAgJ2hlaWdodCc6IGhlaWdodCxcbiAgICAgICAgICAndmlld0JveCc6ICcwIDAgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0LFxuICAgICAgICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJzogJ25vbmUnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHN2ZztcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgc2VyaWFsaXplZCBTVkcgdG8gYSBzdHJpbmcgc3VpdGFibGUgZm9yIGRhdGEgVVJJIHVzZVxuICAgKiBAcGFyYW0gc3ZnU3RyaW5nIFNlcmlhbGl6ZWQgU1ZHIHN0cmluZ1xuICAgKiBAcGFyYW0gW2Jhc2U2NF0gVXNlIGJhc2U2NCBlbmNvZGluZyBmb3IgZGF0YSBVUklcbiAgICovXG4gIGV4cG9ydHMuc3ZnU3RyaW5nVG9EYXRhVVJJID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmF3UHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LCc7XG4gICAgICB2YXIgYmFzZTY0UHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04O2Jhc2U2NCwnO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3ZnU3RyaW5nLCBiYXNlNjQpIHtcbiAgICAgICAgICBpZiAoYmFzZTY0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlNjRQcmVmaXggKyBidG9hKGdsb2JhbC51bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3ZnU3RyaW5nKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiByYXdQcmVmaXggKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc2VyaWFsaXplZCBTVkcgd2l0aCBYTUwgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHN2ZyBTVkcgY29udGV4dFxuICAgKiBAcGFyYW0gc3R5bGVzaGVldHMgQ1NTIHN0eWxlc2hlZXRzIHRvIGluY2x1ZGVcbiAgICovXG4gIGV4cG9ydHMuc2VyaWFsaXplU1ZHID0gZnVuY3Rpb24oc3ZnLCBlbmdpbmVTZXR0aW5ncykge1xuICAgICAgaWYgKCFnbG9iYWwuWE1MU2VyaWFsaXplcikgcmV0dXJuO1xuICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgdmFyIHN2Z0NTUyA9ICcnO1xuICAgICAgdmFyIHN0eWxlc2hlZXRzID0gZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHM7XG5cbiAgICAgIC8vRXh0ZXJuYWwgc3R5bGVzaGVldHM6IFByb2Nlc3NpbmcgSW5zdHJ1Y3Rpb24gbWV0aG9kXG4gICAgICBpZiAoZW5naW5lU2V0dGluZ3Muc3ZnWE1MU3R5bGVzaGVldCkge1xuICAgICAgICAgIHZhciB4bWwgPSBET00uY3JlYXRlWE1MKCk7XG4gICAgICAgICAgLy9BZGQgPD94bWwtc3R5bGVzaGVldCA/PiBkaXJlY3RpdmVzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHN0eWxlc2hlZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIHZhciBjc3NwaSA9IHhtbC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oJ3htbC1zdHlsZXNoZWV0JywgJ2hyZWY9XCInICsgc3R5bGVzaGVldHNbaV0gKyAnXCIgcmVsPVwic3R5bGVzaGVldFwiJyk7XG4gICAgICAgICAgICAgIHhtbC5pbnNlcnRCZWZvcmUoY3NzcGksIHhtbC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4bWwucmVtb3ZlQ2hpbGQoeG1sLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgc3ZnQ1NTID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyh4bWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ZnVGV4dCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKTtcbiAgICAgIHN2Z1RleHQgPSBzdmdUZXh0LnJlcGxhY2UoL1xcJmFtcDsoXFwjWzAtOV17Mix9XFw7KS9nLCAnJiQxJyk7XG4gICAgICByZXR1cm4gc3ZnQ1NTICsgc3ZnVGV4dDtcbiAgfTtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAgICogR2VuZXJpYyBuZXcgRE9NIGVsZW1lbnQgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHZhbHVlXG4gICAqL1xuICBleHBvcnRzLm5ld0VsID0gZnVuY3Rpb24odGFnLCBuYW1lc3BhY2UpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSByZXR1cm47XG5cbiAgICAgIGlmIChuYW1lc3BhY2UgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgc2V0QXR0cmlidXRlIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbCBSZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtIGF0dHJzIE9iamVjdCB3aXRoIGF0dHJpYnV0ZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICovXG4gIGV4cG9ydHMuc2V0QXR0ciA9IGZ1bmN0aW9uIChlbCwgYXR0cnMpIHtcbiAgICAgIGZvciAodmFyIGEgaW4gYXR0cnMpIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYSwgYXR0cnNbYV0pO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgWE1MIGRvY3VtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHBvcnRzLmNyZWF0ZVhNTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFnbG9iYWwuRE9NUGFyc2VyKSByZXR1cm47XG4gICAgICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPHhtbCAvPicsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYSB2YWx1ZSBpbnRvIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgKlxuICAgKiBAcGFyYW0gdmFsIEEgc3RyaW5nLCBhIE5vZGVMaXN0LCBhIE5vZGUsIG9yIGFuIEhUTUxDb2xsZWN0aW9uXG4gICAqL1xuICBleHBvcnRzLmdldE5vZGVBcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHJldHZhbCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mKHZhbCkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKGdsb2JhbC5Ob2RlTGlzdCAmJiB2YWwgaW5zdGFuY2VvZiBnbG9iYWwuTm9kZUxpc3QpIHtcbiAgICAgICAgICByZXR2YWwgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKGdsb2JhbC5Ob2RlICYmIHZhbCBpbnN0YW5jZW9mIGdsb2JhbC5Ob2RlKSB7XG4gICAgICAgICAgcmV0dmFsID0gW3ZhbF07XG4gICAgICB9IGVsc2UgaWYgKGdsb2JhbC5IVE1MQ29sbGVjdGlvbiAmJiB2YWwgaW5zdGFuY2VvZiBnbG9iYWwuSFRNTENvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR2YWwgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgcmV0dmFsID0gdmFsO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dmFsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocmV0dmFsKTtcblxuICAgICAgcmV0dXJuIHJldHZhbDtcbiAgfTtcblxuICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbihjb2xvciwgb3B0aW9ucykge1xuICAgICAgLy90b2RvOiBzdXBwb3J0IHJnYmEsIGhzbGEsIGFuZCBycmdnYmJhYSBub3RhdGlvblxuICAgICAgLy90b2RvOiB1c2UgQ0lFTEFCIGludGVybmFsbHlcbiAgICAgIC8vdG9kbzogYWRkIGNsYW1wIGZ1bmN0aW9uICh3aXRoIHNpZ24pXG4gICAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuXG4gICAgICB0aGlzLm9yaWdpbmFsID0gY29sb3I7XG5cbiAgICAgIGlmIChjb2xvci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIGNvbG9yID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgvW15hLWYwLTldKy9pLnRlc3QoY29sb3IpKSByZXR1cm47XG5cbiAgICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoLy4vZywgJyQmJCYnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yLmxlbmd0aCAhPT0gNikgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFscGhhID0gMTtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbHBoYSkge1xuICAgICAgICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldChwYXJzZUludChjb2xvciwgMTYpKTtcbiAgfTtcblxuICAvL3RvZG86IGpzZG9jc1xuICBDb2xvci5yZ2IyaGV4ID0gZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgZnVuY3Rpb24gZm9ybWF0IChkZWNpbWFsKSB7XG4gICAgICAgICAgdmFyIGhleCA9IChkZWNpbWFsIHwgMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgIGlmIChkZWNpbWFsIDwgMTYpIHtcbiAgICAgICAgICAgICAgaGV4ID0gJzAnICsgaGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3IsIGcsIGJdLm1hcChmb3JtYXQpLmpvaW4oJycpO1xuICB9O1xuXG4gIC8vdG9kbzoganNkb2NzXG4gIENvbG9yLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCkge1xuICAgICAgdmFyIEggPSBoIC8gNjA7XG4gICAgICB2YXIgQyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICAgICAgdmFyIFggPSBDICogKDEgLSBNYXRoLmFicyhwYXJzZUludChIKSAlIDIgLSAxKSk7XG4gICAgICB2YXIgbSA9IGwgLSAoQyAvIDIpO1xuXG4gICAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMDtcblxuICAgICAgaWYgKEggPj0gMCAmJiBIIDwgMSkge1xuICAgICAgICAgIHIgPSBDO1xuICAgICAgICAgIGcgPSBYO1xuICAgICAgfSBlbHNlIGlmIChIID49IDEgJiYgSCA8IDIpIHtcbiAgICAgICAgICByID0gWDtcbiAgICAgICAgICBnID0gQztcbiAgICAgIH0gZWxzZSBpZiAoSCA+PSAyICYmIEggPCAzKSB7XG4gICAgICAgICAgZyA9IEM7XG4gICAgICAgICAgYiA9IFg7XG4gICAgICB9IGVsc2UgaWYgKEggPj0gMyAmJiBIIDwgNCkge1xuICAgICAgICAgIGcgPSBYO1xuICAgICAgICAgIGIgPSBDO1xuICAgICAgfSBlbHNlIGlmIChIID49IDQgJiYgSCA8IDUpIHtcbiAgICAgICAgICByID0gWDtcbiAgICAgICAgICBiID0gQztcbiAgICAgIH0gZWxzZSBpZiAoSCA+PSA1ICYmIEggPCA2KSB7XG4gICAgICAgICAgciA9IEM7XG4gICAgICAgICAgYiA9IFg7XG4gICAgICB9XG5cbiAgICAgIHIgKz0gbTtcbiAgICAgIGcgKz0gbTtcbiAgICAgIGIgKz0gbTtcblxuICAgICAgciA9IHBhcnNlSW50KHIgKiAyNTUpO1xuICAgICAgZyA9IHBhcnNlSW50KGcgKiAyNTUpO1xuICAgICAgYiA9IHBhcnNlSW50KGIgKiAyNTUpO1xuXG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xvciBmcm9tIGEgcmF3IFJHQjg4OCBpbnRlZ2VyXG4gICAqIEBwYXJhbSByYXcgUkdCODg4IHJlcHJlc2VudGF0aW9uIG9mIGNvbG9yXG4gICAqL1xuICAvL3RvZG86IHJlZmFjdG9yIGludG8gYSBzdGF0aWMgbWV0aG9kXG4gIC8vdG9kbzogZmFjdG9yIG91dCBpbmRpdmlkdWFsIGNvbG9yIHNwYWNlc1xuICAvL3RvZG86IGFkZCBIU0wsIENJRUxBQiwgYW5kIENJRUxVVlxuICBDb2xvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5yYXcgPSB2YWw7XG5cbiAgICAgIHZhciByID0gKHRoaXMucmF3ICYgMHhGRjAwMDApID4+IDE2O1xuICAgICAgdmFyIGcgPSAodGhpcy5yYXcgJiAweDAwRkYwMCkgPj4gODtcbiAgICAgIHZhciBiID0gKHRoaXMucmF3ICYgMHgwMDAwRkYpO1xuXG4gICAgICAvLyBCVC43MDlcbiAgICAgIHZhciB5ID0gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuICAgICAgdmFyIHUgPSAtMC4wOTk5MSAqIHIgLSAwLjMzNjA5ICogZyArIDAuNDM2ICogYjtcbiAgICAgIHZhciB2ID0gMC42MTUgKiByIC0gMC41NTg2MSAqIGcgLSAwLjA1NjM5ICogYjtcblxuICAgICAgdGhpcy5yZ2IgPSB7XG4gICAgICAgICAgcjogcixcbiAgICAgICAgICBnOiBnLFxuICAgICAgICAgIGI6IGJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMueXV2ID0ge1xuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgdTogdSxcbiAgICAgICAgICB2OiB2XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGlnaHRlbiBvciBkYXJrZW4gYSBjb2xvclxuICAgKiBAcGFyYW0gbXVsdGlwbGllciBBbW91bnQgdG8gbGlnaHRlbiBvciBkYXJrZW4gKC0xIHRvIDEpXG4gICAqL1xuICBDb2xvci5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uKG11bHRpcGxpZXIpIHtcbiAgICAgIHZhciBjbSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIE1hdGguYWJzKG11bHRpcGxpZXIpKSkgKiAobXVsdGlwbGllciA8IDAgPyAtMSA6IDEpO1xuICAgICAgdmFyIGJtID0gKDI1NSAqIGNtKSB8IDA7XG4gICAgICB2YXIgY3IgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIHRoaXMucmdiLnIgKyBibSkpO1xuICAgICAgdmFyIGNnID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCB0aGlzLnJnYi5nICsgYm0pKTtcbiAgICAgIHZhciBjYiA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgdGhpcy5yZ2IuYiArIGJtKSk7XG4gICAgICB2YXIgaGV4ID0gQ29sb3IucmdiMmhleChjciwgY2csIGNiKTtcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoaGV4KTtcbiAgfTtcblxuICAvKipcbiAgICogT3V0cHV0IGNvbG9yIGluIGhleCBmb3JtYXRcbiAgICogQHBhcmFtIGFkZEhhc2ggQWRkIGEgaGFzaCBjaGFyYWN0ZXIgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgb3V0cHV0XG4gICAqL1xuICBDb2xvci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihhZGRIYXNoKSB7XG4gICAgICByZXR1cm4gKGFkZEhhc2ggPyAnIycgOiAnJykgKyB0aGlzLnJhdy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgY3VycmVudCBjb2xvciBpcyBsaWdodGVyIHRoYW4gYW5vdGhlciBjb2xvclxuICAgKiBAcGFyYW0gY29sb3IgQ29sb3IgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAqL1xuICBDb2xvci5wcm90b3R5cGUubGlnaHRlclRoYW4gPSBmdW5jdGlvbihjb2xvcikge1xuICAgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcbiAgICAgICAgICBjb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnl1di55ID4gY29sb3IueXV2Lnk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtaXhpbmcgY3VycmVudCBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICogQHBhcmFtIGNvbG9yIENvbG9yIHRvIG1peCB3aXRoXG4gICAqIEBwYXJhbSBtdWx0aXBsaWVyIEhvdyBtdWNoIHRvIG1peCB3aXRoIHRoZSBvdGhlciBjb2xvclxuICAgKi9cbiAgLypcbiAgQ29sb3IucHJvdG90eXBlLm1peCA9IGZ1bmN0aW9uIChjb2xvciwgbXVsdGlwbGllcikge1xuICAgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcbiAgICAgICAgICBjb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gdGhpcy5yZ2IucjtcbiAgICAgIHZhciBnID0gdGhpcy5yZ2IuZztcbiAgICAgIHZhciBiID0gdGhpcy5yZ2IuYjtcbiAgICAgIHZhciBhID0gdGhpcy5hbHBoYTtcblxuICAgICAgdmFyIG0gPSB0eXBlb2YgbXVsdGlwbGllciAhPT0gJ3VuZGVmaW5lZCcgPyBtdWx0aXBsaWVyIDogMC41O1xuXG4gICAgICAvL3RvZG86IHdyaXRlIGEgbGVycCBmdW5jdGlvblxuICAgICAgciA9IHIgKyBtICogKGNvbG9yLnJnYi5yIC0gcik7XG4gICAgICBnID0gZyArIG0gKiAoY29sb3IucmdiLmcgLSBnKTtcbiAgICAgIGIgPSBiICsgbSAqIChjb2xvci5yZ2IuYiAtIGIpO1xuICAgICAgYSA9IGEgKyBtICogKGNvbG9yLmFscGhhIC0gYSk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29sb3IoQ29sb3IucmdiVG9IZXgociwgZywgYiksIHtcbiAgICAgICAgICAnYWxwaGEnOiBhXG4gICAgICB9KTtcbiAgfTtcbiAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGJsZW5kaW5nIGFub3RoZXIgY29sb3Igb24gdG9wIG9mIGN1cnJlbnQgY29sb3Igd2l0aCBhbHBoYVxuICAgKiBAcGFyYW0gY29sb3IgQ29sb3IgdG8gYmxlbmQgb24gdG9wIG9mIGN1cnJlbnQgY29sb3IsIGkuZS4gXCJDYVwiXG4gICAqL1xuICAvL3RvZG86IHNlZSBpZiAuYmxlbmRBbHBoYSBjYW4gYmUgbWVyZ2VkIGludG8gLm1peFxuICBDb2xvci5wcm90b3R5cGUuYmxlbmRBbHBoYSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIENhID0gY29sb3I7XG4gICAgICB2YXIgQ2IgPSB0aGlzO1xuXG4gICAgICAvL3RvZG86IHdyaXRlIGFscGhhIGJsZW5kaW5nIGZ1bmN0aW9uXG4gICAgICB2YXIgciA9IENhLmFscGhhICogQ2EucmdiLnIgKyAoMSAtIENhLmFscGhhKSAqIENiLnJnYi5yO1xuICAgICAgdmFyIGcgPSBDYS5hbHBoYSAqIENhLnJnYi5nICsgKDEgLSBDYS5hbHBoYSkgKiBDYi5yZ2IuZztcbiAgICAgIHZhciBiID0gQ2EuYWxwaGEgKiBDYS5yZ2IuYiArICgxIC0gQ2EuYWxwaGEpICogQ2IucmdiLmI7XG5cbiAgICAgIHJldHVybiBuZXcgQ29sb3IoQ29sb3IucmdiMmhleChyLCBnLCBiKSk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ3ZlcnNpb24nOiAnMi45LjYnLFxuICAgICdzdmdfbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG4gIH07XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICB2YXIgc2hhdmVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbiAgdmFyIFNWRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4gIHZhciBjb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbiAgdmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuICB2YXIgU1ZHX05TID0gY29uc3RhbnRzLnN2Z19ucztcblxuICB2YXIgdGVtcGxhdGVzID0ge1xuICAgICdlbGVtZW50JzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWcgPSBvcHRpb25zLnRhZztcbiAgICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuICAgICAgZGVsZXRlIG9wdGlvbnMudGFnO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuY29udGVudDtcbiAgICAgIHJldHVybiAgW3RhZywgY29udGVudCwgb3B0aW9uc107XG4gICAgfVxuICB9O1xuXG4gIC8vdG9kbzogZGVwcmVjYXRlIHRhZyBhcmcsIGluZmVyIHRhZyBmcm9tIHNoYXBlIG9iamVjdFxuICBmdW5jdGlvbiBjb252ZXJ0U2hhcGUgKHNoYXBlLCB0YWcpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgJ3RhZyc6IHRhZyxcbiAgICAgICd3aWR0aCc6IHNoYXBlLndpZHRoLFxuICAgICAgJ2hlaWdodCc6IHNoYXBlLmhlaWdodCxcbiAgICAgICdmaWxsJzogc2hhcGUucHJvcGVydGllcy5maWxsXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0Q3NzIChwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNzc1Byb3BzKHtcbiAgICAgICdmaWxsJzogcHJvcGVydGllcy5maWxsLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JzogcHJvcGVydGllcy5mb250LndlaWdodCxcbiAgICAgICdmb250LWZhbWlseSc6IHByb3BlcnRpZXMuZm9udC5mYW1pbHkgKyAnLCBtb25vc3BhY2UnLFxuICAgICAgJ2ZvbnQtc2l6ZSc6IHByb3BlcnRpZXMuZm9udC5zaXplICsgcHJvcGVydGllcy5mb250LnVuaXRzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvdXRsaW5lUGF0aCAoYmdXaWR0aCwgYmdIZWlnaHQsIG91dGxpbmVXaWR0aCkge1xuICAgIHZhciBvdXRsaW5lT2Zmc2V0V2lkdGggPSBvdXRsaW5lV2lkdGggLyAyO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICdNJywgb3V0bGluZU9mZnNldFdpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgsXG4gICAgICAnSCcsIGJnV2lkdGggLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG4gICAgICAnVicsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoLFxuICAgICAgJ0gnLCBvdXRsaW5lT2Zmc2V0V2lkdGgsXG4gICAgICAnVicsIDAsXG4gICAgICAnTScsIDAsIG91dGxpbmVPZmZzZXRXaWR0aCxcbiAgICAgICdMJywgYmdXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG4gICAgICAnTScsIDAsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoLFxuICAgICAgJ0wnLCBiZ1dpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGhcbiAgICBdLmpvaW4oJyAnKTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjZW5lR3JhcGgsIHJlbmRlclNldHRpbmdzKSB7XG4gICAgdmFyIGVuZ2luZVNldHRpbmdzID0gcmVuZGVyU2V0dGluZ3MuZW5naW5lU2V0dGluZ3M7XG4gICAgdmFyIHN0eWxlc2hlZXRzID0gZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHM7XG4gICAgdmFyIHN0eWxlc2hlZXRYbWwgPSBzdHlsZXNoZWV0cy5tYXAoZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHtcbiAgICAgIHJldHVybiAnPD94bWwtc3R5bGVzaGVldCByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIicgKyBzdHlsZXNoZWV0ICsgJ1wiPz4nO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuXG4gICAgdmFyIGhvbGRlcklkID0gJ2hvbGRlcl8nICsgTnVtYmVyKG5ldyBEYXRlKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciByb290ID0gc2NlbmVHcmFwaC5yb290O1xuICAgIHZhciB0ZXh0R3JvdXAgPSByb290LmNoaWxkcmVuLmhvbGRlclRleHRHcm91cDtcblxuICAgIHZhciBjc3MgPSAnIycgKyBob2xkZXJJZCArICcgdGV4dCB7ICcgKyB0ZXh0Q3NzKHRleHRHcm91cC5wcm9wZXJ0aWVzKSArICcgfSAnO1xuXG4gICAgLy8gcHVzaCB0ZXh0IGRvd24gdG8gYmUgZXF1YWxseSB2ZXJ0aWNhbGx5IGFsaWduZWQgd2l0aCBjYW52YXMgcmVuZGVyZXJcbiAgICB0ZXh0R3JvdXAueSArPSB0ZXh0R3JvdXAudGV4dFBvc2l0aW9uRGF0YS5ib3VuZGluZ0JveC5oZWlnaHQgKiAwLjg7XG5cbiAgICB2YXIgd29yZFRhZ3MgPSBbXTtcblxuICAgIE9iamVjdC5rZXlzKHRleHRHcm91cC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobGluZUtleSkge1xuICAgICAgdmFyIGxpbmUgPSB0ZXh0R3JvdXAuY2hpbGRyZW5bbGluZUtleV07XG5cbiAgICAgIE9iamVjdC5rZXlzKGxpbmUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKHdvcmRLZXkpIHtcbiAgICAgICAgdmFyIHdvcmQgPSBsaW5lLmNoaWxkcmVuW3dvcmRLZXldO1xuICAgICAgICB2YXIgeCA9IHRleHRHcm91cC54ICsgbGluZS54ICsgd29yZC54O1xuICAgICAgICB2YXIgeSA9IHRleHRHcm91cC55ICsgbGluZS55ICsgd29yZC55O1xuICAgICAgICB2YXIgd29yZFRhZyA9IHRlbXBsYXRlcy5lbGVtZW50KHtcbiAgICAgICAgICAndGFnJzogJ3RleHQnLFxuICAgICAgICAgICdjb250ZW50Jzogd29yZC5wcm9wZXJ0aWVzLnRleHQsXG4gICAgICAgICAgJ3gnOiB4LFxuICAgICAgICAgICd5JzogeVxuICAgICAgICB9KTtcblxuICAgICAgICB3b3JkVGFncy5wdXNoKHdvcmRUYWcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgdGV4dCA9IHRlbXBsYXRlcy5lbGVtZW50KHtcbiAgICAgICd0YWcnOiAnZycsXG4gICAgICAnY29udGVudCc6IHdvcmRUYWdzXG4gICAgfSk7XG5cbiAgICB2YXIgb3V0bGluZSA9IG51bGw7XG5cbiAgICBpZiAocm9vdC5jaGlsZHJlbi5ob2xkZXJCZy5wcm9wZXJ0aWVzLm91dGxpbmUpIHtcbiAgICAgIHZhciBvdXRsaW5lUHJvcGVydGllcyA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcucHJvcGVydGllcy5vdXRsaW5lO1xuICAgICAgb3V0bGluZSA9IHRlbXBsYXRlcy5lbGVtZW50KHtcbiAgICAgICAgJ3RhZyc6ICdwYXRoJyxcbiAgICAgICAgJ2QnOiBvdXRsaW5lUGF0aChyb290LmNoaWxkcmVuLmhvbGRlckJnLndpZHRoLCByb290LmNoaWxkcmVuLmhvbGRlckJnLmhlaWdodCwgb3V0bGluZVByb3BlcnRpZXMud2lkdGgpLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogb3V0bGluZVByb3BlcnRpZXMud2lkdGgsXG4gICAgICAgICdzdHJva2UnOiBvdXRsaW5lUHJvcGVydGllcy5maWxsLFxuICAgICAgICAnZmlsbCc6ICdub25lJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJnID0gY29udmVydFNoYXBlKHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcsICdyZWN0Jyk7XG5cbiAgICB2YXIgc2NlbmVDb250ZW50ID0gW107XG5cbiAgICBzY2VuZUNvbnRlbnQucHVzaChiZyk7XG4gICAgaWYgKG91dGxpbmVQcm9wZXJ0aWVzKSB7XG4gICAgICBzY2VuZUNvbnRlbnQucHVzaChvdXRsaW5lKTtcbiAgICB9XG4gICAgc2NlbmVDb250ZW50LnB1c2godGV4dCk7XG5cbiAgICB2YXIgc2NlbmUgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG4gICAgICAndGFnJzogJ2cnLFxuICAgICAgJ2lkJzogaG9sZGVySWQsXG4gICAgICAnY29udGVudCc6IHNjZW5lQ29udGVudFxuICAgIH0pO1xuXG4gICAgdmFyIHN0eWxlID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgJ3RhZyc6ICdzdHlsZScsXG4gICAgICAvL3RvZG86IGZpZ3VyZSBvdXQgaG93IHRvIGFkZCBDREFUQSBkaXJlY3RpdmVcbiAgICAgICdjb250ZW50JzogY3NzLFxuICAgICAgJ3R5cGUnOiAndGV4dC9jc3MnXG4gICAgfSk7XG5cbiAgICB2YXIgZGVmcyA9IHRlbXBsYXRlcy5lbGVtZW50KHtcbiAgICAgICd0YWcnOiAnZGVmcycsXG4gICAgICAnY29udGVudCc6IHN0eWxlXG4gICAgfSk7XG5cbiAgICB2YXIgc3ZnID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuICAgICAgJ3RhZyc6ICdzdmcnLFxuICAgICAgJ2NvbnRlbnQnOiBbZGVmcywgc2NlbmVdLFxuICAgICAgJ3dpZHRoJzogcm9vdC5wcm9wZXJ0aWVzLndpZHRoLFxuICAgICAgJ2hlaWdodCc6IHJvb3QucHJvcGVydGllcy5oZWlnaHQsXG4gICAgICAneG1sbnMnOiBTVkdfTlMsXG4gICAgICAndmlld0JveCc6IFswLCAwLCByb290LnByb3BlcnRpZXMud2lkdGgsIHJvb3QucHJvcGVydGllcy5oZWlnaHRdLmpvaW4oJyAnKSxcbiAgICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJzogJ25vbmUnXG4gICAgfSk7XG5cbiAgICB2YXIgb3V0cHV0ID0gc2hhdmVuKHN2Zyk7XG5cbiAgICBpZiAoL1xcJmFtcDsoeCk/I1swLTlBLUZhLWZdLy50ZXN0KG91dHB1dFswXSkpIHtcbiAgICAgIG91dHB1dFswXSA9IG91dHB1dFswXS5yZXBsYWNlKC8mYW1wOyMvZ20sICcmIycpO1xuICAgIH1cbiAgICBcbiAgICBvdXRwdXQgPSBzdHlsZXNoZWV0WG1sICsgb3V0cHV0WzBdO1xuXG4gICAgdmFyIHN2Z1N0cmluZyA9IFNWRy5zdmdTdHJpbmdUb0RhdGFVUkkob3V0cHV0LCByZW5kZXJTZXR0aW5ncy5tb2RlID09PSAnYmFja2dyb3VuZCcpO1xuICAgIHJldHVybiBzdmdTdHJpbmc7XG4gIH07XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuICB2YXIgZXNjYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNClcblxuICAvLyBUT0RPOiByZW1vdmUgbmFtZXNwYWNlXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGF2ZW4gKGFycmF5LCBuYW1lc3BhY2UsIHJldHVybk9iamVjdCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnXG5cbiAgICB2YXIgaSA9IDFcbiAgICB2YXIgZG9lc0VzY2FwZSA9IHRydWVcbiAgICB2YXIgSFRNTFN0cmluZ1xuICAgIHZhciBhdHRyaWJ1dGVLZXlcbiAgICB2YXIgY2FsbGJhY2tcbiAgICB2YXIga2V5XG5cblxuICAgIHJldHVybk9iamVjdCA9IHJldHVybk9iamVjdCB8fCB7fVxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50IChzdWdhclN0cmluZykge1xuXG4gICAgICB2YXIgdGFncyA9IHN1Z2FyU3RyaW5nLm1hdGNoKC9eW1xcdy1dKy8pXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdGFnOiB0YWdzID8gdGFnc1swXSA6ICdkaXYnLFxuICAgICAgICBhdHRyOiB7fSxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9XG4gICAgICB2YXIgaWQgPSBzdWdhclN0cmluZy5tYXRjaCgvIyhbXFx3LV0rKS8pXG4gICAgICB2YXIgcmVmZXJlbmNlID0gc3VnYXJTdHJpbmcubWF0Y2goL1xcJChbXFx3LV0rKS8pXG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IHN1Z2FyU3RyaW5nLm1hdGNoKC9cXC5bXFx3LV0rL2cpXG5cblxuICAgICAgLy8gQXNzaWduIGlkIGlmIGlzIHNldFxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGVsZW1lbnQuYXR0ci5pZCA9IGlkWzFdXG5cbiAgICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gdGhlIHJldHVybiBvYmplY3RcbiAgICAgICAgcmV0dXJuT2JqZWN0W2lkWzFdXSA9IGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZmVyZW5jZSlcbiAgICAgICAgcmV0dXJuT2JqZWN0W3JlZmVyZW5jZVsxXV0gPSBlbGVtZW50XG5cbiAgICAgIGlmIChjbGFzc05hbWVzKVxuICAgICAgICBlbGVtZW50LmF0dHIuY2xhc3MgPSBjbGFzc05hbWVzLmpvaW4oJyAnKS5yZXBsYWNlKC9cXC4vZywgJycpXG5cbiAgICAgIGlmIChzdWdhclN0cmluZy5tYXRjaCgvJiQvZykpXG4gICAgICAgIGRvZXNFc2NhcGUgPSBmYWxzZVxuXG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyIChrZXksIHZhbHVlKSB7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG5cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZUF0dHJpYnV0ZSAoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyB8fCBzdHJpbmcgPT09IDApID9cbiAgICAgICAgU3RyaW5nKHN0cmluZylcbiAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgOlxuICAgICAgICAnJ1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZUhUTUwgKHN0cmluZykge1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpXG4gICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIH1cblxuXG4gICAgaWYgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycpXG4gICAgICBhcnJheVswXSA9IGNyZWF0ZUVsZW1lbnQoYXJyYXlbMF0pXG5cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5WzBdKSlcbiAgICAgIGkgPSAwXG5cbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdGaXJzdCBlbGVtZW50IG9mIGFycmF5IG11c3QgYmUgYSBzdHJpbmcsICcgK1xuICAgICAgICAnb3IgYW4gYXJyYXkgYW5kIG5vdCAnICsgSlNPTi5zdHJpbmdpZnkoYXJyYXlbMF0pXG4gICAgICApXG5cblxuICAgIGZvciAoOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblxuICAgICAgLy8gRG9uJ3QgcmVuZGVyIGVsZW1lbnQgaWYgdmFsdWUgaXMgZmFsc2Ugb3IgbnVsbFxuICAgICAgaWYgKGFycmF5W2ldID09PSBmYWxzZSB8fCBhcnJheVtpXSA9PT0gbnVsbCkge1xuICAgICAgICBhcnJheVswXSA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIC8vIENvbnRpbnVlIHdpdGggbmV4dCBhcnJheSB2YWx1ZSBpZiBjdXJyZW50IHZhbHVlIGlzIHVuZGVmaW5lZCBvciB0cnVlXG4gICAgICBlbHNlIGlmIChhcnJheVtpXSA9PT0gdW5kZWZpbmVkIHx8IGFycmF5W2ldID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcnJheVtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvZXNFc2NhcGUpXG4gICAgICAgICAgYXJyYXlbaV0gPSBlc2NhcGVIVE1MKGFycmF5W2ldKVxuXG4gICAgICAgIGFycmF5WzBdLmNoaWxkcmVuLnB1c2goYXJyYXlbaV0pXG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcnJheVtpXSA9PT0gJ251bWJlcicpIHtcblxuICAgICAgICBhcnJheVswXS5jaGlsZHJlbi5wdXNoKGFycmF5W2ldKVxuICAgICAgfVxuXG4gICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldWzBdKSkge1xuICAgICAgICAgIGFycmF5W2ldLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJBcnJheSkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGkgKyAxLCAwLCBzdWJBcnJheSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIGkrK1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhdmVuKGFycmF5W2ldLCBuYW1lc3BhY2UsIHJldHVybk9iamVjdClcblxuICAgICAgICBpZiAoYXJyYXlbaV1bMF0pXG4gICAgICAgICAgYXJyYXlbMF0uY2hpbGRyZW4ucHVzaChhcnJheVtpXVswXSlcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFycmF5W2ldID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBjYWxsYmFjayA9IGFycmF5W2ldXG5cblxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFycmF5W2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGF0dHJpYnV0ZUtleSBpbiBhcnJheVtpXSlcbiAgICAgICAgICBpZiAoYXJyYXlbaV0uaGFzT3duUHJvcGVydHkoYXR0cmlidXRlS2V5KSlcbiAgICAgICAgICAgIGlmIChhcnJheVtpXVthdHRyaWJ1dGVLZXldICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIGFycmF5W2ldW2F0dHJpYnV0ZUtleV0gIT09IGZhbHNlKVxuICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlS2V5ID09PSAnc3R5bGUnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFycmF5W2ldW2F0dHJpYnV0ZUtleV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIGFycmF5WzBdLmF0dHJbYXR0cmlidXRlS2V5XSA9IEpTT05cbiAgICAgICAgICAgICAgICAgIC5zdHJpbmdpZnkoYXJyYXlbaV1bYXR0cmlidXRlS2V5XSwgcmVwbGFjZXIpXG4gICAgICAgICAgICAgICAgICAuc2xpY2UoMiwgLTIpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIsXCIvZywgJzsnKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiOlwiL2csICc6JylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1xcJycpXG5cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFycmF5WzBdLmF0dHJbYXR0cmlidXRlS2V5XSA9IGFycmF5W2ldW2F0dHJpYnV0ZUtleV1cbiAgICAgIH1cblxuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIicgKyBhcnJheVtpXSArICdcIiBpcyBub3QgYWxsb3dlZCBhcyBhIHZhbHVlLicpXG4gICAgfVxuXG5cbiAgICBpZiAoYXJyYXlbMF0gIT09IGZhbHNlKSB7XG5cbiAgICAgIEhUTUxTdHJpbmcgPSAnPCcgKyBhcnJheVswXS50YWdcblxuICAgICAgZm9yIChrZXkgaW4gYXJyYXlbMF0uYXR0cilcbiAgICAgICAgaWYgKGFycmF5WzBdLmF0dHIuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICBIVE1MU3RyaW5nICs9ICcgJyArIGtleSArICc9XCInICtcbiAgICAgICAgICAgIGVzY2FwZUF0dHJpYnV0ZShhcnJheVswXS5hdHRyW2tleV0pICsgJ1wiJ1xuXG4gICAgICBIVE1MU3RyaW5nICs9ICc+J1xuXG4gICAgICBhcnJheVswXS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBIVE1MU3RyaW5nICs9IGNoaWxkXG4gICAgICB9KVxuXG4gICAgICBIVE1MU3RyaW5nICs9ICc8LycgKyBhcnJheVswXS50YWcgKyAnPidcblxuICAgICAgYXJyYXlbMF0gPSBIVE1MU3RyaW5nXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHJvb3QgZWxlbWVudCBvbiBpbmRleCAwXG4gICAgcmV0dXJuT2JqZWN0WzBdID0gYXJyYXlbMF1cblxuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIGNhbGxiYWNrKGFycmF5WzBdKVxuXG4gICAgLy8gcmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhbGwgZWxlbWVudHMgd2l0aCBhbiBpZCBhbmQgdGhlIHJvb3QgZWxlbWVudFxuICAgIHJldHVybiByZXR1cm5PYmplY3RcbiAgfVxuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAvKiFcbiAgICogZXNjYXBlLWh0bWxcbiAgICogQ29weXJpZ2h0KGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICAgKiBDb3B5cmlnaHQoYykgMjAxNSBBbmRyZWFzIEx1YmJlXG4gICAqIENvcHlyaWdodChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICAgKiBNSVQgTGljZW5zZWRcbiAgICovXG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgdmFyaWFibGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcblxuICAvKipcbiAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVIdG1sO1xuXG4gIC8qKlxuICAgKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICAgIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGU7XG4gICAgdmFyIGh0bWwgPSAnJztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgIGNhc2UgMzQ6IC8vIFwiXG4gICAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6IC8vICZcbiAgICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM5OiAvLyAnXG4gICAgICAgICAgZXNjYXBlID0gJyYjMzk7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2MDogLy8gPFxuICAgICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICBodG1sICs9IGVzY2FwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleFxuICAgICAgPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgOiBodG1sO1xuICB9XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4gIHZhciBET00gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuICB2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IERPTS5uZXdFbCgnY2FudmFzJyk7XG4gICAgICB2YXIgY3R4ID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjZW5lR3JhcGgpIHtcbiAgICAgICAgICBpZiAoY3R4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRwciA9IHV0aWxzLmNhbnZhc1JhdGlvKCk7XG4gICAgICAgICAgdmFyIHJvb3QgPSBzY2VuZUdyYXBoLnJvb3Q7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gZHByICogcm9vdC5wcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkcHIgKiByb290LnByb3BlcnRpZXMuaGVpZ2h0IDtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgICAgICB2YXIgYmcgPSByb290LmNoaWxkcmVuLmhvbGRlckJnO1xuICAgICAgICAgIHZhciBiZ1dpZHRoID0gZHByICogYmcud2lkdGg7XG4gICAgICAgICAgdmFyIGJnSGVpZ2h0ID0gZHByICogYmcuaGVpZ2h0O1xuICAgICAgICAgIC8vdG9kbzogcGFyYW1ldHJpemUgb3V0bGluZSB3aWR0aCAoZS5nLiBpbiBzY2VuZSBvYmplY3QpXG4gICAgICAgICAgdmFyIG91dGxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgdmFyIG91dGxpbmVPZmZzZXRXaWR0aCA9IG91dGxpbmVXaWR0aCAvIDI7XG5cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmcucHJvcGVydGllcy5maWxsO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBiZ1dpZHRoLCBiZ0hlaWdodCk7XG5cbiAgICAgICAgICBpZiAoYmcucHJvcGVydGllcy5vdXRsaW5lKSB7XG4gICAgICAgICAgICAgIC8vdG9kbzogYWJzdHJhY3QgdGhpcyBpbnRvIGEgbWV0aG9kXG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJnLnByb3BlcnRpZXMub3V0bGluZS5maWxsO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gYmcucHJvcGVydGllcy5vdXRsaW5lLndpZHRoO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKG91dGxpbmVPZmZzZXRXaWR0aCwgb3V0bGluZU9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgLy8gVEwsIFRSLCBCUiwgQkxcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoIC0gb3V0bGluZU9mZnNldFdpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKGJnV2lkdGggLSBvdXRsaW5lT2Zmc2V0V2lkdGgsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhvdXRsaW5lT2Zmc2V0V2lkdGgsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhvdXRsaW5lT2Zmc2V0V2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgIC8vIERpYWdvbmFsc1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmdXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRleHRHcm91cCA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyVGV4dEdyb3VwO1xuICAgICAgICAgIGN0eC5mb250ID0gdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC53ZWlnaHQgKyAnICcgKyAoZHByICogdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC5zaXplKSArIHRleHRHcm91cC5wcm9wZXJ0aWVzLmZvbnQudW5pdHMgKyAnICcgKyB0ZXh0R3JvdXAucHJvcGVydGllcy5mb250LmZhbWlseSArICcsIG1vbm9zcGFjZSc7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRHcm91cC5wcm9wZXJ0aWVzLmZpbGw7XG5cbiAgICAgICAgICBmb3IgKHZhciBsaW5lS2V5IGluIHRleHRHcm91cC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICB2YXIgbGluZSA9IHRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd29yZEtleSBpbiBsaW5lLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgd29yZCA9IGxpbmUuY2hpbGRyZW5bd29yZEtleV07XG4gICAgICAgICAgICAgICAgICB2YXIgeCA9IGRwciAqICh0ZXh0R3JvdXAueCArIGxpbmUueCArIHdvcmQueCk7XG4gICAgICAgICAgICAgICAgICB2YXIgeSA9IGRwciAqICh0ZXh0R3JvdXAueSArIGxpbmUueSArIHdvcmQueSArICh0ZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nIC8gMikpO1xuXG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQod29yZC5wcm9wZXJ0aWVzLnRleHQsIHgsIHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgfTtcbiAgfSkoKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pXG59KTtcbjtcbihmdW5jdGlvbihjdHgsIGlzTWV0ZW9yUGFja2FnZSkge1xuICAgIGlmIChpc01ldGVvclBhY2thZ2UpIHtcbiAgICAgICAgSG9sZGVyID0gY3R4LkhvbGRlcjtcbiAgICB9XG59KSh0aGlzLCB0eXBlb2YgTWV0ZW9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgUGFja2FnZSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5cbiIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9